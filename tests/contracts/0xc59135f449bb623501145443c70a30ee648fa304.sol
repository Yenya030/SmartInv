{{
  "language": "Solidity",
  "sources": {
    "@gearbox-protocol/core-v2/contracts/credit/CreditFacade.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n//  DATA\nimport { MultiCall } from \"../libraries/MultiCall.sol\";\nimport { Balance, BalanceOps } from \"../libraries/Balances.sol\";\n\n/// INTERFACES\nimport { ICreditFacade, ICreditFacadeExtended } from \"../interfaces/ICreditFacade.sol\";\nimport { ICreditManagerV2, ClosureAction } from \"../interfaces/ICreditManagerV2.sol\";\nimport { IPriceOracleV2 } from \"../interfaces/IPriceOracle.sol\";\nimport { IDegenNFT } from \"../interfaces/IDegenNFT.sol\";\nimport { IWETH } from \"../interfaces/external/IWETH.sol\";\n\n// CONSTANTS\n\nimport { LEVERAGE_DECIMALS } from \"../libraries/Constants.sol\";\nimport { PERCENTAGE_FACTOR } from \"../libraries/PercentageMath.sol\";\n\n// EXCEPTIONS\nimport { ZeroAddressException } from \"../interfaces/IErrors.sol\";\n\nstruct Params {\n    /// @dev Maximal amount of new debt that can be taken per block\n    uint128 maxBorrowedAmountPerBlock;\n    /// @dev True if increasing debt is forbidden\n    bool isIncreaseDebtForbidden;\n    /// @dev Timestamp of the next expiration (for expirable Credit Facades only)\n    uint40 expirationDate;\n}\n\nstruct Limits {\n    /// @dev Minimal borrowed amount per credit account\n    uint128 minBorrowedAmount;\n    /// @dev Maximum aborrowed amount per credit account\n    uint128 maxBorrowedAmount;\n}\n\n/// @title CreditFacade\n/// @notice User interface for interacting with Credit Manager.\n/// @dev CreditFacade provides an interface between the user and the Credit Manager. Direct interactions\n/// with the Credit Manager are forbidden. There are two ways the Credit Manager can be interacted with:\n/// - Through CreditFacade, which provides all the required account management function: open / close / liquidate / manageDebt,\n/// as well as Multicalls that allow to perform multiple actions within a single transaction, with a single health check\n/// - Through adapters, which call the Credit Manager directly, but only allow interactions with specific target contracts\ncontract CreditFacade is ICreditFacade, ReentrancyGuard {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    /// @dev Credit Manager connected to this Credit Facade\n    ICreditManagerV2 public immutable creditManager;\n\n    /// @dev Whether the whitelisted mode is active\n    bool public immutable whitelisted;\n\n    /// @dev Whether the Credit Facade implements expirable logic\n    bool public immutable expirable;\n\n    /// @dev Keeps frequently accessed parameters for storage access optimization\n    Params public override params;\n\n    /// @dev Keeps borrowing limits together for storage access optimization\n    Limits public override limits;\n\n    /// @dev Address of the underlying token\n    address public immutable underlying;\n\n    /// @dev A map that stores whether a user allows a transfer of an account from another user to themselves\n    mapping(address => mapping(address => bool))\n        public\n        override transfersAllowed;\n\n    /// @dev Address of WETH\n    address public immutable wethAddress;\n\n    /// @dev Address of the DegenNFT that gatekeeps account openings in whitelisted mode\n    address public immutable override degenNFT;\n\n    /// @dev Stores in a compressed state the last block where borrowing happened and the total amount borrowed in that block\n    uint256 internal totalBorrowedInBlock;\n\n    /// @dev Stores a set of contracts which have special restrictions applied for security (such as upgradeable contracts)\n    EnumerableSet.AddressSet internal upgradeableContracts;\n\n    /// @dev Contract version\n    uint256 public constant override version = 2;\n\n    /// @dev Restricts actions for users with opened credit accounts only\n    modifier creditConfiguratorOnly() {\n        if (msg.sender != creditManager.creditConfigurator())\n            revert CreditConfiguratorOnlyException();\n\n        _;\n    }\n\n    /// @dev Initializes creditFacade and connects it with CreditManager\n    /// @param _creditManager address of Credit Manager\n    /// @param _degenNFT address of the DegenNFT or address(0) if whitelisted mode is not used\n    /// @param _expirable Whether the CreditFacade can expire and implements expiration-related logic\n    constructor(\n        address _creditManager,\n        address _degenNFT,\n        bool _expirable\n    ) {\n        // Additional check that _creditManager is not address(0)\n        if (_creditManager == address(0)) revert ZeroAddressException(); // F:[FA-1]\n\n        creditManager = ICreditManagerV2(_creditManager); // F:[FA-1A]\n        underlying = ICreditManagerV2(_creditManager).underlying(); // F:[FA-1A]\n        wethAddress = ICreditManagerV2(_creditManager).wethAddress(); // F:[FA-1A]\n\n        degenNFT = _degenNFT; // F:[FA-1A]\n        whitelisted = _degenNFT != address(0); // F:[FA-1A]\n\n        expirable = _expirable;\n    }\n\n    // Notice: ETH interactions\n    // CreditFacade implements a new flow for interacting with WETH compared to V1.\n    // During all actions, any sent ETH value is automatically wrapped into WETH and\n    // sent back to the message sender. This makes the protocol's behavior regarding\n    // ETH more flexible and consistent, since there is no need to pre-wrap WETH before\n    // interacting with the protocol, and no need to compute how much unused ETH has to be sent back.\n\n    /// @dev Opens credit account, borrows funds from the pool and pulls collateral\n    /// without any additional action.\n    /// - Performs sanity checks to determine whether opening an account is allowed\n    /// - Wraps ETH to WETH and sends it msg. sender is value > 0\n    /// - Requests CreditManager to open a Credit Account with a specified borrowed amount\n    /// - Transfers collateral in the underlying asset from the user\n    /// - Emits OpenCreditAccount event\n    ///\n    /// More info: https://dev.gearbox.fi/developers/credit/credit_manager#open-credit-account\n    ///\n    /// @param amount The amount of collateral provided by the borrower\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\n    /// msg.sender != obBehalfOf\n    /// @param leverageFactor Percentage of the user's own funds to borrow. 100 is equal to 100% - borrows the same amount\n    /// as the user's own collateral, equivalent to 2x leverage.\n    /// @param referralCode Referral code that is used for potential rewards. 0 if no referral code provided.\n    function openCreditAccount(\n        uint256 amount,\n        address onBehalfOf,\n        uint16 leverageFactor,\n        uint16 referralCode\n    ) external payable override nonReentrant {\n        uint256 borrowedAmount = (amount * leverageFactor) / LEVERAGE_DECIMALS; // F:[FA-5]\n\n        // Checks whether the new borrowed amount does not violate the block limit\n        _checkAndUpdateBorrowedBlockLimit(borrowedAmount); // F:[FA-11A]\n\n        // Checks that the borrowed amount is within the borrowing limits\n        _revertIfOutOfBorrowedLimits(borrowedAmount); // F:[FA-11B]\n\n        // Checks that the msg.sender can open an account for onBehalfOf\n        _revertIfOpenCreditAccountNotAllowed(onBehalfOf); // F:[FA-4A, 4B]\n\n        // Wraps ETH and sends it back to msg.sender\n        _wrapETH(); // F:[FA-3A]\n\n        // Gets the LT of the underlying\n        (, uint256 ltu) = creditManager.collateralTokens(0); // F:[FA-6]\n\n        // In order for the account to pass the health check after opening,\n        // the inequality \"(amount + borrowedAmount) * LTU > borrowedAmount\" must hold\n        // this can be transformed into \"amount * LTU > borrowedAmount * (1 - LTU)\"\n        if (amount * ltu <= borrowedAmount * (PERCENTAGE_FACTOR - ltu))\n            revert NotEnoughCollateralException(); // F:[FA-6]\n\n        // Opens credit accnount and borrows funds from the pool\n        // Returns the new credit account's address\n        address creditAccount = creditManager.openCreditAccount(\n            borrowedAmount,\n            onBehalfOf\n        ); // F:[FA-5]\n\n        // Emits openCreditAccount event before adding collateral, so that order of events is correct\n        emit OpenCreditAccount(\n            onBehalfOf,\n            creditAccount,\n            borrowedAmount,\n            referralCode\n        ); // F:[FA-5]\n\n        // Transfers collateral from the user to the new Credit Account\n        addCollateral(onBehalfOf, creditAccount, underlying, amount); // F:[FA-5]\n    }\n\n    /// @dev Opens a Credit Account and runs a batch of operations in a multicall\n    /// - Opens credit account with the desired borrowed amount\n    /// - Executes all operations in a multicall\n    /// - Checks that the new account has enough collateral\n    /// - Emits OpenCreditAccount event\n    ///\n    /// @param borrowedAmount Debt size\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\n    /// msg.sender != onBehalfOf\n    /// @param calls The array of MultiCall structs encoding the required operations. Generally must have\n    /// at least a call to addCollateral, as otherwise the health check at the end will fail.\n    /// @param referralCode Referral code which is used for potential rewards. 0 if no referral code provided\n    function openCreditAccountMulticall(\n        uint256 borrowedAmount,\n        address onBehalfOf,\n        MultiCall[] calldata calls,\n        uint16 referralCode\n    ) external payable override nonReentrant {\n        // Checks whether the new borrowed amount does not violate the block limit\n        _checkAndUpdateBorrowedBlockLimit(borrowedAmount); // F:[FA-11]\n\n        // Checks that the msg.sender can open an account for onBehalfOf\n        _revertIfOpenCreditAccountNotAllowed(onBehalfOf); // F:[FA-4A, 4B]\n\n        // Checks that the borrowed amount is within the borrowing limits\n        _revertIfOutOfBorrowedLimits(borrowedAmount); // F:[FA-11B]\n\n        // Wraps ETH and sends it back to msg.sender address\n        _wrapETH(); // F:[FA-3B]\n\n        // Requests the Credit Manager to open a Credit Account\n        address creditAccount = creditManager.openCreditAccount(\n            borrowedAmount,\n            onBehalfOf\n        ); // F:[FA-8]\n\n        // emits a new event\n        emit OpenCreditAccount(\n            onBehalfOf,\n            creditAccount,\n            borrowedAmount,\n            referralCode\n        ); // F:[FA-8]\n\n        // F:[FA-10]: no free flashloans through opening a Credit Account\n        // and immediately decreasing debt\n        if (calls.length != 0)\n            _multicall(calls, onBehalfOf, creditAccount, false, true); // F:[FA-8]\n\n        // Checks that the new credit account has enough collateral to cover the debt\n        creditManager.fullCollateralCheck(creditAccount); // F:[FA-8, 9]\n    }\n\n    /// @dev Runs a batch of transactions within a multicall and closes the account\n    /// - Wraps ETH to WETH and sends it msg.sender if value > 0\n    /// - Executes the multicall - the main purpose of a multicall when closing is to convert all assets to underlying\n    /// in order to pay the debt.\n    /// - Closes credit account:\n    ///    + Checks the underlying balance: if it is greater than the amount paid to the pool, transfers the underlying\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from msg.sender.\n    ///    + Transfers all enabled assets with non-zero balances to the \"to\" address, unless they are marked\n    ///      to be skipped in skipTokenMask\n    ///    + If convertWETH is true, converts WETH into ETH before sending to the recipient\n    /// - Emits a CloseCreditAccount event\n    ///\n    /// @param to Address to send funds to during account closing\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\n    /// @param convertWETH If true, converts WETH into ETH before sending to \"to\"\n    /// @param calls The array of MultiCall structs encoding the operations to execute before closing the account.\n    function closeCreditAccount(\n        address to,\n        uint256 skipTokenMask,\n        bool convertWETH,\n        MultiCall[] calldata calls\n    ) external payable override nonReentrant {\n        // Check for existing CA\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        ); // F:[FA-2]\n\n        // Wraps ETH and sends it back to msg.sender\n        _wrapETH(); // F:[FA-3C]\n\n        // [FA-13]: Calls to CreditFacade are forbidden during closure\n        if (calls.length != 0)\n            _multicall(calls, msg.sender, creditAccount, true, false); // F:[FA-2, 12, 13]\n\n        // Requests the Credit manager to close the Credit Account\n        creditManager.closeCreditAccount(\n            msg.sender,\n            ClosureAction.CLOSE_ACCOUNT,\n            0,\n            msg.sender,\n            to,\n            skipTokenMask,\n            convertWETH\n        ); // F:[FA-2, 12]\n\n        // Emits a CloseCreditAccount event\n        emit CloseCreditAccount(msg.sender, to); // F:[FA-12]\n    }\n\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account\n    /// - Computes the total value and checks that hf < 1. An account can't be liquidated when hf >= 1.\n    ///   Total value has to be computed before the multicall, otherwise the liquidator would be able\n    ///   to manipulate it.\n    /// - Wraps ETH to WETH and sends it to msg.sender (liquidator) if value > 0\n    /// - Executes the multicall - the main purpose of a multicall when liquidating is to convert all assets to underlying\n    ///   in order to pay the debt.\n    /// - Liquidate credit account:\n    ///    + Computes the amount that needs to be paid to the pool. If totalValue * liquidationDiscount < borrow + interest + fees,\n    ///      only totalValue * liquidationDiscount has to be paid. Since liquidationDiscount < 1, the liquidator can take\n    ///      totalValue * (1 - liquidationDiscount) as premium. Also computes the remaining funds to be sent to borrower\n    ///      as totalValue * liquidationDiscount - amountToPool.\n    ///    + Checks the underlying balance: if it is greater than amountToPool + remainingFunds, transfers the underlying\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from the liquidator.\n    ///    + Transfers all enabled assets with non-zero balances to the \"to\" address, unless they are marked\n    ///      to be skipped in skipTokenMask. If the liquidator is confident that all assets were converted\n    ///      during the multicall, they can set the mask to uint256.max - 1, to only transfer the underlying\n    ///    + If convertWETH is true, converts WETH into ETH before sending\n    /// - Emits LiquidateCreditAccount event\n    ///\n    /// @param to Address to send funds to after liquidation\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\n    /// @param convertWETH If true, converts WETH into ETH before sending to \"to\"\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\n    function liquidateCreditAccount(\n        address borrower,\n        address to,\n        uint256 skipTokenMask,\n        bool convertWETH,\n        MultiCall[] calldata calls\n    ) external payable override nonReentrant {\n        // Checks that the CA exists to revert early for late liquidations and save gas\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            borrower\n        ); // F:[FA-2]\n\n        // Checks that the to address is not zero\n        if (to == address(0)) revert ZeroAddressException(); // F:[FA-16A]\n\n        // Checks that the account hf < 1 and computes the totalValue\n        // before the multicall\n        (bool isLiquidatable, uint256 totalValue) = _isAccountLiquidatable(\n            creditAccount\n        ); // F:[FA-14]\n\n        // An account can't be liquidated if hf >= 1\n        if (!isLiquidatable)\n            revert CantLiquidateWithSuchHealthFactorException(); // F:[FA-14]\n\n        // Wraps ETH and sends it back to msg.sender\n        _wrapETH(); // F:[FA-3D]\n\n        // Checks if the liquidation is done while the contract is paused\n        bool emergencyLiquidation = _checkIfEmergencyLiquidator(true);\n\n        if (calls.length != 0)\n            _multicall(calls, borrower, creditAccount, true, false); // F:[FA-15]\n\n        if (emergencyLiquidation) {\n            _checkIfEmergencyLiquidator(false);\n        }\n\n        // Liquidates the CA and sends the remaining funds to the borrower\n        uint256 remainingFunds = creditManager.closeCreditAccount(\n            borrower,\n            ClosureAction.LIQUIDATE_ACCOUNT,\n            totalValue,\n            msg.sender,\n            to,\n            skipTokenMask,\n            convertWETH\n        ); // F:[FA-15]\n\n        emit LiquidateCreditAccount(borrower, msg.sender, to, remainingFunds); // F:[FA-15]\n    }\n\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account when\n    /// this Credit Facade is expired\n    /// The general flow of liquidation is nearly the same as normal liquidations, with two main differences:\n    ///     - An account can be liquidated on an expired Credit Facade even with hf > 1. However,\n    ///       no accounts can be liquidated through this function if the Credit Facade is not expired.\n    ///     - Liquidation premiums and fees for liquidating expired accounts are reduced.\n    /// It is still possible to normally liquidate an underwater Credit Account, even when the Credit Facade\n    /// is expired.\n    /// @param to Address to send funds to after liquidation\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\n    /// @param convertWETH If true, converts WETH into ETH before sending to \"to\"\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\n    /// @notice See more at https://dev.gearbox.fi/docs/documentation/credit/liquidation#liquidating-accounts-by-expiration\n    function liquidateExpiredCreditAccount(\n        address borrower,\n        address to,\n        uint256 skipTokenMask,\n        bool convertWETH,\n        MultiCall[] calldata calls\n    ) external payable override nonReentrant {\n        // Checks that the CA exists to revert early for late liquidations and save gas\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            borrower\n        );\n\n        // Checks that the to address is not zero\n        if (to == address(0)) revert ZeroAddressException();\n\n        // Checks that this Credit Facade is expired and reverts if not\n        if (!_isExpired()) {\n            revert CantLiquidateNonExpiredException(); // F: [FA-47,48]\n        }\n\n        // Calculates the total value of an account\n        (uint256 totalValue, ) = calcTotalValue(creditAccount);\n\n        // Wraps ETH and sends it back to msg.sender address\n        _wrapETH();\n\n        // Checks if the liquidsation during pause\n        bool emergencyLiquidation = _checkIfEmergencyLiquidator(true);\n\n        if (calls.length != 0)\n            _multicall(calls, borrower, creditAccount, true, false); // F:[FA-49]\n\n        if (emergencyLiquidation) {\n            _checkIfEmergencyLiquidator(false);\n        }\n\n        // Liquidates the CA and sends the remaining funds to the borrower\n        uint256 remainingFunds = creditManager.closeCreditAccount(\n            borrower,\n            ClosureAction.LIQUIDATE_EXPIRED_ACCOUNT,\n            totalValue,\n            msg.sender,\n            to,\n            skipTokenMask,\n            convertWETH\n        ); // F:[FA-49]\n\n        // Emits event\n        emit LiquidateExpiredCreditAccount(\n            borrower,\n            msg.sender,\n            to,\n            remainingFunds\n        ); // F:[FA-49]\n    }\n\n    /// @dev Increases debt for msg.sender's Credit Account\n    /// - Borrows the requested amount from the pool\n    /// - Updates the CA's borrowAmount / cumulativeIndexOpen\n    ///   to correctly compute interest going forward\n    /// - Performs a full collateral check\n    ///\n    /// @param amount Amount to borrow\n    function increaseDebt(uint256 amount) external override nonReentrant {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        ); // F:[FA-2]\n\n        _increaseDebt(msg.sender, creditAccount, amount);\n\n        // Checks that the credit account has enough collateral to cover the new borrowed amount\n        creditManager.fullCollateralCheck(creditAccount); // F:[FA-17]\n    }\n\n    /// @dev IMPLEMENTATION: increaseDebt\n    function _increaseDebt(\n        address borrower,\n        address creditAccount,\n        uint256 amount\n    ) internal {\n        // It is forbidden to take new debt if increaseDebtForbidden mode is enabled\n        if (params.isIncreaseDebtForbidden)\n            revert IncreaseDebtForbiddenException(); // F:[FA-18C]\n\n        // Checks that the borrowed amount does not violate the per block limit\n        _checkAndUpdateBorrowedBlockLimit(amount); // F:[FA-18A]\n\n        // Checks that there are no forbidden tokens, as borrowing\n        // is prohibited when forbidden tokens are enabled on the account\n        _checkForbiddenTokens(creditAccount);\n\n        // Requests the Credit Manager to borrow additional funds from the pool\n        uint256 newBorrowedAmount = creditManager.manageDebt(\n            creditAccount,\n            amount,\n            true\n        ); // F:[FA-17]\n\n        // Checks that the new total borrowed amount is within bounds\n        _revertIfOutOfBorrowedLimits(newBorrowedAmount); // F:[FA-18B]\n\n        // Emits event\n        emit IncreaseBorrowedAmount(borrower, amount); // F:[FA-17]\n    }\n\n    /// @dev Checks that there are no intersections between the user's enabled tokens\n    /// and the set of forbidden tokens\n    /// @notice The main purpose of forbidding tokens is to prevent exposing\n    /// pool funds to dangerous or exploited collateral, without immediately\n    /// liquidating accounts that hold the forbidden token\n    /// There are two ways pool funds can be exposed:\n    ///     - The CA owner tries to swap borrowed funds to the forbidden asset:\n    ///       this will be blocked by checkAndEnableToken, which is invoked for tokenOut\n    ///       after every operation;\n    ///     - The CA owner with an already enabled forbidden token transfers it\n    ///       to the account - they can't use addCollateral / enableToken due to checkAndEnableToken,\n    ///       but can transfer the token directly when it is enabled and it will be counted in the collateral -\n    ///       an borrows against it. This check is used to prevent this.\n    /// If the owner has a forbidden token and want to take more debt, they must first\n    /// dispose of the token and disable it.\n    function _checkForbiddenTokens(address creditAccount) internal view {\n        uint256 enabledTokenMask = creditManager.enabledTokensMap(\n            creditAccount\n        );\n        uint256 forbiddenTokenMask = creditManager.forbiddenTokenMask();\n\n        if (enabledTokenMask & forbiddenTokenMask > 0) {\n            revert ActionProhibitedWithForbiddenTokensException();\n        }\n    }\n\n    /// @dev Decrease debt\n    /// - Decreases the debt by paying the requested amount + accrued interest + fees back to the pool\n    /// - It's also include to this payment interest accrued at the moment and fees\n    /// - Updates cunulativeIndex to cumulativeIndex now\n    ///\n    /// @param amount Amount to increase borrowed amount\n    function decreaseDebt(uint256 amount) external override nonReentrant {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        ); // F:[FA-2]\n\n        _decreaseDebt(msg.sender, creditAccount, amount); // F:[FA-19]\n\n        // We need this check, cause after paying debt back, it potentially could be\n        // another portfolio structure, which has lower Hf\n        creditManager.fullCollateralCheck(creditAccount); // F:[FA-19]\n    }\n\n    /// @dev IMPLEMENTATION: decreaseDebt\n    function _decreaseDebt(\n        address borrower,\n        address creditAccount,\n        uint256 amount\n    ) internal {\n        // Requests the creditManager to reduce the borrowed sum by amount\n        uint256 newBorrowedAmount = creditManager.manageDebt(\n            creditAccount,\n            amount,\n            false\n        ); // F:[FA-19]\n\n        // Checks that the new borrowed amount is within limits\n        _revertIfOutOfBorrowedLimits(newBorrowedAmount); // F:[FA-20]\n\n        // Emits an event\n        emit DecreaseBorrowedAmount(borrower, amount); // F:[FA-19]\n    }\n\n    /// @dev Adds collateral to borrower's credit account\n    /// @param onBehalfOf Address of the borrower whose account is funded\n    /// @param token Address of a collateral token\n    /// @param amount Amount to add\n    function addCollateral(\n        address onBehalfOf,\n        address token,\n        uint256 amount\n    ) external payable override nonReentrant {\n        // Wraps ETH and sends it back to msg.sender\n        _wrapETH(); // F:[FA-3E]\n\n        // Checks that onBehalfOf has an account\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            onBehalfOf\n        ); // F:[FA-2]\n\n        addCollateral(onBehalfOf, creditAccount, token, amount);\n\n        // Since this action can enable new tokens, Credit Manager\n        // needs to check that the max enabled token limit is not\n        // breached\n        creditManager.checkAndOptimizeEnabledTokens(creditAccount); // F: [FA-21C]\n    }\n\n    function addCollateral(\n        address onBehalfOf,\n        address creditAccount,\n        address token,\n        uint256 amount\n    ) internal {\n        // Checks that msg.sender can transfer funds to onBehalfOf's account\n        // This is done to prevent malicious actors sending bad collateral\n        // to users\n        // mgs.sender can only add collateral if transfer are approved\n        // from itself to onBehalfOf\n        _revertIfActionOnAccountNotAllowed(onBehalfOf); // F: [FA-21A]\n\n        // Requests Credit Manager to transfer collateral to the Credit Account\n        creditManager.addCollateral(msg.sender, creditAccount, token, amount); // F:[FA-21]\n\n        // Emits event\n        emit AddCollateral(onBehalfOf, token, amount); // F:[FA-21]\n    }\n\n    /// @dev Executes a batch of transactions within a Multicall, to manage an existing account\n    ///  - Wraps ETH and sends it back to msg.sender, if value > 0\n    ///  - Executes the Multicall\n    ///  - Performs a fullCollateralCheck to verify that hf > 1 after all actions\n    /// @param calls The array of MultiCall structs encoding the operations to execute.\n    function multicall(MultiCall[] calldata calls)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        // Checks that msg.sender has an account\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        );\n\n        // Wraps ETH and sends it back to msg.sender\n        _wrapETH(); // F:[FA-3F]\n\n        if (calls.length != 0) {\n            _multicall(calls, msg.sender, creditAccount, false, false);\n\n            // Performs a fullCollateralCheck\n            // During a multicall, all intermediary health checks are skipped,\n            // as one fullCollateralCheck at the end is sufficient\n            creditManager.fullCollateralCheck(creditAccount);\n        }\n    }\n\n    /// @dev IMPLEMENTATION: multicall\n    /// - Transfers ownership from  borrower to this contract, as most adapter and Credit Manager functions retrieve\n    ///   the Credit Account by msg.sender\n    /// - Executes the provided list of calls:\n    ///   + if targetContract == address(this), parses call data in the struct and calls the appropriate function (see _processCreditFacadeMulticall below)\n    ///   + if targetContract == adapter, calls the adapter with call data as provided. Adapters skip health checks when Credit Facade is the msg.sender,\n    ///     as it performs the necessary health checks on its own\n    /// @param borrower Owner of the Credit Account\n    /// @param creditAccount Credit Account address\n    /// @param isClosure Whether the multicall is being invoked during a closure action. Calls to Credit Facade are forbidden inside\n    ///                  multicalls on closure.\n    /// @param increaseDebtWasCalled True if debt was increased before or during the multicall. Used to prevent free flashloans by\n    ///                  increasing and decreasing debt within a single multicall.\n    function _multicall(\n        MultiCall[] calldata calls,\n        address borrower,\n        address creditAccount,\n        bool isClosure,\n        bool increaseDebtWasCalled\n    ) internal {\n        // Takes ownership of the Credit Account\n        creditManager.transferAccountOwnership(borrower, address(this)); // F:[FA-26]\n\n        // Emits event for multicall start - used in analytics to track actions within multicalls\n        emit MultiCallStarted(borrower); // F:[FA-26]\n\n        // Declares the expectedBalances array, which can later be used for slippage control\n        Balance[] memory expectedBalances;\n\n        uint256 len = calls.length; // F:[FA-26]\n        for (uint256 i = 0; i < len; ) {\n            MultiCall calldata mcall = calls[i]; // F:[FA-26]\n\n            // Reverts of calldata has less than 4 bytes\n            if (mcall.callData.length < 4) revert IncorrectCallDataException(); // F:[FA-22]\n\n            if (mcall.target == address(this)) {\n                // No internal calls on closure except slippage control, to avoid loss manipulation\n                if (isClosure) {\n                    bytes4 method = bytes4(mcall.callData);\n                    if (\n                        method !=\n                        ICreditFacadeExtended.revertIfReceivedLessThan.selector\n                    ) revert ForbiddenDuringClosureException(); // F:[FA-13]\n                }\n\n                //\n                // CREDIT FACADE\n                //\n\n                // increaseDebtWasCalled and expectedBalances are parameters that persist throughout multicall,\n                // therefore they are passed to the internal function processor, which returns updated values\n                (\n                    increaseDebtWasCalled,\n                    expectedBalances\n                ) = _processCreditFacadeMulticall(\n                    borrower,\n                    creditAccount,\n                    mcall.callData,\n                    increaseDebtWasCalled,\n                    expectedBalances\n                );\n            } else {\n                //\n                // ADAPTERS\n                //\n\n                // Checks that the target is an allowed adapter and not CreditManager\n                // As CreditFacade has powerful permissions in CreditManagers,\n                // functionCall to it is strictly forbidden, even if\n                // the Configurator adds it as an adapter\n                if (\n                    creditManager.adapterToContract(mcall.target) ==\n                    address(0) ||\n                    mcall.target == address(creditManager)\n                ) revert TargetContractNotAllowedException(); // F:[FA-24]\n\n                // Makes a call\n                mcall.target.functionCall(mcall.callData); // F:[FA-29]\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // If expectedBalances was set by calling revertIfGetLessThan,\n        // checks that actual token balances are not less than expected balances\n        if (expectedBalances.length != 0)\n            _compareBalances(expectedBalances, creditAccount);\n\n        // Emits event for multicall end - used in analytics to track actions within multicalls\n        emit MultiCallFinished(); // F:[FA-27,27,29]\n\n        // Returns ownership back to the borrower\n        creditManager.transferAccountOwnership(address(this), borrower); // F:[FA-27,27,29]\n    }\n\n    /// @dev Internal function for processing calls to Credit Facade within the multicall\n    /// @param borrower Original owner of the Credit Account\n    /// @param creditAccount Credit Account address\n    /// @param callData Call data of the currently processed call\n    /// @param increaseDebtWasCalledBefore Whether debt was increased before entering the function\n    /// @param expectedBalances Array of expected balances before entering the function\n    function _processCreditFacadeMulticall(\n        address borrower,\n        address creditAccount,\n        bytes calldata callData,\n        bool increaseDebtWasCalledBefore,\n        Balance[] memory expectedBalancesBefore\n    )\n        internal\n        returns (bool increaseDebtWasCalled, Balance[] memory expectedBalances)\n    {\n        increaseDebtWasCalled = increaseDebtWasCalledBefore;\n        expectedBalances = expectedBalancesBefore;\n\n        bytes4 method = bytes4(callData);\n\n        //\n        // REVERT_IF_GET_LESS_THAN\n        //\n\n        // This is an extension function that instructs CreditFacade to check token balances at the end\n        // Used to control slippage after the entire sequence of operations, since tracking slippage\n        // On each operation is not ideal\n        if (method == ICreditFacadeExtended.revertIfReceivedLessThan.selector) {\n            // Method can only be called once since the provided Balance array\n            // contains deltas that are added to the current balances\n            // Calling this function again could potentially override old values\n            // and cause confusion, especially if called later in the MultiCall\n            if (expectedBalances.length != 0)\n                revert ExpectedBalancesAlreadySetException(); // F:[FA-45A]\n\n            // Retrieves the balance list from calldata\n            expectedBalances = abi.decode(callData[4:], (Balance[])); // F:[FA-45]\n\n            // Sets expected balances to currentBalance + delta\n            expectedBalances = _storeBalances(expectedBalances, creditAccount); // F:[FA-45]\n        }\n        //\n        // ADD COLLATERAL\n        //\n        else if (method == ICreditFacade.addCollateral.selector) {\n            // Parses parameters from calldata\n            (address onBehalfOf, address token, uint256 amount) = abi.decode(\n                callData[4:],\n                (address, address, uint256)\n            ); // F:[FA-26, 27]\n\n            // In case onBehalfOf isn't the owner of the currently processed account,\n            // retrieves onBehalfOf's account\n            addCollateral(\n                onBehalfOf,\n                onBehalfOf == borrower\n                    ? creditAccount\n                    : creditManager.getCreditAccountOrRevert(onBehalfOf),\n                token,\n                amount\n            ); // F:[FA-26, 27]\n        }\n        //\n        // INCREASE DEBT\n        //\n        else if (method == ICreditFacade.increaseDebt.selector) {\n            // Sets increaseDebtWasCalled to prevent debt reductions afterwards,\n            // as that could be used to get free flash loans\n            increaseDebtWasCalled = true; // F:[FA-28]\n\n            // Parses parameters from calldata\n            uint256 amount = abi.decode(callData[4:], (uint256)); // F:[FA-26]\n            _increaseDebt(borrower, creditAccount, amount); // F:[FA-26]\n        }\n        //\n        // DECREASE DEBT\n        //\n        else if (method == ICreditFacade.decreaseDebt.selector) {\n            // it's forbidden to call decreaseDebt after increaseDebt, in the same multicall\n            if (increaseDebtWasCalled)\n                revert IncreaseAndDecreaseForbiddenInOneCallException(); // F:[FA-28]\n\n            // Parses parameters from calldata\n            uint256 amount = abi.decode(callData[4:], (uint256)); // F:[FA-27]\n\n            _decreaseDebt(borrower, creditAccount, amount); // F:[FA-27]\n        }\n        //\n        // ENABLE TOKEN\n        //\n        else if (method == ICreditFacade.enableToken.selector) {\n            // Parses token\n            address token = abi.decode(callData[4:], (address)); // F: [FA-53]\n\n            // Executes enableToken for creditAccount\n            _enableToken(borrower, creditAccount, token); // F: [FA-53]\n        }\n        //\n        // DISABLE TOKEN\n        //\n        // This is an extenstion method used to disable tokens on a Credit Account\n        // Can be used to remove troublesome tokens (e.g., forbidden tokens) from an account\n        else if (method == ICreditFacadeExtended.disableToken.selector) {\n            // Parses token\n            address token = abi.decode(callData[4:], (address)); // F: [FA-54]\n\n            // Executes disableToken for creditAccount\n            _disableToken(borrower, creditAccount, token); // F: [FA-54]\n        } else {\n            // Reverts if the passed selector is unrecognized\n            revert UnknownMethodException(); // F:[FA-23]\n        }\n    }\n\n    /// @dev Adds expected deltas to current balances on a Credit account and returns the result\n    /// @param expected Expected changes to existing balances\n    /// @param creditAccount Credit Account to compute balances for\n    function _storeBalances(Balance[] memory expected, address creditAccount)\n        internal\n        view\n        returns (Balance[] memory)\n    {\n        uint256 len = expected.length; // F:[FA-45]\n        for (uint256 i = 0; i < len; ) {\n            expected[i].balance += IERC20(expected[i].token).balanceOf(\n                creditAccount\n            ); // F:[FA-45]\n            unchecked {\n                ++i;\n            }\n        }\n\n        return expected; // F:[FA-45]\n    }\n\n    /// @dev Compares current balances to previously saved expected balances.\n    /// Reverts if at least one balance is lower than expected\n    /// @param expected Expected balances after all operations\n    /// @param creditAccount Credit Account to check\n    function _compareBalances(Balance[] memory expected, address creditAccount)\n        internal\n        view\n    {\n        uint256 len = expected.length; // F:[FA-45]\n        for (uint256 i = 0; i < len; ) {\n            if (\n                IERC20(expected[i].token).balanceOf(creditAccount) <\n                expected[i].balance\n            ) revert BalanceLessThanMinimumDesiredException(expected[i].token); // F:[FA-45]\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Sets token allowance from msg.sender's Credit Account to a connected target contract\n    /// @param targetContract Contract to set allowance to. Cannot be in the list of upgradeable contracts\n    /// @param token Token address\n    /// @param amount Allowance amount\n    function approve(\n        address targetContract,\n        address token,\n        uint256 amount\n    ) external override nonReentrant {\n        // Checks that targetContract is a non-zero address and is not in the upgradeable contracts list\n        // If an upgradeable contract is compromised, and an attacker is able to call transferFrom from it,\n        // they would be able to steal funds from Credit Accounts while circumventing all health checks\n        // Thus, this action is only allowed for immutable and highly secure contracts\n        if (\n            creditManager.contractToAdapter(targetContract) == address(0) ||\n            upgradeableContracts.contains(targetContract)\n        )\n            // F: [FA-51]\n            revert TargetContractNotAllowedException(); // F:[FA-30]\n\n        // Requests Credit Manager to set token allowance from Credit Account to contract\n        creditManager.approveCreditAccount(\n            msg.sender,\n            targetContract,\n            token,\n            amount\n        ); // F:[FA-31]\n    }\n\n    /// @dev Transfers credit account to another user\n    /// By default, this action is forbidden, and the user has to approve transfers from sender to itself\n    /// by calling approveAccountTransfer.\n    /// This is done to prevent malicious actors from transferring compromised accounts to other users.\n    /// @param to Address to transfer the account to\n    function transferAccountOwnership(address to)\n        external\n        override\n        nonReentrant\n    {\n        // In whitelisted mode only select addresses can have Credit Accounts\n        // So this action is prohibited\n        if (whitelisted) revert NotAllowedInWhitelistedMode(); // F:[FA-32]\n\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        ); // F:[FA-2]\n\n        // Checks that transfer is allowed\n        if (!transfersAllowed[msg.sender][to])\n            revert AccountTransferNotAllowedException(); // F:[FA-33]\n\n        /// Checks that the account hf > 1, as it is forbidden to transfer\n        /// accounts that are liquidatable\n        (bool isLiquidatable, ) = _isAccountLiquidatable(creditAccount); // F:[FA-34]\n\n        if (isLiquidatable) revert CantTransferLiquidatableAccountException(); // F:[FA-34]\n\n        // Requests the Credit Manager to transfer the account\n        creditManager.transferAccountOwnership(msg.sender, to); // F:[FA-35]\n\n        // Emits event\n        emit TransferAccount(msg.sender, to); // F:[FA-35]\n    }\n\n    /// @dev Verifies that the msg.sender can open an account for onBehalfOf\n    /// -  For expirable Credit Facade, expiration date must not be reached\n    /// -  For whitelisted mode, msg.sender must open the account for themselves\n    ///    and have at least one DegenNFT to burn\n    /// -  Otherwise, checks that account transfers from msg.sender to onBehalfOf\n    ///    are approved\n    /// @param onBehalfOf Account which would own credit account\n    function _revertIfOpenCreditAccountNotAllowed(address onBehalfOf) internal {\n        // Opening new Credit Accounts is prohibited in increaseDebtForbidden mode\n        if (params.isIncreaseDebtForbidden)\n            revert IncreaseDebtForbiddenException(); // F:[FA-7]\n\n        // Checks that this CreditFacade is not expired\n        if (_isExpired()) {\n            revert OpenAccountNotAllowedAfterExpirationException(); // F: [FA-46]\n        }\n\n        // F:[FA-5] covers case when degenNFT == address(0)\n        if (degenNFT != address(0)) {\n            // F:[FA-4B]\n\n            // In whitelisted mode, users can only open an account by burning a DegenNFT\n            // And opening an account for another address is forbidden\n            if (whitelisted && msg.sender != onBehalfOf)\n                revert NotAllowedInWhitelistedMode(); // F:[FA-4B]\n\n            IDegenNFT(degenNFT).burn(onBehalfOf, 1); // F:[FA-4B]\n        }\n\n        _revertIfActionOnAccountNotAllowed(onBehalfOf);\n    }\n\n    /// @dev Checks if the message sender is allowed to do an action on a CA\n    /// @param onBehalfOf The account which owns the target CA\n    function _revertIfActionOnAccountNotAllowed(address onBehalfOf)\n        internal\n        view\n    {\n        // msg.sender must either be the account owner themselves,\n        // or be approved for transfers\n        if (\n            msg.sender != onBehalfOf &&\n            !transfersAllowed[msg.sender][onBehalfOf]\n        ) revert AccountTransferNotAllowedException(); // F:[FA-04C]\n    }\n\n    /// @dev Checks that the per-block borrow limit was not violated and updates the\n    /// amount borrowed in current block\n    function _checkAndUpdateBorrowedBlockLimit(uint256 amount) internal {\n        // Skipped in whitelisted mode, since there is a strict limit on the number\n        // of credit accounts that can be opened, which implies a limit on borrowing\n        if (!whitelisted) {\n            uint256 _limitPerBlock = params.maxBorrowedAmountPerBlock; // F:[FA-18]\n\n            // If the limit is unit128.max, the check is disabled\n            // F:[FA-36] test case when _limitPerBlock == type(uint128).max\n            if (_limitPerBlock != type(uint128).max) {\n                (\n                    uint64 lastBlock,\n                    uint128 lastLimit\n                ) = getTotalBorrowedInBlock(); // F:[FA-18, 37]\n\n                uint256 newLimit = (lastBlock == block.number)\n                    ? amount + lastLimit // F:[FA-37]\n                    : amount; // F:[FA-18, 37]\n\n                if (newLimit > _limitPerBlock)\n                    revert BorrowedBlockLimitException(); // F:[FA-18]\n\n                _updateTotalBorrowedInBlock(uint128(newLimit)); // F:[FA-37]\n            }\n        }\n    }\n\n    /// @dev Checks that the borrowed principal is within borrowing limits\n    /// @param borrowedAmount The current principal of a Credit Account\n    function _revertIfOutOfBorrowedLimits(uint256 borrowedAmount)\n        internal\n        view\n    {\n        // Checks that amount is in limits\n        if (\n            borrowedAmount < uint256(limits.minBorrowedAmount) ||\n            borrowedAmount > uint256(limits.maxBorrowedAmount)\n        ) revert BorrowAmountOutOfLimitsException(); // F:\n    }\n\n    function _checkIfEmergencyLiquidator(bool state) internal returns (bool) {\n        return creditManager.checkEmergencyPausable(msg.sender, state);\n    }\n\n    /// @dev Returns the last block where debt was taken,\n    ///      and the total amount borrowed in that block\n    function getTotalBorrowedInBlock()\n        public\n        view\n        returns (uint64 blockLastUpdate, uint128 borrowedInBlock)\n    {\n        blockLastUpdate = uint64(totalBorrowedInBlock >> 128); // F:[FA-37]\n        borrowedInBlock = uint128(totalBorrowedInBlock & type(uint128).max); // F:[FA-37]\n    }\n\n    /// @dev Saves the total amount borrowed in the current block for future checks\n    /// @param borrowedInBlock Updated total borrowed amount\n    function _updateTotalBorrowedInBlock(uint128 borrowedInBlock) internal {\n        totalBorrowedInBlock = uint256(block.number << 128) | borrowedInBlock; // F:[FA-37]\n    }\n\n    /// @dev Approves account transfer from another user to msg.sender\n    /// @param from Address for which account transfers are allowed/forbidden\n    /// @param state True is transfer is allowed, false if forbidden\n    function approveAccountTransfer(address from, bool state)\n        external\n        override\n        nonReentrant\n    {\n        transfersAllowed[from][msg.sender] = state; // F:[FA-38]\n\n        // Emits event\n        emit TransferAccountAllowed(from, msg.sender, state); // F:[FA-38]\n    }\n\n    /// @dev Enables token in enabledTokenMask for the Credit Account of msg.sender\n    /// @param token Address of token to enable\n    function enableToken(address token) external override nonReentrant {\n        address creditAccount = creditManager.getCreditAccountOrRevert(\n            msg.sender\n        ); // F:[FA-2]\n\n        _enableToken(msg.sender, creditAccount, token);\n\n        // Since this action potentially increases the number of enabled tokens,\n        // the Credit Manager is requested to check that the max limit for enabled tokens\n        // is not violated\n        creditManager.checkAndOptimizeEnabledTokens(creditAccount); // F: [FA-39A]\n    }\n\n    /// @dev IMPLEMENTATION: enableToken\n    /// @param creditAccount Account for which the token is enabled\n    /// @param token Collateral token to enabled\n    function _enableToken(\n        address borrower,\n        address creditAccount,\n        address token\n    ) internal {\n        // Will revert if the token is not known or forbidden,\n        // If the token is disabled, adds the respective bit to the mask, otherwise does nothing\n        creditManager.checkAndEnableToken(creditAccount, token); // F:[FA-39]\n\n        // Emits event\n        emit TokenEnabled(borrower, token);\n    }\n\n    function _disableToken(\n        address borrower,\n        address creditAccount,\n        address token\n    ) internal {\n        // If the token is enabled, removes a respective bit from the mask,\n        // otherwise does nothing\n        if (creditManager.disableToken(creditAccount, token)) {\n            // Emits event\n            emit TokenDisabled(borrower, token);\n        } // F: [FA-54]\n    }\n\n    //\n    // GETTERS\n    //\n\n    /// @dev Returns true if token is a collateral token and is not forbidden,\n    /// otherwise returns false\n    /// @param token Token to check\n    function isTokenAllowed(address token)\n        public\n        view\n        override\n        returns (bool allowed)\n    {\n        uint256 tokenMask = creditManager.tokenMasksMap(token); // F:[FA-40]\n        allowed =\n            (tokenMask != 0) &&\n            (creditManager.forbiddenTokenMask() & tokenMask == 0); // F:[FA-40]\n    }\n\n    /// @dev Calculates total value for provided Credit Account in underlying\n    /// More: https://dev.gearbox.fi/developers/credit/economy#totalUSD-value\n    ///\n    /// @param creditAccount Credit Account address\n    /// @return total Total value in underlying\n    /// @return twv Total weighted (discounted by liquidation thresholds) value in underlying\n    function calcTotalValue(address creditAccount)\n        public\n        view\n        override\n        returns (uint256 total, uint256 twv)\n    {\n        IPriceOracleV2 priceOracle = IPriceOracleV2(\n            creditManager.priceOracle()\n        ); // F:[FA-41]\n\n        (uint256 totalUSD, uint256 twvUSD) = _calcTotalValueUSD(\n            priceOracle,\n            creditAccount\n        );\n        total = priceOracle.convertFromUSD(totalUSD, underlying); // F:[FA-41]\n        twv =\n            priceOracle.convertFromUSD(twvUSD, underlying) /\n            PERCENTAGE_FACTOR; // F:[FA-41]\n    }\n\n    /// @dev Calculates total value for provided Credit Account in USD\n    /// @param priceOracle Oracle used to convert assets to USD\n    /// @param creditAccount Address of the Credit Account\n    /// @return totalUSD Total value of the account in USD\n    /// @return twvUSD Total weighted (discounted by liquidation thresholds) value in USD\n    function _calcTotalValueUSD(\n        IPriceOracleV2 priceOracle,\n        address creditAccount\n    ) internal view returns (uint256 totalUSD, uint256 twvUSD) {\n        uint256 tokenMask = 1;\n        uint256 enabledTokensMask = creditManager.enabledTokensMap(\n            creditAccount\n        ); // F:[FA-41]\n\n        while (tokenMask <= enabledTokensMask) {\n            if (enabledTokensMask & tokenMask != 0) {\n                (address token, uint16 liquidationThreshold) = creditManager\n                    .collateralTokensByMask(tokenMask);\n                uint256 balance = IERC20(token).balanceOf(creditAccount); // F:[FA-41]\n\n                if (balance > 1) {\n                    uint256 value = priceOracle.convertToUSD(balance, token); // F:[FA-41]\n\n                    unchecked {\n                        totalUSD += value; // F:[FA-41]\n                    }\n                    twvUSD += value * liquidationThreshold; // F:[FA-41]\n                }\n            } // T:[FA-41]\n\n            tokenMask = tokenMask << 1; // F:[FA-41]\n        }\n    }\n\n    /**\n     * @dev Calculates health factor for the credit account\n     *\n     *          sum(asset[i] * liquidation threshold[i])\n     *   Hf = --------------------------------------------\n     *         borrowed amount + interest accrued + fees\n     *\n     *\n     * More info: https://dev.gearbox.fi/developers/credit/economy#health-factor\n     *\n     * @param creditAccount Credit account address\n     * @return hf = Health factor in bp (see PERCENTAGE FACTOR in PercentageMath.sol)\n     */\n    function calcCreditAccountHealthFactor(address creditAccount)\n        public\n        view\n        override\n        returns (uint256 hf)\n    {\n        (, uint256 twv) = calcTotalValue(creditAccount); // F:[FA-42]\n        (, , uint256 borrowAmountWithInterestAndFees) = creditManager\n            .calcCreditAccountAccruedInterest(creditAccount); // F:[FA-42]\n        hf = (twv * PERCENTAGE_FACTOR) / borrowAmountWithInterestAndFees; // F:[FA-42]\n    }\n\n    /// @dev Returns true if the borrower has an open Credit Account\n    /// @param borrower Borrower address\n    function hasOpenedCreditAccount(address borrower)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return creditManager.creditAccounts(borrower) != address(0); // F:[FA-43]\n    }\n\n    /// @dev Wraps ETH into WETH and sends it back to msg.sender\n    function _wrapETH() internal {\n        if (msg.value > 0) {\n            IWETH(wethAddress).deposit{ value: msg.value }(); // F:[FA-3]\n            IWETH(wethAddress).transfer(msg.sender, msg.value); // F:[FA-3]\n        }\n    }\n\n    /// @dev Checks if account is liquidatable (i.e., hf < 1)\n    /// @param creditAccount Address of credit account to check\n    /// @return isLiquidatable True if account can be liquidated\n    /// @return totalValue Total value of the Credit Account in underlying\n    function _isAccountLiquidatable(address creditAccount)\n        internal\n        view\n        returns (bool isLiquidatable, uint256 totalValue)\n    {\n        IPriceOracleV2 priceOracle = IPriceOracleV2(\n            creditManager.priceOracle()\n        ); // F:[FA-14]\n\n        (uint256 totalUSD, uint256 twvUSD) = _calcTotalValueUSD(\n            priceOracle,\n            creditAccount\n        );\n\n        // Computes total value in underlying\n        totalValue = priceOracle.convertFromUSD(totalUSD, underlying); // F:[FA-14]\n\n        (, , uint256 borrowAmountWithInterestAndFees) = creditManager\n            .calcCreditAccountAccruedInterest(creditAccount); // F:[FA-14]\n\n        // borrowAmountPlusInterestRateUSD x 10000 to be compared with USD values multiplied by LTs\n        uint256 borrowAmountPlusInterestRateUSD = priceOracle.convertToUSD(\n            borrowAmountWithInterestAndFees,\n            underlying\n        ) * PERCENTAGE_FACTOR;\n\n        // Checks that current Hf < 1\n        isLiquidatable = twvUSD < borrowAmountPlusInterestRateUSD;\n    }\n\n    /// @dev Returns whether the Credit Facade is expired\n    function _isExpired() internal view returns (bool isExpired) {\n        isExpired = (expirable) && (block.timestamp >= params.expirationDate); // F: [FA-46,47,48]\n    }\n\n    //\n    // CONFIGURATION\n    //\n\n    /// @dev Sets the increaseDebtForbidden mode\n    /// @notice increaseDebtForbidden can be used to secure pool funds\n    /// without pausing the entire system. E.g., if a bug is reported\n    /// that can potentially lead to loss of funds, but there is no\n    /// immediate threat, new borrowing can be stopped, while other\n    /// functionality (trading, closing/liquidating accounts) is retained\n    function setIncreaseDebtForbidden(bool _mode)\n        external\n        creditConfiguratorOnly // F:[FA-44]\n    {\n        params.isIncreaseDebtForbidden = _mode;\n    }\n\n    /// @dev Sets borrowing limit per single block\n    /// @notice Borrowing limit per block in conjunction with\n    /// the monitoring system serves to minimize loss from hacks\n    /// While an attacker would be able to steal, in worst case,\n    /// up to (limitPerBlock * n blocks) of funds, the monitoring\n    /// system would pause the contracts after detecting suspicious\n    /// activity\n    function setLimitPerBlock(uint128 newLimit)\n        external\n        creditConfiguratorOnly // F:[FA-44]\n    {\n        params.maxBorrowedAmountPerBlock = newLimit;\n    }\n\n    /// @dev Sets Credit Facade expiration date\n    /// @notice See more at https://dev.gearbox.fi/docs/documentation/credit/liquidation#liquidating-accounts-by-expiration\n    function setExpirationDate(uint40 newExpirationDate)\n        external\n        creditConfiguratorOnly\n    {\n        if (!expirable) {\n            revert NotAllowedWhenNotExpirableException();\n        }\n        params.expirationDate = newExpirationDate;\n    }\n\n    /// @dev Sets borrowing limits per single Credit Account\n    /// @param _minBorrowedAmount The minimal borrowed amount per Credit Account. Minimal amount can be relevant\n    /// for liquidations, since very small amounts will make liquidations unprofitable for liquidators\n    /// @param _maxBorrowedAmount The maximal borrowed amount per Credit Account. Used to limit exposure per a single\n    /// credit account - especially relevant in whitelisted mode.\n    function setCreditAccountLimits(\n        uint128 _minBorrowedAmount,\n        uint128 _maxBorrowedAmount\n    ) external creditConfiguratorOnly {\n        limits.minBorrowedAmount = _minBorrowedAmount; // F:\n        limits.maxBorrowedAmount = _maxBorrowedAmount; // F:\n    }\n\n    //\n    // CONTRACT WATCHLIST CONFIGURATION AND GETTERS\n    //\n\n    /// @dev Change upgradable contract state (add/remove depending on addOrRemove param).\n    /// Direct approvals are forbidden for contracts marked as \"upgradeable\" for\n    /// security reasions\n    /// @param addr Address to add to / remove from the list\n    /// @param addOrRemove True to be added, false to be removed\n    /// @notice Upgradeable contracts are contracts with an upgradeable proxy\n    /// Or other practices and patterns potentially detrimental to security\n    /// Contracts from the list have certain restrictions applied to them\n    function setUpgradeable(address addr, bool addOrRemove)\n        external\n        creditConfiguratorOnly\n    {\n        if (addOrRemove) {\n            upgradeableContracts.add(addr); // F: [FA-50]\n        } else {\n            upgradeableContracts.remove(addr); // F: [FA-50]\n        }\n    }\n\n    /// @dev Returns whether the address is in the list of upgradeable contracts\n    /// @param addr Address to check\n    function isUpgradeableContract(address addr) external view returns (bool) {\n        return upgradeableContracts.contains(addr); // F: [FA-50]\n    }\n\n    /// @dev Returns the entire upgradeable contract list\n    function upgradeableContractsList()\n        external\n        view\n        returns (address[] memory)\n    {\n        return upgradeableContracts.values(); // F: [FA-50]\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/libraries/MultiCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nstruct MultiCall {\n    address target;\n    bytes callData;\n}\n\nlibrary MultiCallOps {\n    function copyMulticall(MultiCall memory call)\n        internal\n        pure\n        returns (MultiCall memory)\n    {\n        return MultiCall({ target: call.target, callData: call.callData });\n    }\n\n    function trim(MultiCall[] memory calls)\n        internal\n        pure\n        returns (MultiCall[] memory trimmed)\n    {\n        uint256 len = calls.length;\n\n        if (len == 0) return calls;\n\n        uint256 foundLen;\n        while (calls[foundLen].target != address(0)) {\n            unchecked {\n                ++foundLen;\n                if (foundLen == len) return calls;\n            }\n        }\n\n        if (foundLen > 0) return copy(calls, foundLen);\n    }\n\n    function copy(MultiCall[] memory calls, uint256 len)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        res = new MultiCall[](len);\n        for (uint256 i; i < len; ) {\n            res[i] = copyMulticall(calls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function clone(MultiCall[] memory calls)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        return copy(calls, calls.length);\n    }\n\n    function append(MultiCall[] memory calls, MultiCall memory newCall)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len = calls.length;\n        res = new MultiCall[](len + 1);\n        for (uint256 i; i < len; ) {\n            res[i] = copyMulticall(calls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        res[len] = copyMulticall(newCall);\n    }\n\n    function prepend(MultiCall[] memory calls, MultiCall memory newCall)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len = calls.length;\n        res = new MultiCall[](len + 1);\n        res[0] = copyMulticall(newCall);\n\n        for (uint256 i = 1; i < len + 1; ) {\n            res[i] = copyMulticall(calls[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function concat(MultiCall[] memory calls1, MultiCall[] memory calls2)\n        internal\n        pure\n        returns (MultiCall[] memory res)\n    {\n        uint256 len1 = calls1.length;\n        uint256 lenTotal = len1 + calls2.length;\n\n        if (lenTotal == calls1.length) return clone(calls1);\n        if (lenTotal == calls2.length) return clone(calls2);\n\n        res = new MultiCall[](lenTotal);\n\n        for (uint256 i; i < lenTotal; ) {\n            res[i] = (i < len1)\n                ? copyMulticall(calls1[i])\n                : copyMulticall(calls2[i - len1]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/libraries/Balances.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\n\nstruct Balance {\n    address token;\n    uint256 balance;\n}\n\nlibrary BalanceOps {\n    error UnknownToken(address);\n\n    function copyBalance(Balance memory b)\n        internal\n        pure\n        returns (Balance memory)\n    {\n        return Balance({ token: b.token, balance: b.balance });\n    }\n\n    function addBalance(\n        Balance[] memory b,\n        address token,\n        uint256 amount\n    ) internal pure {\n        b[getIndex(b, token)].balance += amount;\n    }\n\n    function subBalance(\n        Balance[] memory b,\n        address token,\n        uint256 amount\n    ) internal pure {\n        b[getIndex(b, token)].balance -= amount;\n    }\n\n    function getBalance(Balance[] memory b, address token)\n        internal\n        pure\n        returns (uint256 amount)\n    {\n        return b[getIndex(b, token)].balance;\n    }\n\n    function setBalance(\n        Balance[] memory b,\n        address token,\n        uint256 amount\n    ) internal pure {\n        b[getIndex(b, token)].balance = amount;\n    }\n\n    function getIndex(Balance[] memory b, address token)\n        internal\n        pure\n        returns (uint256 index)\n    {\n        for (uint256 i; i < b.length; ) {\n            if (b[i].token == token) {\n                return i;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        revert UnknownToken(token);\n    }\n\n    function copy(Balance[] memory b, uint256 len)\n        internal\n        pure\n        returns (Balance[] memory res)\n    {\n        res = new Balance[](len);\n        for (uint256 i; i < len; ) {\n            res[i] = copyBalance(b[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function clone(Balance[] memory b)\n        internal\n        pure\n        returns (Balance[] memory)\n    {\n        return copy(b, b.length);\n    }\n\n    function getModifiedAfterSwap(\n        Balance[] memory b,\n        address tokenFrom,\n        uint256 amountFrom,\n        address tokenTo,\n        uint256 amountTo\n    ) internal pure returns (Balance[] memory res) {\n        res = copy(b, b.length);\n        setBalance(res, tokenFrom, getBalance(b, tokenFrom) - amountFrom);\n        setBalance(res, tokenTo, getBalance(b, tokenTo) + amountTo);\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\nimport { IVersion } from \"./IVersion.sol\";\n\ninterface IPriceOracleV2Events {\n    /// @dev Emits when a new price feed is added\n    event NewPriceFeed(address indexed token, address indexed priceFeed);\n}\n\ninterface IPriceOracleV2Exceptions {\n    /// @dev Thrown if a price feed returns 0\n    error ZeroPriceException();\n\n    /// @dev Thrown if the last recorded result was not updated in the last round\n    error ChainPriceStaleException();\n\n    /// @dev Thrown on attempting to get a result for a token that does not have a price feed\n    error PriceOracleNotExistsException();\n}\n\n/// @title Price oracle interface\ninterface IPriceOracleV2 is\n    IPriceOracleV2Events,\n    IPriceOracleV2Exceptions,\n    IVersion\n{\n    /// @dev Converts a quantity of an asset to USD (decimals = 8).\n    /// @param amount Amount to convert\n    /// @param token Address of the token to be converted\n    function convertToUSD(uint256 amount, address token)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Converts a quantity of USD (decimals = 8) to an equivalent amount of an asset\n    /// @param amount Amount to convert\n    /// @param token Address of the token converted to\n    function convertFromUSD(uint256 amount, address token)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Converts one asset into another\n    ///\n    /// @param amount Amount to convert\n    /// @param tokenFrom Address of the token to convert from\n    /// @param tokenTo Address of the token to convert to\n    function convert(\n        uint256 amount,\n        address tokenFrom,\n        address tokenTo\n    ) external view returns (uint256);\n\n    /// @dev Returns collateral values for two tokens, required for a fast check\n    /// @param amountFrom Amount of the outbound token\n    /// @param tokenFrom Address of the outbound token\n    /// @param amountTo Amount of the inbound token\n    /// @param tokenTo Address of the inbound token\n    /// @return collateralFrom Value of the outbound token amount in USD\n    /// @return collateralTo Value of the inbound token amount in USD\n    function fastCheck(\n        uint256 amountFrom,\n        address tokenFrom,\n        uint256 amountTo,\n        address tokenTo\n    ) external view returns (uint256 collateralFrom, uint256 collateralTo);\n\n    /// @dev Returns token's price in USD (8 decimals)\n    /// @param token The token to compute the price for\n    function getPrice(address token) external view returns (uint256);\n\n    /// @dev Returns the price feed address for the passed token\n    /// @param token Token to get the price feed for\n    function priceFeeds(address token)\n        external\n        view\n        returns (address priceFeed);\n\n    /// @dev Returns the price feed for the passed token,\n    ///      with additional parameters\n    /// @param token Token to get the price feed for\n    function priceFeedsWithFlags(address token)\n        external\n        view\n        returns (\n            address priceFeed,\n            bool skipCheck,\n            uint256 decimals\n        );\n}\n\ninterface IPriceOracleV2Ext is IPriceOracleV2 {\n    /// @dev Sets a price feed if it doesn't exist, or updates an existing one\n    /// @param token Address of the token to set the price feed for\n    /// @param priceFeed Address of a USD price feed adhering to Chainlink's interface\n    function addPriceFeed(address token, address priceFeed) external;\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/libraries/Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\n\n// Denominations\n\nuint256 constant WAD = 1e18;\nuint256 constant RAY = 1e27;\n\n// 25% of type(uint256).max\nuint256 constant ALLOWANCE_THRESHOLD = type(uint96).max >> 3;\n\n// FEE = 50%\nuint16 constant DEFAULT_FEE_INTEREST = 50_00; // 50%\n\n// LIQUIDATION_FEE 1.5%\nuint16 constant DEFAULT_FEE_LIQUIDATION = 1_50; // 1.5%\n\n// LIQUIDATION PREMIUM 4%\nuint16 constant DEFAULT_LIQUIDATION_PREMIUM = 4_00; // 4%\n\n// LIQUIDATION_FEE_EXPIRED 2%\nuint16 constant DEFAULT_FEE_LIQUIDATION_EXPIRED = 1_00; // 2%\n\n// LIQUIDATION PREMIUM EXPIRED 2%\nuint16 constant DEFAULT_LIQUIDATION_PREMIUM_EXPIRED = 2_00; // 2%\n\n// DEFAULT PROPORTION OF MAX BORROWED PER BLOCK TO MAX BORROWED PER ACCOUNT\nuint16 constant DEFAULT_LIMIT_PER_BLOCK_MULTIPLIER = 2;\n\n// Seconds in a year\nuint256 constant SECONDS_PER_YEAR = 365 days;\nuint256 constant SECONDS_PER_ONE_AND_HALF_YEAR = (SECONDS_PER_YEAR * 3) / 2;\n\n// OPERATIONS\n\n// Leverage decimals - 100 is equal to 2x leverage (100% * collateral amount + 100% * borrowed amount)\nuint8 constant LEVERAGE_DECIMALS = 100;\n\n// Maximum withdraw fee for pool in PERCENTAGE_FACTOR format\nuint8 constant MAX_WITHDRAW_FEE = 100;\n\nuint256 constant EXACT_INPUT = 1;\nuint256 constant EXACT_OUTPUT = 2;\n\naddress constant UNIVERSAL_CONTRACT = 0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC;\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IDegenNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\nimport { IVersion } from \"./IVersion.sol\";\nimport { IERC721Metadata } from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\ninterface IDegenNFTExceptions {\n    /// @dev Thrown if an access-restricted function was called by non-CreditFacade\n    error CreditFacadeOrConfiguratorOnlyException();\n\n    /// @dev Thrown if an access-restricted function was called by non-minter\n    error MinterOnlyException();\n\n    /// @dev Thrown if trying to add a burner address that is not a correct Credit Facade\n    error InvalidCreditFacadeException();\n\n    /// @dev Thrown if the account's balance is not sufficient for an action (usually a burn)\n    error InsufficientBalanceException();\n}\n\ninterface IDegenNFTEvents {\n    /// @dev Minted when new minter set\n    event NewMinterSet(address indexed);\n\n    /// @dev Minted each time when new credit facade added\n    event NewCreditFacadeAdded(address indexed);\n\n    /// @dev Minted each time when new credit facade added\n    event NewCreditFacadeRemoved(address indexed);\n}\n\ninterface IDegenNFT is\n    IDegenNFTExceptions,\n    IDegenNFTEvents,\n    IVersion,\n    IERC721Metadata\n{\n    /// @dev address of the current minter\n    function minter() external view returns (address);\n\n    /// @dev Stores the total number of tokens on holder accounts\n    function totalSupply() external view returns (uint256);\n\n    /// @dev Stores the base URI for NFT metadata\n    function baseURI() external view returns (string memory);\n\n    /// @dev Mints a specified amount of tokens to the address\n    /// @param to Address the tokens are minted to\n    /// @param amount The number of tokens to mint\n    function mint(address to, uint256 amount) external;\n\n    /// @dev Burns a number of tokens from a specified address\n    /// @param from The address a token will be burnt from\n    /// @param amount The number of tokens to burn\n    function burn(address from, uint256 amount) external;\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/libraries/PercentageMath.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.10;\n\nimport { Errors } from \"./Errors.sol\";\n\nuint16 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\nuint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded half up\n **/\n\nlibrary PercentageMath {\n    /**\n     * @dev Executes a percentage multiplication\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return The percentage of value\n     **/\n    function percentMul(uint256 value, uint256 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (value == 0 || percentage == 0) {\n            return 0; // T:[PM-1]\n        }\n\n        //        require(\n        //            value <= (type(uint256).max - HALF_PERCENT) / percentage,\n        //            Errors.MATH_MULTIPLICATION_OVERFLOW\n        //        ); // T:[PM-1]\n\n        return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR; // T:[PM-1]\n    }\n\n    /**\n     * @dev Executes a percentage division\n     * @param value The value of which the percentage needs to be calculated\n     * @param percentage The percentage of the value to be calculated\n     * @return The value divided the percentage\n     **/\n    function percentDiv(uint256 value, uint256 percentage)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO); // T:[PM-2]\n        uint256 halfPercentage = percentage / 2; // T:[PM-2]\n\n        //        require(\n        //            value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\n        //            Errors.MATH_MULTIPLICATION_OVERFLOW\n        //        ); // T:[PM-2]\n\n        return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/ICreditFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\n\nimport { Balance } from \"../libraries/Balances.sol\";\nimport { MultiCall } from \"../libraries/MultiCall.sol\";\nimport { ICreditManagerV2, ICreditManagerV2Exceptions } from \"./ICreditManagerV2.sol\";\nimport { IVersion } from \"./IVersion.sol\";\n\ninterface ICreditFacadeExtended {\n    /// @dev Stores expected balances (computed as current balance + passed delta)\n    ///      and compare with actual balances at the end of a multicall, reverts\n    ///      if at least one is less than expected\n    /// @param expected Array of expected balance changes\n    /// @notice This is an extenstion function that does not exist in the Credit Facade\n    ///         itself and can only be used within a multicall\n    function revertIfReceivedLessThan(Balance[] memory expected) external;\n\n    /// @dev Enables token in enabledTokenMask for the Credit Account of msg.sender\n    /// @param token Address of token to enable\n    function enableToken(address token) external;\n\n    /// @dev Disables a token on the caller's Credit Account\n    /// @param token Token to disable\n    /// @notice This is an extenstion function that does not exist in the Credit Facade\n    ///         itself and can only be used within a multicall\n    function disableToken(address token) external;\n\n    /// @dev Adds collateral to borrower's credit account\n    /// @param onBehalfOf Address of the borrower whose account is funded\n    /// @param token Address of a collateral token\n    /// @param amount Amount to add\n    function addCollateral(\n        address onBehalfOf,\n        address token,\n        uint256 amount\n    ) external payable;\n\n    /// @dev Increases debt for msg.sender's Credit Account\n    /// - Borrows the requested amount from the pool\n    /// - Updates the CA's borrowAmount / cumulativeIndexOpen\n    ///   to correctly compute interest going forward\n    /// - Performs a full collateral check\n    ///\n    /// @param amount Amount to borrow\n    function increaseDebt(uint256 amount) external;\n\n    /// @dev Decrease debt\n    /// - Decreases the debt by paying the requested amount + accrued interest + fees back to the pool\n    /// - It's also include to this payment interest accrued at the moment and fees\n    /// - Updates cunulativeIndex to cumulativeIndex now\n    ///\n    /// @param amount Amount to increase borrowed amount\n    function decreaseDebt(uint256 amount) external;\n}\n\ninterface ICreditFacadeEvents {\n    /// @dev Emits when a new Credit Account is opened through the\n    ///      Credit Facade\n    event OpenCreditAccount(\n        address indexed onBehalfOf,\n        address indexed creditAccount,\n        uint256 borrowAmount,\n        uint16 referralCode\n    );\n\n    /// @dev Emits when the account owner closes their CA normally\n    event CloseCreditAccount(address indexed borrower, address indexed to);\n\n    /// @dev Emits when a Credit Account is liquidated due to low health factor\n    event LiquidateCreditAccount(\n        address indexed borrower,\n        address indexed liquidator,\n        address indexed to,\n        uint256 remainingFunds\n    );\n\n    /// @dev Emits when a Credit Account is liquidated due to expiry\n    event LiquidateExpiredCreditAccount(\n        address indexed borrower,\n        address indexed liquidator,\n        address indexed to,\n        uint256 remainingFunds\n    );\n\n    /// @dev Emits when the account owner increases CA's debt\n    event IncreaseBorrowedAmount(address indexed borrower, uint256 amount);\n\n    /// @dev Emits when the account owner reduces CA's debt\n    event DecreaseBorrowedAmount(address indexed borrower, uint256 amount);\n\n    /// @dev Emits when the account owner add new collateral to a CA\n    event AddCollateral(\n        address indexed onBehalfOf,\n        address indexed token,\n        uint256 value\n    );\n\n    /// @dev Emits when a multicall is started\n    event MultiCallStarted(address indexed borrower);\n\n    /// @dev Emits when a multicall is finished\n    event MultiCallFinished();\n\n    /// @dev Emits when Credit Account ownership is transferred\n    event TransferAccount(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev Emits when the user changes approval for account transfers to itself from another address\n    event TransferAccountAllowed(\n        address indexed from,\n        address indexed to,\n        bool state\n    );\n\n    /// @dev Emits when the account owner enables a token on their CA\n    event TokenEnabled(address indexed borrower, address indexed token);\n\n    /// @dev Emits when the account owner disables a token on their CA\n    event TokenDisabled(address indexed borrower, address indexed token);\n}\n\ninterface ICreditFacadeExceptions is ICreditManagerV2Exceptions {\n    /// @dev Thrown if the CreditFacade is not expirable, and an aciton is attempted that\n    ///      requires expirability\n    error NotAllowedWhenNotExpirableException();\n\n    /// @dev Thrown if whitelisted mode is enabled, and an action is attempted that is\n    ///      not allowed in whitelisted mode\n    error NotAllowedInWhitelistedMode();\n\n    /// @dev Thrown if a user attempts to transfer a CA to an address that didn't allow it\n    error AccountTransferNotAllowedException();\n\n    /// @dev Thrown if a liquidator tries to liquidate an account with a health factor above 1\n    error CantLiquidateWithSuchHealthFactorException();\n\n    /// @dev Thrown if a liquidator tries to liquidate an account by expiry while a Credit Facade is not expired\n    error CantLiquidateNonExpiredException();\n\n    /// @dev Thrown if call data passed to a multicall is too short\n    error IncorrectCallDataException();\n\n    /// @dev Thrown inside account closure multicall if the borrower attempts an action that is forbidden on closing\n    ///      an account\n    error ForbiddenDuringClosureException();\n\n    /// @dev Thrown if debt increase and decrease are subsequently attempted in one multicall\n    error IncreaseAndDecreaseForbiddenInOneCallException();\n\n    /// @dev Thrown if a selector that doesn't match any allowed function is passed to the Credit Facade\n    ///      during a multicall\n    error UnknownMethodException();\n\n    /// @dev Thrown if a user tries to open an account or increase debt with increaseDebtForbidden mode on\n    error IncreaseDebtForbiddenException();\n\n    /// @dev Thrown if the account owner tries to transfer an unhealthy account\n    error CantTransferLiquidatableAccountException();\n\n    /// @dev Thrown if too much new debt was taken within a single block\n    error BorrowedBlockLimitException();\n\n    /// @dev Thrown if the new debt principal for a CA falls outside of borrowing limits\n    error BorrowAmountOutOfLimitsException();\n\n    /// @dev Thrown if one of the balances on a Credit Account is less than expected\n    ///      at the end of a multicall, if revertIfReceivedLessThan was called\n    error BalanceLessThanMinimumDesiredException(address);\n\n    /// @dev Thrown if a user attempts to open an account on a Credit Facade that has expired\n    error OpenAccountNotAllowedAfterExpirationException();\n\n    /// @dev Thrown if expected balances are attempted to be set through revertIfReceivedLessThan twice\n    error ExpectedBalancesAlreadySetException();\n\n    /// @dev Thrown if a Credit Account has enabled forbidden tokens and the owner attempts to perform an action\n    ///      that is not allowed with any forbidden tokens enabled\n    error ActionProhibitedWithForbiddenTokensException();\n}\n\ninterface ICreditFacade is\n    ICreditFacadeEvents,\n    ICreditFacadeExceptions,\n    IVersion\n{\n    //\n    // CREDIT ACCOUNT MANAGEMENT\n    //\n\n    /// @dev Opens credit account, borrows funds from the pool and pulls collateral\n    /// without any additional action.\n    /// @param amount The amount of collateral provided by the borrower\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\n    /// msg.sender != obBehalfOf\n    /// @param leverageFactor Percentage of the user's own funds to borrow. 100 is equal to 100% - borrows the same amount\n    /// as the user's own collateral, equivalent to 2x leverage.\n    /// @param referralCode Referral code that is used for potential rewards. 0 if no referral code provided.\n    function openCreditAccount(\n        uint256 amount,\n        address onBehalfOf,\n        uint16 leverageFactor,\n        uint16 referralCode\n    ) external payable;\n\n    /// @dev Opens a Credit Account and runs a batch of operations in a multicall\n    /// @param borrowedAmount Debt size\n    /// @param onBehalfOf The address to open an account for. Transfers to it have to be allowed if\n    /// msg.sender != obBehalfOf\n    /// @param calls The array of MultiCall structs encoding the required operations. Generally must have\n    /// at least a call to addCollateral, as otherwise the health check at the end will fail.\n    /// @param referralCode Referral code which is used for potential rewards. 0 if no referral code provided\n    function openCreditAccountMulticall(\n        uint256 borrowedAmount,\n        address onBehalfOf,\n        MultiCall[] calldata calls,\n        uint16 referralCode\n    ) external payable;\n\n    /// @dev Runs a batch of transactions within a multicall and closes the account\n    /// - Wraps ETH to WETH and sends it msg.sender if value > 0\n    /// - Executes the multicall - the main purpose of a multicall when closing is to convert all assets to underlying\n    /// in order to pay the debt.\n    /// - Closes credit account:\n    ///    + Checks the underlying balance: if it is greater than the amount paid to the pool, transfers the underlying\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from msg.sender.\n    ///    + Transfers all enabled assets with non-zero balances to the \"to\" address, unless they are marked\n    ///      to be skipped in skipTokenMask\n    ///    + If convertWETH is true, converts WETH into ETH before sending to the recipient\n    /// - Emits a CloseCreditAccount event\n    ///\n    /// @param to Address to send funds to during account closing\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\n    /// @param convertWETH If true, converts WETH into ETH before sending to \"to\"\n    /// @param calls The array of MultiCall structs encoding the operations to execute before closing the account.\n    function closeCreditAccount(\n        address to,\n        uint256 skipTokenMask,\n        bool convertWETH,\n        MultiCall[] calldata calls\n    ) external payable;\n\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account\n    /// - Computes the total value and checks that hf < 1. An account can't be liquidated when hf >= 1.\n    ///   Total value has to be computed before the multicall, otherwise the liquidator would be able\n    ///   to manipulate it.\n    /// - Wraps ETH to WETH and sends it to msg.sender (liquidator) if value > 0\n    /// - Executes the multicall - the main purpose of a multicall when liquidating is to convert all assets to underlying\n    ///   in order to pay the debt.\n    /// - Liquidate credit account:\n    ///    + Computes the amount that needs to be paid to the pool. If totalValue * liquidationDiscount < borrow + interest + fees,\n    ///      only totalValue * liquidationDiscount has to be paid. Since liquidationDiscount < 1, the liquidator can take\n    ///      totalValue * (1 - liquidationDiscount) as premium. Also computes the remaining funds to be sent to borrower\n    ///      as totalValue * liquidationDiscount - amountToPool.\n    ///    + Checks the underlying balance: if it is greater than amountToPool + remainingFunds, transfers the underlying\n    ///      from the Credit Account and proceeds. If not, tries to transfer the shortfall from the liquidator.\n    ///    + Transfers all enabled assets with non-zero balances to the \"to\" address, unless they are marked\n    ///      to be skipped in skipTokenMask. If the liquidator is confident that all assets were converted\n    ///      during the multicall, they can set the mask to uint256.max - 1, to only transfer the underlying\n    ///    + If convertWETH is true, converts WETH into ETH before sending\n    /// - Emits LiquidateCreditAccount event\n    ///\n    /// @param to Address to send funds to after liquidation\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\n    /// @param convertWETH If true, converts WETH into ETH before sending to \"to\"\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\n    function liquidateCreditAccount(\n        address borrower,\n        address to,\n        uint256 skipTokenMask,\n        bool convertWETH,\n        MultiCall[] calldata calls\n    ) external payable;\n\n    /// @dev Runs a batch of transactions within a multicall and liquidates the account when\n    /// this Credit Facade is expired\n    /// The general flow of liquidation is nearly the same as normal liquidations, with two main differences:\n    ///     - An account can be liquidated on an expired Credit Facade even with hf > 1. However,\n    ///       no accounts can be liquidated through this function if the Credit Facade is not expired.\n    ///     - Liquidation premiums and fees for liquidating expired accounts are reduced.\n    /// It is still possible to normally liquidate an underwater Credit Account, even when the Credit Facade\n    /// is expired.\n    /// @param to Address to send funds to after liquidation\n    /// @param skipTokenMask Uint-encoded bit mask where 1's mark tokens that shouldn't be transferred\n    /// @param convertWETH If true, converts WETH into ETH before sending to \"to\"\n    /// @param calls The array of MultiCall structs encoding the operations to execute before liquidating the account.\n    /// @notice See more at https://dev.gearbox.fi/docs/documentation/credit/liquidation#liquidating-accounts-by-expiration\n    function liquidateExpiredCreditAccount(\n        address borrower,\n        address to,\n        uint256 skipTokenMask,\n        bool convertWETH,\n        MultiCall[] calldata calls\n    ) external payable;\n\n    /// @dev Increases debt for msg.sender's Credit Account\n    /// - Borrows the requested amount from the pool\n    /// - Updates the CA's borrowAmount / cumulativeIndexOpen\n    ///   to correctly compute interest going forward\n    /// - Performs a full collateral check\n    ///\n    /// @param amount Amount to borrow\n    function increaseDebt(uint256 amount) external;\n\n    /// @dev Decrease debt\n    /// - Decreases the debt by paying the requested amount + accrued interest + fees back to the pool\n    /// - It's also include to this payment interest accrued at the moment and fees\n    /// - Updates cunulativeIndex to cumulativeIndex now\n    ///\n    /// @param amount Amount to increase borrowed amount\n    function decreaseDebt(uint256 amount) external;\n\n    /// @dev Adds collateral to borrower's credit account\n    /// @param onBehalfOf Address of the borrower whose account is funded\n    /// @param token Address of a collateral token\n    /// @param amount Amount to add\n    function addCollateral(\n        address onBehalfOf,\n        address token,\n        uint256 amount\n    ) external payable;\n\n    /// @dev Executes a batch of transactions within a Multicall, to manage an existing account\n    ///  - Wraps ETH and sends it back to msg.sender, if value > 0\n    ///  - Executes the Multicall\n    ///  - Performs a fullCollateralCheck to verify that hf > 1 after all actions\n    /// @param calls The array of MultiCall structs encoding the operations to execute.\n    function multicall(MultiCall[] calldata calls) external payable;\n\n    /// @dev Returns true if the borrower has an open Credit Account\n    /// @param borrower Borrower address\n    function hasOpenedCreditAccount(address borrower)\n        external\n        view\n        returns (bool);\n\n    /// @dev Sets token allowance from msg.sender's Credit Account to a connected target contract\n    /// @param targetContract Contract to set allowance to. Cannot be in the list of upgradeable contracts\n    /// @param token Token address\n    /// @param amount Allowance amount\n    function approve(\n        address targetContract,\n        address token,\n        uint256 amount\n    ) external;\n\n    /// @dev Approves account transfer from another user to msg.sender\n    /// @param from Address for which account transfers are allowed/forbidden\n    /// @param state True is transfer is allowed, false if forbidden\n    function approveAccountTransfer(address from, bool state) external;\n\n    /// @dev Enables token in enabledTokenMask for the Credit Account of msg.sender\n    /// @param token Address of token to enable\n    function enableToken(address token) external;\n\n    /// @dev Transfers credit account to another user\n    /// By default, this action is forbidden, and the user has to approve transfers from sender to itself\n    /// by calling approveAccountTransfer.\n    /// This is done to prevent malicious actors from transferring compromised accounts to other users.\n    /// @param to Address to transfer the account to\n    function transferAccountOwnership(address to) external;\n\n    //\n    // GETTERS\n    //\n\n    /// @dev Calculates total value for provided Credit Account in underlying\n    ///\n    /// @param creditAccount Credit Account address\n    /// @return total Total value in underlying\n    /// @return twv Total weighted (discounted by liquidation thresholds) value in underlying\n    function calcTotalValue(address creditAccount)\n        external\n        view\n        returns (uint256 total, uint256 twv);\n\n    /**\n     * @dev Calculates health factor for the credit account\n     *\n     *          sum(asset[i] * liquidation threshold[i])\n     *   Hf = --------------------------------------------\n     *         borrowed amount + interest accrued + fees\n     *\n     *\n     * More info: https://dev.gearbox.fi/developers/credit/economy#health-factor\n     *\n     * @param creditAccount Credit account address\n     * @return hf = Health factor in bp (see PERCENTAGE FACTOR in PercentageMath.sol)\n     */\n    function calcCreditAccountHealthFactor(address creditAccount)\n        external\n        view\n        returns (uint256 hf);\n\n    /// @dev Returns true if token is a collateral token and is not forbidden,\n    /// otherwise returns false\n    /// @param token Token to check\n    function isTokenAllowed(address token) external view returns (bool);\n\n    /// @dev Returns the CreditManager connected to this Credit Facade\n    function creditManager() external view returns (ICreditManagerV2);\n\n    /// @dev Returns true if 'from' is allowed to transfer Credit Accounts to 'to'\n    /// @param from Sender address to check allowance for\n    /// @param to Receiver address to check allowance for\n    function transfersAllowed(address from, address to)\n        external\n        view\n        returns (bool);\n\n    /// @return maxBorrowedAmountPerBlock Maximal amount of new debt that can be taken per block\n    /// @return isIncreaseDebtForbidden True if increasing debt is forbidden\n    /// @return expirationDate Timestamp of the next expiration (for expirable Credit Facades only)\n    function params()\n        external\n        view\n        returns (\n            uint128 maxBorrowedAmountPerBlock,\n            bool isIncreaseDebtForbidden,\n            uint40 expirationDate\n        );\n\n    /// @return minBorrowedAmount Minimal borrowed amount per credit account\n    /// @return maxBorrowedAmount Maximal borrowed amount per credit account\n    function limits()\n        external\n        view\n        returns (uint128 minBorrowedAmount, uint128 maxBorrowedAmount);\n\n    /// @dev Address of the DegenNFT that gatekeeps account openings in whitelisted mode\n    function degenNFT() external view returns (address);\n\n    /// @dev Address of the underlying asset\n    function underlying() external view returns (address);\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/ICreditManagerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\n\nimport { IPriceOracleV2 } from \"./IPriceOracle.sol\";\nimport { IVersion } from \"./IVersion.sol\";\n\nenum ClosureAction {\n    CLOSE_ACCOUNT,\n    LIQUIDATE_ACCOUNT,\n    LIQUIDATE_EXPIRED_ACCOUNT,\n    LIQUIDATE_PAUSED\n}\n\ninterface ICreditManagerV2Events {\n    /// @dev Emits when a call to an external contract is made through the Credit Manager\n    event ExecuteOrder(address indexed borrower, address indexed target);\n\n    /// @dev Emits when a configurator is upgraded\n    event NewConfigurator(address indexed newConfigurator);\n}\n\ninterface ICreditManagerV2Exceptions {\n    /// @dev Thrown if an access-restricted function is called by an address that is not\n    ///      the connected Credit Facade, or an allowed adapter\n    error AdaptersOrCreditFacadeOnlyException();\n\n    /// @dev Thrown if an access-restricted function is called by an address that is not\n    ///      the connected Credit Facade\n    error CreditFacadeOnlyException();\n\n    /// @dev Thrown if an access-restricted function is called by an address that is not\n    ///      the connected Credit Configurator\n    error CreditConfiguratorOnlyException();\n\n    /// @dev Thrown on attempting to open a Credit Account for or transfer a Credit Account\n    ///      to the zero address or an address that already owns a Credit Account\n    error ZeroAddressOrUserAlreadyHasAccountException();\n\n    /// @dev Thrown on attempting to execute an order to an address that is not an allowed\n    ///      target contract\n    error TargetContractNotAllowedException();\n\n    /// @dev Thrown on failing a full collateral check after an operation\n    error NotEnoughCollateralException();\n\n    /// @dev Thrown on attempting to receive a token that is not a collateral token\n    ///      or was forbidden\n    error TokenNotAllowedException();\n\n    /// @dev Thrown if an attempt to approve a collateral token to a target contract failed\n    error AllowanceFailedException();\n\n    /// @dev Thrown on attempting to perform an action for an address that owns no Credit Account\n    error HasNoOpenedAccountException();\n\n    /// @dev Thrown on attempting to add a token that is already in a collateral list\n    error TokenAlreadyAddedException();\n\n    /// @dev Thrown on configurator attempting to add more than 256 collateral tokens\n    error TooManyTokensException();\n\n    /// @dev Thrown if more than the maximal number of tokens were enabled on a Credit Account,\n    ///      and there are not enough unused token to disable\n    error TooManyEnabledTokensException();\n\n    /// @dev Thrown when a reentrancy into the contract is attempted\n    error ReentrancyLockException();\n}\n\n/// @notice All Credit Manager functions are access-restricted and can only be called\n///         by the Credit Facade or allowed adapters. Users are not allowed to\n///         interact with the Credit Manager directly\ninterface ICreditManagerV2 is\n    ICreditManagerV2Events,\n    ICreditManagerV2Exceptions,\n    IVersion\n{\n    //\n    // CREDIT ACCOUNT MANAGEMENT\n    //\n\n    ///  @dev Opens credit account and borrows funds from the pool.\n    /// - Takes Credit Account from the factory;\n    /// - Requests the pool to lend underlying to the Credit Account\n    ///\n    /// @param borrowedAmount Amount to be borrowed by the Credit Account\n    /// @param onBehalfOf The owner of the newly opened Credit Account\n    function openCreditAccount(uint256 borrowedAmount, address onBehalfOf)\n        external\n        returns (address);\n\n    ///  @dev Closes a Credit Account - covers both normal closure and liquidation\n    /// - Checks whether the contract is paused, and, if so, if the payer is an emergency liquidator.\n    ///   Only emergency liquidators are able to liquidate account while the CM is paused.\n    ///   Emergency liquidations do not pay a liquidator premium or liquidation fees.\n    /// - Calculates payments to various recipients on closure:\n    ///    + Computes amountToPool, which is the amount to be sent back to the pool.\n    ///      This includes the principal, interest and fees, but can't be more than\n    ///      total position value\n    ///    + Computes remainingFunds during liquidations - these are leftover funds\n    ///      after paying the pool and the liquidator, and are sent to the borrower\n    ///    + Computes protocol profit, which includes interest and liquidation fees\n    ///    + Computes loss if the totalValue is less than borrow amount + interest\n    /// - Checks the underlying token balance:\n    ///    + if it is larger than amountToPool, then the pool is paid fully from funds on the Credit Account\n    ///    + else tries to transfer the shortfall from the payer - either the borrower during closure, or liquidator during liquidation\n    /// - Send assets to the \"to\" address, as long as they are not included into skipTokenMask\n    /// - If convertWETH is true, the function converts WETH into ETH before sending\n    /// - Returns the Credit Account back to factory\n    ///\n    /// @param borrower Borrower address\n    /// @param closureActionType Whether the account is closed, liquidated or liquidated due to expiry\n    /// @param totalValue Portfolio value for liqution, 0 for ordinary closure\n    /// @param payer Address which would be charged if credit account has not enough funds to cover amountToPool\n    /// @param to Address to which the leftover funds will be sent\n    /// @param skipTokenMask Tokenmask contains 1 for tokens which needed to be skipped for sending\n    /// @param convertWETH If true converts WETH to ETH\n    function closeCreditAccount(\n        address borrower,\n        ClosureAction closureActionType,\n        uint256 totalValue,\n        address payer,\n        address to,\n        uint256 skipTokenMask,\n        bool convertWETH\n    ) external returns (uint256 remainingFunds);\n\n    /// @dev Manages debt size for borrower:\n    ///\n    /// - Increase debt:\n    ///   + Increases debt by transferring funds from the pool to the credit account\n    ///   + Updates the cumulative index to keep interest the same. Since interest\n    ///     is always computed dynamically as borrowedAmount * (cumulativeIndexNew / cumulativeIndexOpen - 1),\n    ///     cumulativeIndexOpen needs to be updated, as the borrow amount has changed\n    ///\n    /// - Decrease debt:\n    ///   + Repays debt partially + all interest and fees accrued thus far\n    ///   + Updates cunulativeIndex to cumulativeIndex now\n    ///\n    /// @param creditAccount Address of the Credit Account to change debt for\n    /// @param amount Amount to increase / decrease the principal by\n    /// @param increase True to increase principal, false to decrease\n    /// @return newBorrowedAmount The new debt principal\n    function manageDebt(\n        address creditAccount,\n        uint256 amount,\n        bool increase\n    ) external returns (uint256 newBorrowedAmount);\n\n    /// @dev Adds collateral to borrower's credit account\n    /// @param payer Address of the account which will be charged to provide additional collateral\n    /// @param creditAccount Address of the Credit Account\n    /// @param token Collateral token to add\n    /// @param amount Amount to add\n    function addCollateral(\n        address payer,\n        address creditAccount,\n        address token,\n        uint256 amount\n    ) external;\n\n    /// @dev Transfers Credit Account ownership to another address\n    /// @param from Address of previous owner\n    /// @param to Address of new owner\n    function transferAccountOwnership(address from, address to) external;\n\n    /// @dev Requests the Credit Account to approve a collateral token to another contract.\n    /// @param borrower Borrower's address\n    /// @param targetContract Spender to change allowance for\n    /// @param token Collateral token to approve\n    /// @param amount New allowance amount\n    function approveCreditAccount(\n        address borrower,\n        address targetContract,\n        address token,\n        uint256 amount\n    ) external;\n\n    /// @dev Requests a Credit Account to make a low-level call with provided data\n    /// This is the intended pathway for state-changing interactions with 3rd-party protocols\n    /// @param borrower Borrower's address\n    /// @param targetContract Contract to be called\n    /// @param data Data to pass with the call\n    function executeOrder(\n        address borrower,\n        address targetContract,\n        bytes memory data\n    ) external returns (bytes memory);\n\n    //\n    // COLLATERAL VALIDITY AND ACCOUNT HEALTH CHECKS\n    //\n\n    /// @dev Enables a token on a Credit Account, including it\n    /// into account health and total value calculations\n    /// @param creditAccount Address of a Credit Account to enable the token for\n    /// @param token Address of the token to be enabled\n    function checkAndEnableToken(address creditAccount, address token) external;\n\n    /// @dev Optimized health check for individual swap-like operations.\n    /// @notice Fast health check assumes that only two tokens (input and output)\n    ///         participate in the operation and computes a % change in weighted value between\n    ///         inbound and outbound collateral. The cumulative negative change across several\n    ///         swaps in sequence cannot be larger than feeLiquidation (a fee that the\n    ///         protocol is ready to waive if needed). Since this records a % change\n    ///         between just two tokens, the corresponding % change in TWV will always be smaller,\n    ///         which makes this check safe.\n    ///         More details at https://dev.gearbox.fi/docs/documentation/risk/fast-collateral-check#fast-check-protection\n    /// @param creditAccount Address of the Credit Account\n    /// @param tokenIn Address of the token spent by the swap\n    /// @param tokenOut Address of the token received from the swap\n    /// @param balanceInBefore Balance of tokenIn before the operation\n    /// @param balanceOutBefore Balance of tokenOut before the operation\n    function fastCollateralCheck(\n        address creditAccount,\n        address tokenIn,\n        address tokenOut,\n        uint256 balanceInBefore,\n        uint256 balanceOutBefore\n    ) external;\n\n    /// @dev Performs a full health check on an account, summing up\n    /// value of all enabled collateral tokens\n    /// @param creditAccount Address of the Credit Account to check\n    function fullCollateralCheck(address creditAccount) external;\n\n    /// @dev Checks that the number of enabled tokens on a Credit Account\n    ///      does not violate the maximal enabled token limit and tries\n    ///      to disable unused tokens if it does\n    /// @param creditAccount Account to check enabled tokens for\n    function checkAndOptimizeEnabledTokens(address creditAccount) external;\n\n    /// @dev Disables a token on a credit account\n    /// @notice Usually called by adapters to disable spent tokens during a multicall,\n    ///         but can also be called separately from the Credit Facade to remove\n    ///         unwanted tokens\n    /// @return True if token mask was change otherwise False\n    function disableToken(address creditAccount, address token)\n        external\n        returns (bool);\n\n    //\n    // GETTERS\n    //\n\n    /// @dev Returns the address of a borrower's Credit Account, or reverts if there is none.\n    /// @param borrower Borrower's address\n    function getCreditAccountOrRevert(address borrower)\n        external\n        view\n        returns (address);\n\n    /// @dev Computes amounts that must be sent to various addresses before closing an account\n    /// @param totalValue Credit Accounts total value in underlying\n    /// @param closureActionType Type of account closure\n    ///        * CLOSE_ACCOUNT: The account is healthy and is closed normally\n    ///        * LIQUIDATE_ACCOUNT: The account is unhealthy and is being liquidated to avoid bad debt\n    ///        * LIQUIDATE_EXPIRED_ACCOUNT: The account has expired and is being liquidated (lowered liquidation premium)\n    ///        * LIQUIDATE_PAUSED: The account is liquidated while the system is paused due to emergency (no liquidation premium)\n    /// @param borrowedAmount Credit Account's debt principal\n    /// @param borrowedAmountWithInterest Credit Account's debt principal + interest\n    /// @return amountToPool Amount of underlying to be sent to the pool\n    /// @return remainingFunds Amount of underlying to be sent to the borrower (only applicable to liquidations)\n    /// @return profit Protocol's profit from fees (if any)\n    /// @return loss Protocol's loss from bad debt (if any)\n    function calcClosePayments(\n        uint256 totalValue,\n        ClosureAction closureActionType,\n        uint256 borrowedAmount,\n        uint256 borrowedAmountWithInterest\n    )\n        external\n        view\n        returns (\n            uint256 amountToPool,\n            uint256 remainingFunds,\n            uint256 profit,\n            uint256 loss\n        );\n\n    /// @dev Calculates the debt accrued by a Credit Account\n    /// @param creditAccount Address of the Credit Account\n    /// @return borrowedAmount The debt principal\n    /// @return borrowedAmountWithInterest The debt principal + accrued interest\n    /// @return borrowedAmountWithInterestAndFees The debt principal + accrued interest and protocol fees\n    function calcCreditAccountAccruedInterest(address creditAccount)\n        external\n        view\n        returns (\n            uint256 borrowedAmount,\n            uint256 borrowedAmountWithInterest,\n            uint256 borrowedAmountWithInterestAndFees\n        );\n\n    /// @dev Maps Credit Accounts to bit masks encoding their enabled token sets\n    /// Only enabled tokens are counted as collateral for the Credit Account\n    /// @notice An enabled token mask encodes an enabled token by setting\n    ///         the bit at the position equal to token's index to 1\n    function enabledTokensMap(address creditAccount)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Maps the Credit Account to its current percentage drop across all swaps since\n    ///      the last full check, in RAY format\n    function cumulativeDropAtFastCheckRAY(address creditAccount)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns the collateral token at requested index and its liquidation threshold\n    /// @param id The index of token to return\n    function collateralTokens(uint256 id)\n        external\n        view\n        returns (address token, uint16 liquidationThreshold);\n\n    /// @dev Returns the collateral token with requested mask and its liquidationThreshold\n    /// @param tokenMask Token mask corresponding to the token\n    function collateralTokensByMask(uint256 tokenMask)\n        external\n        view\n        returns (address token, uint16 liquidationThreshold);\n\n    /// @dev Total number of known collateral tokens.\n    function collateralTokensCount() external view returns (uint256);\n\n    /// @dev Returns the mask for the provided token\n    /// @param token Token to returns the mask for\n    function tokenMasksMap(address token) external view returns (uint256);\n\n    /// @dev Bit mask encoding a set of forbidden tokens\n    function forbiddenTokenMask() external view returns (uint256);\n\n    /// @dev Maps allowed adapters to their respective target contracts.\n    function adapterToContract(address adapter) external view returns (address);\n\n    /// @dev Maps 3rd party contracts to their respective adapters\n    function contractToAdapter(address targetContract)\n        external\n        view\n        returns (address);\n\n    /// @dev Address of the underlying asset\n    function underlying() external view returns (address);\n\n    /// @dev Address of the connected pool\n    function pool() external view returns (address);\n\n    /// @dev Address of the connected pool\n    /// @notice [DEPRECATED]: use pool() instead.\n    function poolService() external view returns (address);\n\n    /// @dev A map from borrower addresses to Credit Account addresses\n    function creditAccounts(address borrower) external view returns (address);\n\n    /// @dev Address of the connected Credit Configurator\n    function creditConfigurator() external view returns (address);\n\n    /// @dev Address of WETH\n    function wethAddress() external view returns (address);\n\n    /// @dev Returns the liquidation threshold for the provided token\n    /// @param token Token to retrieve the LT for\n    function liquidationThresholds(address token)\n        external\n        view\n        returns (uint16);\n\n    /// @dev The maximal number of enabled tokens on a single Credit Account\n    function maxAllowedEnabledTokenLength() external view returns (uint8);\n\n    /// @dev Maps addresses to their status as emergency liquidator.\n    /// @notice Emergency liquidators are trusted addresses\n    /// that are able to liquidate positions while the contracts are paused,\n    /// e.g. when there is a risk of bad debt while an exploit is being patched.\n    /// In the interest of fairness, emergency liquidators do not receive a premium\n    /// And are compensated by the Gearbox DAO separately.\n    function canLiquidateWhilePaused(address) external view returns (bool);\n\n    /// @dev Returns the fee parameters of the Credit Manager\n    /// @return feeInterest Percentage of interest taken by the protocol as profit\n    /// @return feeLiquidation Percentage of account value taken by the protocol as profit\n    ///         during unhealthy account liquidations\n    /// @return liquidationDiscount Multiplier that reduces the effective totalValue during unhealthy account liquidations,\n    ///         allowing the liquidator to take the unaccounted for remainder as premium. Equal to (1 - liquidationPremium)\n    /// @return feeLiquidationExpired Percentage of account value taken by the protocol as profit\n    ///         during expired account liquidations\n    /// @return liquidationDiscountExpired Multiplier that reduces the effective totalValue during expired account liquidations,\n    ///         allowing the liquidator to take the unaccounted for remainder as premium. Equal to (1 - liquidationPremiumExpired)\n    function fees()\n        external\n        view\n        returns (\n            uint16 feeInterest,\n            uint16 feeLiquidation,\n            uint16 liquidationDiscount,\n            uint16 feeLiquidationExpired,\n            uint16 liquidationDiscountExpired\n        );\n\n    /// @dev Address of the connected Credit Facade\n    function creditFacade() external view returns (address);\n\n    /// @dev Address of the connected Price Oracle\n    function priceOracle() external view returns (IPriceOracleV2);\n\n    /// @dev Address of the universal adapter\n    function universalAdapter() external view returns (address);\n\n    /// @dev Contract's version\n    function version() external view returns (uint256);\n\n    /// @dev Paused() state\n    function checkEmergencyPausable(address caller, bool state)\n        external\n        returns (bool);\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\n\n/// @dev Common contract exceptions\n\n/// @dev Thrown on attempting to set an important address to zero address\nerror ZeroAddressException();\n\n/// @dev Thrown on attempting to call a non-implemented function\nerror NotImplementedException();\n\n/// @dev Thrown on attempting to set an EOA as an important contract in the system\nerror AddressIsNotContractException(address);\n\n/// @dev Thrown on attempting to use a non-ERC20 contract or an EOA as a token\nerror IncorrectTokenContractException();\n\n/// @dev Thrown on attempting to set a token price feed to an address that is not a\n///      correct price feed\nerror IncorrectPriceFeedException();\n\n/// @dev Thrown on attempting to call an access restricted function as a non-Configurator\nerror CallerNotConfiguratorException();\n\n/// @dev Thrown on attempting to pause a contract as a non-Pausable admin\nerror CallerNotPausableAdminException();\n\n/// @dev Thrown on attempting to pause a contract as a non-Unpausable admin\nerror CallerNotUnPausableAdminException();\n\nerror TokenIsNotAddedToCreditManagerException(address token);\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/external/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.4;\n\ninterface IWETH {\n    /// @dev Deposits native ETH into the contract and mints WETH\n    function deposit() external payable;\n\n    /// @dev Transfers WETH to another account\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /// @dev Burns WETH from msg.sender and send back native ETH\n    function withdraw(uint256) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/interfaces/IVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\n\n/// @title IVersion\n/// @dev Declares a version function which returns the contract's version\ninterface IVersion {\n    /// @dev Returns contract version\n    function version() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@gearbox-protocol/core-v2/contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Holdings, 2022\npragma solidity ^0.8.10;\n\n/// @title Errors library\nlibrary Errors {\n    //\n    // COMMON\n    //\n    string public constant ZERO_ADDRESS_IS_NOT_ALLOWED = \"Z0\";\n    string public constant NOT_IMPLEMENTED = \"NI\";\n    string public constant INCORRECT_PATH_LENGTH = \"PL\";\n    string public constant INCORRECT_ARRAY_LENGTH = \"CR\";\n    string public constant REGISTERED_CREDIT_ACCOUNT_MANAGERS_ONLY = \"CP\";\n    string public constant REGISTERED_POOLS_ONLY = \"RP\";\n    string public constant INCORRECT_PARAMETER = \"IP\";\n\n    //\n    // MATH\n    //\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \"M1\";\n    string public constant MATH_ADDITION_OVERFLOW = \"M2\";\n    string public constant MATH_DIVISION_BY_ZERO = \"M3\";\n\n    //\n    // POOL\n    //\n    string public constant POOL_CONNECTED_CREDIT_MANAGERS_ONLY = \"PS0\";\n    string public constant POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER = \"PS1\";\n    string public constant POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT = \"PS2\";\n    string public constant POOL_INCORRECT_WITHDRAW_FEE = \"PS3\";\n    string public constant POOL_CANT_ADD_CREDIT_MANAGER_TWICE = \"PS4\";\n\n    //\n    // ACCOUNT FACTORY\n    //\n    string public constant AF_CANT_CLOSE_CREDIT_ACCOUNT_IN_THE_SAME_BLOCK =\n        \"AF1\";\n    string public constant AF_MINING_IS_FINISHED = \"AF2\";\n    string public constant AF_CREDIT_ACCOUNT_NOT_IN_STOCK = \"AF3\";\n    string public constant AF_EXTERNAL_ACCOUNTS_ARE_FORBIDDEN = \"AF4\";\n\n    //\n    // ADDRESS PROVIDER\n    //\n    string public constant AS_ADDRESS_NOT_FOUND = \"AP1\";\n\n    //\n    // CONTRACTS REGISTER\n    //\n    string public constant CR_POOL_ALREADY_ADDED = \"CR1\";\n    string public constant CR_CREDIT_MANAGER_ALREADY_ADDED = \"CR2\";\n\n    //\n    // CREDIT ACCOUNT\n    //\n    string public constant CA_CONNECTED_CREDIT_MANAGER_ONLY = \"CA1\";\n    string public constant CA_FACTORY_ONLY = \"CA2\";\n\n    //\n    // ACL\n    //\n    string public constant ACL_CALLER_NOT_PAUSABLE_ADMIN = \"ACL1\";\n    string public constant ACL_CALLER_NOT_CONFIGURATOR = \"ACL2\";\n\n    //\n    // WETH GATEWAY\n    //\n    string public constant WG_DESTINATION_IS_NOT_WETH_COMPATIBLE = \"WG1\";\n    string public constant WG_RECEIVE_IS_NOT_ALLOWED = \"WG2\";\n    string public constant WG_NOT_ENOUGH_FUNDS = \"WG3\";\n\n    //\n    // TOKEN DISTRIBUTOR\n    //\n    string public constant TD_WALLET_IS_ALREADY_CONNECTED_TO_VC = \"TD1\";\n    string public constant TD_INCORRECT_WEIGHTS = \"TD2\";\n    string public constant TD_NON_ZERO_BALANCE_AFTER_DISTRIBUTION = \"TD3\";\n    string public constant TD_CONTRIBUTOR_IS_NOT_REGISTERED = \"TD4\";\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}