{{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IGaugeController.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\ninterface IGaugeController {\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    struct UserPoint {\n        uint256 bias;\n        uint256 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n\n    event AddType(string name, int128 type_id);\n\n    event NewTypeWeight(int128 indexed type_id, uint256 time, uint256 weight, uint256 total_weight);\n\n    event NewGaugeWeight(address indexed gauge_address, uint256 time, uint256 weight, uint256 total_weight);\n\n    event VoteForGauge(address indexed user, address indexed gauge_address, uint256 time, uint256 weight);\n\n    event NewGauge(address indexed gauge_address, int128 gauge_type, uint256 weight);\n\n    /**\n     * @notice Get gauge type for address\n     *  @param _addr Gauge address\n     * @return Gauge type id\n     */\n    function gaugeTypes(address _addr) external view returns (int128);\n\n    /**\n     * @notice Add gauge `addr` of type `gauge_type` with weight `weight`\n     * @param addr Gauge address\n     * @param gaugeType Gauge type\n     * @param weight Gauge weight\n     */\n    function addGauge(address addr, int128 gaugeType, uint256 weight) external;\n\n    /**\n     * @notice Checkpoint to fill data common for all gauges\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Checkpoint to fill data for both a specific gauge and common for all gauge\n     * @param addr Gauge address\n     */\n    function checkpointGauge(address addr) external;\n\n    /**\n     * @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18(e.g. 1.0 == 1e18). Inflation which will be received by\n     * it is inflation_rate * relative_weight / 1e18\n     * @param gaugeAddress Gauge address\n     * @param time Relative weight at the specified timestamp in the past or present\n     * @return Value of relative weight normalized to 1e18\n     */\n    function gaugeRelativeWeight(address gaugeAddress, uint256 time) external view returns (uint256);\n\n    /**\n     *  @notice Get gauge weight normalized to 1e18 and also fill all the unfilled values for type and gauge records\n     * @dev Any address can call, however nothing is recorded if the values are filled already\n     * @param gaugeAddress Gauge address\n     * @param time Relative weight at the specified timestamp in the past or present\n     * @return Value of relative weight normalized to 1e18\n     */\n    function gaugeRelativeWeightWrite(address gaugeAddress, uint256 time) external returns (uint256);\n\n    /**\n     * @notice Add gauge type with name `_name` and weight `weight`\n     * @dev only owner call\n     * @param _name Name of gauge type\n     * @param weight Weight of gauge type\n     */\n    function addType(string memory _name, uint256 weight) external;\n\n    /**\n     * @notice Change gauge type `type_id` weight to `weight`\n     * @dev only owner call\n     * @param type_id Gauge type id\n     * @param weight New Gauge weight\n     */\n    function changeTypeWeight(int128 type_id, uint256 weight) external;\n\n    /**\n     * @notice Change weight of gauge `addr` to `weight`\n     * @param gaugeAddress `Gauge` contract address\n     * @param weight New Gauge weight\n     */\n    function changeGaugeWeight(address gaugeAddress, uint256 weight) external;\n\n    /**\n     * @notice Allocate voting power for changing pool weights\n     * @param gaugeAddress Gauge which `msg.sender` votes for\n     * @param userWeight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0.\n     *        example: 10%=1000,3%=300,0.01%=1,100%=10000\n     */\n    function voteForGaugeWeights(address gaugeAddress, uint256 userWeight) external;\n\n    /**\n     * @notice Get current gauge weight\n     * @param addr Gauge address\n     * @return Gauge weight\n     */\n\n    function getGaugeWeight(address addr) external view returns (uint256);\n\n    /**\n     * @notice Get current type weight\n     * @param type_id Type id\n     * @return Type weight\n     */\n    function getTypeWeight(int128 type_id) external view returns (uint256);\n\n    /**\n     * @notice Get current total (type-weighted) weight\n     * @return Total weight\n     */\n    function getTotalWeight() external view returns (uint256);\n\n    /**\n     * @notice Get sum of gauge weights per type\n     * @param type_id Type id\n     * @return Sum of gauge weights\n     */\n    function getWeightsSumPreType(int128 type_id) external view returns (uint256);\n\n    function votingEscrow() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ILT.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\ninterface ILT {\n    /**\n     * @dev Emitted when LT inflation rate update\n     *\n     * Note once a year\n     */\n    event UpdateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n\n    /**\n     * @dev Emitted when set LT minter,can set the minter only once, at creation\n     */\n    event SetMinter(address indexed minter);\n\n    function rate() external view returns (uint256);\n\n    /**\n     * @notice Update mining rate and supply at the start of the epoch\n     * @dev   Callable by any address, but only once per epoch\n     *        Total supply becomes slightly larger if this function is called late\n     */\n    function updateMiningParameters() external;\n\n    /**\n     * @notice Get timestamp of the next mining epoch start while simultaneously updating mining parameters\n     * @return Timestamp of the next epoch\n     */\n    function futureEpochTimeWrite() external returns (uint256);\n\n    /**\n     * @notice Current number of tokens in existence (claimed or unclaimed)\n     */\n    function availableSupply() external view returns (uint256);\n\n    /**\n     * @notice How much supply is mintable from start timestamp till end timestamp\n     * @param start Start of the time interval (timestamp)\n     * @param end End of the time interval (timestamp)\n     * @return Tokens mintable from `start` till `end`\n     */\n    function mintableInTimeframe(uint256 start, uint256 end) external view returns (uint256);\n\n    /**\n     *  @notice Set the minter address\n     *  @dev Only callable once, when minter has not yet been set\n     *  @param _minter Address of the minter\n     */\n    function setMinter(address _minter) external;\n\n    /**\n     *  @notice Mint `value` tokens and assign them to `to`\n     *   @dev Emits a Transfer event originating from 0x00\n     *   @param to The account that will receive the created tokens\n     *   @param value The amount that will be created\n     *   @return bool success\n     */\n    function mint(address to, uint256 value) external returns (bool);\n\n    /**\n     * @notice Burn `value` tokens belonging to `msg.sender`\n     * @dev Emits a Transfer event with a destination of 0x00\n     * @param value The amount that will be burned\n     * @return bool success\n     */\n    function burn(uint256 value) external returns (bool);\n}\n"
    },
    "contracts/Minter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/ILT.sol\";\nimport \"./interfaces/IGaugeController.sol\";\n\ninterface LiquidityGauge {\n    function integrateFraction(address addr) external view returns (uint256);\n\n    function userCheckpoint(address addr) external returns (bool);\n}\n\ncontract Minter {\n    event Minted(address indexed recipient, address gauge, uint256 minted);\n    event ToogleApproveMint(address sender, address indexed mintingUser, bool status);\n\n    address public immutable token;\n    address public immutable controller;\n\n    // user -> gauge -> value\n    mapping(address => mapping(address => uint256)) public minted;\n\n    // minter -> user -> can mint?\n    mapping(address => mapping(address => bool)) public allowedToMintFor;\n\n    /*\n     * @notice Contract constructor\n     * @param _token  LT Token Address\n     * @param _controller gauge Controller Address\n     */\n    constructor(address _token, address _controller) {\n        token = _token;\n        controller = _controller;\n    }\n\n    /**\n     * @notice Mint everything which belongs to `msg.sender` and send to them\n     * @param gaugeAddress `LiquidityGauge` address to get mintable amount from\n     */\n    function mint(address gaugeAddress) external {\n        _mintFor(gaugeAddress, msg.sender);\n    }\n\n    /**\n     * @notice Mint everything which belongs to `msg.sender` across multiple gauges\n     * @param gaugeAddressList List of `LiquidityGauge` addresses\n     */\n    function mintMany(address[] memory gaugeAddressList) external {\n        for (uint256 i = 0; i < gaugeAddressList.length && i < 128; i++) {\n            if (gaugeAddressList[i] == address(0)) {\n                continue;\n            }\n            _mintFor(gaugeAddressList[i], msg.sender);\n        }\n    }\n\n    /**\n     * @notice Mint tokens for `_for`\n     * @dev Only possible when `msg.sender` has been approved via `toggle_approve_mint`\n     * @param gaugeAddress `LiquidityGauge` address to get mintable amount from\n     * @param _for Address to mint to\n     */\n    function mintFor(address gaugeAddress, address _for) external {\n        if (allowedToMintFor[msg.sender][_for]) {\n            _mintFor(gaugeAddress, _for);\n        }\n    }\n\n    /**\n     * @notice allow `mintingUser` to mint for `msg.sender`\n     * @param mintingUser Address to toggle permission for\n     */\n    function toggleApproveMint(address mintingUser) external {\n        bool flag = allowedToMintFor[mintingUser][msg.sender];\n        allowedToMintFor[mintingUser][msg.sender] = !flag;\n        emit ToogleApproveMint(msg.sender, mintingUser, !flag);\n    }\n\n    function _mintFor(address gaugeAddr, address _for) internal {\n        ///Gomnoc not adde\n        require(IGaugeController(controller).gaugeTypes(gaugeAddr) >= 0, \"CE000\");\n\n        bool success = LiquidityGauge(gaugeAddr).userCheckpoint(_for);\n        require(success, \"CHECK FAILED\");\n        uint256 totalMint = LiquidityGauge(gaugeAddr).integrateFraction(_for);\n        uint256 toMint = totalMint - minted[_for][gaugeAddr];\n\n        if (toMint != 0) {\n            minted[_for][gaugeAddr] = totalMint;\n            bool success = ILT(token).mint(_for, toMint);\n            require(success, \"MINT FAILED\");\n            emit Minted(_for, gaugeAddr, toMint);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}