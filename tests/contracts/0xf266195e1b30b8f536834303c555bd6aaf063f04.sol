{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts/claim/ContinuousVestingMerkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { ContinuousVesting } from \"./abstract/ContinuousVesting.sol\";\nimport { MerkleSet } from \"./abstract/MerkleSet.sol\";\n\ncontract ContinuousVestingMerkle is\n  ContinuousVesting,\n  MerkleSet\n{\n\n  constructor(\n    IERC20 _token, // the token being claimed\n    uint256 _total, // the total claimable by all users\n    string memory _uri, // information on the sale (e.g. merkle proofs)\n    uint256 _voteFactor, // votes have this weight\n    uint256 _start, // vesting clock starts at this time\n    uint256 _cliff, // claims open at this time\n    uint256 _end, // vesting clock ends and this time\n    bytes32 _merkleRoot // the merkle root for claim membership\n  )\n    ContinuousVesting(_token, _total, _uri, _voteFactor, _start, _cliff, _end)\n    MerkleSet(_merkleRoot)\n  {}\n\n  function NAME() external override pure returns (string memory) {\n    return 'ContinuousVestingMerkle';\n  }\n  \n  function VERSION() external override pure returns (uint) {\n    return 2;\n  }\n\n  function initializeDistributionRecord(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 amount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  ) validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount)), merkleProof) external {\n    _initializeDistributionRecord(beneficiary, amount);\n  }\n\n  function claim(\n    uint256 index, // the beneficiary's index in the merkle root\n    address beneficiary, // the address that will receive tokens\n    uint256 amount, // the total claimable by this beneficiary\n    bytes32[] calldata merkleProof\n  ) external validMerkleProof(keccak256(abi.encodePacked(index, beneficiary, amount)), merkleProof) nonReentrant {\n    if (!records[beneficiary].initialized) {\n      _initializeDistributionRecord(beneficiary, amount);\n    }\n    super._executeClaim(beneficiary, uint120(getClaimableAmount(beneficiary)));\n  }\n\n  function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\n    _setMerkleRoot(_merkleRoot);\n  }\n}\n"
    },
    "contracts/claim/abstract/AdvancedDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {Distributor, DistributionRecord, IERC20} from \"./Distributor.sol\";\nimport {IAdjustable} from \"../interfaces/IAdjustable.sol\";\nimport {IVotesLite} from \"../interfaces/IVotesLite.sol\";\nimport {Sweepable} from \"../../utilities/Sweepable.sol\";\n\nabstract contract AdvancedDistributor is Ownable, Distributor, Sweepable, IAdjustable, IVotesLite {\n  using SafeERC20 for IERC20;\n\n  uint256 private voteFactor;\n  constructor(\n    IERC20 _token,\n    uint256 _total,\n    string memory _uri,\n    uint256 _voteFactor,\n    uint256 _fractionDenominator\n  ) Distributor(_token, _total, _uri, _fractionDenominator) {\n    voteFactor = _voteFactor;\n    emit SetVoteFactor(voteFactor);\n  }\n\n  function adjust(address beneficiary, int256 amount) external onlyOwner {\n    DistributionRecord memory distributionRecord = records[beneficiary];\n    require(\n        distributionRecord.initialized,\n        \"must initialize before adjusting\"\n    );\n\n      uint256 diff = uint256(amount > 0 ? amount : -amount);\n      require(diff < type(uint120).max, \"adjustment > max uint120\");\n\n      if (amount < 0) {\n        // decreasing claimable tokens\n        require(total >= diff, \"decrease greater than distributor total\");\n        require(\n          distributionRecord.total >= diff,\n          \"decrease greater than distributionRecord total\"\n        );\n        total -= diff;\n        records[beneficiary].total -= uint120(diff);\n\n        token.safeTransfer(owner(), diff);\n    } else {\n        // increasing claimable tokens\n        total += diff;\n        records[beneficiary].total += uint120(diff);\n    }\n\n    emit Adjust(beneficiary, amount);\n  }\n\n\t// Set the token being distributed\n\tfunction setToken(IERC20 _token) external onlyOwner {\n    require(address(_token) != address(0), \"Adjustable: token is address(0)\");\n\t\ttoken = _token;\n\t\temit SetToken(token);\n\t}\n\n\t// Set the total to distribute\n\tfunction setTotal(uint256 _total) external onlyOwner {\n\t\ttotal = _total;\n\t\temit SetTotal(total);\n\t}\n\n\t// Set the distributor metadata URI\n\tfunction setUri(string memory _uri) external onlyOwner {\n\t\turi = _uri;\n\t\temit SetUri(uri);\n\t}\n\n  function getVotes(\n    address beneficiary\n  ) external override(IVotesLite) view returns (uint256) {\n    // Uninitialized claims will not have any votes! (returns 0)\n\n    // The user can vote using tokens that are allocated to them but not yet claimed\n    return (records[beneficiary].total - records[beneficiary].claimed) * voteFactor / fractionDenominator;\n  }\n  \n  function getTotalVotes() external override(IVotesLite) view returns (uint256) {\n    // Return total voting power for this distributor across all users\n    return (total - claimed) * voteFactor / fractionDenominator;\n  }\n\n  function getVoteFactor(address) external override(IVotesLite) view returns (uint256) {\n\treturn voteFactor;\n  }\n\n\t// Set the voting power of undistributed tokens\n\tfunction setVoteFactor(uint256 _voteFactor) external onlyOwner {\n\t\tvoteFactor = _voteFactor;\n\t\temit SetVoteFactor(voteFactor);\n\t}\n}\n"
    },
    "contracts/claim/abstract/ContinuousVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {Distributor, AdvancedDistributor} from \"./AdvancedDistributor.sol\";\nimport {IVesting} from \"../interfaces/IVesting.sol\";\nimport {IContinuousVesting} from \"../interfaces/IContinuousVesting.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract ContinuousVesting is AdvancedDistributor, IContinuousVesting {\n    uint256 private start; // time vesting clock begins\n    uint256 private cliff; // time vesting begins (all tokens vested prior to the cliff are immediately claimable)\n    uint256 private end; // time vesting clock ends\n\n    constructor(\n        IERC20 _token,\n        uint256 _total,\n        string memory _uri,\n        uint256 _voteFactor,\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _end\n    )\n        // use a large fraction denominator to provide the highest resolution on continuous vesting.\n        AdvancedDistributor(_token, _total, _uri, _voteFactor, 10**18)\n    {\n        require(_start <= _cliff, \"vesting cliff before start\");\n        require(_cliff <= _end, \"vesting end before cliff\");\n        require(\n            _end <= 4102444800,\n            \"vesting ends after 4102444800 (Jan 1 2100)\"\n        );\n\n        start = _start;\n        cliff = _cliff;\n        end = _end;\n\n        emit SetContinuousVesting(start, cliff, end);\n    }\n\n    function getVestedFraction(\n        address, /*beneficiary*/\n        uint256 time // time is in seconds past the epoch (e.g. block.timestamp)\n    ) public view override(Distributor, IVesting) returns (uint256) {\n        // no tokens are vested\n        if (time <= cliff) {\n            return 0;\n        }\n\n        // all tokens are vested\n        if (time >= end) {\n            return fractionDenominator;\n        }\n\n        // some tokens are vested\n        return (fractionDenominator * (time - start)) / (end - start);\n    }\n\n    function getVestingConfig()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (start, cliff, end);\n    }\n\n    // Adjustable admin functions\n    function setVestingConfig(\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _end\n    ) external onlyOwner {\n        start = _start;\n        cliff = _cliff;\n        end = _end;\n        emit SetContinuousVesting(start, cliff, end);\n    }\n}\n"
    },
    "contracts/claim/abstract/Distributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport {IDistributor, DistributionRecord} from \"../interfaces/IDistributor.sol\";\n\nabstract contract Distributor is IDistributor, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    mapping(address => DistributionRecord) internal records; // track distribution records per user\n    IERC20 public token; // the token being claimed\n    uint256 public total; // total tokens allocated for claims\n    uint256 public claimed; // tokens already claimed\n    string public uri; // ipfs link on distributor info\n    uint256 immutable fractionDenominator; // denominator for vesting fraction (e.g. if vested fraction is 100 and fractionDenominator is 10000, 1% of tokens have vested)\n\n    // provide context on the contract name and version\n    function NAME() external virtual returns (string memory);\n\n    function VERSION() external virtual returns (uint256);\n\n    constructor(\n        IERC20 _token,\n        uint256 _total,\n        string memory _uri,\n        uint256 _fractionDenominator\n    ) {\n        require(\n            address(_token) != address(0),\n            \"Distributor: token is address(0)\"\n        );\n        require(_total > 0, \"Distributor: total is 0\");\n\n        token = _token;\n        total = _total;\n        uri = _uri;\n        fractionDenominator = _fractionDenominator;\n        emit InitializeDistributor(token, total, uri, fractionDenominator);\n    }\n\n    function _initializeDistributionRecord(address beneficiary, uint256 amount)\n        internal\n    {\n        // CALLER MUST VERIFY THE BENEFICIARY AND AMOUNT ARE VALID!\n\n        // Checks\n        require(\n            amount <= type(uint120).max,\n            \"Distributor: amount > type(uint120).max\"\n        );\n        require(amount > 0, \"Distributor: amount == 0\");\n        require(\n            !records[beneficiary].initialized,\n            \"Distributor: already initialized\"\n        );\n\n        // Effects\n        records[beneficiary] = DistributionRecord(true, uint120(amount), 0);\n        emit InitializeDistributionRecord(beneficiary, amount);\n    }\n\n    function _executeClaim(address beneficiary, uint256 _amount) internal {\n        // Checks: NONE! THIS FUNCTION DOES NOT CHECK PERMISSIONS: CALLER MUST VERIFY THE CLAIM IS VALID!\n        uint120 amount = uint120(_amount);\n        require(amount > 0, \"Distributor: no more tokens claimable right now\");\n\n        // effects\n        records[beneficiary].claimed += amount;\n        claimed += amount;\n\n        // interactions\n        token.safeTransfer(beneficiary, amount);\n        emit Claim(beneficiary, amount);\n    }\n\n    function getDistributionRecord(address beneficiary)\n        external\n        view\n        virtual\n        returns (DistributionRecord memory)\n    {\n        return records[beneficiary];\n    }\n\n    // Get tokens vested as fraction of fractionDenominator\n    function getVestedFraction(address beneficiary, uint256 time)\n        public\n        view\n        virtual\n        returns (uint256);\n\n    function getFractionDenominator() public view returns (uint256) {\n        return fractionDenominator;\n    }\n\n    // get the number of tokens currently claimable by a specific use\n    function getClaimableAmount(address beneficiary)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        require(\n            records[beneficiary].initialized,\n            \"Distributor: claim not initialized\"\n        );\n\n        DistributionRecord memory record = records[beneficiary];\n\n        uint256 claimable = (record.total *\n            getVestedFraction(beneficiary, block.timestamp)) /\n            fractionDenominator;\n        return\n            record.claimed >= claimable\n                ? 0 // no more tokens to claim\n                : claimable - record.claimed; // claim all available tokens\n    }\n}\n"
    },
    "contracts/claim/abstract/MerkleSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { IMerkleSet } from \"../interfaces/IMerkleSet.sol\";\n\ncontract MerkleSet is IMerkleSet {\n  bytes32 private merkleRoot;\n  constructor(bytes32 _merkleRoot) {\n    _setMerkleRoot(_merkleRoot);\n  }\n\n  modifier validMerkleProof(\n    bytes32 leaf,\n    bytes32[] calldata merkleProof\n  ) {\n    _verifyMembership(leaf, merkleProof);\n\n    _;\n  }\n\n  function _testMembership(bytes32 leaf, bytes32[] calldata merkleProof)\n    internal\n    view returns (bool)\n  {\n    return MerkleProof.verify(merkleProof, merkleRoot, leaf);\n  }\n\n  function getMerkleRoot() public view returns (bytes32) {\n    return merkleRoot;\n  }\n\n  function _verifyMembership(bytes32 leaf, bytes32[] calldata merkleProof)\n    internal\n    view\n  {\n    require(_testMembership(leaf, merkleProof), \"invalid proof\");\n  }\n\n  function _setMerkleRoot(bytes32 _merkleRoot) internal {\n    merkleRoot = _merkleRoot;\n    emit SetMerkleRoot(merkleRoot);\n  }\n}\n"
    },
    "contracts/claim/interfaces/IAdjustable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ninterface IAdjustable {\n  event Adjust(address indexed beneficiary, int256 amount);\n  event SetToken(IERC20 indexed token);\n  event SetTotal(uint256 total);\n  event SetUri(string indexed uri);\n  event SetVoteFactor(uint256 voteFactor);\n\n  // Adjust the quantity claimable by a user\n  function adjust(address beneficiary, int256 amount) external;\n  // Set the token being distributed\n  function setToken(IERC20 token) external;\n  // Set the total distribution quantity\n  function setTotal(uint256 total) external;\n  // Set the distributor metadata URI\n  function setUri(string memory uri) external;\n  // Set the voting power of undistributed tokens\n  function setVoteFactor(uint256 setVoteFactor) external;\n}\n"
    },
    "contracts/claim/interfaces/IContinuousVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IVesting} from \"./IVesting.sol\";\n\ninterface IContinuousVesting is IVesting {\n    event SetContinuousVesting(uint256 start, uint256 cliff, uint256 end);\n\n    function getVestingConfig()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function setVestingConfig(\n        uint256 _start,\n        uint256 _cliff,\n        uint256 _end\n    ) external;\n}\n"
    },
    "contracts/claim/interfaces/IDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nstruct DistributionRecord {\n    bool initialized; // has the claim record been initialized\n    uint120 total; // total token quantity claimable\n    uint120 claimed; // token quantity already claimed\n}\n\ninterface IDistributor {\n    event InitializeDistributor(\n        IERC20 indexed token,\n        uint256 total,\n        string uri,\n        uint256 fractionDenominator\n    );\n    event InitializeDistributionRecord(\n        address indexed beneficiary,\n        uint256 amount\n    );\n    event Claim(address indexed beneficiary, uint256 amount);\n\n    function getDistributionRecord(address beneficiary) external view returns (DistributionRecord memory);\n    function getClaimableAmount(address beneficiary) external view returns (uint256);\n    function getFractionDenominator() external view returns (uint256);\n}\n"
    },
    "contracts/claim/interfaces/IMerkleSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\ninterface IMerkleSet {\n  event SetMerkleRoot(bytes32 merkleRoot);\n\n\tfunction getMerkleRoot() external view returns (bytes32 root);\n}\n"
    },
    "contracts/claim/interfaces/IVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IVesting {\n    function getVestedFraction(\n        address, /*beneficiary*/\n        uint256 time // time is in seconds past the epoch (e.g. block.timestamp)\n    ) external returns (uint256);\n}\n"
    },
    "contracts/claim/interfaces/IVotesLite.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\ninterface IVotesLite {\n    // an account's current voting power\n    function getVotes(address account) external view returns (uint256);\n    // an total current voting power\n    function getTotalVotes() external view returns (uint256);\n    // a weighting factor used to convert token holdings to voting power (eg in basis points)\n    function getVoteFactor(address account) external view returns (uint256);\n}\n"
    },
    "contracts/utilities/Sweepable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nabstract contract Sweepable is Ownable {\n    using SafeERC20 for IERC20;\n\n    event SweepToken(address indexed token, uint256 amount);\n    event SweepNative(uint256 amount);\n    constructor() {}\n\n    // Sweep an ERC20 token to the owner\n    function sweepToken(IERC20 token) external onlyOwner {\n        uint256 amount = token.balanceOf(address(this));\n        token.safeTransfer(owner(), amount);\n        emit SweepToken(address(token), amount);\n    }\n\n    function sweepToken(IERC20 token, uint256 amount) external onlyOwner {\n        token.safeTransfer(owner(), amount);\n        emit SweepToken(address(token), amount);\n    }\n\n    // sweep native token to the owner\n    function sweepNative() external onlyOwner {\n        uint256 amount = address(this).balance;\n        (bool success, ) = owner().call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n        emit SweepNative(amount);\n    }\n\n    function sweepNative(uint256 amount) external onlyOwner {\n        (bool success, ) = owner().call{value: amount}(\"\");\n        require(success, \"Transfer failed.\");\n        emit SweepNative(amount);\n    }\n}\n"
    }
  }
}}