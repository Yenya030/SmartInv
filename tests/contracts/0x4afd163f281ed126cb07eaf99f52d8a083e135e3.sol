{{
  "language": "Solidity",
  "sources": {
    "/contracts/BAPOrchestratorReduce.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n// solhint-disable-next-line\r\npragma solidity 0.8.12;\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./reduced_interfaces/BAPGenesisInterface.sol\";\r\nimport \"./reduced_interfaces/BAPMethaneInterface.sol\";\r\nimport \"./reduced_interfaces/BAPUtilitiesInterface.sol\";\r\nimport \"./reduced_interfaces/BAPTeenBullsInterface.sol\";\r\nimport \"./reduced_interfaces/BAPOrchestratorInterfaceV2.sol\";\r\nimport \"./IERC721Receiver.sol\";\r\n\r\ncontract BAPOrchestratorV3 is Ownable, IERC721Receiver {\r\n    string public constant project = \"Bulls & Apes Project\";\r\n\r\n    uint256 public constant startTime = 1665291600;\r\n    uint256 public timeCounter = 1 days;\r\n    uint256 public powerCooldown = 14 days;\r\n    uint256 private lastTokenReceived;\r\n\r\n    address public treasuryWallet;\r\n    address public secret;\r\n\r\n    bool public claimFlag = true;\r\n    bool public refundFlag = false;\r\n    bool private isReviving = false;\r\n\r\n    mapping(uint256 => uint256) public breedingsLeft;\r\n    mapping(uint256 => uint256) public claimedMeth;\r\n    mapping(uint256 => uint256) public claimedTeenMeth;\r\n    mapping(uint256 => uint256) public lastChestOpen;\r\n\r\n    mapping(uint256 => bool) public isGod;\r\n    mapping(uint256 => bool) public prevClaimed;\r\n\r\n    mapping(address => uint256) public userLastClaim;\r\n\r\n    BAPGenesisInterface public bapGenesis;\r\n    BAPMethaneInterface public bapMeth;\r\n    BAPUtilitiesInterface public bapUtilities;\r\n    BAPTeenBullsInterface public bapTeenBulls;\r\n    BAPOrchestratorInterfaceV2 public bapOrchestratorV2;\r\n\r\n    event CHEST_OPENED(\r\n        uint256 num,\r\n        uint256 godId,\r\n        uint256 prize,\r\n        uint256 timestamp\r\n    );\r\n    event METH_CLAIMED(address user, uint256 amount, uint256 timestamp);\r\n    event GOD_MINTED(address user, uint256 id, uint256 timestamp);\r\n    event TEEN_RESURRECTED(\r\n        address user,\r\n        uint256 sacrificed,\r\n        uint256 resurrected,\r\n        uint256 newlyMinted\r\n    );\r\n\r\n    constructor(\r\n        address _bapGenesis,\r\n        address _bapMethane,\r\n        address _bapUtilities,\r\n        address _bapTeenBulls,\r\n        address _orchestratorV2\r\n    ) {\r\n        bapGenesis = BAPGenesisInterface(_bapGenesis);\r\n        bapMeth = BAPMethaneInterface(_bapMethane);\r\n        bapUtilities = BAPUtilitiesInterface(_bapUtilities);\r\n        bapTeenBulls = BAPTeenBullsInterface(_bapTeenBulls);\r\n        bapOrchestratorV2 = BAPOrchestratorInterfaceV2(_orchestratorV2);\r\n    }\r\n\r\n    modifier noZeroAddress(address _address) {\r\n        require(_address != address(0), \"200:ZERO_ADDRESS\");\r\n        _;\r\n    }\r\n\r\n    // WRITE FUNCTIONS\r\n\r\n    function claimMeth(\r\n        uint256[] memory bulls,\r\n        uint256[] memory gods,\r\n        uint256[] memory teens\r\n    ) public {\r\n        require(claimFlag, \"Claim is disabled\");\r\n\r\n        uint256 claimableMeth;\r\n\r\n        for (uint256 i; i < bulls.length; i++) {\r\n            claimableMeth += _claimMeth(bulls[i], 0);\r\n        }\r\n        for (uint256 i; i < gods.length; i++) {\r\n            require(godBulls(gods[i]), \"Not a god bull\");\r\n            claimableMeth += _claimMeth(gods[i], 1);\r\n        }\r\n        for (uint256 i; i < teens.length; i++) {\r\n            require(isResurrected(teens[i]), \"Not a resurrected teen\");\r\n            claimableMeth += _claimMeth(teens[i], 2);\r\n        }\r\n\r\n        bapMeth.claim(msg.sender, claimableMeth);\r\n    }\r\n\r\n    function generateTeenBull() public {\r\n        bapMeth.pay(600, 300);\r\n        bapUtilities.burn(1, 1);\r\n        bapTeenBulls.generateTeenBull();\r\n    }\r\n\r\n    function generateGodBull(\r\n        bytes memory signature,\r\n        uint256 bull1,\r\n        uint256 bull2,\r\n        uint256 bull3,\r\n        uint256 bull4\r\n    ) public {\r\n        require(\r\n            _verifyHashSignature(\r\n                keccak256(abi.encode(msg.sender, bull1, bull2, bull3, bull4)),\r\n                signature\r\n            ),\r\n            \"Signature is invalid\"\r\n        );\r\n        bapMeth.pay(4800, 2400);\r\n        bapUtilities.burn(2, 1);\r\n        _burnTeen(bull1);\r\n        _burnTeen(bull2);\r\n        _burnTeen(bull3);\r\n        _burnTeen(bull4);\r\n\r\n        uint256 id = bapGenesis.minted() + 1;\r\n        prevClaimed[id] = true;\r\n        claimedMeth[id] = getClaimableMeth(id, 1);\r\n\r\n        bapGenesis.generateGodBull();\r\n\r\n        emit GOD_MINTED(msg.sender, id, block.timestamp);\r\n    }\r\n\r\n    function buyIncubator(\r\n        bytes memory signature,\r\n        uint256 bull1,\r\n        uint256 bull2\r\n    ) public {\r\n        require(\r\n            _verifyHashSignature(\r\n                keccak256(abi.encode(msg.sender, bull1, bull2)),\r\n                signature\r\n            ),\r\n            \"Signature is invalid\"\r\n        );\r\n        bapMeth.pay(600, 300);\r\n        _breedToken(bull1);\r\n        _breedToken(bull2);\r\n        bapUtilities.purchaseIncubator();\r\n    }\r\n\r\n    function buyMergeOrb(uint256 teen) public {\r\n        bapMeth.pay(2400, 1200);\r\n        _burnTeen(teen);\r\n        bapUtilities.purchaseMergerOrb();\r\n    }\r\n\r\n    function refund(uint256 tokenId) external noZeroAddress(treasuryWallet) {\r\n        require(availableForRefund(tokenId), \"Token not available for refund\");\r\n\r\n        bapGenesis.refund(msg.sender, tokenId);\r\n        bapGenesis.safeTransferFrom(msg.sender, treasuryWallet, tokenId);\r\n    }\r\n\r\n    // NEW FUNCTIONS\r\n    function openChest(\r\n        uint256 godId,\r\n        uint256 guild,\r\n        uint256 seed,\r\n        bool hasPower,\r\n        bytes memory signature\r\n    ) external {\r\n        require(seed > block.timestamp, \"Seed is no longer valid\");\r\n        require(\r\n            _verifyHashSignature(\r\n                keccak256(abi.encode(msg.sender, godId, guild, seed, hasPower)),\r\n                signature\r\n            ),\r\n            \"Signature is invalid\"\r\n        );\r\n        require(bapGenesis.ownerOf(godId) == msg.sender, \"Not the god owner\");\r\n        require(godBulls(godId), \"Not a god bull\");\r\n\r\n        if (\r\n            !hasPower || lastChestOpen[godId] + powerCooldown > block.timestamp\r\n        ) {\r\n            require(\r\n                lastChestOpen[godId] + 20 minutes > block.timestamp,\r\n                \"Re open time elapsed\"\r\n            );\r\n\r\n            bapMeth.pay(1200, 1200);\r\n            lastChestOpen[godId] = block.timestamp - 21 minutes;\r\n        } else {\r\n            bapMeth.pay(600, 600);\r\n            lastChestOpen[godId] = block.timestamp;\r\n        }\r\n\r\n        uint256 num = random(seed) % 100;\r\n        uint256 prize;\r\n\r\n        if (num < 10) {\r\n            prize = 20 + guild;\r\n            bapUtilities.airdrop(msg.sender, 1, (prize)); // UTILITIE #20 - 23 METH MAKER - 10%\r\n        } else if (num < 40) {\r\n            prize = 30 + guild;\r\n            bapUtilities.airdrop(msg.sender, 1, (prize)); // UTILITIE #30 - 33 RESURRECTION - 30%\r\n        } else {\r\n            prize = 40 + guild;\r\n            bapUtilities.airdrop(msg.sender, 1, (prize)); // UTILITIE #40 - 43 BREED REPLENISH - 60%\r\n        }\r\n\r\n        emit CHEST_OPENED(num, godId, prize, block.timestamp);\r\n    }\r\n\r\n    function useItem(\r\n        uint256 item,\r\n        uint256 tokenId,\r\n        uint256 godId,\r\n        uint256 resurrected,\r\n        bytes memory signature\r\n    ) external {\r\n        require(\r\n            _verifyHashSignature(\r\n                keccak256(\r\n                    abi.encode(msg.sender, item, tokenId, godId, resurrected)\r\n                ),\r\n                signature\r\n            ),\r\n            \"Signature is invalid\"\r\n        );\r\n\r\n        bapUtilities.burn(item, 1); // #30 - 33 RESURRECTION, #40 - 43 BREED REPLENISH\r\n\r\n        if (item >= 30 && item < 35) {\r\n            require(godBulls(godId), \"You need to use a good\");\r\n            require(\r\n                bapGenesis.ownerOf(godId) == msg.sender,\r\n                \"Not the god owner\"\r\n            );\r\n\r\n            _burnTeen(tokenId);\r\n\r\n            isReviving = true;\r\n\r\n            bapTeenBulls.airdrop(address(this), 1);\r\n            claimedTeenMeth[lastTokenReceived] = getClaimableMeth(\r\n                lastTokenReceived,\r\n                2\r\n            );\r\n\r\n            isReviving = false;\r\n\r\n            bapTeenBulls.safeTransferFrom(\r\n                address(this),\r\n                msg.sender,\r\n                lastTokenReceived\r\n            );\r\n\r\n            emit TEEN_RESURRECTED(\r\n                msg.sender,\r\n                tokenId,\r\n                resurrected,\r\n                lastTokenReceived\r\n            );\r\n\r\n            lastTokenReceived = 0;\r\n        } else if (item >= 40 && item < 45) {\r\n            require(\r\n                bapGenesis.ownerOf(tokenId) == msg.sender,\r\n                \"Only the owner can replenish\"\r\n            );\r\n            require(\r\n                !godBulls(tokenId),\r\n                \"God bulls cannot claim extra breeding\"\r\n            );\r\n\r\n            uint256 currentBreeds = breedings(tokenId);\r\n\r\n            require(currentBreeds < 3, \"Bull has all breeds available\");\r\n\r\n            breedingsLeft[tokenId] = 3 - currentBreeds;\r\n        } else {\r\n            require(false, \"Wrong item id\");\r\n        }\r\n    }\r\n\r\n    function claimTeenMeth(\r\n        uint256 amount,\r\n        uint256 seed,\r\n        bytes memory signature\r\n    ) public {\r\n        require(seed > block.timestamp, \"Seed is no longer valid\");\r\n        require(\r\n            userLastClaim[msg.sender] + 1 days < block.timestamp,\r\n            \"Can claim only once a day\"\r\n        );\r\n        require(\r\n            _verifyHashSignature(\r\n                keccak256(abi.encode(amount, seed, msg.sender)),\r\n                signature\r\n            ),\r\n            \"Signature is invalid\"\r\n        );\r\n\r\n        userLastClaim[msg.sender] = block.timestamp;\r\n\r\n        bapMeth.claim(msg.sender, amount);\r\n\r\n        emit METH_CLAIMED(msg.sender, amount, block.timestamp);\r\n    }\r\n\r\n    // BULK FUNCTIONS\r\n\r\n    function claimAllMeth(\r\n        uint256[] memory bulls,\r\n        uint256[] memory gods,\r\n        uint256[] memory teens,\r\n        uint256 amount,\r\n        uint256 seed,\r\n        bytes memory signature\r\n    ) external {\r\n        claimMeth(bulls, gods, teens);\r\n        claimTeenMeth(amount, seed, signature);\r\n    }\r\n\r\n    function breedAndIncubate(\r\n        bytes memory signature,\r\n        uint256 bull1,\r\n        uint256 bull2\r\n    ) external {\r\n        buyIncubator(signature, bull1, bull2);\r\n        generateTeenBull();\r\n    }\r\n\r\n    function buyOrbAndSummon(\r\n        uint256 teen,\r\n        bytes memory signature,\r\n        uint256 bull1,\r\n        uint256 bull2,\r\n        uint256 bull3,\r\n        uint256 bull4\r\n    ) external {\r\n        buyMergeOrb(teen);\r\n        generateGodBull(signature, bull1, bull2, bull3, bull4);\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n\r\n    function _claimMeth(uint256 tokenId, uint256 _type)\r\n        internal\r\n        returns (uint256 amount)\r\n    {\r\n        amount = getClaimableMeth(tokenId, _type);\r\n\r\n        if (_type == 2) {\r\n            require(\r\n                bapTeenBulls.ownerOf(tokenId) == msg.sender,\r\n                \"Only the owner can claim\"\r\n            );\r\n\r\n            claimedTeenMeth[tokenId] += amount;\r\n        } else {\r\n            require(\r\n                bapGenesis.ownerOf(tokenId) == msg.sender,\r\n                \"Only the owner can claim\"\r\n            );\r\n\r\n            claimedMeth[tokenId] += amount;\r\n\r\n            if (!godBulls(tokenId) && breedings(tokenId) == 0) {\r\n                amount += amount / 2;\r\n            }\r\n\r\n            if (!prevClaimed[tokenId]) {\r\n                amount += getOldClaimableMeth(tokenId, godBulls(tokenId));\r\n                prevClaimed[tokenId] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _breedToken(uint256 tokenId) internal {\r\n        require(\r\n            bapGenesis.ownerOf(tokenId) == msg.sender,\r\n            \"Only the owner can breed\"\r\n        );\r\n\r\n        uint256 currentBreeds = bapGenesis.breedings(tokenId);\r\n\r\n        if (breedings(tokenId) == 1) {\r\n            uint256 claimableMeth = _claimMeth(tokenId, 0);\r\n            if (claimableMeth > 0) {\r\n                bapMeth.claim(msg.sender, claimableMeth);\r\n            }\r\n        }\r\n\r\n        if (currentBreeds != 0) {\r\n            bapGenesis.updateBullBreedings(tokenId);\r\n        } else {\r\n            require(breedingsLeft[tokenId] != 0, \"No more breadings left\");\r\n            breedingsLeft[tokenId]--;\r\n        }\r\n    }\r\n\r\n    function _burnTeen(uint256 tokenId) internal {\r\n        require(\r\n            bapTeenBulls.ownerOf(tokenId) == msg.sender,\r\n            \"Only the owner can burn\"\r\n        );\r\n        require(claimedTeenMeth[tokenId] == 0, \"Can't burn resurrected teens\");\r\n\r\n        bapTeenBulls.burnTeenBull(tokenId);\r\n    }\r\n\r\n    function random(uint256 seed) internal view returns (uint256) {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        seed,\r\n                        block.timestamp,\r\n                        gasleft(),\r\n                        tx.origin\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function _dailyRewards(uint256 _type) internal pure returns (uint256) {\r\n        if (_type == 0) {\r\n            return 10;\r\n        } else if (_type == 1) {\r\n            return 20;\r\n        } else {\r\n            return 5;\r\n        }\r\n    }\r\n\r\n    function _refundPeriodAllowed() internal view returns (bool) {\r\n        return\r\n            block.timestamp >= bapGenesis.genesisTimestamp() + 31 days &&\r\n            block.timestamp <= bapGenesis.genesisTimestamp() + 180 days;\r\n    }\r\n\r\n    function _verifyHashSignature(bytes32 freshHash, bytes memory signature)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", freshHash)\r\n        );\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (signature.length != 65) {\r\n            return false;\r\n        }\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        address signer = address(0);\r\n        if (v == 27 || v == 28) {\r\n            // solium-disable-next-line arg-overflow\r\n            signer = ecrecover(hash, v, r, s);\r\n        }\r\n        return secret == signer;\r\n    }\r\n\r\n    // VIEW FUNCTIONS\r\n\r\n    function breedings(uint256 tokenId) public view returns (uint256) {\r\n        uint256 currentBreeds = bapGenesis.breedings(tokenId);\r\n\r\n        return currentBreeds + breedingsLeft[tokenId];\r\n    }\r\n\r\n    function getClaimableMeth(uint256 tokenId, uint256 _type)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 claimed = 0;\r\n\r\n        if (_type == 2) {\r\n            claimed = claimedTeenMeth[tokenId];\r\n        } else {\r\n            claimed = claimedMeth[tokenId];\r\n        }\r\n\r\n        uint256 timeFromCreation = (block.timestamp - startTime) /\r\n            (timeCounter);\r\n\r\n        return (timeFromCreation * _dailyRewards(_type)) - claimed;\r\n    }\r\n\r\n    function getOldClaimableMeth(uint256 tokenId, bool isGod)\r\n        public\r\n        view\r\n        returns (uint256 methAmount)\r\n    {\r\n        if (prevClaimed[tokenId]) {\r\n            return 0;\r\n        }\r\n        uint256 mintDate = bapOrchestratorV2.bullLastClaim(tokenId);\r\n        uint256 claimed = 0;\r\n        uint256 dailyRewards = isGod ? 20 : 10;\r\n\r\n        if (mintDate == 0) {\r\n            if (isGod) {\r\n                mintDate = bapOrchestratorV2.godsMintingDate(tokenId);\r\n            } else {\r\n                mintDate = bapGenesis.mintingDatetime(tokenId);\r\n            }\r\n\r\n            claimed = bapOrchestratorV2.totalClaimed(tokenId);\r\n        } else if (!isGod && breedings(tokenId) == 0) {\r\n            dailyRewards = 15;\r\n        }\r\n\r\n        if (mintDate > startTime) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 timeFromCreation = (startTime - mintDate) / (timeCounter);\r\n\r\n        methAmount = dailyRewards * timeFromCreation - claimed;\r\n    }\r\n\r\n    function godBulls(uint256 tokenId) public view returns (bool) {\r\n        return tokenId > 10010 || isGod[tokenId];\r\n    }\r\n\r\n    function isResurrected(uint256 tokenId) public view returns (bool) {\r\n        return claimedTeenMeth[tokenId] != 0;\r\n    }\r\n\r\n    function availableForRefund(uint256 tokenId) public view returns (bool) {\r\n        return\r\n            (_refundPeriodAllowed() || refundFlag) &&\r\n            bapGenesis.breedings(tokenId) == 3 &&\r\n            bapOrchestratorV2.totalClaimed(tokenId) == 0 &&\r\n            claimedMeth[tokenId] == 0 &&\r\n            !prevClaimed[tokenId];\r\n    }\r\n\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256 tokenId,\r\n        bytes memory\r\n    ) external virtual override returns (bytes4) {\r\n        require(\r\n            msg.sender == address(bapTeenBulls),\r\n            \"Only receive from BAP Teens\"\r\n        );\r\n        require(isReviving, \"Only accept transfers while reviving\");\r\n        lastTokenReceived = tokenId;\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    // OWNER FUNCTIONS\r\n\r\n    function initializeGodBull(uint256[] memory gods, bool godFlag)\r\n        external\r\n        onlyOwner\r\n    {\r\n        for (uint256 i; i < gods.length; i++) {\r\n            isGod[gods[i]] = godFlag;\r\n        }\r\n    }\r\n\r\n    function transferExternalOwnership(address _contract, address _newOwner)\r\n        external\r\n        onlyOwner\r\n        noZeroAddress(_newOwner)\r\n    {\r\n        Ownable(_contract).transferOwnership(_newOwner);\r\n    }\r\n\r\n    function utilitiesAirdrop(\r\n        address _to,\r\n        uint256 amount,\r\n        uint256 utility\r\n    ) external onlyOwner noZeroAddress(_to) {\r\n        bapUtilities.airdrop(_to, amount, utility);\r\n    }\r\n\r\n    function teenAirdrop(address _to, uint256 amount)\r\n        external\r\n        onlyOwner\r\n        noZeroAddress(_to)\r\n    {\r\n        bapTeenBulls.airdrop(_to, amount);\r\n    }\r\n\r\n    function setGenesisContract(address _newAddress)\r\n        external\r\n        onlyOwner\r\n        noZeroAddress(_newAddress)\r\n    {\r\n        bapGenesis = BAPGenesisInterface(_newAddress);\r\n    }\r\n\r\n    function setMethaneContract(address _newAddress)\r\n        external\r\n        onlyOwner\r\n        noZeroAddress(_newAddress)\r\n    {\r\n        bapMeth = BAPMethaneInterface(_newAddress);\r\n    }\r\n\r\n    function setUtilitiesContract(address _newAddress)\r\n        external\r\n        onlyOwner\r\n        noZeroAddress(_newAddress)\r\n    {\r\n        bapUtilities = BAPUtilitiesInterface(_newAddress);\r\n    }\r\n\r\n    function setTeenBullsContract(address _newAddress)\r\n        external\r\n        onlyOwner\r\n        noZeroAddress(_newAddress)\r\n    {\r\n        bapTeenBulls = BAPTeenBullsInterface(_newAddress);\r\n    }\r\n\r\n    function setTreasuryWallet(address _newTreasuryWallet)\r\n        external\r\n        onlyOwner\r\n        noZeroAddress(_newTreasuryWallet)\r\n    {\r\n        treasuryWallet = _newTreasuryWallet;\r\n    }\r\n\r\n    function setWhitelistedAddress(address _secret)\r\n        external\r\n        onlyOwner\r\n        noZeroAddress(_secret)\r\n    {\r\n        secret = _secret;\r\n    }\r\n\r\n    function setTimeCounter(uint256 _timeCounter) external onlyOwner {\r\n        timeCounter = _timeCounter;\r\n    }\r\n\r\n    function setPowerCooldown(uint256 _powerCooldown) external onlyOwner {\r\n        powerCooldown = _powerCooldown;\r\n    }\r\n\r\n    function setRefundFlag(bool _refundFlag) external onlyOwner {\r\n        refundFlag = _refundFlag;\r\n    }\r\n\r\n    function setClaimFlag(bool _claimFlag) external onlyOwner {\r\n        claimFlag = _claimFlag;\r\n    }\r\n}\r\n"
    },
    "/contracts/reduced_interfaces/BAPUtilitiesInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\ninterface BAPUtilitiesInterface {\r\n    function burn(uint256, uint256) external;\r\n\r\n    function purchaseIncubator() external;\r\n\r\n    function purchaseMergerOrb() external;\r\n\r\n    function transferOwnership(address) external;\r\n\r\n    function airdrop(\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) external;\r\n}\r\n"
    },
    "/contracts/reduced_interfaces/BAPTeenBullsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\ninterface BAPTeenBullsInterface {\r\n    function generateTeenBull() external;\r\n\r\n    function generateMergerOrb() external;\r\n\r\n    function ownerOf(uint256) external view returns (address);\r\n\r\n    function burnTeenBull(uint256) external;\r\n\r\n    function airdrop(address, uint256) external;\r\n\r\n    function safeTransferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external;\r\n}\r\n"
    },
    "/contracts/reduced_interfaces/BAPOrchestratorInterfaceV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\ninterface BAPOrchestratorInterfaceV2 {\r\n    function prevClaimed(uint256) external returns (bool);\r\n\r\n    function totalClaimed(uint256) external view returns (uint256);\r\n\r\n    function bullLastClaim(uint256) external view returns (uint256);\r\n\r\n    function godsMintingDate(uint256) external view returns (uint256);\r\n}\r\n"
    },
    "/contracts/reduced_interfaces/BAPMethaneInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\ninterface BAPMethaneInterface {\r\n    function claim(address, uint256) external;\r\n\r\n    function pay(uint256, uint256) external;\r\n}\r\n"
    },
    "/contracts/reduced_interfaces/BAPGenesisInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\ninterface BAPGenesisInterface {\r\n    function minted() external view returns (uint256);\r\n\r\n    function mintingDatetime(uint256) external view returns (uint256);\r\n\r\n    function updateBullBreedings(uint256) external;\r\n\r\n    function ownerOf(uint256) external view returns (address);\r\n\r\n    function breedings(uint256) external view returns (uint256);\r\n\r\n    function maxBreedings() external view returns (uint256);\r\n\r\n    function generateGodBull() external;\r\n\r\n    function refund(address, uint256) external payable;\r\n\r\n    function safeTransferFrom(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) external;\r\n\r\n    function genesisTimestamp() external view returns (uint256);\r\n}\r\n"
    },
    "/contracts/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// ERC721A Contracts v4.0.0\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev ERC721 token receiver interface.\r\n */\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}