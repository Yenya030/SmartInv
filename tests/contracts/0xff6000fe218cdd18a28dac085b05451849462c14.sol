{{
  "language": "Solidity",
  "sources": {
    "src/EtherRoXX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC721} from \"solady/tokens/ERC721.sol\";\nimport {Rockify} from \"./Rockify.sol\";\nimport {EtherRoXXConstantsEventsAndErrors} from \"./EtherRoXXConstantsEventsAndErrors.sol\";\nimport {XXYYZZ} from \"xxyyzz/XXYYZZ.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {IERC4906, IERC165} from \"./interfaces/IERC4906.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\n/**\n * @title EtherRoXX\n * @author emo.eth, aspyn.eth\n * @notice EtherRoXX is a collection of fully onchain, collectible rocks. Each rock has a unique hex value.\n *         Rocks may be \"rerolled\" to new hex values, provided that the rock's owner also owns\n *         the corresponding XXYYZZ color.\n *\n *         Tokens may be burned, which removes it from the token supply, but unless the token was finalized, its\n *         particular hex value may be minted or rerolled again.\n *\n *         Mints are pseudorandom by default, leveraging the pseudorandomness defined in the XXYYZZ contract, unless\n *         one of the \"Specific\" methods is called. To prevent front-running \"specific\" mint transactions, the rocks\n *         contract uses a commit-reveal scheme. Users must commit a hash of their desired hex value with a secret salt,\n *         wait at least one minute, and then submit their mint transaction with the original hex value(s) and salt.\n *         Multiple IDs may be minted in a single transaction by committing the result of hash of all IDs in order\n *         with a single secret salt.\n */\ncontract EtherRoXX is ERC721, EtherRoXXConstantsEventsAndErrors, IERC4906, Ownable {\n    using Base64 for bytes;\n    using LibString for uint256;\n\n    address payable immutable XXYYZZ_ADDRESS;\n\n    uint256 public numMinted;\n\n    constructor(address initialOwner, address payable _xxyyzzAddress) payable {\n        XXYYZZ_ADDRESS = _xxyyzzAddress;\n        _initializeOwner(initialOwner);\n        _mintTo(initialOwner, 69);\n    }\n\n    /**\n     * @dev allows receiving ether refunds from XXYYZZ mints\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Withdraw any ETH in the contract to the owner. OnlyOwner.\n     * @dev This is a safety function to allow the owner to withdraw any ETH sent to the contract\n     */\n    function withdraw() public onlyOwner {\n        address _owner = owner();\n        assembly {\n            if iszero(call(gas(), _owner, selfbalance(), 0, 0, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    //////////////\n    // METADATA //\n    //////////////\n\n    ///@notice Returns the name of the token\n    function name() public pure override returns (string memory) {\n        // note that this is unsafe to call internally, as it abi-encodes the name and\n        // performs a low-level return\n        assembly {\n            mstore(0x20, 0x20)\n            mstore(0x4a, 0x0a457468657220526f5858)\n            return(0x20, 0x80)\n        }\n    }\n\n    ///@notice Returns the symbol of the token\n    function symbol() public pure override returns (string memory) {\n        // note that this is unsafe to call internally, as it abi-encodes the name and\n        // performs a low-level return\n        assembly {\n            mstore(0x20, 0x20)\n            mstore(0x44, 0x04524f5858)\n            return(0x20, 0x80)\n        }\n    }\n\n    ///@notice Returns the base64-encoded token-level metadata\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        if (_ownerOf(tokenId) == address(0)) {\n            revert TokenDoesNotExist();\n        }\n\n        return string.concat(\n            \"data:application/json;base64,\",\n            bytes(\n                string.concat(\n                    '{\"name\":\"#',\n                    tokenId.toHexStringNoPrefix(3),\n                    '\",\"description\":\"Ether RoXX are onchain rocks composable with XXYYZZ colors\",\"image\":\"data:image/svg+xml;base64,',\n                    bytes(Rockify.rockify(tokenId)).encode(),\n                    '\",\"traits\":[{\"trait_type\":\"XXYYZZ Color\",\"value\":\"#',\n                    tokenId.toHexStringNoPrefix(3),\n                    '\"}]}'\n                )\n            ).encode()\n        );\n    }\n\n    ///@notice Return the base64-encoded contract-level metadata\n    function contractURI() public pure returns (string memory) {\n        return string.concat(\"data:application/json;base64,\", bytes(_stringContractURI()).encode());\n    }\n\n    ///@inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        override(ERC721, IERC165)\n        returns (bool result)\n    {\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f. ERC4906: 0x49064906\n            result := or(or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f)), eq(s, 0x49064906))\n        }\n    }\n\n    ///@dev Return a contract-level JSON string\n    function _stringContractURI() internal pure returns (string memory) {\n        return string.concat(\n            '{\"name\":\"Ether RoXX\",\"description\":\"Collectible, customizable rocks, entirely onchain. Powered by XXYYZZ.\",\"external_link\":\"https://xxyyzz.art\",\"image\":\"',\n            string.concat(\"data:application/json;base64,\", bytes(Rockify.rockify(0xff6000)).encode()),\n            '\"}'\n        );\n    }\n\n    //////////\n    // MINT //\n    //////////\n\n    /**\n     * @notice Mint EtherRoXX tokens along with underlying XXYYZZ colors.\n     * @param quantity The number of tokens to mint.\n     */\n    function mint(uint256 quantity) public payable returns (uint256[] memory) {\n        return mintTo(msg.sender, quantity);\n    }\n\n    /**\n     * @notice Mint EtherRoXX tokens along with underlying XXYYZZ colors to a specific address.\n     * @param recipient The address to mint tokens to.\n     * @param quantity The number of tokens to mint.\n     */\n    function mintTo(address recipient, uint256 quantity) public payable returns (uint256[] memory) {\n        // Check max mint per transaction not exceeded\n        if (quantity > MAX_MINT_PER_TRANSACTION) {\n            revert MaxMintPerTransactionExceeded();\n        }\n\n        return _mintTo(recipient, quantity);\n    }\n\n    /**\n     * @notice Mint a token for a specific XXYYZZ color held by the minter.\n     * @param color The XXYYZZ color to mint. The caller must own the color.\n     */\n    function mintWithColor(uint256 color) public {\n        uint256 numMinted_;\n        unchecked {\n            numMinted_ = numMinted + 1;\n        }\n        // Check max supply not exceeded\n        if (numMinted_ > MAX_SUPPLY) {\n            revert MaxSupplyReached();\n        }\n\n        _validateXXYYZZOwner(color);\n\n        // Increment number minted\n        numMinted = numMinted_;\n\n        // Mint token with color\n        _mint(msg.sender, color);\n    }\n\n    /**\n     * @notice Mint EtherRoXX tokens for XXYYZZ colors held by the minter.\n     * @param colors The XXYYZZ colors to mint. The caller must own the colors.\n     */\n    function batchMintWithColor(uint256[] calldata colors) public {\n        if (colors.length == 0) {\n            revert ArrayLengthMustBeGreaterThanZero();\n        }\n        uint256 numMinted_;\n        unchecked {\n            numMinted_ = numMinted + colors.length;\n        }\n\n        // Check max supply not exceeded\n        if (numMinted_ > MAX_SUPPLY) {\n            revert MaxSupplyReached();\n        }\n\n        // Check caller owns all colors\n        for (uint256 i; i < colors.length;) {\n            _validateXXYYZZOwner(colors[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Update number minted\n        numMinted = numMinted_;\n        // Mint tokens with colors\n        for (uint256 i; i < colors.length;) {\n            uint256 color = colors[i];\n            // increment before skipping\n            unchecked {\n                ++i;\n            }\n            // skip if already minted\n            if (_ownerOf(color) != address(0)) {\n                continue;\n            }\n            _mint(msg.sender, color);\n        }\n    }\n\n    /**\n     * @notice Mint EtherRoXX token along with the specific underlying XXYYZZ color and validate it was committed to.\n     * @param id The XXYYZZ color to mint.\n     * @param salt The user-specific salt used in the previous commitment. It will be further hashed to derive the salt used in the XXYYZZ mint.\n     */\n    function mintSpecific(uint256 id, bytes32 salt) public payable {\n        uint256 numMinted_ = numMinted;\n        unchecked {\n            numMinted_ = numMinted_ + 1;\n        }\n        if (numMinted_ > MAX_SUPPLY) {\n            revert MaxSupplyReached();\n        }\n        bytes32 newSalt = deriveUserSalt(msg.sender, bytes32(salt));\n        XXYYZZ(XXYYZZ_ADDRESS).mintSpecific{value: msg.value}(id, newSalt);\n        numMinted = numMinted_;\n        _mint(msg.sender, id);\n    }\n\n    /**\n     * @notice Mint EtherRoXX tokens along with the specific underlying XXYYZZ colors.\n     * @param colors The XXYYZZ colors to mint.\n     * @param salt The user-specific salt used in the previous commitment. It will be further hashed to derive the salt used in the XXYYZZ mint.\n     */\n    function batchMintSpecific(uint256[] calldata colors, bytes32 salt) public payable {\n        if (colors.length == 0) {\n            revert ArrayLengthMustBeGreaterThanZero();\n        }\n        if (colors.length > MAX_MINT_PER_TRANSACTION) {\n            revert MaxMintPerTransactionExceeded();\n        }\n        uint256 numMinted_ = numMinted;\n        unchecked {\n            numMinted_ = numMinted_ + colors.length;\n        }\n        if (numMinted_ > MAX_SUPPLY) {\n            revert MaxSupplyReached();\n        }\n        bytes32 newSalt = deriveUserSalt(msg.sender, bytes32(salt));\n        bool[] memory minted = XXYYZZ(XXYYZZ_ADDRESS).batchMintSpecific{value: msg.value}(colors, newSalt);\n        uint256 actualNumMinted;\n        uint256 mintedLength = minted.length;\n        for (uint256 i; i < mintedLength;) {\n            // only mint if xxyyzz mint was successful\n            if (minted[i]) {\n                unchecked {\n                    ++actualNumMinted;\n                }\n                _transferXXYYZZ(msg.sender, colors[i]);\n                _mint(msg.sender, colors[i]);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        numMinted += actualNumMinted;\n        uint256 mintPrice = 0.005 ether;\n\n        if (actualNumMinted < colors.length) {\n            assembly {\n                let diff := sub(colors.length, actualNumMinted)\n                let refund := mul(diff, mintPrice)\n                if iszero(call(gas(), caller(), refund, 0, 0, 0, 0)) {\n                    mstore(0, ETHER_TRANSFER_FAILED_SELECTOR) // revert with EtherTransferFailed()\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev low-level helper function to transfer XXYYZZ tokens to intended recipient\n     * @param to address to transfer to\n     * @param id token id to transfer\n     */\n    function _transferXXYYZZ(address to, uint256 id) internal {\n        address xxyyzz = XXYYZZ_ADDRESS;\n        assembly {\n            // cache free mem ptr\n            let ptr := mload(0x40)\n            // clobber first four words of memory\n            mstore(0, TRANSFER_FROM_SELECTOR)\n            mstore(0x20, address())\n            mstore(0x40, to)\n            mstore(0x60, id)\n            // call transferFrom and check result\n            if iszero(call(gas(), xxyyzz, 0, 0x1c, 0x64, 0, 0)) {\n                // revert with return data\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n            // restore free mem ptr\n            mstore(0x40, ptr)\n            // restore zero pointer\n            mstore(0x60, 0)\n        }\n    }\n\n    /**\n     * @dev Mint EtherRoXX tokens along with underlying XXYYZZ colors to a specific address.\n     * @param recipient The address to mint tokens to\n     * @param quantity The number of tokens to mint\n     */\n    function _mintTo(address recipient, uint256 quantity) internal returns (uint256[] memory) {\n        uint256 numMinted_ = numMinted;\n\n        uint256 newSupply;\n        unchecked {\n            newSupply = numMinted_ + quantity;\n        }\n        // Check max supply not exceeded\n        if (newSupply > MAX_SUPPLY) {\n            revert MaxSupplyReached();\n        }\n        // Mint colors\n        uint256[] memory mintedColors = XXYYZZ(XXYYZZ_ADDRESS).mintTo{value: msg.value}(recipient, quantity);\n        unchecked {\n            numMinted = newSupply;\n        }\n        for (uint256 i; i < quantity;) {\n            // Increment token id\n            unchecked {\n                ++numMinted_;\n            }\n\n            _mint(recipient, mintedColors[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n        return mintedColors;\n    }\n\n    ////////////\n    // REROLL //\n    ////////////\n\n    /**\n     * @notice Reroll an existing EtherRoXX for one with a new color. The user must own the XXYYZZ token of the new color.\n     * @param originalId The old token id\n     * @param newId The new token id – the user must own the XXYYZZ token with this ID\n     */\n    function reroll(uint256 originalId, uint256 newId) public {\n        // Check caller owns original token\n        if (ownerOf(originalId) != msg.sender) {\n            revert CallerDoesNotOwnEtherRoXX();\n        }\n        _validateXXYYZZOwner(newId);\n\n        // Burn original token\n        _burn(originalId);\n\n        // Mint new token\n        _mint(msg.sender, newId);\n    }\n\n    ////////////\n    // COMMIT //\n    ////////////\n\n    /**\n     * @notice Commit to a specific XXYYZZ color. Derives a new salt to pass through to the original XXYYZZ contract.\n     */\n    function commit(bytes32 commitHash) public {\n        XXYYZZ(XXYYZZ_ADDRESS).commit(commitHash);\n    }\n\n    /**\n     * @notice Derive the salt that EtherRoXX will pass to the original XXYYZZ contract given a user's salt.\n     * @dev this allows for user commitments to be unique, so other users cannot copy others' commitments.\n     */\n    function deriveUserSalt(address caller_, bytes32 salt) public pure returns (bytes32 newSalt) {\n        assembly {\n            mstore(0, caller_)\n            mstore(0x20, salt)\n            newSalt := keccak256(0, 0x40)\n        }\n    }\n\n    //////////////\n    // INTERNAL //\n    //////////////\n\n    /**\n     * @dev Validate that the caller owns the XXYYZZ color with the given id.\n     */\n    function _validateXXYYZZOwner(uint256 id) internal view {\n        address token = XXYYZZ_ADDRESS;\n        assembly {\n            mstore(0, OWNER_OF_SELECTOR)\n            // store id in second word\n            mstore(0x20, id)\n            // call ownerOf(id), check result, and store result in first word\n            if iszero(staticcall(gas(), token, 0x1c, 0x24, 0, 0x20)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n            // compare result to caller\n            if iszero(eq(mload(0), caller())) {\n                // revert with error if not equal\n                mstore(0, CALLER_DOES_NOT_OWN_XXYYZZ_COLOR_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "lib/solady/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple ERC721 implementation with storage hitchhiking.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC721.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol)\n///\n/// @dev Note:\n/// The ERC721 standard allows for self-approvals.\n/// For performance, this implementation WILL NOT revert for such actions.\n/// Please add any checks with overrides if desired.\nabstract contract ERC721 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev An account can hold up to 4294967295 tokens.\n    uint256 internal constant _MAX_ACCOUNT_BALANCE = 0xffffffff;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Only the token owner or an approved account can manage the token.\n    error NotOwnerNorApproved();\n\n    /// @dev The token does not exist.\n    error TokenDoesNotExist();\n\n    /// @dev The token already exists.\n    error TokenAlreadyExists();\n\n    /// @dev Cannot query the balance for the zero address.\n    error BalanceQueryForZeroAddress();\n\n    /// @dev Cannot mint or transfer to the zero address.\n    error TransferToZeroAddress();\n\n    /// @dev The token must be owned by `from`.\n    error TransferFromIncorrectOwner();\n\n    /// @dev The recipient's balance has overflowed.\n    error AccountBalanceOverflow();\n\n    /// @dev Cannot safely transfer to a contract that does not implement\n    /// the ERC721Receiver interface.\n    error TransferToNonERC721ReceiverImplementer();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\n\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\n\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\n\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership data slot of `id` is given by:\n    /// ```\n    ///     mstore(0x00, id)\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n    ///     let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n    /// ```\n    /// Bits Layout:\n    // - [0..159]   `addr`\n    // - [160..223] `extraData`\n    ///\n    /// The approved address slot is given by: `add(1, ownershipSlot)`.\n    ///\n    /// See: https://notes.ethereum.org/%40vbuterin/verkle_tree_eip\n    ///\n    /// The balance slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n    ///     mstore(0x00, owner)\n    ///     let balanceSlot := keccak256(0x0c, 0x1c)\n    /// ```\n    /// Bits Layout:\n    /// - [0..31]   `balance`\n    /// - [32..225] `aux`\n    ///\n    /// The `operator` approval slot of `owner` is given by:\n    /// ```\n    ///     mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n    ///     mstore(0x00, owner)\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x30)\n    /// ```\n    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;\n\n    /// @dev Pre-shifted and pre-masked constant.\n    uint256 private constant _ERC721_MASTER_SLOT_SEED_MASKED = 0x0a5a2e7a00000000;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC721 METADATA                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the token collection name.\n    function name() public view virtual returns (string memory);\n\n    /// @dev Returns the token collection symbol.\n    function symbol() public view virtual returns (string memory);\n\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           ERC721                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function ownerOf(uint256 id) public view virtual returns (address result) {\n        result = _ownerOf(id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(result) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the number of tokens owned by `owner`.\n    ///\n    /// Requirements:\n    /// - `owner` must not be the zero address.\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Revert if the `owner` is the zero address.\n            if iszero(owner) {\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\n        }\n    }\n\n    /// @dev Returns the account approved to managed token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function getApproved(uint256 id) public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            if iszero(shr(96, shl(96, sload(ownershipSlot)))) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            result := sload(add(1, ownershipSlot))\n        }\n    }\n\n    /// @dev Sets `account` as the approved account to manage token `id`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    /// - The caller must be the owner of the token,\n    ///   or an approved operator for the token owner.\n    ///\n    /// Emits a {Approval} event.\n    function approve(address account, uint256 id) public payable virtual {\n        _approve(msg.sender, account, id);\n    }\n\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, owner)\n            result := sload(keccak256(0x0c, 0x30))\n        }\n    }\n\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\n    ///\n    /// Emits a {ApprovalForAll} event.\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`msg.sender`, `operator`).\n            mstore(0x1c, operator)\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            log3(\n                0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator))\n            )\n        }\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function transferFrom(address from, address to, uint256 id) public payable virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if `from` is not the owner, or does not exist.\n            if iszero(mul(owner, eq(owner, from))) {\n                if iszero(owner) {\n                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                    revert(0x1c, 0x04)\n                }\n                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.\n                revert(0x1c, 0x04)\n            }\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // Revert if the caller is not the owner, nor approved.\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }\n\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \"\")`.\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\n        public\n        payable\n        virtual\n    {\n        transferFrom(from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\n    /// See: https://eips.ethereum.org/EIPS/eip-165\n    /// This function call must use less than 30000 gas.\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL QUERY FUNCTIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns if token `id` exists.\n    function _exists(uint256 id) internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Returns the owner of token `id`.\n    /// Returns the zero address instead of reverting if the token does not exist.\n    function _ownerOf(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*            INTERNAL DATA HITCHHIKING FUNCTIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the auxiliary data for `owner`.\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\n    function _getAux(address owner) internal view virtual returns (uint224 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\n        }\n    }\n\n    /// @dev Set the auxiliary data for `owner` to `value`.\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\n    function _setAux(address owner, uint224 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            mstore(0x00, owner)\n            let balanceSlot := keccak256(0x0c, 0x1c)\n            let packed := sload(balanceSlot)\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\n        }\n    }\n\n    /// @dev Returns the extra data for token `id`.\n    /// Minting, transferring, burning a token will not change the extra data.\n    /// The extra data can be set on a non-existent token.\n    function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Sets the extra data for token `id` to `value`.\n    /// Minting, transferring, burning a token will not change the extra data.\n    /// The extra data can be set on a non-existent token.\n    function _setExtraData(uint256 id, uint96 value) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let packed := sload(ownershipSlot)\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL MINT FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Mints token `id` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must not exist.\n    /// - `to` cannot be the zero address.\n    ///\n    /// Emits a {Transfer} event.\n    function _mint(address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(address(0), to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            to := shr(96, shl(96, to))\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Revert if the token already exists.\n            if shl(96, ownershipPacked) {\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\n                revert(0x1c, 0x04)\n            }\n            // Update with the owner.\n            sstore(ownershipSlot, or(ownershipPacked, to))\n            // Increment the balance of the owner.\n            {\n                mstore(0x00, to)\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\n                if iszero(and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(balanceSlot, balanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\n        }\n        _afterTokenTransfer(address(0), to, id);\n    }\n\n    /// @dev Equivalent to `_safeMint(to, id, \"\")`.\n    function _safeMint(address to, uint256 id) internal virtual {\n        _safeMint(to, id, \"\");\n    }\n\n    /// @dev Mints token `id` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must not exist.\n    /// - `to` cannot be the zero address.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\n        _mint(to, id);\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  INTERNAL BURN FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `_burn(address(0), id)`.\n    function _burn(uint256 id) internal virtual {\n        _burn(address(0), id);\n    }\n\n    /// @dev Destroys token `id`, using `by`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function _burn(address by, uint256 id) internal virtual {\n        address owner = ownerOf(id);\n        _beforeTokenTransfer(owner, address(0), id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\n            owner := shr(96, shl(96, ownershipPacked))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Load and check the token approval.\n            {\n                mstore(0x00, owner)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Clear the owner.\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\n            // Decrement the balance of `owner`.\n            {\n                let balanceSlot := keccak256(0x0c, 0x1c)\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\n            }\n            // Emit the {Transfer} event.\n            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\n        }\n        _afterTokenTransfer(owner, address(0), id);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns whether `account` is the owner of token `id`, or is approved to managed it.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    function _isApprovedOrOwner(address account, uint256 id)\n        internal\n        view\n        virtual\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            // Clear the upper 96 bits.\n            account := shr(96, shl(96, account))\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // Check if `account` is the `owner`.\n            if iszero(eq(account, owner)) {\n                mstore(0x00, owner)\n                // Check if `account` is approved to\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    result := eq(account, sload(add(1, ownershipSlot)))\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the account approved to manage token `id`.\n    /// Returns the zero address instead of reverting if the token does not exist.\n    function _getApproved(uint256 id) internal view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\n        }\n    }\n\n    /// @dev Equivalent to `_approve(address(0), account, id)`.\n    function _approve(address account, uint256 id) internal virtual {\n        _approve(address(0), account, id);\n    }\n\n    /// @dev Sets `account` as the approved account to manage token `id`, using `by`.\n    ///\n    /// Requirements:\n    /// - Token `id` must exist.\n    /// - If `by` is not the zero address, `by` must be the owner\n    ///   or an approved operator for the token owner.\n    ///\n    /// Emits a {Transfer} event.\n    function _approve(address by, address account, uint256 id) internal virtual {\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            account := and(bitmaskAddress, account)\n            by := and(bitmaskAddress, by)\n            // Load the owner of the token.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\n            // Revert if the token does not exist.\n            if iszero(owner) {\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                revert(0x1c, 0x04)\n            }\n            // If `by` is not the zero address, do the authorization check.\n            // Revert if `by` is not the owner, nor approved.\n            if iszero(or(iszero(by), eq(by, owner))) {\n                mstore(0x00, owner)\n                if iszero(sload(keccak256(0x0c, 0x30))) {\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Sets `account` as the approved account to manage `id`.\n            sstore(add(1, ownershipSlot), account)\n            // Emit the {Approval} event.\n            log4(0x00, 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\n        }\n    }\n\n    /// @dev Approve or remove the `operator` as an operator for `by`,\n    /// without authorization checks.\n    ///\n    /// Emits a {ApprovalForAll} event.\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            by := shr(96, shl(96, by))\n            operator := shr(96, shl(96, operator))\n            // Convert to 0 or 1.\n            isApproved := iszero(iszero(isApproved))\n            // Update the `isApproved` for (`by`, `operator`).\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\n            mstore(0x00, by)\n            sstore(keccak256(0x0c, 0x30), isApproved)\n            // Emit the {ApprovalForAll} event.\n            mstore(0x00, isApproved)\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `_transfer(address(0), from, to, id)`.\n    function _transfer(address from, address to, uint256 id) internal virtual {\n        _transfer(address(0), from, to, id);\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    ///\n    /// Emits a {Transfer} event.\n    function _transfer(address by, address from, address to, uint256 id) internal virtual {\n        _beforeTokenTransfer(from, to, id);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clear the upper 96 bits.\n            let bitmaskAddress := shr(96, not(0))\n            from := and(bitmaskAddress, from)\n            to := and(bitmaskAddress, to)\n            by := and(bitmaskAddress, by)\n            // Load the ownership data.\n            mstore(0x00, id)\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\n            let ownershipPacked := sload(ownershipSlot)\n            let owner := and(bitmaskAddress, ownershipPacked)\n            // Revert if `from` is not the owner, or does not exist.\n            if iszero(mul(owner, eq(owner, from))) {\n                if iszero(owner) {\n                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\n                    revert(0x1c, 0x04)\n                }\n                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.\n                revert(0x1c, 0x04)\n            }\n            // Revert if `to` is the zero address.\n            if iszero(to) {\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n            // Load, check, and update the token approval.\n            {\n                mstore(0x00, from)\n                let approvedAddress := sload(add(1, ownershipSlot))\n                // If `by` is not the zero address, do the authorization check.\n                // Revert if the `by` is not the owner, nor approved.\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n                // Delete the approved address if any.\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\n            }\n            // Update with the new owner.\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\n            // Decrement the balance of `from`.\n            {\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\n            }\n            // Increment the balance of `to`.\n            {\n                mstore(0x00, to)\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\n                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n                sstore(toBalanceSlot, toBalanceSlotPacked)\n            }\n            // Emit the {Transfer} event.\n            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\n        }\n        _afterTokenTransfer(from, to, id);\n    }\n\n    /// @dev Equivalent to `_safeTransfer(from, to, id, \"\")`.\n    function _safeTransfer(address from, address to, uint256 id) internal virtual {\n        _safeTransfer(from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - The caller must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeTransfer(address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(address(0), from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /// @dev Equivalent to `_safeTransfer(by, from, to, id, \"\")`.\n    function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\n        _safeTransfer(by, from, to, id, \"\");\n    }\n\n    /// @dev Transfers token `id` from `from` to `to`.\n    ///\n    /// Requirements:\n    ///\n    /// - Token `id` must exist.\n    /// - `from` must be the owner of the token.\n    /// - `to` cannot be the zero address.\n    /// - If `by` is not the zero address,\n    ///   it must be the owner of the token, or be approved to manage the token.\n    /// - If `to` refers to a smart contract, it must implement\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n    ///\n    /// Emits a {Transfer} event.\n    function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\n        internal\n        virtual\n    {\n        _transfer(by, from, to, id);\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    HOOKS FOR OVERRIDING                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Hook that is called before any token transfers, including minting and burning.\n    function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}\n\n    /// @dev Hook that is called after any token transfers, including minting and burning.\n    function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns if `a` has bytecode of non-zero length.\n    function _hasCode(address a) private view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := extcodesize(a) // Can handle dirty upper bits.\n        }\n    }\n\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\n    /// Reverts if the target does not support the function correctly.\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\n        private\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the calldata.\n            let m := mload(0x40)\n            let onERC721ReceivedSelector := 0x150b7a02\n            mstore(m, onERC721ReceivedSelector)\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\n            mstore(add(m, 0x60), id)\n            mstore(add(m, 0x80), 0x80)\n            let n := mload(data)\n            mstore(add(m, 0xa0), n)\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\n            // Revert if the call reverts.\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\n                if returndatasize() {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(0x00, 0x00, returndatasize())\n                    revert(0x00, returndatasize())\n                }\n                mstore(m, 0)\n            }\n            // Load the returndata and compare it.\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "src/Rockify.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {LibString} from \"solady/utils/LibString.sol\";\n\n/**\n * @title Rockify\n * @author emo.eth, aspyn.eth\n * @notice Rockify is a utility library for generating rock svgs from xxyyzz colors.\n */\nlibrary Rockify {\n    using LibString for uint256;\n\n    uint256 constant CANON = 0xb3;\n    uint256 constant FILL_1 = 0x1a;\n    uint256 constant FILL_2 = 0x30;\n    uint256 constant FILL_3 = 0x4d;\n    uint256 constant FILL_4 = 0x60;\n    uint256 constant FILL_5 = 0x80;\n    uint256 constant FILL_6 = 0x90;\n    uint256 constant FILL_7 = 0xe6;\n\n    uint256 constant SCALE = 2 ** 16;\n    uint256 constant FILL_1_SCALAR = ((FILL_1) * SCALE) / (CANON);\n    uint256 constant FILL_2_SCALAR = ((FILL_2) * SCALE) / (CANON);\n    uint256 constant FILL_3_SCALAR = ((FILL_3) * SCALE) / (CANON);\n    uint256 constant FILL_4_SCALAR = ((FILL_4) * SCALE) / (CANON);\n    uint256 constant FILL_5_SCALAR = ((FILL_5) * SCALE) / (CANON);\n    uint256 constant FILL_6_SCALAR = ((FILL_6) * SCALE) / (CANON);\n    uint256 constant FILL_7_SCALAR = ((FILL_7) * SCALE) / (CANON);\n\n    function r(uint256 color) internal pure returns (uint256) {\n        return color >> 16;\n    }\n\n    function g(uint256 color) internal pure returns (uint256) {\n        return (color >> 8) & 0xff;\n    }\n\n    function b(uint256 color) internal pure returns (uint256) {\n        return color & 0xff;\n    }\n\n    function assemble(uint256 _r, uint256 _g, uint256 _b) internal pure returns (uint256) {\n        return (_r << 16) | (_g << 8) | _b;\n    }\n\n    function scaleAndClamp(uint256 component, uint256 scalar) internal pure returns (uint256) {\n        uint256 scaled = (component * scalar) / SCALE;\n        if (scaled > 0xff) {\n            return 0xff;\n        }\n        return scaled;\n    }\n\n    function scaleForColor(uint256 color, uint256 scalar) internal pure returns (uint256) {\n        uint256 _r = scaleAndClamp(r(color), scalar);\n        uint256 _g = scaleAndClamp(g(color), scalar);\n        uint256 _b = scaleAndClamp(b(color), scalar);\n        uint256 scaled = assemble(_r, _g, _b);\n\n        return scaled;\n    }\n\n    function scaleColor(uint256 color, uint256 scalar) internal pure returns (string memory) {\n        return scaleForColor(color, scalar).toHexStringNoPrefix(3);\n    }\n\n    function rockify(uint256 xxyyzz) internal pure returns (string memory) {\n        string memory interp = string.concat(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"210 0 1332.9 1156\"><path d=\"M567.13 305.138c4.385 20.532 15.045 40.346 11.212 61.941-.446 23.197 24.037 56.1 13.411 77.799-6.015 18.316-15.089 34.052-13.192 53.356-2.232 19.396-12.572 32.265-1.918 48.713 10.684 19.938 14.352 42.782 17.941 64.8 2.428 22.402 24.14 44.855 24.053 67.345 1.459 19.258.32 86.082-24.216 94.921-17.587 7.91-49.575-30.254-58.788-10.005-5.805 12.776-16.015 9.186-15.143-4.366-.65-19.518 7.65-43.022-7.915-58.846-9.443-17.406-39.528-17.737-40.662-37.98.402-24.365 19.997-41.855 26.566-64.34 14.163-15.61 4.35-39.087 12.203-57.145 3.828-20.419 11.062-39.953 15.185-60.244 1.747-18.215 3.414-36.297 6.366-54.365 1.685-13.326 4.528-27.463 13.925-37.676 8.657-22.484 8.6-46.768 13.404-70.036 1.483-5.1 4.015-9.908 7.568-13.872z\" fill=\"#',\n            scaleColor(xxyyzz, FILL_4_SCALAR)\n        );\n        interp = string.concat(\n            interp,\n            '\" /><path d=\"M501.242 665.288c-15.39-1.479-16.105 17.697-21.332 27.761-6.661 16.888-4.158 35.335-4.787 52.983-1.073 18.283 19.381 16.537 29.758 25.004 16.045 10.063 22.043 28.798 29.064 45.32 3.358 15.096 3.017 30.881 8.608 45.464 4.016 13.837-.249 28.352 2.657 42.405 3.461 12.429-.819 30.204 12.366 37.555 16.249 6.109 17.753-15.953 26.346-23.895 9.106-11.32 24.059-17.96 38.572-15.62 13.972-1.95 13.851-21.72 11.336-31.84-7.761-9.71-20.165-14.19-28.074-23.55-8.368-11.57-14.62-26.02-28.313-31.87-13.053-4.24-16.416-18.54-23.994-28.44-7.16-6.694-22.074-7.376-18.336-21.325.265-13.049 1.702-26.439-.816-39.315-7.781-13.347-2.599-32.433-15.761-42.986-3.528-7.715-10.348-13.146-17.293-17.657z\" fill=\"#',\n            scaleColor(xxyyzz, FILL_4_SCALAR)\n        );\n        interp = string.concat(interp, '\" /><g fill=\"#', scaleColor(xxyyzz, FILL_3_SCALAR));\n        interp = string.concat(\n            interp,\n            '\"><path d=\"M670.824 858.088c-12.96-8.6 4.576-25.22 1.571-39.28-3.686-17.3-18.441-51.45-32.233-61.92-9.403-7.455-30.224 1.544-42.101-1.878-26.488-33.385-13.5-18.039-34.347-18.194-5.736 9.509-39.917 16.674-40.814 23.34.192 9.914 5.525 11.842 8.224 21.444 1.708 11.655 12.815 22.106 17.831 32.78 4.337 11.268 11.966 20.796 19.31 30.22 4.441 5.635 11.293 8.085 17.99 9.79 9.926 2.436 16.211 10.624 23.882 16.434 8.46 3.661 18.798 5.616 22.396 15.419 8.777 16.96 28.165 3.325 30.825-2.98 3.816-6.497 12.757-50.965 20.417-52.433 1.406-.407-14.328 27.761-12.952 27.261z\" /><path d=\"M975.59 1040.088c-14.205-.852-17.565-47.114-33.058-47.353a922.18 922.18 0 0 1-38.413-26.993c-8.454-7.902-39.115-8.248-49.501-15.555-14.359-8.247-28.577-16.735-41.134-27.578-11.125-6.69-25.7 5.484-36.508-1.585-12.506-4.98-18.436-11.616-30.303-18.534-15.044-6.519-50.234-89.52-66.062-94.434-13.796-3.399-8.471 55.504-23.892 62.74-11.798 10.156-24.37 25.567-21.505 39.258 6.816 10.413 26.196 28.096 31.065 39.526 5.1 15.397 10.421 31.129 21.624 43.338 9.004 8.669 17.299 18.413 27.629 25.59 11.295 9.79 14.44 27.207 26.583 35.744 14.661 2.75 37.534-3.815 49.483 5.35 13.167 5.086 26.702 9.56 41.003 8.53 19.38-.446 38.869 1.054 58.038-2.447 15.151-2.698 32.919 4.207 45.407-7.834 18.35 9.842 54.187.949 39.542-17.761z\" /></g><path d=\"M1141.42 1079.428c25.203-7.351 27.29 40.32 53.345 23.031 17.546-17.452 39.612-27.088 64.071-30.481 20.649-5.942 42.674-8.85 62.002-16.894 5.137-24.06-4.002-49.026-8.788-72.913-10.971-22.789-11.727-48.649-15.563-73.366-2.283-24.09-9.222-47.36-12.402-71.118.367-22.472 10.476-70.186-14.327-61.805-13.869 17.628-23.634 30.266-49.33 34.422-22.666 8.445-54.697 8.32-78.305 14.194-39.581 13.777-71.09 44.665-112.77 50.615-22.661 7.646-45.261 16.317-69.208 19.302-25.141 7.147-49.897 15.346-74.005 25.275-18.433 6.006-37.821 9.119-55.58 17.133-25.535 1.693 8.74 17.995 15.145 22.44 18.574 19.877 47.538 23.401 68.275 40.359 23.745 10.022 39.655 31.404 41.211 57.231-.662 18.166 19.058 41.051 31.014 17.767 8.455-16.57 37.359-11.408 49.765-27.282 25.141-3.049 50.453-3.664 75.633-5.353 26.807-2.706 33.525 13.527 29.819 37.441z\" fill=\"#',\n            scaleColor(xxyyzz, FILL_6_SCALAR)\n        );\n        interp = string.concat(\n            interp,\n            '\" /><path d=\"M504.273 742.288c-45.561-25.034-28.799 24.835-5.417 55.81 26.748 21.902 31.81 57.255 38.47 89.049 5.014 38.726 23.663 66.865 37.06 96.498 20.885 28.723 66.848 13.738 86.426 44.278 19.222 22.338 46.963 42.109 77.956 37.817 63.106 13.266 127.78 17.84 190.88 30.332 54.392 1.239 108.8.149 163.2.502 15.936 27.686 200.16-18.206 30.651-15.16-30.78-17.468-67.588-12.975-101.28-18.788-32.439 1.855-64.355-3.776-96.337-6.153-38.538-.275-77.103 1.125-115.62-.753-26.76-13.774-64.442 1.437-84.647-25.561-6.147-30.556-17.829-71.771-46.891-90.091-36.264-32.69-46.603-69.95-89.418-95.78-30.323-23.55-49.205-65.37-73.102-94.02-3.491-3.304-7.491-6.116-11.931-7.993z\" fill=\"#',\n            scaleColor(xxyyzz, FILL_1_SCALAR)\n        );\n        interp = string.concat(\n            interp,\n            '\" /><path d=\"M975.7 1082.288c14.38-5.143 21.369-20.466 34.736-27.214 11.916-9.445 27.491-15.511 42.814-12.73 14.831.307 29.67-4.023 44.495-3.327 9.215 4.464 25.291-7.062 34.881-6.522 7.301 3.294 42.016 25.649 41.182 32.531 19.094 6.517 36.905 12.536 36.909 20.018s-12.897 19.697-19.282 22.264c-.375 6.736-56.152-17.099-61.281-18.811-13.023-5.268-27.439-3.731-41.157-3.261-21.208.69-42.434-.884-63.646-.028-14.696 3.917-30.68 5.006-45.241-.072-1.571-.779-3.063-1.725-4.411-2.849z\" fill=\"#',\n            scaleColor(xxyyzz, FILL_2_SCALAR)\n        );\n        interp = string.concat(\n            interp,\n            '\" /><path d=\"M655.828 13.718c-21.21 19.147-33.262 6.307-24.939 34.185-6.504 48.588-41.665 87.943-47.347 136.41.981 45.325-14.006 88.883-16.469 133.3 14.009 40.736 31.383 83.854 7.396 125.01-6.964 39.535-5.424 80.691-2.503 120.66 28.064 27.118 20.32 67.41 28.792 102.53 21.205 34.541-15.109 71.545 5.571 101.39 45.669 10.807 38.855 74.503 69.619 94.54 13.416 41.891 47.776 31.373 88.324 69.123 39.482 23.406 84.557 10.026 128.17 11.546 37.694-1.383 63.596-40.151 105.34-36.546 49.716 6.099 76.958-33.834 118.27-51.039 34.005-26.101 75.677-29.766 116.19-36.244 28.981-11.858 55.274-14.171 51.008-69.897-11.596-38.204-8.853-79.929-10.573-119.75-1.777-32.121 9.591-77.501-26.89-93.402-34.388-25.486-17.343-76.907-21.33-113.87 9.95-41.749-15.472-77.091-51.832-95.116-51.71-25.42-71.48-82.461-108.5-122.54-23.41-33.841-42.27-81.108-86.93-90.72-46.21-5.333-85.9-31.088-129.56-45.222-31.27-21.728-76.28-15.358-102.88-43.238-29.515-3.162-59.864-11.474-88.932-11.115z\" fill=\"#',\n            xxyyzz.toHexStringNoPrefix(3)\n        );\n        interp = string.concat(\n            interp,\n            '\" /><path d=\"M910.3 88.519c-17.997-1.638-34.182-7.924-32.972 15.98.015 19.077 30.48 15.097 31.452 35.704 15.408 11.458 26.686 30.373 45.25 35.94 25.86-1.709 21.275 25.705 25.117 42.594 6.349 19.807 21.904 34.824 32.579 52.409 14.125 22.136 38.502 35.563 50.82 58.948 9.738 17.945 13.355 38.763 26.56 54.891 4.827 15.415 16.107 31.362 34.051 25.873 17.951 2.465 48.658 16.846 57.02-6.014 25.743-4.612 41.453-44.084 22.197-58.068-7.702-19.149-15.544-22.51-50.386-30.943.044-19.92-17.195-33.128-30.835-47.925-14.35-14.452-22.71-25.878-35.45-39.56-4.69-19.33-19.23-33.52-30.54-49.085-18.79-19.599-25.93-50.102-52.11-62.193-19.17-6.729-33.41-24.03-53.89-27.03-12.111 2.469-30.751 7.166-38.867-1.532z\" fill=\"#',\n            scaleColor(xxyyzz, FILL_7_SCALAR)\n        );\n        interp = string.concat(\n            interp,\n            '\" /><path d=\"M657.801 13.208c-17.077 3.035-34.924 13.904-32.659 33.219L603.395 94.07c-10.587 18.419-22.046 37.43-22.647 59.333-2.702 25.477-22.082 47.133-19.332 73.676l-.001 129.49c-7.778 16.093-3.111 34.657-7.886 51.117-.643 15.047-2.3 33.836 1.03 46.79 27.602 2.418 26.632-24.791 30.572-41.392 9.592-15.69 3.969-37.01 9.116-54.45 2.977-17.55 6.104-35.13 15.816-50.25 7.516-21.53 18.078-42.1 32.825-59.576 10.65-15.087 13.863-34.464 7.413-51.914-4.834-16.658-10.906-33.302-8.887-50.938V82.27c10.003-12.635 22.633-22.23 37.544-27.758 4.888-2.287 2.899-11.831 4.093-14.752 1.055-2.583-5.18-8.129-14.335-7.544-12.725-.399-24.827-.587-8.907-17.091\" fill=\"#',\n            scaleColor(xxyyzz, FILL_5_SCALAR)\n        );\n        interp = string.concat(\n            interp,\n            '\" /><path d=\"M1267.13 642.288c-12.244-2.531-22.702 8.301-35.108 5.741l-70.606-.027c-9.053-6.734-22.274-2.633-30.535-11.18-11.898-6.147-22.452-14.493-35.039-18.991-9.501-6.06-21.003-5.501-30.964-10.309-8.028 1.398 5.241 12.89 5.014 18.193 3.002 9.812 6.387 19.276 10.752 28.533 3.187 10.121 7.068 20.332 14.948 27.798 8.347 10.533 14.6 23.046 17.507 36.06 8.144 2.182 8.39 14.103 14.722 20.443 5.563 7.798 9.433 17.226 7.853 26.932 1.651 15.339 19.103 10.55 29.404 13.071 14.227 2.815 28.88-1.392 42.995 2.725 9.519 1.571 19.443.355 29.032 2.197 8.12 2.56 15.964.943 24.231 1.389 7.308-.576 22.719 7.792 23.117-3.198 1.217-15.924-3.601-31.445-4.298-47.277-1.623-10.606-1.921-21.364-1.74-32.025-1.309-13.645-3.065-27.377-7.927-40.272-1.552-6.527-1.398-13.359-3.357-19.803z\" fill=\"#',\n            scaleColor(xxyyzz, FILL_6_SCALAR)\n        );\n        interp = string.concat(interp, '\" /></svg> ');\n        return interp;\n    }\n}\n"
    },
    "src/EtherRoXXConstantsEventsAndErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {ERC721} from \"solady/tokens/ERC721.sol\";\nimport {Rockify} from \"./Rockify.sol\";\n\n/**\n * @title EtherRoXXConstantsEventsAndErrors\n * @author emo.eth, aspyn.eth\n * @notice Constants, events, and errors for use in EtherRoXX contract.\n */\ncontract EtherRoXXConstantsEventsAndErrors {\n    uint256 constant MAX_SUPPLY = 969;\n    uint256 constant MAX_MINT_PER_TRANSACTION = 10;\n    uint256 constant OWNER_OF_SELECTOR = 0x6352211e;\n    uint256 constant CALLER_DOES_NOT_OWN_XXYYZZ_COLOR_ERROR_SELECTOR = 0x82c7950c;\n    uint256 constant ETHER_TRANSFER_FAILED_SELECTOR = 0x6747a288;\n    uint256 constant TRANSFER_FROM_SELECTOR = 0x23b872dd;\n\n    error MaxSupplyReached();\n    error MaxMintPerTransactionExceeded();\n    error CallerDoesNotOwnXXYYZZColor();\n    error CallerDoesNotOwnEtherRoXX();\n    error InvalidPayment();\n    error InvalidHex();\n    error EtherTransferFailed();\n    error ArrayLengthMustBeGreaterThanZero();\n}\n"
    },
    "lib/xxyyzz/src/XXYYZZ.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {XXYYZZMetadata} from \"./XXYYZZMetadata.sol\";\nimport {XXYYZZBurn} from \"./XXYYZZBurn.sol\";\nimport {XXYYZZSeaDrop} from \"./XXYYZZSeaDrop.sol\";\nimport {XXYYZZCore} from \"./XXYYZZCore.sol\";\nimport {XXYYZZRerollFinalize} from \"./XXYYZZRerollFinalize.sol\";\nimport {XXYYZZCore} from \"./XXYYZZCore.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\n\n/**\n * @title XXYYZZ\n * @author emo.eth\n * @notice XXYYZZ is a collection of fully onchain, collectible colors. Each token has a unique hex value.\n *         Tokens may be \"rerolled\" to new hex values, unless they are \"finalized,\" in which case, they are immutable.\n *\n *         Finalizing tokens also adds the finalizer's wallet address to the token's metadata.\n *         Tokens may be burned, which removes it from the token supply, but unless the token was finalized, its\n *         particular hex value may be minted or rerolled again.\n *\n *         Mints and rerolls are pseudorandom by default, unless one of the \"Specific\" methods is called.\n *         To prevent front-running \"specific\" mint transactions, the XXYYZZ contract uses a commit-reveal scheme.\n *         Users must commit a hash of their desired hex value with a secret salt, wait at least one minute, and then\n *         submit their mint or reroll transaction with the original hex value(s) and salt.\n *         Multiple IDs may be minted or rerolled in a single transaction by committixng the result of hash of all IDs in order\n *         with a single secret salt.\n *         In batch methods, unavailable IDs are skipped, and excess payment is refunded to the caller.\n */\ncontract XXYYZZ is XXYYZZMetadata, XXYYZZBurn, XXYYZZSeaDrop, XXYYZZRerollFinalize {\n    using LibString for uint256;\n    using LibString for address;\n    using Base64 for bytes;\n\n    constructor(\n        address initialOwner,\n        address creatorPayout,\n        uint256 maxBatchSize,\n        uint24[] memory preMintIds,\n        address seaDrop\n    ) XXYYZZSeaDrop(seaDrop, creatorPayout, initialOwner, maxBatchSize) {\n        for (uint256 i; i < preMintIds.length;) {\n            _mint(initialOwner, preMintIds[i]);\n            _finalizeToken(preMintIds[i], initialOwner);\n            unchecked {\n                ++i;\n            }\n        }\n        _numMinted = uint32(preMintIds.length);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        override(XXYYZZSeaDrop, XXYYZZCore)\n        returns (bool)\n    {\n        return XXYYZZSeaDrop.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "lib/solady/src/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, sub(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0230)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"
    },
    "lib/solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(uint256(-value));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(mload(a), 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store the bytes of the packed offsets and strides into the scratch space.\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n                mstore(0x1f, 0x900094)\n                mstore(0x08, 0xc0000000a6ab)\n                // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let end := add(s, mload(s))\n                result := add(mload(0x40), 0x20)\n                // Store \"\\\\u0000\" in scratch space.\n                // Store \"0123456789abcdef\" in scratch space.\n                // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n                // into the scratch space.\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n                // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\n            } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
    },
    "src/interfaces/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IERC165} from \"forge-std/interfaces/IERC165.sol\";\n\ninterface IERC4906 is IERC165 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "lib/solady/src/auth/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\n/// for compatibility, the nomenclature for the 2-step ownership handover\n/// may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"
    },
    "lib/xxyyzz/src/XXYYZZMetadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {XXYYZZCore} from \"./XXYYZZCore.sol\";\nimport {LibString} from \"solady/utils/LibString.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\n\n/**\n * @title XXYYZZMetadata\n * @author emo.eth\n * @notice XXYYZZMetadata implements the onchain metadata for XXYYZZ tokens.\n */\nabstract contract XXYYZZMetadata is XXYYZZCore {\n    using LibString for uint256;\n    using LibString for address;\n    using Base64 for bytes;\n\n    /**\n     * @notice Return the base64-encoded token metadata. Won't revert if the token doesn't exist.\n     *         Will revert if the id is not a valid six-hex-digit ID.\n     */\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {\n        _validateId(id);\n        return string.concat(\"data:application/json;base64,\", bytes(_stringURI(id)).encode());\n    }\n\n    ///@notice Return the base64-encoded contract-level metadata\n    function contractURI() public pure returns (string memory) {\n        return string.concat(\"data:application/json;base64,\", bytes(_stringContractURI()).encode());\n    }\n\n    ///@dev Return a token-level JSON string\n    function _stringURI(uint256 id) internal view virtual returns (string memory) {\n        return string.concat(\n            \"{\",\n            _kv(\"name\", _name(id)),\n            \",\",\n            _kv(\"external_link\", \"https://xxyyzz.art\"),\n            \",\",\n            _kv(\n                \"description\",\n                \"Proof of color. XXYYZZ is a collection of fully onchain, unique, composable, and collectable colors.\"\n            ),\n            \",\",\n            _kv(\"image\", _imageURI(id)),\n            \",\",\n            _kRawV(\"attributes\", _traits(id)),\n            \"}\"\n        );\n    }\n\n    ///@dev Return a contract-level JSON string\n    function _stringContractURI() internal pure returns (string memory) {\n        return\n        '{\"name\":\"XXYYZZ\",\"description\":\"Collectible, composable, and unique onchain colors.\",\"external_link\":\"https://xxyyzz.art\"}';\n    }\n\n    ///@dev Return a name like \"#aabbcc\"\n    function _name(uint256 id) internal pure returns (string memory) {\n        return string.concat(\"#\", id.toHexStringNoPrefix({length: 3}));\n    }\n\n    ///@dev Return an svg as a base64-encoded data uri string\n    function _imageURI(uint256 id) internal pure returns (string memory) {\n        return string.concat(\"data:image/svg+xml;base64,\", bytes(_svg(id)).encode());\n    }\n\n    ///@dev Return a 690x690 SVG with a single rect of the token's color\n    function _svg(uint256 id) internal pure returns (string memory) {\n        return string.concat(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"690\" height=\"690\"><rect width=\"690\" height=\"690\" fill=\"#',\n            id.toHexStringNoPrefix({length: 3}),\n            '\" /></svg>'\n        );\n    }\n\n    ///@dev Return a JSON array of {\"trait_type\":\"key\",\"value\":\"value\"} pairs\n    function _traits(uint256 id) internal view returns (string memory) {\n        string memory color = _trait(\"Color\", _name(id));\n        if (isFinalized(id)) {\n            string memory finalizedProp = _trait(\"Finalized\", \"Yes\");\n            return string.concat(\n                \"[\", color, \",\", finalizedProp, \",\", _trait(\"Finalizer\", finalizers[id].toHexString()), \"]\"\n            );\n        } else {\n            return string.concat(\"[\", color, \",\", _trait(\"Finalized\", \"No\"), \"]\");\n        }\n    }\n\n    ///@dev return a {\"trait_type\":\"key\",\"value\":\"value\"} pair\n    function _trait(string memory key, string memory value) internal pure returns (string memory) {\n        return string.concat('{\"trait_type\":\"', key, '\",\"value\":\"', value, '\"}');\n    }\n\n    ///@dev return a \"key\":\"value\" pair\n    function _kv(string memory key, string memory value) internal pure returns (string memory) {\n        return string.concat('\"', key, '\":\"', value, '\"');\n    }\n\n    ///@dev Return a \"key\":value pair without quoting value\n    function _kRawV(string memory key, string memory value) internal pure returns (string memory) {\n        return string.concat('\"', key, '\":', value);\n    }\n}\n"
    },
    "lib/xxyyzz/src/XXYYZZBurn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {XXYYZZCore} from \"./XXYYZZCore.sol\";\n\nabstract contract XXYYZZBurn is XXYYZZCore {\n    //////////\n    // BURN //\n    //////////\n\n    /**\n     * @notice Permanently burn a token that the caller owns or is approved for.\n     * @param xxyyzz The token to burn.\n     * @param onlyFinalized If true, only tokens that have been finalized can be burned. Useful if an approved operator\n     *                      is burning tokens on behalf of a user.\n     */\n    function burn(uint256 xxyyzz, bool onlyFinalized) public {\n        // cannot overflow as there are at most 2^24 tokens, and _numBurned is a uint32\n        unchecked {\n            _numBurned += 1;\n        }\n        if (onlyFinalized) {\n            if (!_isFinalized(xxyyzz)) {\n                revert OnlyFinalized();\n            }\n        }\n        _burn(msg.sender, xxyyzz);\n    }\n\n    /**\n     * @notice Permanently burn multiple tokens. All must be owned by the same address.\n     * @param ids The tokens to burn.\n     * @param onlyFinalized If true, only tokens that have been finalized can be burned. Useful if an approved operator\n     *                      is burning tokens on behalf of a user.\n     */\n    function batchBurn(uint256[] calldata ids, bool onlyFinalized) public {\n        if (ids.length == 0) {\n            revert NoIdsProvided();\n        }\n        uint256 packedOwnerFinalizedSlot = _packedOwnershipSlot(ids[0]);\n        address initialTokenOwner = address(uint160(packedOwnerFinalizedSlot));\n        if (onlyFinalized) {\n            if (packedOwnerFinalizedSlot < type(uint160).max) {\n                revert OnlyFinalized();\n            }\n        }\n        // validate that msg.sender has approval to burn all tokens\n        if (initialTokenOwner != msg.sender) {\n            if (!isApprovedForAll(initialTokenOwner, msg.sender)) {\n                revert BatchBurnerNotApprovedForAll();\n            }\n        }\n        // safe because there are at most 2^24 tokens, and ownerships are checked\n        unchecked {\n            _numBurned += uint32(ids.length);\n        }\n        _burn(ids[0]);\n        for (uint256 i = 1; i < ids.length;) {\n            uint256 id = ids[i];\n            packedOwnerFinalizedSlot = _packedOwnershipSlot(id);\n            address owner = address(uint160(packedOwnerFinalizedSlot));\n            // ensure that all tokens are owned by the same address\n            if (owner != initialTokenOwner) {\n                revert OwnerMismatch();\n            }\n            if (onlyFinalized) {\n                if (packedOwnerFinalizedSlot < type(uint160).max) {\n                    revert OnlyFinalized();\n                }\n            }\n            // no need to specify msg.sender since caller is approved for all tokens\n            // this also checks token exists\n            _burn(id);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "lib/xxyyzz/src/XXYYZZSeaDrop.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {XXYYZZMint} from \"./XXYYZZMint.sol\";\nimport {ISeaDrop, PublicDrop} from \"./lib/SeaDropSpecific.sol\";\n\nabstract contract XXYYZZSeaDrop is XXYYZZMint {\n    error OnlySeadrop();\n\n    address immutable SEADROP;\n    address immutable CREATOR_PAYOUT;\n    uint256 immutable DEPLOYED_TIME;\n\n    uint256 private constant SEADROP_TOKEN_CREATED_EVENT_TOPIC =\n        0xd7aca75208b9be5ffc04c6a01922020ffd62b55e68e502e317f5344960279af8;\n    address private constant SEADROP_FEE_RECIPIENT = 0x0000a26b00c1F0DF003000390027140000fAa719;\n    address private constant SEADROP_ALLOWED_PAYER_1 = 0xf408Bee3443D0397e2c1cdE588Fb060AC657006F;\n    address private constant SEADROP_ALLOWED_PAYER_2 = 0xE3d3D0eD702504e19825f44BC6542Ff2ec45cB9A;\n    uint256 private constant INONFUNGIBLESEADROP_INTERFACE_ID = 0x1890fe8e;\n\n    constructor(address seadrop, address creatorPayout, address initialOwner, uint256 maxBatchSize)\n        XXYYZZMint(initialOwner, maxBatchSize)\n    {\n        SEADROP = seadrop;\n        DEPLOYED_TIME = block.timestamp;\n        CREATOR_PAYOUT = creatorPayout;\n\n        // log without adding event to abi\n        assembly {\n            log1(0, 0, SEADROP_TOKEN_CREATED_EVENT_TOPIC)\n        }\n    }\n\n    /**\n     * @notice Configure the SeaDrop contract. onlyOwner.\n     * @dev SeaDrop calls supportsInterface, so this unfortunately can't live in the constructor.\n     */\n    function configureSeaDrop() external onlyOwner {\n        ISeaDrop seadrop = ISeaDrop(SEADROP);\n        seadrop.updatePublicDrop(\n            PublicDrop({\n                mintPrice: uint80(0.005 ether),\n                startTime: uint48(DEPLOYED_TIME),\n                endTime: uint48(MAX_MINT_CLOSE_TIMESTAMP),\n                maxTotalMintableByWallet: type(uint16).max,\n                feeBps: uint16(1000),\n                restrictFeeRecipients: true\n            })\n        );\n        seadrop.updateCreatorPayoutAddress(CREATOR_PAYOUT);\n        seadrop.updateAllowedFeeRecipient(SEADROP_FEE_RECIPIENT, true);\n        seadrop.updatePayer(SEADROP_ALLOWED_PAYER_1, true);\n        seadrop.updatePayer(SEADROP_ALLOWED_PAYER_2, true);\n    }\n\n    function mintSeaDrop(address recipient, uint256 quantity) external {\n        if (msg.sender != SEADROP) {\n            revert OnlySeadrop();\n        }\n        // increment supply before minting\n        uint128 newAmount;\n        // this can be unchecked because an ID can only be minted once, and all IDs are later validated to be uint24s\n        unchecked {\n            newAmount = _numMinted + uint128(quantity);\n        }\n        _numMinted = newAmount;\n        _mintTo(recipient, quantity, newAmount);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}. Overridden to support SeaDrop.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool result) {\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f. ERC4906: 0x49064906\n            result :=\n                or(\n                    or(or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f)), eq(s, 0x49064906)),\n                    eq(s, INONFUNGIBLESEADROP_INTERFACE_ID)\n                )\n        }\n    }\n\n    /**\n     * @dev Hard-coded for SeaDrop support\n     */\n    function getMintStats(address) external view returns (uint256, uint256, uint256) {\n        return (0, _numMinted, 16777216);\n    }\n\n    /**\n     * @dev Hard-coded for SeaDrop support\n     */\n    function maxSupply() external pure returns (uint256) {\n        return 16777216;\n    }\n}\n"
    },
    "lib/xxyyzz/src/XXYYZZCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {ERC721} from \"solady/tokens/ERC721.sol\";\nimport {CommitReveal} from \"./lib/CommitReveal.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {IERC4906, IERC165} from \"./interfaces/IERC4906.sol\";\n\n/**\n * @title XXYYZZCore\n * @author emo.eth\n * @notice Core contract for XXYYZZ NFTs. Contains errors, constants, core token information, and helper functions.\n */\nabstract contract XXYYZZCore is ERC721, IERC4906, CommitReveal, Ownable {\n    error InvalidPayment();\n    error InvalidHex();\n    error MaximumSupplyExceeded();\n    error AlreadyFinalized();\n    error OnlyTokenOwner();\n    error NoIdsProvided();\n    error OwnerMismatch();\n    error BatchBurnerNotApprovedForAll();\n    error ArrayLengthMismatch();\n    error MintClosed();\n    error InvalidTimestamp();\n    error OnlyFinalized();\n    error Unavailable();\n    error NoneAvailable();\n    error MaxBatchSizeExceeded();\n\n    uint256 public constant MINT_PRICE = 0.005 ether;\n    uint256 public constant REROLL_PRICE = 0.00025 ether;\n    uint256 public constant FINALIZE_PRICE = 0.005 ether;\n    uint256 public constant REROLL_AND_FINALIZE_PRICE = 0.00525 ether;\n    uint256 public immutable MAX_SPECIFIC_BATCH_SIZE;\n\n    uint256 constant BYTES3_UINT_SHIFT = 232;\n    uint256 constant MAX_UINT24 = 0xFFFFFF;\n    uint96 constant FINALIZED = 1;\n    uint96 constant NOT_FINALIZED = 0;\n\n    // re-declared from solady ERC721 for custom gas optimizations\n    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;\n\n    mapping(uint256 tokenId => address finalizer) public finalizers;\n    uint128 _numBurned;\n    uint128 _numMinted;\n\n    constructor(address initialOwner, uint256 maxBatchSize)\n        // lifespan\n        CommitReveal(\n            1 days,\n            // delay – MM/RPC will report a tx will revert until first eligible block is validated,\n            // so 48 seconds will result in 60 seconds of delay before the frontend will report\n            // that a tx will succeed\n            48 seconds\n        )\n    {\n        _initializeOwner(initialOwner);\n        MAX_SPECIFIC_BATCH_SIZE = maxBatchSize;\n    }\n\n    receive() external payable {\n        // send ether – see what happens! :)\n    }\n\n    ///////////////////\n    // OWNER METHODS //\n    ///////////////////\n\n    /**\n     * @notice Withdraws all funds from the contract to the current owner. onlyOwner.\n     */\n    function withdraw() public onlyOwner {\n        assembly (\"memory-safe\") {\n            let succ := call(gas(), caller(), selfbalance(), 0, 0, 0, 0)\n            // revert with returndata if call failed\n            if iszero(succ) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    ///////////////////\n    // INFORMATIONAL //\n    ///////////////////\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     */\n    function totalSupply() public view returns (uint256) {\n        return _numMinted - _numBurned;\n    }\n\n    /**\n     * @notice Get the total number of tokens minted\n     */\n    function numMinted() external view returns (uint256) {\n        return _numMinted;\n    }\n\n    /**\n     * @notice Get the total number of tokens burned\n     */\n    function numBurned() external view returns (uint256) {\n        return _numBurned;\n    }\n\n    /**\n     * @notice Get the name of the token\n     */\n    function name() public pure override returns (string memory) {\n        // note that this is unsafe to call internally, as it abi-encodes the name and\n        // performs a low-level return\n        assembly {\n            mstore(0x20, 0x20)\n            mstore(0x46, 0x06585859595a5a)\n            return(0x20, 0x80)\n        }\n    }\n\n    /**\n     * @notice Get the symbol of the token\n     */\n    function symbol() public pure override returns (string memory) {\n        // note that this is unsafe to call internally, as it abi-encodes the symbol and\n        // performs a low-level return\n        assembly {\n            mstore(0x20, 0x20)\n            mstore(0x46, 0x06585859595a5a)\n            return(0x20, 0x80)\n        }\n    }\n\n    /**\n     * @notice Check if a specific token ID has been finalized. Will return true for tokens that were finalized and\n     *         then burned. Will not revert if the tokenID does not currently exist. Will revert on invalid tokenIds.\n     * @param id The token ID to check\n     * @return True if the token ID has been finalized, false otherwise\n     */\n    function isFinalized(uint256 id) public view returns (bool) {\n        _validateId(id);\n        return _isFinalized(id);\n    }\n\n    ///@inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        override(ERC721, IERC165)\n        returns (bool result)\n    {\n        assembly {\n            let s := shr(224, interfaceId)\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f. ERC4906: 0x49064906\n            result := or(or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f)), eq(s, 0x49064906))\n        }\n    }\n\n    /////////////////\n    // COMMITMENTS //\n    /////////////////\n\n    /**\n     * @notice Get a commitment hash for a given sender, tokenId, and salt. Note that this could expose your desired\n     *         ID to the RPC provider. Won't revert if the ID is invalid, but will return an invalid hash.\n     * @param sender The address of the account that will mint or reroll the token ID\n     * @param id The 6-hex-digit token ID to mint or reroll\n     * @param salt The salt to use for the commitment\n     */\n    function computeCommitment(address sender, uint256 id, bytes32 salt)\n        public\n        pure\n        returns (bytes32 committmentHash)\n    {\n        assembly (\"memory-safe\") {\n            // shift sender left by 24 bits; id stays in bottom 24\n            mstore(0, or(shl(24, sender), and(id, MAX_UINT24)))\n            mstore(0x20, salt)\n            // start hashing at 0x09 to skip 9 empty bytes (32 - (20 + 3))\n            committmentHash := keccak256(0x09, 0x40)\n        }\n    }\n\n    /**\n     * @notice Get a commitment hash for a given sender, array of tokenIds, and salt. This allows for a single\n     *         commitment for a batch of IDs, but note that order and length of IDs matters.\n     *         If 5 IDs are passed, all 5 must be passed to either batchMintSpecific or batchRerollSpecific, in the\n     *         same order. Note that this could expose your desired IDs to the RPC provider.\n     *         Won't revert if any IDs are invalid or duplicated.\n     * @param sender The address of the account that will mint or reroll the token IDs\n     * @param ids The 6-hex-digit token IDs to mint or reroll\n     * @param salt The salt to use for the batch commitment\n     */\n    function computeBatchCommitment(address sender, uint256[] calldata ids, bytes32 salt)\n        public\n        pure\n        returns (bytes32 commitmentHash)\n    {\n        assembly (\"memory-safe\") {\n            // cache free mem pointer\n            let freeMemPtr := mload(0x40)\n            // multiply length of elements by 32 bytes for each element\n            let numBytes := shl(5, ids.length)\n            // copy contents of array to unallocated free memory\n            calldatacopy(freeMemPtr, ids.offset, numBytes)\n            // hash contents of array, without length\n            let arrayHash :=\n                keccak256(\n                    // start of array contents\n                    freeMemPtr,\n                    //length of array contents\n                    numBytes\n                )\n\n            // store sender in first memory slot\n            mstore(0, sender)\n            // store array hash in second memory slot\n            mstore(0x20, arrayHash)\n            // clobber free memory pointer with salt\n            mstore(0x40, salt)\n            // compute commitment hash\n            // start hashing at 12 bytes since addresses are 20 bytes\n            commitmentHash := keccak256(0x0c, 0x60)\n            // restore free memory pointer\n            mstore(0x40, freeMemPtr)\n        }\n    }\n\n    /////////////\n    // HELPERS //\n    /////////////\n\n    /**\n     * @dev Mint a token with a specific hex value and validate it was committed to\n     * @param id The 6-hex-digit token ID to mint\n     * @param salt The salt to use for the commitment\n     */\n    function _mintSpecific(uint256 id, bytes32 salt) internal {\n        bytes32 computedCommitment = computeCommitment(msg.sender, id, salt);\n\n        // validate ID is valid 6-hex-digit number\n        _validateId(id);\n        // validate commitment to prevent front-running\n        _assertCommittedReveal(computedCommitment);\n\n        // don't allow minting of tokens that were finalized and then burned\n        if (_isFinalized(id)) {\n            revert AlreadyFinalized();\n        }\n        _mint(msg.sender, id);\n    }\n\n    /**\n     * @dev Mint a token with a specific hex value and validate it was committed to\n     * @param id The 6-hex-digit token ID to mint\n     * @param computedCommitment The commitment hash to validate\n     */\n    function _mintSpecificWithCommitment(uint256 id, bytes32 computedCommitment) internal {\n        // validate ID is valid 6-hex-digit number\n        _validateId(id);\n        // validate commitment to prevent front-running\n        _assertCommittedReveal(computedCommitment);\n\n        // don't allow minting of tokens that were finalized and then burned\n        if (_packedOwnershipSlot(id) != 0) {\n            revert AlreadyFinalized();\n        }\n        _mint(msg.sender, id);\n    }\n\n    /**\n     * @dev Mint a token with a specific hex value without validating it was committed to\n     * @param id The 6-hex-digit token ID to mint\n     * @return True if the token was minted, false otherwise\n     */\n    function _mintSpecificUnprotected(uint256 id) internal returns (bool) {\n        // validate ID is valid 6-hex-digit number\n        _validateId(id);\n        // don't allow minting of tokens that exist or were finalized and then burned\n        if (_packedOwnershipSlot(id) != 0) {\n            // return false indicating a no-op\n            return false;\n        }\n        // otherwise mint the token\n        _mint(msg.sender, id);\n        return true;\n    }\n\n    /**\n     * @dev Find the first unminted token ID based on the current number minted and PREVRANDAO\n     * @param seed The seed to use for the random number generation – when minting, should be _numMinted, when\n     *             re-rolling, should be a function of the caller. In the case of re-rolling, this means that if a single caller makes\n     *             multiple re-rolls in the same block, there will be collisions. This is fine, as the extra gas  cost\n     *             discourages batch re-rolling with bots or scripts (at least from the same address).\n     */\n    function _findAvailableHex(uint256 seed) internal view returns (uint256) {\n        uint256 tokenId;\n        assembly {\n            mstore(0, seed)\n            mstore(0x20, prevrandao())\n            // hash the two values together and then mask to a uint24\n            // seed is max an address, so start hashing at 0x0c\n            tokenId := and(keccak256(0x0c, 0x40), MAX_UINT24)\n        }\n        // check for the small chance that the token ID is already minted or finalized – if so, increment until we\n        // find one that isn't\n        while (_packedOwnershipSlot(tokenId) != 0) {\n            // safe to do unchecked math here as it is modulo 2^24\n            unchecked {\n                tokenId = (tokenId + 1) & MAX_UINT24;\n            }\n        }\n        return tokenId;\n    }\n\n    ///@dev Check if an ID is a valid six-hex-digit number\n    function _validateId(uint256 xxyyzz) internal pure {\n        if (xxyyzz > MAX_UINT24) {\n            revert InvalidHex();\n        }\n    }\n\n    ///@dev Validate msg value is equal to total price\n    function _validatePayment(uint256 unitPrice, uint256 quantity) internal view {\n        // can't overflow because there are at most uint24 tokens, and existence is checked for each token down the line\n        unchecked {\n            if (msg.value != (unitPrice * quantity)) {\n                revert InvalidPayment();\n            }\n        }\n    }\n\n    /**\n     * @dev Refund any overpayment\n     * @param unitPrice The price per action (mint, reroll, reroll+finalize)\n     * @param availableQuantity The number of tokens (mints, rerolls) that were actually available for purchase\n     */\n    function _refundOverpayment(uint256 unitPrice, uint256 availableQuantity) internal {\n        unchecked {\n            // can't underflow because payment was already validated; even if it did, value would be larger than ether\n            // supply\n            uint256 overpayment = msg.value - (unitPrice * availableQuantity);\n            if (overpayment != 0) {\n                SafeTransferLib.safeTransferETH(msg.sender, overpayment);\n            }\n        }\n    }\n\n    /**\n     * @dev Check if a specific token has been finalized. Does not check if token exists.\n     * @param id The 6-hex-digit token ID to check\n     */\n    function _isFinalized(uint256 id) internal view returns (bool) {\n        return _getExtraData(id) == FINALIZED;\n    }\n\n    /**\n     * @dev Load the raw ownership slot for a given token ID, which contains both the owner and the extra data\n     *      (finalization status). This allows for succint checking of whether or not a token is mintable,\n     *      i.e., whether it does not currently exist and has not been finalized. It also allows for avoiding\n     *      an extra SLOAD in cases when checking both owner/existence and finalization status.\n     * @param id The 6-hex-digit token ID to check\n     */\n    function _packedOwnershipSlot(uint256 id) internal view returns (uint256 result) {\n        assembly {\n            // since all ids are < uint24, this basically just clears the 0-slot before writing 4 bytes of slot seed\n            mstore(0x00, id)\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\n            result := sload(add(id, add(id, keccak256(0x00, 0x20))))\n        }\n    }\n\n    function _checkCallerIsOwnerAndNotFinalized(uint256 id) internal view {\n        uint256 packedSlot = _packedOwnershipSlot(id);\n        // clean and cast to address\n        address owner = address(uint160(packedSlot));\n        if ((packedSlot) > type(uint160).max) {\n            revert AlreadyFinalized();\n        }\n        // check that caller is owner\n        if (owner != msg.sender) {\n            revert OnlyTokenOwner();\n        }\n    }\n\n    /**\n     * @dev Check that array lengths match, the batch size is not too large, and that the payment is correct\n     * @param a The first array to check\n     * @param b The second array to check\n     * @param unitPrice The price per action (mint, reroll, reroll+finalize)\n     */\n    function _validateRerollBatchAndPayment(uint256[] calldata a, uint256[] calldata b, uint256 unitPrice)\n        internal\n        view\n    {\n        if (a.length != b.length) {\n            revert ArrayLengthMismatch();\n        }\n        if (a.length > MAX_SPECIFIC_BATCH_SIZE) {\n            revert MaxBatchSizeExceeded();\n        }\n        _validatePayment(a.length, unitPrice);\n    }\n}\n"
    },
    "lib/xxyyzz/src/XXYYZZRerollFinalize.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {XXYYZZCore} from \"./XXYYZZCore.sol\";\n\n/**\n * @title XXYYZZRerollFinalize\n * @author emo.eth\n * @notice This contract handles \"rerolling\" and \"finalizing\" tokens.\n *         Rerolling allows users to burn a token they own in exchange for a new one. The new token may be either\n *         pseudorandom, or a specific color when using one of the \"Specific\" methods.\n *         Finalizing allows users to prevent a token from being rerolled again, in addition to adding their\n *         wallet address to the token's metadata as the \"Finalizer\" trait.\n */\nabstract contract XXYYZZRerollFinalize is XXYYZZCore {\n    ////////////\n    // REROLL //\n    ////////////\n    /**\n     * @notice Burn a token you own and mint a new one with a pseudorandom hex value.\n     * @param oldId The 6-hex-digit token ID to burn\n     * @return The new token ID\n     */\n    function reroll(uint256 oldId) public payable returns (uint256) {\n        _validatePayment(REROLL_PRICE, 1);\n        // use the caller as the seed to derive the new token ID\n        // this means multiple calls in the same block will be gas-inefficient\n        // which may somewhat discourage botting\n        return _rerollWithSeed(oldId, uint160(msg.sender));\n    }\n\n    /**\n     * @notice Burn a number of tokens you own and mint new ones with pseudorandom hex values.\n     * @param ids The 6-hex-digit token IDs to burn in exchange for new tokens\n     * @return The new token IDs\n     */\n    function batchReroll(uint256[] calldata ids) public payable returns (uint256[] memory) {\n        _validatePayment(REROLL_PRICE, ids.length);\n        // use the caller as the seed to derive the new token IDs\n        // this means multiple calls in the same block will be gas-inefficient\n        // which may somewhat discourage botting\n        uint256 seed = uint256(uint160(msg.sender));\n        uint256[] memory newIds = new uint256[](ids.length);\n        for (uint256 i; i < ids.length;) {\n            newIds[i] = _rerollWithSeed(ids[i], seed);\n            unchecked {\n                ++i;\n                ++seed;\n            }\n        }\n        return newIds;\n    }\n\n    /**\n     * @notice Burn and re-mint a token with a specific hex ID. Uses a commit-reveal scheme to prevent front-running.\n     *         Only callable by the owner of the token. Users must call `commit(bytes32)` with the result of\n     *         `computeCommitment(address,uint256,bytes32)` and wait at least COMMITMENT_LIFESPAN seconds before\n     *         calling `rerollSpecific`.\n     * @param oldId The 6-hex-digit token ID to burn\n     * @param newId The 6-hex-digit token ID to mint\n     * @param salt The salt used in the commitment for the new ID commitment\n     */\n    function rerollSpecific(uint256 oldId, uint256 newId, bytes32 salt) public payable {\n        _validatePayment(REROLL_PRICE, 1);\n        _rerollSpecificWithSalt(oldId, newId, salt);\n    }\n\n    /**\n     * @notice Burn and re-mint a number of tokens with specific hex values. Uses a commit-reveal scheme to prevent\n     *         front-running. Only callable by the owner of the tokens. Users must call `commit(bytes32)` with the\n     *         result of `computeBatchCommitment(address,uint256[],bytes32)` and wait at least COMMITMENT_LIFESPAN\n     *         seconds before calling `batchRerollSpecific`.\n     * @param oldIds The 6-hex-digit token IDs to burn\n     * @param newIds The 6-hex-digit token IDs to mint\n     * @param salt The salt used in the commitment for the new IDs commitment\n     * @return An array of booleans indicating whether each token was successfully rerolled\n     */\n    function batchRerollSpecific(uint256[] calldata oldIds, uint256[] calldata newIds, bytes32 salt)\n        public\n        payable\n        returns (bool[] memory)\n    {\n        _validateRerollBatchAndPayment(oldIds, newIds, REROLL_PRICE);\n        bytes32 computedCommitment = computeBatchCommitment(msg.sender, newIds, salt);\n        _assertCommittedReveal(computedCommitment);\n\n        return _batchRerollAndRefund(oldIds, newIds);\n    }\n\n    /**\n     * @notice Burn and re-mint a token with a specific hex ID, then finalize it. Uses a commit-reveal scheme to\n     *         prevent front-running. Only callable by the owner of the token. Users must call `commit(bytes32)`\n     *         with the result of `computeCommitment(address,uint256,bytes32)` and wait at least COMMITMENT_LIFESPAN\n     *         seconds before calling `rerollSpecificAndFinalize`.\n     * @param oldId The 6-hex-digit token ID to burn\n     * @param newId The 6-hex-digit token ID to mint\n     * @param salt The salt used in the commitment for the new ID commitment\n     */\n    function rerollSpecificAndFinalize(uint256 oldId, uint256 newId, bytes32 salt) public payable {\n        _validatePayment(REROLL_AND_FINALIZE_PRICE, 1);\n\n        _rerollSpecificWithSalt(oldId, newId, salt);\n        // won't re-validate price, but above function already did\n        _finalizeToken(newId, msg.sender);\n    }\n\n    /**\n     * @notice Burn and re-mint a number of tokens with specific hex values, then finalize them.\n     * @param oldIds The 6-hex-digit token IDs to burn\n     * @param newIds The 6-hex-digit token IDs to mint\n     * @param salt The salt used in the batch commitment for the new ID commitment\n     * @return An array of booleans indicating whether each token was successfully rerolled\n     */\n    function batchRerollSpecificAndFinalize(uint256[] calldata oldIds, uint256[] calldata newIds, bytes32 salt)\n        public\n        payable\n        returns (bool[] memory)\n    {\n        _validateRerollBatchAndPayment(oldIds, newIds, REROLL_AND_FINALIZE_PRICE);\n        bytes32 computedCommitment = computeBatchCommitment(msg.sender, newIds, salt);\n        _assertCommittedReveal(computedCommitment);\n        return _batchRerollAndFinalizeAndRefund(oldIds, newIds);\n    }\n\n    //////////////\n    // FINALIZE //\n    //////////////\n\n    /**\n     * @notice Finalize a token, which updates its metadata with a \"Finalizer\" trait and prevents it from being\n     *         rerolled in the future.\n     * @param id The 6-hex-digit token ID to finalize. Must be owned by the caller.\n     */\n    function finalize(uint256 id) public payable {\n        _validatePayment(FINALIZE_PRICE, 1);\n        _finalize(id);\n    }\n\n    /**\n     * @notice Finalize a number of tokens, which updates their metadata with a \"Finalizer\" trait and prevents them\n     *         from being rerolled in the future. The caller must pay the finalization price for each token, and must\n     *         own all tokens.\n     * @param ids The 6-hex-digit token IDs to finalize\n     */\n    function batchFinalize(uint256[] calldata ids) public payable {\n        _validatePayment(FINALIZE_PRICE, ids.length);\n        for (uint256 i; i < ids.length;) {\n            _finalize(ids[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    //////////////\n    // INTERNAL //\n    //////////////\n\n    /**\n     * @dev Internal function to burn and re-mint tokens with a specific hex ID. Does not check initial payment.\n     *      Does refund any overpayment.\n     * @param oldIds The 6-hex-digit token IDs to burn\n     * @param newIds The 6-hex-digit token IDs to mint\n     * @return An array of booleans indicating whether each token was successfully rerolled\n     */\n    function _batchRerollAndRefund(uint256[] calldata oldIds, uint256[] calldata newIds)\n        internal\n        returns (bool[] memory)\n    {\n        bool[] memory rerolled = new bool[](oldIds.length);\n        uint256 quantityRerolled;\n        for (uint256 i; i < oldIds.length;) {\n            if (_rerollSpecificUnprotected(oldIds[i], newIds[i])) {\n                rerolled[i] = true;\n                unchecked {\n                    ++quantityRerolled;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // if none were rerolled, revert to avoid wasting further gas\n        if (quantityRerolled == 0) {\n            revert NoneAvailable();\n        }\n        // refund any overpayment\n        _refundOverpayment(REROLL_PRICE, quantityRerolled);\n\n        return rerolled;\n    }\n\n    /**\n     * @dev Internal function to burn and re-mint tokens with a specific hex ID, then finalize them. Does not check\n     *     initial payment. Does refund any overpayment.\n     * @param oldIds The 6-hex-digit token IDs to burn\n     * @param newIds The 6-hex-digit token IDs to mint\n     * @return An array of booleans indicating whether each token was successfully rerolled\n     */\n    function _batchRerollAndFinalizeAndRefund(uint256[] calldata oldIds, uint256[] calldata newIds)\n        internal\n        returns (bool[] memory)\n    {\n        bool[] memory rerolled = new bool[](oldIds.length);\n        uint256 quantityRerolled;\n        for (uint256 i; i < oldIds.length;) {\n            if (_rerollSpecificUnprotected(oldIds[i], newIds[i])) {\n                _finalizeToken(newIds[i], msg.sender);\n                rerolled[i] = true;\n                unchecked {\n                    ++quantityRerolled;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        // if none were rerolled, revert to avoid wasting gas\n        if (quantityRerolled == 0) {\n            revert NoneAvailable();\n        }\n        // refund any overpayment\n        _refundOverpayment(REROLL_AND_FINALIZE_PRICE, quantityRerolled);\n\n        return rerolled;\n    }\n\n    /**\n     * @dev Validate an old tokenId is rerollable, burn it, then mint a token with a pseudorandom\n     *      hex ID.\n     * @param oldId The old ID to reroll\n     * @param seed The seed to use for the reroll\n     *\n     */\n    function _rerollWithSeed(uint256 oldId, uint256 seed) internal returns (uint256) {\n        _checkCallerIsOwnerAndNotFinalized(oldId);\n        // burn old token\n        _burn(oldId);\n        uint256 tokenId = _findAvailableHex(seed);\n        _mint(msg.sender, tokenId);\n        return tokenId;\n    }\n\n    /**\n     * @dev Validate an old tokenId is rerollable, burn it, then mint a token with a specific\n     *     hex ID, validating that the commit-reveal scheme was followed.\n     * @param oldId The old ID to reroll\n     * @param newId The new ID to mint\n     * @param salt The salt used in the commit-reveal scheme\n     */\n    function _rerollSpecificWithSalt(uint256 oldId, uint256 newId, bytes32 salt) internal {\n        _checkCallerIsOwnerAndNotFinalized(oldId);\n        // burn old token\n        _burn(oldId);\n        _mintSpecific(newId, salt);\n    }\n\n    /**\n     * @dev Validate an old tokenId is rerollable, mint a token with a specific new hex ID (if available)\n     *      and burn the old token.\n     * @param oldId The old ID to reroll\n     * @param newId The new ID to mint\n     * @return Whether the mint succeeded, ie, the new ID was available\n     */\n    function _rerollSpecificUnprotected(uint256 oldId, uint256 newId) internal returns (bool) {\n        _checkCallerIsOwnerAndNotFinalized(oldId);\n        // only burn old token if mint succeeded\n        if (_mintSpecificUnprotected(newId)) {\n            _burn(oldId);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Internal function to finalize a token, first checking that the caller is the owner and that the token\n     *      has not already been finalized.\n     * @param id The 6-hex-digit token ID to finalize\n     */\n    function _finalize(uint256 id) internal {\n        _checkCallerIsOwnerAndNotFinalized(id);\n        // set finalized flag\n        _finalizeToken(id, msg.sender);\n        // emit onchain metadata update event\n        emit MetadataUpdate(id);\n    }\n\n    /**\n     * @dev Finalize a tokenId, updating its metadata with a \"Finalizer\" trait, and preventing it from being rerolled in the future.\n     * @param id The 6-hex-digit token ID to finalize\n     * @param finalizer The address of the account finalizing the token\n     */\n    function _finalizeToken(uint256 id, address finalizer) internal {\n        finalizers[id] = finalizer;\n        _setExtraData(id, 1);\n    }\n}\n"
    },
    "lib/forge-std/src/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "lib/xxyyzz/src/XXYYZZMint.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {XXYYZZCore} from \"./XXYYZZCore.sol\";\n\n/**\n * @title XXYYZZMint\n * @author emo.eth\n * @notice This contract handles minting of XXYYZZ tokens.\n *         Tokens may be minted with a pseudorandom hex value, or with a specific hex value.\n *         The \"Specific\" methods allow for minting tokens with specific hex values with a commit-reveal scheme.\n *         Users may protect themselves against front-running by\n */\nabstract contract XXYYZZMint is XXYYZZCore {\n    uint256 public immutable MAX_MINT_CLOSE_TIMESTAMP;\n\n    constructor(address initialOwner, uint256 maxBatchSize) XXYYZZCore(initialOwner, maxBatchSize) {\n        MAX_MINT_CLOSE_TIMESTAMP = block.timestamp + 14 days;\n    }\n\n    //////////\n    // MINT //\n    //////////\n\n    /**\n     * @notice Mint a token with a pseudorandom hex value.\n     * @return The token ID\n     */\n    function mint() public payable returns (uint256) {\n        uint256 newAmount = _checkMintAndIncrementNumMinted(1);\n        // get pseudorandom hex id – doesn't need to be derived from caller\n        uint256 tokenId = _findAvailableHex(newAmount);\n        _mint(msg.sender, tokenId);\n        return tokenId;\n    }\n\n    /**\n     * @notice Mint a number of tokens with pseudorandom hex values.\n     * @param quantity The number of tokens to mint\n     * @return The token IDs\n     */\n    function mint(uint256 quantity) public payable returns (uint256[] memory) {\n        return _checkMintTo(msg.sender, quantity);\n    }\n\n    function mintTo(address to, uint256 quantity) public payable returns (uint256[] memory) {\n        return _checkMintTo(to, quantity);\n    }\n\n    /**\n     * @notice Mint a token with a specific hex value.\n     *         A user must first call commit(bytes32) or batchCommit(bytes32[]) with the result(s) of\n     *         computeCommittment(address,uint256,bytes32), and wait at least one minute.\n     *         When calling mintSpecific, the \"salt\" should be the bytes32 salt provided to `computeCommitment` when\n     *         creating the commitment hash.\n     *\n     *         Example: To register 0x123456 with salt bytes32(0xDEADBEEF)\n     *             1. Call `computeCommitment(<minting addr>, 0x123456, bytes32(0xDEADBEEF))` for `bytes32 result`\n     *             2. Call `commit(result)`\n     *             3. Wait at least 1 minute, but less than 1 day\n     *             4. Call `mintSpecific(0x123456, bytes32(0xDEADBEEF))`\n     * @param id The 6-hex-digit token ID to mint\n     * @param salt The salt used in the commitment for the commitment\n     */\n    function mintSpecific(uint256 id, bytes32 salt) public payable {\n        _checkMintAndIncrementNumMinted(1);\n        _mintSpecific(id, salt);\n    }\n\n    /**\n     * @notice Mint a number of tokens with specific hex values.\n     *         A user must first call commit(bytes32) with the result of\n     *         `computeBatchCommitment(address,uint256[],bytes32)`, and wait at least COMMITMENT_LIFESPAN seconds.\n     * @param ids The 6-hex-digit token IDs to mint\n     * @param salt The salt used in the batch commitment\n     * @return An array of booleans indicating whether each token was minted\n     */\n    function batchMintSpecific(uint256[] calldata ids, bytes32 salt) public payable returns (bool[] memory) {\n        _validateBatchMintAndTimestamp(ids);\n        bytes32 computedCommitment = computeBatchCommitment(msg.sender, ids, salt);\n        _assertCommittedReveal(computedCommitment);\n        return _batchMintAndIncrementAndRefund(ids);\n    }\n\n    /////////////\n    // HELPERS //\n    /////////////\n\n    /**\n     * @dev Mint tokens, validate that tokens were minted, and increment the number of minted tokens\n     * @param to Recipient of the tokens\n     * @param quantity Number of tokens to mint\n     */\n    function _checkMintTo(address to, uint256 quantity) internal returns (uint256[] memory) {\n        // check payment and quantity once\n        uint256 newAmount = _checkMintAndIncrementNumMinted(quantity);\n        return _mintTo(to, quantity, newAmount);\n    }\n\n    /**\n     * @dev Mint tokens, validate that tokens were minted, and increment the number of minted tokens\n     * @param to Recipient of the tokens\n     * @param quantity Number of tokens to mint\n     */\n    function _mintTo(address to, uint256 quantity, uint256 newAmount) internal returns (uint256[] memory) {\n        uint256[] memory tokenIds = new uint256[](quantity);\n        for (uint256 i; i < quantity;) {\n            // get pseudorandom hex id\n            uint256 tokenId = _findAvailableHex(newAmount);\n            _mint(to, tokenId);\n            tokenIds[i] = tokenId;\n            unchecked {\n                ++i;\n                ++newAmount;\n            }\n        }\n        return tokenIds;\n    }\n\n    /**\n     * @dev Mint tokens, validate that tokens were minted, increment the number of minted tokens, and refund any\n     *      overpayment\n     * @param ids The 6-hex-digit token IDs to mint\n     */\n    function _batchMintAndIncrementAndRefund(uint256[] calldata ids) internal returns (bool[] memory) {\n        bool[] memory minted = new bool[](ids.length);\n        uint256 quantityMinted;\n        for (uint256 i; i < ids.length;) {\n            if (_mintSpecificUnprotected(ids[i])) {\n                minted[i] = true;\n                unchecked {\n                    ++quantityMinted;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        if (quantityMinted == 0) {\n            revert NoneAvailable();\n        }\n\n        _incrementNumMintedAndRefundOverpayment(quantityMinted);\n        return minted;\n    }\n\n    /**\n     * @dev Check payment and quantity validation – quantityRequested for payment, quantityAvailable for updating\n     *      the number of minted tokens, which may be different\n     * @param quantityRequested The number of tokens requested by the user, which must be paid for\n     * @return The new number of minted tokens\n     */\n    function _checkMintAndIncrementNumMinted(uint256 quantityRequested) internal returns (uint256) {\n        if (block.timestamp > MAX_MINT_CLOSE_TIMESTAMP) {\n            revert MintClosed();\n        }\n        _validatePayment(MINT_PRICE, quantityRequested);\n\n        // increment supply before minting\n        uint128 newAmount;\n        // this can be unchecked because an ID can only be minted once, and all IDs are later validated to be uint24s\n        unchecked {\n            newAmount = _numMinted + uint128(quantityRequested);\n        }\n        _numMinted = newAmount;\n        return newAmount;\n    }\n\n    /**\n     * @dev Increment the number of minted tokens and refund any overpayment\n     * @param quantity The number of tokens actually minted\n     */\n    function _incrementNumMintedAndRefundOverpayment(uint256 quantity) internal returns (uint256) {\n        uint256 newAmount;\n        // this can be unchecked because an ID can only be minted once, and all IDs are validated to be uint24s\n        // overflow here implies invalid IDs down the line, which will cause a revert when minting\n        unchecked {\n            newAmount = _numMinted + quantity;\n        }\n        _numMinted = uint32(newAmount);\n        _refundOverpayment(MINT_PRICE, quantity);\n        return newAmount;\n    }\n\n    /**\n     * @dev Validate the timestamp and payment for a batch mint\n     * @param ids The 6-hex-digit token IDs to mint\n     */\n    function _validateBatchMintAndTimestamp(uint256[] calldata ids) internal view {\n        if (block.timestamp > MAX_MINT_CLOSE_TIMESTAMP) {\n            revert MintClosed();\n        }\n        if (ids.length > MAX_SPECIFIC_BATCH_SIZE) {\n            revert MaxBatchSizeExceeded();\n        }\n        _validatePayment(ids.length, MINT_PRICE);\n    }\n}\n"
    },
    "lib/xxyyzz/src/lib/SeaDropSpecific.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nstruct PublicDrop {\n    uint80 mintPrice; // 80/256 bits\n    uint48 startTime; // 128/256 bits\n    uint48 endTime; // 176/256 bits\n    uint16 maxTotalMintableByWallet; // 224/256 bits\n    uint16 feeBps; // 240/256 bits\n    bool restrictFeeRecipients; // 248/256 bits\n}\n\ninterface ISeaDrop {\n    /**\n     * @notice Updates the public drop data for the nft contract\n     *         and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param publicDrop The public drop data.\n     */\n    function updatePublicDrop(PublicDrop calldata publicDrop) external;\n\n    /**\n     * @notice Updates the creator payout address and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param payoutAddress The creator payout address.\n     */\n    function updateCreatorPayoutAddress(address payoutAddress) external;\n\n    /**\n     * @notice Updates the allowed fee recipient and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param feeRecipient The fee recipient.\n     * @param allowed      If the fee recipient is allowed.\n     */\n    function updateAllowedFeeRecipient(address feeRecipient, bool allowed) external;\n\n    /**\n     * @notice Updates the allowed payer and emits an event.\n     *\n     *         This method assume msg.sender is an nft contract and its\n     *         ERC165 interface id matches INonFungibleSeaDropToken.\n     *\n     *         Note: Be sure only authorized users can call this from\n     *         token contracts that implement INonFungibleSeaDropToken.\n     *\n     * @param payer   The payer to add or remove.\n     * @param allowed Whether to add or remove the payer.\n     */\n    function updatePayer(address payer, bool allowed) external;\n}\n"
    },
    "lib/xxyyzz/src/lib/CommitReveal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ncontract CommitReveal {\n    error InvalidCommitment(uint256 committedTimestamp);\n\n    uint256 private constant INVALID_COMMITMENT_SELECTOR = 0x31e63ea0;\n\n    uint256 public immutable COMMITMENT_LIFESPAN;\n    uint256 public immutable COMMITMENT_DELAY;\n\n    constructor(uint256 commitmentLifespan, uint256 commitmentDelay) {\n        COMMITMENT_LIFESPAN = commitmentLifespan;\n        COMMITMENT_DELAY = commitmentDelay;\n    }\n\n    ///@dev mapping of user to key to commitment hash to timestamp.\n    mapping(address user => mapping(bytes32 commitment => uint256 timestamp)) public commitments;\n\n    /**\n     * @notice Commit a hash to the contract, to be retrieved and verified after a delay. A commitment is valid only\n     *         after COMMITMENT_DELAY seconds have passed, and is only valid for COMMITMENT_LIFESPAN seconds.\n     * @param commitment The hash to commit.\n     */\n    function commit(bytes32 commitment) public {\n        commitments[msg.sender][commitment] = block.timestamp;\n    }\n\n    /**\n     * @dev Assert that a commitment has been made and is within a valid time\n     *      window.\n     * @param computedCommitmentHash The derived commitment hash to verify.\n     */\n    function _assertCommittedReveal(bytes32 computedCommitmentHash) internal view {\n        // retrieve the timestamp of the commitment (if it exists)\n        uint256 retrievedTimestamp = commitments[msg.sender][computedCommitmentHash];\n        // compute the time difference\n        uint256 timeDiff;\n        // unchecked; assume blockchain time is monotonically increasing\n        unchecked {\n            timeDiff = block.timestamp - retrievedTimestamp;\n        }\n        uint256 commitmentLifespan = COMMITMENT_LIFESPAN;\n        uint256 commitmentDelay = COMMITMENT_DELAY;\n        assembly {\n            // if the time difference is greater than the commitment lifespan,\n            // the commitment has expired\n            // if the time difference is less than the commitment delay, the\n            // commitment is pending\n            let invalidCommitment := or(gt(timeDiff, commitmentLifespan), lt(timeDiff, commitmentDelay))\n            if invalidCommitment {\n                mstore(0, INVALID_COMMITMENT_SELECTOR)\n                mstore(0x20, retrievedTimestamp)\n                revert(0x1c, 0x24)\n            }\n        }\n    }\n}\n"
    },
    "lib/solady/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for gas griefing protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n/// responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH\n    /// that disallows any storage writes.\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    /// Multiply by a small constant (e.g. 2), if needed.\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    /// Reverts upon failure.\n    ///\n    /// Note: This implementation does NOT protect against gas griefing.\n    /// Please use `forceSafeTransferETH` for gas griefing protection.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                if iszero(create(amount, 0x0b, 0x16)) {\n                    // For better gas estimation.\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\n                }\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\n    /// for 99% of cases and can be overridden with the three-argument version of this\n    /// function if necessary.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        // Manually inlined because the compiler doesn't inline functions with branches.\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                if iszero(create(amount, 0x0b, 0x16)) {\n                    // For better gas estimation.\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\n                }\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\n    ///\n    /// Note: Does NOT revert upon failure.\n    /// Returns whether the transfer of ETH is successful instead.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `balanceOf(address)`.\n            mstore(0x0c, 0x70a08231000000000000000000000000)\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x23b872dd)\n            // The `amount` argument is already written to the memory word at 0x60.\n            amount := mload(0x60)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x14, to) // Store the `to` argument.\n            // The `amount` argument is already written to the memory word at 0x34.\n            amount := mload(0x34)\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `approve(address,uint256)`.\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `ApproveFailed()`.\n                mstore(0x00, 0x3e3f8f73)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            // Store the function selector of `balanceOf(address)`.\n            mstore(0x00, 0x70a08231000000000000000000000000)\n            amount :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n}\n"
    },
    "lib/xxyyzz/src/interfaces/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IERC165} from \"forge-std/interfaces/IERC165.sol\";\n\ninterface IERC4906 is IERC165 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "creat2-helpers/=lib/creat2-helpers/",
      "create2-helpers/=lib/create2-helpers/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc721a/=lib/xxyyzz/lib/erc721a/contracts/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/create2-helpers/lib/openzeppelin-contracts/",
      "solady-test/=lib/solady/test/",
      "solady/=lib/solady/src/",
      "solarray/=lib/xxyyzz/lib/solarray/src/",
      "xxyyzz/=lib/xxyyzz/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "bytecodeHash": "none",
      "appendCBOR": false
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "libraries": {}
  }
}}