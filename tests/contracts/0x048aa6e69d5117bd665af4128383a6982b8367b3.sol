{{
  "language": "Solidity",
  "sources": {
    "/contracts/VoxNET.sol": {
      "content": "/**\n * SPDX-License-Identifier: unlicensed\n * Web: voxnet.xyz\n * Community: discord.gg/voxnet\n */\n\npragma solidity 0.8.17;\n\nimport \"@uniswap/v2-core/contracts/interfaces/IERC20.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\nlibrary FixedPoint {\n    uint8 public constant RESOLUTION = 112;\n\n    function mulDecode(uint224 x, uint y) internal pure returns (uint) {\n        return (x * y) >> RESOLUTION;\n    }\n\n    function fraction(uint numerator, uint denominator) internal pure returns (uint) {\n        if (numerator == 0) return 0;\n\n        require(denominator > 0, \"FixedPoint: division by zero\");\n        require(numerator <= type(uint144).max, \"FixedPoint: numerator too big\");\n\n        return (numerator << RESOLUTION) / denominator;\n    }\n}\n\nabstract contract Auth {\n    address internal _owner;\n    mapping(address => bool) public isAuthorized;\n\n    constructor(address owner) {\n        _owner = owner;\n        isAuthorized[owner] = true;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(msg.sender), \"Auth: owner only\");\n        _;\n    }\n\n    modifier authorized() {\n        require(isAuthorized[msg.sender], \"Auth: authorized only\");\n        _;\n    }\n\n    function setAuthorization(address address_, bool authorization) external onlyOwner {\n        isAuthorized[address_] = authorization;\n    }\n\n    function isOwner(address account) public view returns (bool) {\n        return account == _owner;\n    }\n\n    function transferOwnership(address payable newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Auth: owner address cannot be zero\");\n        isAuthorized[newOwner] = true;\n        _transferOwnership(newOwner);\n    }\n\n    function renounceOwnership() external onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        _owner = newOwner;\n        emit OwnershipTransferred(newOwner);\n    }\n\n    event OwnershipTransferred(address owner);\n}\n\ncontract VoxNET is IERC20, Auth {\n    string public constant name = \"VoxNET\";\n    string public constant symbol = \"$VXON\";\n    uint8 public constant decimals = 4;\n    uint public constant totalSupply = 1 * 10**6 * 10**decimals;\n\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    uint private ecosystemFee = 2;\n    uint private marketingFee = 4;\n    uint private treasuryFee = 3;\n    uint public fee;\n\n    event FeesSet(uint ecosystem, uint marketing, uint treasury);\n\n    function setFees(\n        uint ecosystem,\n        uint marketing,\n        uint treasury\n    ) external authorized {\n        fee = ecosystem + marketing + treasury;\n        require(fee <= 20, \"VoxNET: fee cannot be more than 20%\");\n\n        ecosystemFee = ecosystem;\n        marketingFee = marketing;\n        treasuryFee = treasury;\n\n        emit FeesSet(ecosystem, marketing, treasury);\n    }\n\n    address private constant router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n    address private weth;\n\n    constructor() Auth(msg.sender) {\n        weth = IUniswapV2Router02(router).WETH();\n        fee = ecosystemFee + marketingFee + treasuryFee;\n\n        isFeeExempt[msg.sender] = true;\n\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    }\n\n    function approve(address spender, uint amount) external override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint amount) external override returns (bool) {\n        return doTransfer(msg.sender, recipient, amount);\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external override returns (bool) {\n        if (allowance[sender][msg.sender] != type(uint).max) {\n            require(allowance[sender][msg.sender] >= amount, \"VoxNET: insufficient allowance\");\n            allowance[sender][msg.sender] = allowance[sender][msg.sender] - amount;\n        }\n\n        return doTransfer(sender, recipient, amount);\n    }\n\n    function doTransfer(\n        address sender,\n        address recipient,\n        uint amount\n    ) internal returns (bool) {\n        if (!isAuthorized[sender] && !isAuthorized[recipient]) {\n            require(launched, \"VoxNET: transfers not allowed yet\");\n        }\n\n        require(balanceOf[sender] >= amount, \"VoxNET: insufficient balance\");\n\n        balanceOf[sender] = balanceOf[sender] - amount;\n\n        uint amountAfterFee = amount;\n\n        if (!distributingFee) {\n            if ((isPool[sender] && !isFeeExempt[recipient]) || (isPool[recipient] && !isFeeExempt[sender])) {\n                amountAfterFee = takeFee(sender, amount);\n            } else {\n                distributeFeeIfApplicable(amount);\n            }\n        }\n\n        balanceOf[recipient] = balanceOf[recipient] + amountAfterFee;\n\n        emit Transfer(sender, recipient, amountAfterFee);\n        return true;\n    }\n\n    bool private launched = false;\n\n    function launch() external onlyOwner {\n        require(!launched, \"VoxNET: already launched\");\n\n        require(pair != address(0), \"VoxNET: DEx pair address must be set\");\n        require(\n            ecosystemFeeReceiver != address(0) &&\n                marketingFeeReceiver1 != address(0) &&\n                marketingFeeReceiver2 != address(0) &&\n                treasuryFeeReceiver != address(0),\n            \"VoxNET: fee recipient addresses must be set\"\n        );\n\n        launched = true;\n        tokenPriceTimestamp = block.timestamp;\n    }\n\n    function takeFee(address sender, uint amount) internal returns (uint) {\n        uint feeAmount = (amount * fee) / 100 / 2;\n        balanceOf[address(this)] = balanceOf[address(this)] + feeAmount;\n\n        emit Transfer(sender, address(this), feeAmount);\n\n        return amount - feeAmount;\n    }\n\n    uint private feeDistributionTransactionThreshold = 1 * 10**18;\n    uint private feeDistributionBalanceThreshold = 1 * 10**18;\n    uint private priceUpdateTimeThreshold = 900;\n\n    function distributeFeeIfApplicable(uint amount) internal {\n        updateTokenPriceIfApplicable();\n\n        if (\n            FixedPoint.mulDecode(tokenPrice, amount) >= feeDistributionTransactionThreshold &&\n            FixedPoint.mulDecode(tokenPrice, balanceOf[address(this)]) >= feeDistributionBalanceThreshold\n        ) {\n            distributeFee();\n        }\n    }\n\n    bool private distributingFee;\n\n    function distributeFee() public {\n        require(distributingFee == false, \"VoxNET: reentry prohibited\");\n        distributingFee = true;\n\n        uint tokensToSell = balanceOf[address(this)];\n\n        if (tokensToSell > 0) {\n            address[] memory path = new address[](2);\n            path[0] = address(this);\n            path[1] = weth;\n\n            allowance[address(this)][router] = tokensToSell;\n\n            IUniswapV2Router02(router).swapExactTokensForETHSupportingFeeOnTransferTokens(\n                tokensToSell,\n                0,\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        uint amount = address(this).balance;\n\n        if (amount > 0) {\n            bool success;\n\n            if (ecosystemFee != 0) {\n                uint amountEcosystem = (amount * ecosystemFee) / fee;\n                (success, ) = payable(ecosystemFeeReceiver).call{ value: amountEcosystem, gas: 30000 }(\"\");\n            }\n\n            uint amountMarketing = (amount * marketingFee) / fee;\n            (success, ) = payable(marketingFeeReceiver1).call{ value: amountMarketing / 2, gas: 30000 }(\"\");\n            (success, ) = payable(marketingFeeReceiver2).call{ value: amountMarketing / 2, gas: 30000 }(\"\");\n\n            uint amountTreasury = (amount * treasuryFee) / fee;\n            (success, ) = payable(treasuryFeeReceiver).call{ value: amountTreasury, gas: 30000 }(\"\");\n        }\n\n        distributingFee = false;\n    }\n\n    uint224 private tokenPrice = 0;\n    uint private tokenPriceTimestamp;\n    uint private tokenPriceCumulativeLast;\n\n    function updateTokenPriceIfApplicable() internal {\n        if (tokenPriceTimestamp != 0) {\n            uint timeElapsed = block.timestamp - tokenPriceTimestamp;\n\n            if (timeElapsed > priceUpdateTimeThreshold) {\n                uint tokenPriceCumulative = getCumulativeTokenPrice();\n\n                if (tokenPriceCumulativeLast != 0) {\n                    tokenPrice = uint224((tokenPriceCumulative - tokenPriceCumulativeLast) / timeElapsed);\n                }\n\n                tokenPriceCumulativeLast = tokenPriceCumulative;\n                tokenPriceTimestamp = block.timestamp;\n            }\n        }\n    }\n\n    function getCumulativeTokenPrice() internal view returns (uint) {\n        uint cumulativePrice;\n\n        if (IUniswapV2Pair(pair).token0() == address(this)) {\n            cumulativePrice = IUniswapV2Pair(pair).price0CumulativeLast();\n        } else {\n            cumulativePrice = IUniswapV2Pair(pair).price1CumulativeLast();\n        }\n\n        if (cumulativePrice != 0) {\n            uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n\n            (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n\n            if (blockTimestampLast != blockTimestamp) {\n                uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n                if (IUniswapV2Pair(pair).token0() == address(this)) {\n                    cumulativePrice += FixedPoint.fraction(reserve1, reserve0) * timeElapsed;\n                } else {\n                    cumulativePrice += FixedPoint.fraction(reserve0, reserve1) * timeElapsed;\n                }\n            }\n        }\n\n        return cumulativePrice;\n    }\n\n    mapping(address => bool) private isPool;\n\n    event IsPool(address indexed addr, bool indexed isPool);\n\n    function setIsPool(address contractAddress, bool contractIsPool) public onlyOwner {\n        isPool[contractAddress] = contractIsPool;\n        emit IsPool(contractAddress, contractIsPool);\n    }\n\n    address private pair;\n\n    function setPair(address pairAddress) external onlyOwner {\n        require(pairAddress != address(0), \"VoxNET: DEx pair address cannot be zero\");\n        pair = pairAddress;\n        setIsPool(pairAddress, true);\n    }\n\n    event FeeDistributionThresholdsSet(\n        uint transactionThreshold,\n        uint balanceThreshold,\n        uint tokenPriceUpdateTimeThreshold\n    );\n\n    function setFeeDistributionThresholds(\n        uint transactionThreshold,\n        uint balanceThreshold,\n        uint tokenPriceUpdateTimeThreshold\n    ) external authorized {\n        require(tokenPriceUpdateTimeThreshold > 0, \"VoxNET: price update time threshold cannot be zero\");\n\n        feeDistributionTransactionThreshold = transactionThreshold;\n        feeDistributionBalanceThreshold = balanceThreshold;\n        priceUpdateTimeThreshold = tokenPriceUpdateTimeThreshold;\n\n        emit FeeDistributionThresholdsSet(transactionThreshold, balanceThreshold, tokenPriceUpdateTimeThreshold);\n    }\n\n    mapping(address => bool) private isFeeExempt;\n\n    event IsFeeExempt(address indexed addr, bool indexed isFeeExempt);\n\n    function setIsFeeExempt(address excemptAddress, bool isExempt) external authorized {\n        isFeeExempt[excemptAddress] = isExempt;\n        emit IsFeeExempt(excemptAddress, isExempt);\n    }\n\n    address private ecosystemFeeReceiver;\n    address private marketingFeeReceiver1;\n    address private marketingFeeReceiver2;\n    address private treasuryFeeReceiver;\n\n    event FeeReceiversSet(\n        address ecosystemFeeReceiver,\n        address marketingFeeReceiver1,\n        address marketingFeeReceiver2,\n        address treasuryFeeReceiver\n    );\n\n    function setFeeReceivers(\n        address ecosystem,\n        address marketing1,\n        address marketing2,\n        address treasury\n    ) external authorized {\n        require(\n            ecosystem != address(0) && marketing1 != address(0) && marketing2 != address(0) && treasury != address(0),\n            \"VoxNET: zero address provided\"\n        );\n\n        ecosystemFeeReceiver = ecosystem;\n        marketingFeeReceiver1 = marketing1;\n        marketingFeeReceiver2 = marketing2;\n        treasuryFeeReceiver = treasury;\n\n        emit FeeReceiversSet(ecosystem, marketing1, marketing2, treasury);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}