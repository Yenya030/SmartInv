{{
  "language": "Solidity",
  "sources": {
    "contracts/AnonymiceBadges.sol": {
      "content": "/* solhint-disable quotes */\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"./POAPBoard.sol\";\nimport \"./POAPLibrary.sol\";\nimport \"./IDescriptor.sol\";\nimport \"./IBadgesVerifier.sol\";\nimport \"./ICheeth.sol\";\n\ncontract AnonymiceBadges is POAPBoard {\n    address public cheethAddress;\n    address public descriptorAddress;\n    address public badgesVerifierAddress;\n    bool public isPaused = true;\n    mapping(uint256 => uint256) public boardPrices;\n    mapping(address => string) public boardNames;\n    mapping(address => bool) private _auth;\n\n    constructor() POAPBoard(\"Anonymice Collector Cards\", \"AnonymiceCollectorCards\") {}\n\n    function mint() external pure override {\n        revert(\"no free mint\");\n    }\n\n    function claimAll(\n        uint256[] calldata ids,\n        bytes32[][] calldata proofs,\n        uint256[] calldata genesisMice,\n        uint256[] calldata babyMice\n    ) external {\n        for (uint256 index = 0; index < ids.length; index++) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            require(MerkleProof.verify(proofs[index], merkleRootsByPOAPId[ids[index]], leaf), \"not in whitelist\");\n            _claimPOAP(ids[index], msg.sender);\n        }\n\n        uint256[] memory badgeIds = IBadgesVerifier(badgesVerifierAddress).claimableBadges(\n            genesisMice,\n            babyMice,\n            msg.sender\n        );\n\n        for (uint256 index = 0; index < badgeIds.length; index++) {\n            uint256 badgeId = badgeIds[index];\n            if (badgeId == 0) break;\n            if (!_poapOwners[badgeId][msg.sender]) {\n                _claimPOAP(badgeIds[index], msg.sender);\n            }\n        }\n    }\n\n    function claimVerifiedBadge(\n        uint256[] calldata genesisMice,\n        uint256[] calldata babyMice,\n        uint256 badgeIdToClaim\n    ) external {\n        uint256[] memory badgeIds = IBadgesVerifier(badgesVerifierAddress).claimableBadges(\n            genesisMice,\n            babyMice,\n            msg.sender\n        );\n\n        for (uint256 index = 0; index < badgeIds.length; index++) {\n            uint256 badgeId = badgeIds[index];\n            if (badgeId == 0) break;\n            if (badgeIdToClaim == badgeId) {\n                if (!_poapOwners[badgeId][msg.sender]) {\n                    _claimPOAP(badgeIds[index], msg.sender);\n                }\n            }\n        }\n    }\n\n    function getVerifiedBadges(uint256[] memory genesisMice, uint256[] memory babyMice)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return IBadgesVerifier(badgesVerifierAddress).claimableBadges(genesisMice, babyMice, msg.sender);\n    }\n\n    function buyBoard(uint256 boardId) external {\n        require(boardPrices[boardId] > 0, \"price not set\");\n        ICheeth(cheethAddress).burnFrom(msg.sender, boardPrices[boardId]);\n        if (!_minted(msg.sender)) {\n            _mint(msg.sender);\n            currentBoard[msg.sender] = boardId;\n        }\n        _claimBoard(boardId, msg.sender);\n    }\n\n    function setBoardName(string memory name) external {\n        boardNames[msg.sender] = name;\n    }\n\n    function externalClaimBoard(uint256 boardId, address to) external {\n        require(_auth[msg.sender], \"no auth\");\n        _claimBoard(boardId, to);\n    }\n\n    function externalClaimPOAP(uint256 id, address to) external {\n        require(_auth[msg.sender], \"no auth\");\n        _claimPOAP(id, to);\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return IDescriptor(descriptorAddress).tokenURI(id);\n    }\n\n    function rearrangeBoardAndName(\n        uint256 boardId,\n        uint256[] memory slots,\n        string memory text\n    ) external {\n        if (boardId != currentBoard[msg.sender]) _swapBoard(boardId, false);\n        _rearrangePOAPs(slots);\n        boardNames[msg.sender] = text;\n    }\n\n    function previewBoard(\n        uint256 boardId,\n        uint256[] calldata badges,\n        string memory text\n    ) external view returns (string memory) {\n        return IDescriptor(descriptorAddress).buildSvg(boardId, badges, text, true);\n    }\n\n    function setDescriptorAddress(address _descriptorAddress) external onlyOwner {\n        descriptorAddress = _descriptorAddress;\n    }\n\n    function setCheethAddress(address _cheethAddress) external onlyOwner {\n        cheethAddress = _cheethAddress;\n    }\n\n    function setBadgesVerifierAddress(address _badgesVerifierAddress) external onlyOwner {\n        badgesVerifierAddress = _badgesVerifierAddress;\n    }\n\n    function setAuth(address wallet, bool value) external onlyOwner {\n        _auth[wallet] = value;\n    }\n\n    function setIsPaused(bool value) external onlyOwner {\n        isPaused = value;\n    }\n\n    function setBoardPrice(uint256 boardId, uint256 boardPrice) external onlyOwner {\n        boardPrices[boardId] = boardPrice;\n    }\n}\n/* solhint-enable quotes */\n"
    },
    "contracts/POAPBoard.sol": {
      "content": "/* solhint-disable quotes */\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./ERC721UniqueBound.sol\";\nimport \"./IPOAPBoard.sol\";\nimport \"./POAPLibrary.sol\";\n\ncontract POAPBoard is Ownable, ERC721UniqueBound {\n    mapping(uint256 => mapping(address => bool)) internal _poapOwners;\n    mapping(address => mapping(uint256 => uint256)) internal _poaps;\n\n    uint256 public boardCount;\n    uint256 public poapCount;\n    mapping(uint256 => POAPLibrary.Board) public boards;\n    mapping(address => uint256) public currentBoard;\n    mapping(address => uint256) public poapsBalanceOf;\n    mapping(uint256 => bytes32) public merkleRootsByPOAPId;\n    mapping(uint256 => bytes32) public merkleRootsByBoardId;\n    mapping(address => mapping(uint256 => bool)) public availableBoards;\n    mapping(address => mapping(uint256 => uint256)) public poapPositions;\n\n    constructor(string memory name_, string memory symbol_) ERC721UniqueBound(name_, symbol_) {}\n\n    function mint() external virtual {\n        _mint(msg.sender);\n        availableBoards[msg.sender][1] = true;\n        currentBoard[msg.sender] = 1;\n    }\n\n    function claimBoard(uint256 boardId, bytes32[] calldata proof) external {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(MerkleProof.verify(proof, merkleRootsByBoardId[boardId], leaf), \"not in whitelist\");\n        _claimBoard(boardId, msg.sender);\n    }\n\n    function claimPOAP(uint256 id, bytes32[] calldata proof) public {\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(MerkleProof.verify(proof, merkleRootsByPOAPId[id], leaf), \"not in whitelist\");\n        _claimPOAP(id, msg.sender);\n    }\n\n    function setCurrentBoard(uint256 boardId) external {\n        _swapBoard(boardId, true);\n    }\n\n    function rearrangeBoard(uint256 boardId, uint256[] memory slots) external {\n        if (boardId != currentBoard[msg.sender]) _swapBoard(boardId, false);\n        _rearrangePOAPs(slots);\n    }\n\n    function rearrangePOAPs(uint256[] memory slots) external {\n        _rearrangePOAPs(slots);\n    }\n\n    function _rearrangePOAPs(uint256[] memory slots) internal {\n        POAPLibrary.Board memory selectedBoard = boards[currentBoard[msg.sender]];\n        require(slots.length == selectedBoard.slots.length, \"wrong size\");\n        for (uint256 index = 0; index < slots.length; index++) {\n            uint256 poapId = slots[index];\n            for (uint256 innerIndex = 0; innerIndex < index; innerIndex++) {\n                require(poapId == 0 || poapId != slots[innerIndex], \"already used\");\n            }\n            poapPositions[msg.sender][index] = _poapOwners[poapId][msg.sender] ? poapId : 0;\n        }\n    }\n\n    function _swapBoard(uint256 boardId, bool shouldWipe) internal {\n        require(currentBoard[msg.sender] != boardId, \"same board\");\n        require(availableBoards[msg.sender][boardId], \"locked board\");\n\n        currentBoard[msg.sender] = boardId;\n        if (shouldWipe) {\n            POAPLibrary.Board memory selectedBoard = boards[boardId];\n            for (uint256 index = 0; index < selectedBoard.slots.length; index++) {\n                poapPositions[msg.sender][index] = 0;\n            }\n        }\n    }\n\n    function getAllPOAPs(address wallet) public view returns (uint256[] memory) {\n        uint256 poapsCount = poapsBalanceOf[wallet];\n        uint256[] memory poaps = new uint256[](poapsCount);\n        for (uint256 index = 0; index < poapsCount; index++) {\n            poaps[index] = _poaps[wallet][index];\n        }\n        return poaps;\n    }\n\n    function getBoardPOAPs(address wallet) public view returns (uint256[] memory) {\n        POAPLibrary.Board memory selectedBoard = boards[currentBoard[wallet]];\n        uint256[] memory poaps = new uint256[](selectedBoard.slots.length);\n        for (uint256 index = 0; index < poaps.length; index++) {\n            poaps[index] = poapPositions[wallet][index];\n        }\n        return poaps;\n    }\n\n    function getBoards(address wallet) public view returns (POAPLibrary.Board[] memory) {\n        uint256 walletCount;\n        for (uint256 boardId = 1; boardId <= boardCount; boardId++) {\n            if (availableBoards[wallet][boardId]) {\n                walletCount++;\n            }\n        }\n        POAPLibrary.Board[] memory walletBoards = new POAPLibrary.Board[](walletCount);\n        uint256 walletBoardsIndex;\n        for (uint256 boardId = 1; boardId <= boardCount; boardId++) {\n            if (availableBoards[wallet][boardId]) {\n                walletBoards[walletBoardsIndex++] = boards[boardId];\n            }\n        }\n        return walletBoards;\n    }\n\n    function getCurrentBoard(address wallet) public view returns (POAPLibrary.Board memory) {\n        return boards[currentBoard[wallet]];\n    }\n\n    function getWalletState(address wallet)\n        external\n        view\n        returns (\n            uint256[] memory,\n            POAPLibrary.Board[] memory,\n            POAPLibrary.Board memory\n        )\n    {\n        return (getAllPOAPs(wallet), getBoards(wallet), getCurrentBoard(wallet));\n    }\n\n    function getBoard(uint256 boardId) external view returns (POAPLibrary.Board memory) {\n        return boards[boardId];\n    }\n\n    function _claimPOAP(uint256 poapId, address to) internal existingPOAP(poapId) {\n        if (_poapOwners[poapId][to]) return;\n        _poapOwners[poapId][to] = true;\n        _poaps[to][poapsBalanceOf[to]] = poapId;\n        poapsBalanceOf[to]++;\n    }\n\n    function _claimBoard(uint256 boardId, address to) internal existingBoard(boardId) {\n        require(_minted(to), \"mint required\");\n        require(!availableBoards[to][boardId], \"already claimed\");\n        availableBoards[to][boardId] = true;\n    }\n\n    // OWNER FUNCTIONS\n\n    function registerBoard(\n        uint64 width,\n        uint64 height,\n        POAPLibrary.Slot[] memory slots\n    ) external onlyOwner {\n        boardCount++;\n        POAPLibrary.Board storage newBoard = boards[boardCount];\n        newBoard.id = uint128(boardCount);\n        newBoard.width = width;\n        newBoard.height = height;\n        for (uint256 index = 0; index < slots.length; index++) {\n            newBoard.slots.push(slots[index]);\n        }\n    }\n\n    function registerPOAP() external onlyOwner {\n        poapCount++;\n    }\n\n    function setPOAPCount(uint256 count) external onlyOwner {\n        poapCount = count;\n    }\n\n    function overrideBoard(\n        uint128 id,\n        uint64 width,\n        uint64 height,\n        POAPLibrary.Slot[] memory slots\n    ) external onlyOwner existingBoard(id) {\n        POAPLibrary.Board storage newBoard = boards[id];\n        newBoard.id = id;\n        newBoard.width = width;\n        newBoard.height = height;\n        uint256 oldSlotsSize = newBoard.slots.length; // 3\n        for (uint256 index = 0; index < slots.length; index++) {\n            if (oldSlotsSize <= index) {\n                newBoard.slots.push(slots[index]);\n            } else {\n                newBoard.slots[index] = slots[index];\n            }\n        }\n    }\n\n    function setMerkleRootsByPOAPId(uint256 poapId, bytes32 merkleRoot) external onlyOwner {\n        merkleRootsByPOAPId[poapId] = merkleRoot;\n    }\n\n    function setMerkleRootsByBoardId(uint256 boardId, bytes32 merkleRoot) external onlyOwner {\n        merkleRootsByBoardId[boardId] = merkleRoot;\n    }\n\n    modifier existingBoard(uint256 boardId) {\n        require(boardId <= boardCount, \"unknown board\");\n        _;\n    }\n\n    modifier existingPOAP(uint256 poapId) {\n        require(poapId <= poapCount, \"unknown poap\");\n        _;\n    }\n}\n/* solhint-enable quotes */\n"
    },
    "contracts/POAPLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nlibrary POAPLibrary {\n    struct Slot {\n        uint32 x;\n        uint32 y;\n        uint32 scale;\n    }\n    struct Board {\n        uint128 id;\n        uint64 width;\n        uint64 height;\n        Slot[] slots;\n    }\n\n    string internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n\n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n\n                // read 3 bytes\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n\n    function _toString(uint256 value) internal pure returns (string memory ptr) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit),\n            // but we allocate 128 bytes to keep the free memory pointer 32-byte word aliged.\n            // We will need 1 32-byte word to store the length,\n            // and 3 32-byte words to store a maximum of 78 digits. Total: 32 + 3 * 32 = 128.\n            ptr := add(mload(0x40), 128)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, ptr)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := ptr\n\n            // We write the string from the rightmost digit to the leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // Costs a bit more than early returning for the zero case,\n            // but cheaper in terms of deployment and overall runtime costs.\n            for {\n                // Initialize and perform the first pass without check.\n                let temp := value\n                // Move the pointer 1 byte leftwards to point to an empty character slot.\n                ptr := sub(ptr, 1)\n                // Write the character to the pointer. 48 is the ASCII index of '0'.\n                mstore8(ptr, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n            } temp {\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n            } {\n                // Body of the for loop.\n                ptr := sub(ptr, 1)\n                mstore8(ptr, add(48, mod(temp, 10)))\n            }\n\n            let length := sub(end, ptr)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            ptr := sub(ptr, 32)\n            // Store the length.\n            mstore(ptr, length)\n        }\n    }\n}\n"
    },
    "contracts/IDescriptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\ninterface IDescriptor {\n    function badgeImages(uint256 badgeId) external view returns (string memory);\n\n    function boardImages(uint256 boardId) external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function getSvg(uint256 id) external view returns (string memory);\n\n    function buildSvg(\n        uint256 boardId,\n        uint256[] memory poaps,\n        string memory boardName,\n        bool isPreview\n    ) external view returns (string memory);\n}\n"
    },
    "contracts/IBadgesVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"./POAPLibrary.sol\";\n\ninterface IBadgesVerifier {\n    function claimableBadges(\n        uint256[] memory genesisMice,\n        uint256[] memory babyMice,\n        address wallet\n    ) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/ICheeth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICheeth is IERC20 {\n    function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "contracts/ERC721UniqueBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.1.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.7;\n\nimport \"./IERC721UniqueBound.sol\";\n\ncontract ERC721UniqueBound is IERC721UniqueBound {\n    uint256 private _currentIndex;\n\n    string private _name;\n\n    string private _symbol;\n\n    mapping(uint256 => address) private _ownerships;\n\n    mapping(address => uint256) private _ownerToTokenId;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 1;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return _minted(owner) ? 1 : 0;\n    }\n\n    function _minted(address owner) internal view returns (bool) {\n        uint256 tokenId = _ownerToTokenId[owner];\n        return _ownerships[tokenId] == owner;\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _ownerships[tokenId];\n    }\n\n    function tokenOf(address owner) public view override returns (uint256) {\n        return _ownerToTokenId[owner];\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _startTokenId() <= tokenId && tokenId < _currentIndex;\n    }\n\n    function _mint(address to) internal {\n        if (to == address(0)) revert MintToZeroAddress();\n        if (_minted(to)) revert MintToExistingOwnerAddress();\n\n        _ownerships[_currentIndex] = to;\n        _ownerToTokenId[to] = _currentIndex;\n        emit Transfer(address(0), to, _currentIndex);\n        _currentIndex++;\n    }\n\n    function _toString(uint256 value) internal pure returns (string memory ptr) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit),\n            // but we allocate 128 bytes to keep the free memory pointer 32-byte word aliged.\n            // We will need 1 32-byte word to store the length,\n            // and 3 32-byte words to store a maximum of 78 digits. Total: 32 + 3 * 32 = 128.\n            ptr := add(mload(0x40), 128)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, ptr)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := ptr\n\n            // We write the string from the rightmost digit to the leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // Costs a bit more than early returning for the zero case,\n            // but cheaper in terms of deployment and overall runtime costs.\n            for {\n                // Initialize and perform the first pass without check.\n                let temp := value\n                // Move the pointer 1 byte leftwards to point to an empty character slot.\n                ptr := sub(ptr, 1)\n                // Write the character to the pointer. 48 is the ASCII index of '0'.\n                mstore8(ptr, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n            } temp {\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n            } {\n                // Body of the for loop.\n                ptr := sub(ptr, 1)\n                mstore8(ptr, add(48, mod(temp, 10)))\n            }\n\n            let length := sub(end, ptr)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            ptr := sub(ptr, 32)\n            // Store the length.\n            mstore(ptr, length)\n        }\n    }\n}\n"
    },
    "contracts/IPOAPBoard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\nimport \"./POAPLibrary.sol\";\n\ninterface IPOAPBoard {\n    function totalSupply() external view returns (uint256);\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function getAllPOAPs(address wallet) external view returns (uint256[] memory);\n\n    function getBoardPOAPs(address wallet) external view returns (uint256[] memory);\n\n    function currentBoard(address wallet) external view returns (uint256);\n\n    function getBoard(uint256 boardId) external view returns (POAPLibrary.Board memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/IERC721UniqueBound.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\ninterface IERC721UniqueBound {\n    error MintZeroQuantity();\n    error MintToZeroAddress();\n    error MintToExistingOwnerAddress();\n    error BalanceQueryForZeroAddress();\n    error URIQueryForNonexistentToken();\n\n    function totalSupply() external view returns (uint256);\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function tokenOf(address owner) external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}