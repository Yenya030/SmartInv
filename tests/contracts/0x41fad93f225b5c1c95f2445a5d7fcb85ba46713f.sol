{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/pendle/contracts/core/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\n/// Adapted from UniswapV3's Oracle\n\nlibrary Errors {\n    // BulkSeller\n    error BulkInsufficientSyForTrade(uint256 currentAmount, uint256 requiredAmount);\n    error BulkInsufficientTokenForTrade(uint256 currentAmount, uint256 requiredAmount);\n    error BulkInSufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\n    error BulkInSufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n    error BulkInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\n    error BulkNotMaintainer();\n    error BulkNotAdmin();\n    error BulkSellerAlreadyExisted(address token, address SY, address bulk);\n    error BulkSellerInvalidToken(address token, address SY);\n    error BulkBadRateTokenToSy(uint256 actualRate, uint256 currentRate, uint256 eps);\n    error BulkBadRateSyToToken(uint256 actualRate, uint256 currentRate, uint256 eps);\n\n    // APPROX\n    error ApproxFail();\n    error ApproxParamsInvalid(uint256 guessMin, uint256 guessMax, uint256 eps);\n    error ApproxBinarySearchInputInvalid(\n        uint256 approxGuessMin,\n        uint256 approxGuessMax,\n        uint256 minGuessMin,\n        uint256 maxGuessMax\n    );\n\n    // MARKET + MARKET MATH CORE\n    error MarketExpired();\n    error MarketZeroAmountsInput();\n    error MarketZeroAmountsOutput();\n    error MarketZeroLnImpliedRate();\n    error MarketInsufficientPtForTrade(int256 currentAmount, int256 requiredAmount);\n    error MarketInsufficientPtReceived(uint256 actualBalance, uint256 requiredBalance);\n    error MarketInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\n    error MarketZeroTotalPtOrTotalAsset(int256 totalPt, int256 totalAsset);\n    error MarketExchangeRateBelowOne(int256 exchangeRate);\n    error MarketProportionMustNotEqualOne();\n    error MarketRateScalarBelowZero(int256 rateScalar);\n    error MarketScalarRootBelowZero(int256 scalarRoot);\n    error MarketProportionTooHigh(int256 proportion, int256 maxProportion);\n\n    error OracleUninitialized();\n    error OracleTargetTooOld(uint32 target, uint32 oldest);\n    error OracleZeroCardinality();\n\n    error MarketFactoryExpiredPt();\n    error MarketFactoryInvalidPt();\n    error MarketFactoryMarketExists();\n\n    error MarketFactoryLnFeeRateRootTooHigh(uint80 lnFeeRateRoot, uint256 maxLnFeeRateRoot);\n    error MarketFactoryReserveFeePercentTooHigh(\n        uint8 reserveFeePercent,\n        uint8 maxReserveFeePercent\n    );\n    error MarketFactoryZeroTreasury();\n    error MarketFactoryInitialAnchorTooLow(int256 initialAnchor, int256 minInitialAnchor);\n\n    // ROUTER\n    error RouterInsufficientLpOut(uint256 actualLpOut, uint256 requiredLpOut);\n    error RouterInsufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\n    error RouterInsufficientPtOut(uint256 actualPtOut, uint256 requiredPtOut);\n    error RouterInsufficientYtOut(uint256 actualYtOut, uint256 requiredYtOut);\n    error RouterInsufficientPYOut(uint256 actualPYOut, uint256 requiredPYOut);\n    error RouterInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n    error RouterExceededLimitSyIn(uint256 actualSyIn, uint256 limitSyIn);\n    error RouterExceededLimitPtIn(uint256 actualPtIn, uint256 limitPtIn);\n    error RouterExceededLimitYtIn(uint256 actualYtIn, uint256 limitYtIn);\n    error RouterInsufficientSyRepay(uint256 actualSyRepay, uint256 requiredSyRepay);\n    error RouterInsufficientPtRepay(uint256 actualPtRepay, uint256 requiredPtRepay);\n    error RouterNotAllSyUsed(uint256 netSyDesired, uint256 netSyUsed);\n\n    error RouterTimeRangeZero();\n    error RouterCallbackNotPendleMarket(address caller);\n    error RouterInvalidAction(bytes4 selector);\n\n    error RouterKyberSwapDataZero();\n\n    // YIELD CONTRACT\n    error YCExpired();\n    error YCNotExpired();\n    error YieldContractInsufficientSy(uint256 actualSy, uint256 requiredSy);\n    error YCNothingToRedeem();\n    error YCPostExpiryDataNotSet();\n    error YCNoFloatingSy();\n\n    // YieldFactory\n    error YCFactoryInvalidExpiry();\n    error YCFactoryYieldContractExisted();\n    error YCFactoryZeroExpiryDivisor();\n    error YCFactoryZeroTreasury();\n    error YCFactoryInterestFeeRateTooHigh(uint256 interestFeeRate, uint256 maxInterestFeeRate);\n    error YCFactoryRewardFeeRateTooHigh(uint256 newRewardFeeRate, uint256 maxRewardFeeRate);\n\n    // SY\n    error SYInvalidTokenIn(address token);\n    error SYInvalidTokenOut(address token);\n    error SYZeroDeposit();\n    error SYZeroRedeem();\n    error SYInsufficientSharesOut(uint256 actualSharesOut, uint256 requiredSharesOut);\n    error SYInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n\n    // SY-specific\n    error SYQiTokenMintFailed(uint256 errCode);\n    error SYQiTokenRedeemFailed(uint256 errCode);\n    error SYQiTokenRedeemRewardsFailed(uint256 rewardAccruedType0, uint256 rewardAccruedType1);\n    error SYQiTokenBorrowRateTooHigh(uint256 borrowRate, uint256 borrowRateMax);\n\n    error SYCurveInvalidPid();\n    error SYCurve3crvPoolNotFound();\n\n    // Liquidity Mining\n    error VCInactivePool(address pool);\n    error VCPoolAlreadyActive(address pool);\n    error VCZeroVePendle(address user);\n    error VCExceededMaxWeight(uint256 totalWeight, uint256 maxWeight);\n    error VCEpochNotFinalized(uint256 wTime);\n    error VCPoolAlreadyAddAndRemoved(address pool);\n\n    error VEInvalidNewExpiry(uint256 newExpiry);\n    error VEExceededMaxLockTime();\n    error VEInsufficientLockTime();\n    error VENotAllowedReduceExpiry();\n    error VEZeroAmountLocked();\n    error VEPositionNotExpired();\n    error VEZeroPosition();\n    error VEZeroSlope(uint128 bias, uint128 slope);\n    error VEReceiveOldSupply(uint256 msgTime);\n\n    error GCNotPendleMarket(address caller);\n    error GCNotVotingController(address caller);\n\n    error InvalidWTime(uint256 wTime);\n    error ExpiryInThePast(uint256 expiry);\n    error ChainNotSupported(uint256 chainId);\n\n    error FDCantFundFutureEpoch();\n    error FDFactoryDistributorAlreadyExisted(address pool, address distributor);\n\n    // Cross-Chain\n    error MsgNotFromSendEndpoint(uint16 srcChainId, bytes path);\n    error MsgNotFromReceiveEndpoint(address sender);\n    error InsufficientFeeToSendMsg(uint256 currentFee, uint256 requiredFee);\n    error ApproxDstExecutionGasNotSet();\n    error InvalidRetryData();\n\n    // GENERIC MSG\n    error ArrayLengthMismatch();\n    error ArrayEmpty();\n    error ArrayOutOfBounds();\n    error ZeroAddress();\n\n    error OnlyLayerZeroEndpoint();\n    error OnlyYT();\n    error OnlyYCFactory();\n    error OnlyWhitelisted();\n}\n"
    },
    "contracts/pendle/contracts/core/libraries/math/LogExpMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the “Software”), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity 0.8.17;\n\n/* solhint-disable */\n\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 2ˆ7\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // eˆ(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 2ˆ6\n    int256 constant a1 = 6235149080811616882910000000; // eˆ(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 2ˆ5\n    int256 constant a2 = 7896296018268069516100000000000000; // eˆ(x2)\n    int256 constant x3 = 1600000000000000000000; // 2ˆ4\n    int256 constant a3 = 888611052050787263676000000; // eˆ(x3)\n    int256 constant x4 = 800000000000000000000; // 2ˆ3\n    int256 constant a4 = 298095798704172827474000; // eˆ(x4)\n    int256 constant x5 = 400000000000000000000; // 2ˆ2\n    int256 constant a5 = 5459815003314423907810; // eˆ(x5)\n    int256 constant x6 = 200000000000000000000; // 2ˆ1\n    int256 constant a6 = 738905609893065022723; // eˆ(x6)\n    int256 constant x7 = 100000000000000000000; // 2ˆ0\n    int256 constant a7 = 271828182845904523536; // eˆ(x7)\n    int256 constant x8 = 50000000000000000000; // 2ˆ-1\n    int256 constant a8 = 164872127070012814685; // eˆ(x8)\n    int256 constant x9 = 25000000000000000000; // 2ˆ-2\n    int256 constant a9 = 128402541668774148407; // eˆ(x9)\n    int256 constant x10 = 12500000000000000000; // 2ˆ-3\n    int256 constant a10 = 113314845306682631683; // eˆ(x10)\n    int256 constant x11 = 6250000000000000000; // 2ˆ-4\n    int256 constant a11 = 106449445891785942956; // eˆ(x11)\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        unchecked {\n            require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, \"Invalid exponent\");\n\n            if (x < 0) {\n                // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n                // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n                // Fixed point division requires multiplying by ONE_18.\n                return ((ONE_18 * ONE_18) / exp(-x));\n            }\n\n            // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n            // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n            // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n            // decomposition.\n            // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest x_n.\n            // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n            // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n            // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n            // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n            // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n            // decomposition.\n\n            // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n            // it and compute the accumulated product.\n\n            int256 firstAN;\n            if (x >= x0) {\n                x -= x0;\n                firstAN = a0;\n            } else if (x >= x1) {\n                x -= x1;\n                firstAN = a1;\n            } else {\n                firstAN = 1; // One with no decimal places\n            }\n\n            // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n            // smaller terms.\n            x *= 100;\n\n            // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n            // one. Recall that fixed point multiplication requires dividing by ONE_20.\n            int256 product = ONE_20;\n\n            if (x >= x2) {\n                x -= x2;\n                product = (product * a2) / ONE_20;\n            }\n            if (x >= x3) {\n                x -= x3;\n                product = (product * a3) / ONE_20;\n            }\n            if (x >= x4) {\n                x -= x4;\n                product = (product * a4) / ONE_20;\n            }\n            if (x >= x5) {\n                x -= x5;\n                product = (product * a5) / ONE_20;\n            }\n            if (x >= x6) {\n                x -= x6;\n                product = (product * a6) / ONE_20;\n            }\n            if (x >= x7) {\n                x -= x7;\n                product = (product * a7) / ONE_20;\n            }\n            if (x >= x8) {\n                x -= x8;\n                product = (product * a8) / ONE_20;\n            }\n            if (x >= x9) {\n                x -= x9;\n                product = (product * a9) / ONE_20;\n            }\n\n            // x10 and x11 are unnecessary here since we have high enough precision already.\n\n            // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n            // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n            int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n            int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n            // The first term is simply x.\n            term = x;\n            seriesSum += term;\n\n            // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n            // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n            term = ((term * x) / ONE_20) / 2;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 3;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 4;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 5;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 6;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 7;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 8;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 9;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 10;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 11;\n            seriesSum += term;\n\n            term = ((term * x) / ONE_20) / 12;\n            seriesSum += term;\n\n            // 12 Taylor terms are sufficient for 18 decimal precision.\n\n            // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n            // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n            // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n            // and then drop two digits to return an 18 decimal value.\n\n            return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n        }\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        unchecked {\n            // The real natural logarithm is not defined for negative numbers or zero.\n            require(a > 0, \"out of bounds\");\n            if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n                return _ln_36(a) / ONE_18;\n            } else {\n                return _ln(a);\n            }\n        }\n    }\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            if (y == 0) {\n                // We solve the 0^0 indetermination by making it equal one.\n                return uint256(ONE_18);\n            }\n\n            if (x == 0) {\n                return 0;\n            }\n\n            // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n            // arrive at that r`esult. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n            // x^y = exp(y * ln(x)).\n\n            // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n            require(x < 2**255, \"x out of bounds\");\n            int256 x_int256 = int256(x);\n\n            // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n            // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n            // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n            require(y < MILD_EXPONENT_BOUND, \"y out of bounds\");\n            int256 y_int256 = int256(y);\n\n            int256 logx_times_y;\n            if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n                int256 ln_36_x = _ln_36(x_int256);\n\n                // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n                // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n                // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n                // (downscaled) last 18 decimals.\n                logx_times_y = ((ln_36_x / ONE_18) *\n                    y_int256 +\n                    ((ln_36_x % ONE_18) * y_int256) /\n                    ONE_18);\n            } else {\n                logx_times_y = _ln(x_int256) * y_int256;\n            }\n            logx_times_y /= ONE_18;\n\n            // Finally, we compute exp(y * ln(x)) to arrive at x^y\n            require(\n                MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n                \"product out of bounds\"\n            );\n\n            return uint256(exp(logx_times_y));\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        unchecked {\n            if (a < ONE_18) {\n                // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n                // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n                // Fixed point division requires multiplying by ONE_18.\n                return (-_ln((ONE_18 * ONE_18) / a));\n            }\n\n            // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n            // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n            // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n            // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n            // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n            // decomposition, which will be lower than the smallest a_n.\n            // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n            // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n            // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n            // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n            // ONE_18 to convert them to fixed point.\n            // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n            // by it and compute the accumulated sum.\n\n            int256 sum = 0;\n            if (a >= a0 * ONE_18) {\n                a /= a0; // Integer, not fixed point division\n                sum += x0;\n            }\n\n            if (a >= a1 * ONE_18) {\n                a /= a1; // Integer, not fixed point division\n                sum += x1;\n            }\n\n            // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n            sum *= 100;\n            a *= 100;\n\n            // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n            if (a >= a2) {\n                a = (a * ONE_20) / a2;\n                sum += x2;\n            }\n\n            if (a >= a3) {\n                a = (a * ONE_20) / a3;\n                sum += x3;\n            }\n\n            if (a >= a4) {\n                a = (a * ONE_20) / a4;\n                sum += x4;\n            }\n\n            if (a >= a5) {\n                a = (a * ONE_20) / a5;\n                sum += x5;\n            }\n\n            if (a >= a6) {\n                a = (a * ONE_20) / a6;\n                sum += x6;\n            }\n\n            if (a >= a7) {\n                a = (a * ONE_20) / a7;\n                sum += x7;\n            }\n\n            if (a >= a8) {\n                a = (a * ONE_20) / a8;\n                sum += x8;\n            }\n\n            if (a >= a9) {\n                a = (a * ONE_20) / a9;\n                sum += x9;\n            }\n\n            if (a >= a10) {\n                a = (a * ONE_20) / a10;\n                sum += x10;\n            }\n\n            if (a >= a11) {\n                a = (a * ONE_20) / a11;\n                sum += x11;\n            }\n\n            // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n            // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n            // Let z = (a - 1) / (a + 1).\n            // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n            // division by ONE_20.\n            int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n            int256 z_squared = (z * z) / ONE_20;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_20;\n            seriesSum += num / 11;\n\n            // 6 Taylor terms are sufficient for 36 decimal precision.\n\n            // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n            seriesSum *= 2;\n\n            // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n            // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n            // value.\n\n            return (sum + seriesSum) / 100;\n        }\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        unchecked {\n            // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n            // worthwhile.\n\n            // First, we transform x to a 36 digit fixed point value.\n            x *= ONE_18;\n\n            // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n            // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n            // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n            // division by ONE_36.\n            int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n            int256 z_squared = (z * z) / ONE_36;\n\n            // num is the numerator of the series: the z^(2 * n + 1) term\n            int256 num = z;\n\n            // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n            int256 seriesSum = num;\n\n            // In each step, the numerator is multiplied by z^2\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 3;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 5;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 7;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 9;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 11;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 13;\n\n            num = (num * z_squared) / ONE_36;\n            seriesSum += num / 15;\n\n            // 8 Taylor terms are sufficient for 36 decimal precision.\n\n            // All that remains is multiplying by 2 (non fixed point).\n            return seriesSum * 2;\n        }\n    }\n}\n"
    },
    "contracts/pendle/contracts/core/libraries/math/Math.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.17;\n\n/* solhint-disable private-vars-leading-underscore, reason-string */\n\nlibrary Math {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, \"negative\");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function isAApproxB(\n        uint256 a,\n        uint256 b,\n        uint256 eps\n    ) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(\n        uint256 a,\n        uint256 b,\n        uint256 eps\n    ) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(\n        uint256 a,\n        uint256 b,\n        uint256 eps\n    ) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}\n"
    },
    "contracts/pendle/contracts/core/libraries/MiniHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nlibrary MiniHelpers {\n    function isCurrentlyExpired(uint256 expiry) internal view returns (bool) {\n        return (expiry <= block.timestamp);\n    }\n\n    function isExpired(uint256 expiry, uint256 blockTime) internal pure returns (bool) {\n        return (expiry <= blockTime);\n    }\n\n    function isTimeInThePast(uint256 timestamp) internal view returns (bool) {\n        return (timestamp <= block.timestamp); // same definition as isCurrentlyExpired\n    }\n}\n"
    },
    "contracts/pendle/contracts/core/libraries/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nabstract contract TokenHelper {\n    using SafeERC20 for IERC20;\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(\n        address token,\n        address from,\n        uint256 amount\n    ) internal {\n        if (token == NATIVE) require(msg.value == amount, \"eth mismatch\");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{ value: amount }(\"\");\n            require(success, \"eth send failed\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(\n        address[] memory tokens,\n        address to,\n        uint256[] memory amounts\n    ) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"Safe Approve\");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n}\n"
    },
    "contracts/pendle/contracts/core/Market/MarketMathCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../libraries/math/Math.sol\";\nimport \"../libraries/math/LogExpMath.sol\";\n\nimport \"../StandardizedYield/PYIndex.sol\";\nimport \"../libraries/MiniHelpers.sol\";\nimport \"../libraries/Errors.sol\";\n\nstruct MarketState {\n    int256 totalPt;\n    int256 totalSy;\n    int256 totalLp;\n    address treasury;\n    /// immutable variables ///\n    int256 scalarRoot;\n    uint256 expiry;\n    /// fee data ///\n    uint256 lnFeeRateRoot;\n    uint256 reserveFeePercent; // base 100\n    /// last trade data ///\n    uint256 lastLnImpliedRate;\n}\n\n// params that are expensive to compute, therefore we pre-compute them\nstruct MarketPreCompute {\n    int256 rateScalar;\n    int256 totalAsset;\n    int256 rateAnchor;\n    int256 feeRate;\n}\n\n// solhint-disable ordering\nlibrary MarketMathCore {\n    using Math for uint256;\n    using Math for int256;\n    using LogExpMath for int256;\n    using PYIndexLib for PYIndex;\n\n    int256 internal constant MINIMUM_LIQUIDITY = 10**3;\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant IMPLIED_RATE_TIME = 365 * DAY;\n\n    int256 internal constant MAX_MARKET_PROPORTION = (1e18 * 96) / 100;\n\n    using Math for uint256;\n    using Math for int256;\n\n    /*///////////////////////////////////////////////////////////////\n                UINT FUNCTIONS TO PROXY TO CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidity(\n        MarketState memory market,\n        uint256 syDesired,\n        uint256 ptDesired,\n        uint256 blockTime\n    )\n        internal\n        pure\n        returns (\n            uint256 lpToReserve,\n            uint256 lpToAccount,\n            uint256 syUsed,\n            uint256 ptUsed\n        )\n    {\n        (\n            int256 _lpToReserve,\n            int256 _lpToAccount,\n            int256 _syUsed,\n            int256 _ptUsed\n        ) = addLiquidityCore(market, syDesired.Int(), ptDesired.Int(), blockTime);\n\n        lpToReserve = _lpToReserve.Uint();\n        lpToAccount = _lpToAccount.Uint();\n        syUsed = _syUsed.Uint();\n        ptUsed = _ptUsed.Uint();\n    }\n\n    function removeLiquidity(MarketState memory market, uint256 lpToRemove)\n        internal\n        pure\n        returns (uint256 netSyToAccount, uint256 netPtToAccount)\n    {\n        (int256 _syToAccount, int256 _ptToAccount) = removeLiquidityCore(market, lpToRemove.Int());\n\n        netSyToAccount = _syToAccount.Uint();\n        netPtToAccount = _ptToAccount.Uint();\n    }\n\n    function swapExactPtForSy(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToMarket,\n        uint256 blockTime\n    )\n        internal\n        pure\n        returns (\n            uint256 netSyToAccount,\n            uint256 netSyFee,\n            uint256 netSyToReserve\n        )\n    {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToMarket.neg(),\n            blockTime\n        );\n\n        netSyToAccount = _netSyToAccount.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function swapSyForExactPt(\n        MarketState memory market,\n        PYIndex index,\n        uint256 exactPtToAccount,\n        uint256 blockTime\n    )\n        internal\n        pure\n        returns (\n            uint256 netSyToMarket,\n            uint256 netSyFee,\n            uint256 netSyToReserve\n        )\n    {\n        (int256 _netSyToAccount, int256 _netSyFee, int256 _netSyToReserve) = executeTradeCore(\n            market,\n            index,\n            exactPtToAccount.Int(),\n            blockTime\n        );\n\n        netSyToMarket = _netSyToAccount.neg().Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    CORE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function addLiquidityCore(\n        MarketState memory market,\n        int256 syDesired,\n        int256 ptDesired,\n        uint256 blockTime\n    )\n        internal\n        pure\n        returns (\n            int256 lpToReserve,\n            int256 lpToAccount,\n            int256 syUsed,\n            int256 ptUsed\n        )\n    {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (syDesired == 0 || ptDesired == 0) revert Errors.MarketZeroAmountsInput();\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        if (market.totalLp == 0) {\n            lpToAccount = Math.sqrt((syDesired * ptDesired).Uint()).Int() - MINIMUM_LIQUIDITY;\n            lpToReserve = MINIMUM_LIQUIDITY;\n            syUsed = syDesired;\n            ptUsed = ptDesired;\n        } else {\n            int256 netLpByPt = (ptDesired * market.totalLp) / market.totalPt;\n            int256 netLpBySy = (syDesired * market.totalLp) / market.totalSy;\n            if (netLpByPt < netLpBySy) {\n                lpToAccount = netLpByPt;\n                ptUsed = ptDesired;\n                syUsed = (market.totalSy * lpToAccount) / market.totalLp;\n            } else {\n                lpToAccount = netLpBySy;\n                syUsed = syDesired;\n                ptUsed = (market.totalPt * lpToAccount) / market.totalLp;\n            }\n        }\n\n        if (lpToAccount <= 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalSy += syUsed;\n        market.totalPt += ptUsed;\n        market.totalLp += lpToAccount + lpToReserve;\n    }\n\n    function removeLiquidityCore(MarketState memory market, int256 lpToRemove)\n        internal\n        pure\n        returns (int256 netSyToAccount, int256 netPtToAccount)\n    {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (lpToRemove == 0) revert Errors.MarketZeroAmountsInput();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        netSyToAccount = (lpToRemove * market.totalSy) / market.totalLp;\n        netPtToAccount = (lpToRemove * market.totalPt) / market.totalLp;\n\n        if (netSyToAccount == 0 && netPtToAccount == 0) revert Errors.MarketZeroAmountsOutput();\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.totalLp = market.totalLp.subNoNeg(lpToRemove);\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount);\n    }\n\n    function executeTradeCore(\n        MarketState memory market,\n        PYIndex index,\n        int256 netPtToAccount,\n        uint256 blockTime\n    )\n        internal\n        pure\n        returns (\n            int256 netSyToAccount,\n            int256 netSyFee,\n            int256 netSyToReserve\n        )\n    {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n        if (market.totalPt <= netPtToAccount)\n            revert Errors.MarketInsufficientPtForTrade(market.totalPt, netPtToAccount);\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        MarketPreCompute memory comp = getMarketPreCompute(market, index, blockTime);\n\n        (netSyToAccount, netSyFee, netSyToReserve) = calcTrade(\n            market,\n            comp,\n            index,\n            netPtToAccount\n        );\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        _setNewMarketStateTrade(\n            market,\n            comp,\n            index,\n            netPtToAccount,\n            netSyToAccount,\n            netSyToReserve,\n            blockTime\n        );\n    }\n\n    function getMarketPreCompute(\n        MarketState memory market,\n        PYIndex index,\n        uint256 blockTime\n    ) internal pure returns (MarketPreCompute memory res) {\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        res.rateScalar = _getRateScalar(market, timeToExpiry);\n        res.totalAsset = index.syToAsset(market.totalSy);\n\n        if (market.totalPt == 0 || res.totalAsset == 0)\n            revert Errors.MarketZeroTotalPtOrTotalAsset(market.totalPt, res.totalAsset);\n\n        res.rateAnchor = _getRateAnchor(\n            market.totalPt,\n            market.lastLnImpliedRate,\n            res.totalAsset,\n            res.rateScalar,\n            timeToExpiry\n        );\n        res.feeRate = _getExchangeRateFromImpliedRate(market.lnFeeRateRoot, timeToExpiry);\n    }\n\n    function calcTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount\n    )\n        internal\n        pure\n        returns (\n            int256 netSyToAccount,\n            int256 netSyFee,\n            int256 netSyToReserve\n        )\n    {\n        int256 preFeeExchangeRate = _getExchangeRate(\n            market.totalPt,\n            comp.totalAsset,\n            comp.rateScalar,\n            comp.rateAnchor,\n            netPtToAccount\n        );\n\n        int256 preFeeAssetToAccount = netPtToAccount.divDown(preFeeExchangeRate).neg();\n        int256 fee = comp.feeRate;\n\n        if (netPtToAccount > 0) {\n            int256 postFeeExchangeRate = preFeeExchangeRate.divDown(fee);\n            if (postFeeExchangeRate < Math.IONE)\n                revert Errors.MarketExchangeRateBelowOne(postFeeExchangeRate);\n\n            fee = preFeeAssetToAccount.mulDown(Math.IONE - fee);\n        } else {\n            fee = ((preFeeAssetToAccount * (Math.IONE - fee)) / fee).neg();\n        }\n\n        int256 netAssetToReserve = (fee * market.reserveFeePercent.Int()) / PERCENTAGE_DECIMALS;\n        int256 netAssetToAccount = preFeeAssetToAccount - fee;\n\n        netSyToAccount = netAssetToAccount < 0\n            ? index.assetToSyUp(netAssetToAccount)\n            : index.assetToSy(netAssetToAccount);\n        netSyFee = index.assetToSy(fee);\n        netSyToReserve = index.assetToSy(netAssetToReserve);\n    }\n\n    function _setNewMarketStateTrade(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        int256 netPtToAccount,\n        int256 netSyToAccount,\n        int256 netSyToReserve,\n        uint256 blockTime\n    ) internal pure {\n        uint256 timeToExpiry = market.expiry - blockTime;\n\n        market.totalPt = market.totalPt.subNoNeg(netPtToAccount);\n        market.totalSy = market.totalSy.subNoNeg(netSyToAccount + netSyToReserve);\n\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            index.syToAsset(market.totalSy),\n            comp.rateScalar,\n            comp.rateAnchor,\n            timeToExpiry\n        );\n\n        if (market.lastLnImpliedRate == 0) revert Errors.MarketZeroLnImpliedRate();\n    }\n\n    function _getRateAnchor(\n        int256 totalPt,\n        uint256 lastLnImpliedRate,\n        int256 totalAsset,\n        int256 rateScalar,\n        uint256 timeToExpiry\n    ) internal pure returns (int256 rateAnchor) {\n        int256 newExchangeRate = _getExchangeRateFromImpliedRate(lastLnImpliedRate, timeToExpiry);\n\n        if (newExchangeRate < Math.IONE) revert Errors.MarketExchangeRateBelowOne(newExchangeRate);\n\n        {\n            int256 proportion = totalPt.divDown(totalPt + totalAsset);\n\n            int256 lnProportion = _logProportion(proportion);\n\n            rateAnchor = newExchangeRate - lnProportion.divDown(rateScalar);\n        }\n    }\n\n    /// @notice Calculates the current market implied rate.\n    /// @return lnImpliedRate the implied rate\n    function _getLnImpliedRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        uint256 timeToExpiry\n    ) internal pure returns (uint256 lnImpliedRate) {\n        // This will check for exchange rates < Math.IONE\n        int256 exchangeRate = _getExchangeRate(totalPt, totalAsset, rateScalar, rateAnchor, 0);\n\n        // exchangeRate >= 1 so its ln >= 0\n        uint256 lnRate = exchangeRate.ln().Uint();\n\n        lnImpliedRate = (lnRate * IMPLIED_RATE_TIME) / timeToExpiry;\n    }\n\n    /// @notice Converts an implied rate to an exchange rate given a time to expiry. The\n    /// formula is E = e^rt\n    function _getExchangeRateFromImpliedRate(uint256 lnImpliedRate, uint256 timeToExpiry)\n        internal\n        pure\n        returns (int256 exchangeRate)\n    {\n        uint256 rt = (lnImpliedRate * timeToExpiry) / IMPLIED_RATE_TIME;\n\n        exchangeRate = LogExpMath.exp(rt.Int());\n    }\n\n    function _getExchangeRate(\n        int256 totalPt,\n        int256 totalAsset,\n        int256 rateScalar,\n        int256 rateAnchor,\n        int256 netPtToAccount\n    ) internal pure returns (int256 exchangeRate) {\n        int256 numerator = totalPt.subNoNeg(netPtToAccount);\n\n        int256 proportion = (numerator.divDown(totalPt + totalAsset));\n\n        if (proportion > MAX_MARKET_PROPORTION)\n            revert Errors.MarketProportionTooHigh(proportion, MAX_MARKET_PROPORTION);\n\n        int256 lnProportion = _logProportion(proportion);\n\n        exchangeRate = lnProportion.divDown(rateScalar) + rateAnchor;\n\n        if (exchangeRate < Math.IONE) revert Errors.MarketExchangeRateBelowOne(exchangeRate);\n    }\n\n    function _logProportion(int256 proportion) internal pure returns (int256 res) {\n        if (proportion == Math.IONE) revert Errors.MarketProportionMustNotEqualOne();\n\n        int256 logitP = proportion.divDown(Math.IONE - proportion);\n\n        res = logitP.ln();\n    }\n\n    function _getRateScalar(MarketState memory market, uint256 timeToExpiry)\n        internal\n        pure\n        returns (int256 rateScalar)\n    {\n        rateScalar = (market.scalarRoot * IMPLIED_RATE_TIME.Int()) / timeToExpiry.Int();\n        if (rateScalar <= 0) revert Errors.MarketRateScalarBelowZero(rateScalar);\n    }\n\n    function setInitialLnImpliedRate(\n        MarketState memory market,\n        PYIndex index,\n        int256 initialAnchor,\n        uint256 blockTime\n    ) internal pure {\n        /// ------------------------------------------------------------\n        /// CHECKS\n        /// ------------------------------------------------------------\n        if (MiniHelpers.isExpired(market.expiry, blockTime)) revert Errors.MarketExpired();\n\n        /// ------------------------------------------------------------\n        /// MATH\n        /// ------------------------------------------------------------\n        int256 totalAsset = index.syToAsset(market.totalSy);\n        uint256 timeToExpiry = market.expiry - blockTime;\n        int256 rateScalar = _getRateScalar(market, timeToExpiry);\n\n        /// ------------------------------------------------------------\n        /// WRITE\n        /// ------------------------------------------------------------\n        market.lastLnImpliedRate = _getLnImpliedRate(\n            market.totalPt,\n            totalAsset,\n            rateScalar,\n            initialAnchor,\n            timeToExpiry\n        );\n    }\n}\n"
    },
    "contracts/pendle/contracts/core/StandardizedYield/PYIndex.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\nimport \"../../interfaces/IPYieldToken.sol\";\nimport \"../../interfaces/IPPrincipalToken.sol\";\n\nimport \"./SYUtils.sol\";\nimport \"../libraries/math/Math.sol\";\n\ntype PYIndex is uint256;\n\nlibrary PYIndexLib {\n    using Math for uint256;\n    using Math for int256;\n\n    function newIndex(IPYieldToken YT) internal returns (PYIndex) {\n        return PYIndex.wrap(YT.pyIndexCurrent());\n    }\n\n    function syToAsset(PYIndex index, uint256 syAmount)\n        internal\n        pure\n        returns (uint256)\n    {\n        return SYUtils.syToAsset(PYIndex.unwrap(index), syAmount);\n    }\n\n    function assetToSy(PYIndex index, uint256 assetAmount)\n        internal\n        pure\n        returns (uint256)\n    {\n        return SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function assetToSyUp(PYIndex index, uint256 assetAmount)\n        internal\n        pure\n        returns (uint256)\n    {\n        return SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount);\n    }\n\n    function syToAssetUp(PYIndex index, uint256 syAmount)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 _index = PYIndex.unwrap(index);\n        return SYUtils.syToAssetUp(_index, syAmount);\n    }\n\n    function syToAsset(PYIndex index, int256 syAmount)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 sign = syAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.syToAsset(PYIndex.unwrap(index), syAmount.abs())).Int();\n    }\n\n    function assetToSy(PYIndex index, int256 assetAmount)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSy(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n    function assetToSyUp(PYIndex index, int256 assetAmount)\n        internal\n        pure\n        returns (int256)\n    {\n        int256 sign = assetAmount < 0 ? int256(-1) : int256(1);\n        return sign * (SYUtils.assetToSyUp(PYIndex.unwrap(index), assetAmount.abs())).Int();\n    }\n\n}\n"
    },
    "contracts/pendle/contracts/core/StandardizedYield/SYUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nlibrary SYUtils {\n    uint256 internal constant ONE = 1e18;\n\n    function syToAsset(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate) / ONE;\n    }\n\n    function syToAssetUp(uint256 exchangeRate, uint256 syAmount) internal pure returns (uint256) {\n        return (syAmount * exchangeRate + ONE - 1) / ONE;\n    }\n\n    function assetToSy(uint256 exchangeRate, uint256 assetAmount) internal pure returns (uint256) {\n        return (assetAmount * ONE) / exchangeRate;\n    }\n\n    function assetToSyUp(uint256 exchangeRate, uint256 assetAmount)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (assetAmount * ONE + exchangeRate - 1) / exchangeRate;\n    }\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPActionAddRemoveLiq.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../router/base/MarketApproxLib.sol\";\nimport \"../router/kyberswap/KyberSwapHelper.sol\";\n\ninterface IPActionAddRemoveLiq {\n    event AddLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenIn,\n        address receiver,\n        uint256 netTokenUsed,\n        uint256 netPtUsed,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netPtIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netSyIn,\n        uint256 netLpOut\n    );\n\n    event AddLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netLpOut\n    );\n\n    event RemoveLiquidityDualSyAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquidityDualTokenAndPt(\n        address indexed caller,\n        address indexed market,\n        address indexed tokenOut,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut,\n        uint256 netTokenOut\n    );\n\n    event RemoveLiquiditySinglePt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netPtOut\n    );\n\n    event RemoveLiquiditySingleSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        uint256 netLpToRemove,\n        uint256 netSyOut\n    );\n\n    event RemoveLiquiditySingleToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        uint256 netLpToRemove,\n        uint256 netTokenOut\n    );\n\n    function addLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netSyDesired,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    )\n        external\n        returns (\n            uint256 netLpOut,\n            uint256 netSyUsed,\n            uint256 netPtUsed\n        );\n\n    function addLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        TokenInput calldata input,\n        uint256 netPtDesired,\n        uint256 minLpOut\n    )\n        external\n        payable\n        returns (\n            uint256 netLpOut,\n            uint256 netTokenUsed,\n            uint256 netPtUsed\n        );\n\n    function addLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netPtIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtSwapToSy\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netSyIn,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy\n    ) external returns (uint256 netLpOut, uint256 netSyFee);\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee);\n\n    function removeLiquidityDualSyAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut,\n        uint256 minPtOut\n    ) external returns (uint256 netSyOut, uint256 netPtOut);\n\n    function removeLiquidityDualTokenAndPt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        uint256 minPtOut\n    ) external returns (uint256 netTokenOut, uint256 netPtOut);\n\n    function removeLiquiditySinglePt(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function removeLiquiditySingleSy(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        uint256 minSyOut\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output\n    ) external returns (uint256 netTokenOut, uint256 netSyFee);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPActionMintRedeem.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../router/base/MarketApproxLib.sol\";\nimport \"../router/kyberswap/KyberSwapHelper.sol\";\n\ninterface IPActionMintRedeem {\n    event MintSyFromToken(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed SY,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netSyOut\n    );\n\n    event RedeemSyToToken(\n        address indexed caller,\n        address indexed tokenOut,\n        address indexed SY,\n        address receiver,\n        uint256 netSyIn,\n        uint256 netTokenOut\n    );\n\n    event MintPyFromSy(\n        address indexed caller,\n        address indexed receiver,\n        address indexed YT,\n        uint256 netSyIn,\n        uint256 netPyOut\n    );\n\n    event RedeemPyToSy(\n        address indexed caller,\n        address indexed receiver,\n        address indexed YT,\n        uint256 netPyIn,\n        uint256 netSyOut\n    );\n\n    event MintPyFromToken(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed YT,\n        address receiver,\n        uint256 netTokenIn,\n        uint256 netPyOut\n    );\n\n    event RedeemPyToToken(\n        address indexed caller,\n        address indexed tokenOut,\n        address indexed YT,\n        address receiver,\n        uint256 netPyIn,\n        uint256 netTokenOut\n    );\n\n    event RedeemDueInterestAndRewards(\n        address indexed user,\n        address[] sys,\n        address[] yts,\n        address[] markets,\n        uint256[][] syRewards,\n        uint256[] ytInterests,\n        uint256[][] ytRewards,\n        uint256[][] marketRewards\n    );\n\n    event RedeemDueInterestAndRewardsThenSwapAll(\n        address indexed user,\n        address[] sys,\n        address[] yts,\n        address[] markets,\n        address indexed tokenOut,\n        uint256 netTokenOut\n    );\n\n    function mintSyFromToken(\n        address receiver,\n        address SY,\n        uint256 minSyOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netSyOut);\n\n    function redeemSyToToken(\n        address receiver,\n        address SY,\n        uint256 netSyIn,\n        TokenOutput calldata output\n    ) external returns (uint256 netTokenOut);\n\n    function mintPyFromToken(\n        address receiver,\n        address YT,\n        uint256 minPyOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netPyOut);\n\n    function redeemPyToToken(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        TokenOutput calldata output\n    ) external returns (uint256 netTokenOut);\n\n    function mintPyFromSy(\n        address receiver,\n        address YT,\n        uint256 netSyIn,\n        uint256 minPyOut\n    ) external returns (uint256 netPyOut);\n\n    function redeemPyToSy(\n        address receiver,\n        address YT,\n        uint256 netPyIn,\n        uint256 minSyOut\n    ) external returns (uint256 netSyOut);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        address[] calldata sys,\n        address[] calldata yts,\n        address[] calldata markets\n    )\n        external\n        returns (\n            uint256[][] memory syRewards,\n            uint256[] memory ytInterests,\n            uint256[][] memory ytRewards,\n            uint256[][] memory marketRewards\n        );\n\n    struct RouterYtRedeemStruct {\n        address[] yts;\n        // key-value pair\n        address[] syAddrs;\n        address[] tokenRedeemSys;\n        address[] bulks;\n        //\n    }\n\n    struct RouterSwapAllStruct {\n        // key-value pair\n        address[] tokens;\n        bytes[] kybercalls;\n        //\n        address kyberRouter;\n        address outputToken;\n        uint256 minTokenOut;\n    }\n\n    function redeemDueInterestAndRewardsThenSwapAll(\n        address[] calldata sys,\n        RouterYtRedeemStruct calldata dataYT,\n        address[] calldata markets,\n        RouterSwapAllStruct calldata dataSwap\n    ) external returns (uint256 netTokenOut, uint256[] memory amountsSwapped);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPActionMisc.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IPActionMisc {\n    function consult(address market, uint32 secondsAgo)\n        external\n        view\n        returns (uint96 lnImpliedRateMean);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPActionSwapPT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../router/base/MarketApproxLib.sol\";\nimport \"../router/kyberswap/KyberSwapHelper.sol\";\n\ninterface IPActionSwapPT {\n    event SwapPtAndSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        int256 netPtToAccount,\n        int256 netSyToAccount\n    );\n\n    event SwapPtAndToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        int256 netPtToAccount,\n        int256 netTokenToAccount\n    );\n\n    function swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minSyOut\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapPtForExactSy(\n        address receiver,\n        address market,\n        uint256 exactSyOut,\n        uint256 maxPtIn,\n        ApproxParams calldata guessPtIn\n    ) external returns (uint256 netPtIn, uint256 netSyFee);\n\n    function swapSyForExactPt(\n        address receiver,\n        address market,\n        uint256 exactPtOut,\n        uint256 maxSyIn\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n\n    function swapExactTokenForPt(\n        address receiver,\n        address market,\n        uint256 minPtOut,\n        ApproxParams calldata guessPtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netPtOut, uint256 netSyFee);\n\n    function swapExactPtForToken(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        TokenOutput calldata output\n    ) external returns (uint256 netTokenOut, uint256 netSyFee);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPActionSwapPTYT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../router/base/MarketApproxLib.sol\";\nimport \"../router/kyberswap/KyberSwapHelper.sol\";\n\ninterface IPActionSwapPTYT {\n    event SwapPtAndYt(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        int256 netPtToAccount,\n        int256 netYtToAccount\n    );\n\n    function swapExactPtForYt(\n        address receiver,\n        address market,\n        uint256 exactPtIn,\n        uint256 minYtOut,\n        ApproxParams calldata guessTotalPtToSwap\n    ) external returns (uint256 netYtOut, uint256 netSyFee);\n\n    function swapExactYtForPt(\n        address receiver,\n        address market,\n        uint256 exactYtIn,\n        uint256 minPtOut,\n        ApproxParams calldata guessTotalPtSwapped\n    ) external returns (uint256 netPtOut, uint256 netSyFee);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPActionSwapYT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../router/base/MarketApproxLib.sol\";\nimport \"../router/kyberswap/KyberSwapHelper.sol\";\n\ninterface IPActionSwapYT {\n    event SwapYtAndSy(\n        address indexed caller,\n        address indexed market,\n        address indexed receiver,\n        int256 netYtToAccount,\n        int256 netSyToAccount\n    );\n\n    event SwapYtAndToken(\n        address indexed caller,\n        address indexed market,\n        address indexed token,\n        address receiver,\n        int256 netYtToAccount,\n        int256 netTokenToAccount\n    );\n\n    function swapExactSyForYt(\n        address receiver,\n        address market,\n        uint256 exactSyIn,\n        uint256 minYtOut,\n        ApproxParams memory guessYtOut\n    ) external returns (uint256 netYtOut, uint256 netSyFee);\n\n    function swapExactYtForSy(\n        address receiver,\n        address market,\n        uint256 exactYtIn,\n        uint256 minSyOut\n    ) external returns (uint256 netSyOut, uint256 netSyFee);\n\n    function swapSyForExactYt(\n        address receiver,\n        address market,\n        uint256 exactYtOut,\n        uint256 maxSyIn\n    ) external returns (uint256 netSyIn, uint256 netSyFee);\n\n    function swapYtForExactSy(\n        address receiver,\n        address market,\n        uint256 exactSyOut,\n        uint256 maxYtIn,\n        ApproxParams memory guessYtIn\n    ) external returns (uint256 netYtIn, uint256 netSyFee);\n\n    function swapExactTokenForYt(\n        address receiver,\n        address market,\n        uint256 minYtOut,\n        ApproxParams memory guessYtOut,\n        TokenInput calldata input\n    ) external payable returns (uint256 netYtOut, uint256 netSyFee);\n\n    function swapExactYtForToken(\n        address receiver,\n        address market,\n        uint256 netYtIn,\n        TokenOutput calldata output\n    ) external returns (uint256 netTokenOut, uint256 netSyFee);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPAllAction.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.17;\n\nimport \"./IPActionAddRemoveLiq.sol\";\nimport \"./IPActionSwapPT.sol\";\nimport \"./IPActionSwapYT.sol\";\nimport \"./IPActionSwapPTYT.sol\";\nimport \"./IPActionMintRedeem.sol\";\nimport \"./IPActionMisc.sol\";\n\ninterface IPAllAction is\n    IPActionAddRemoveLiq,\n    IPActionSwapPT,\n    IPActionSwapYT,\n    IPActionSwapPTYT,\n    IPActionMintRedeem,\n    IPActionMisc\n{}\n"
    },
    "contracts/pendle/contracts/interfaces/IPInterestManagerYT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IPInterestManagerYT {\n    function userInterest(address user)\n        external\n        view\n        returns (uint128 lastPYIndex, uint128 accruedInterest);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPMarketSwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IPMarketSwapCallback {\n    function swapCallback(\n        int256 ptToAccount,\n        int256 syToAccount,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPPrincipalToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IPPrincipalToken is IERC20Metadata {\n    function burnByYT(address user, uint256 amount) external;\n\n    function mintByYT(address user, uint256 amount) external;\n\n    function initialize(address _YT) external;\n\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IPYieldToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./IRewardManager.sol\";\nimport \"./IPInterestManagerYT.sol\";\n\ninterface IPYieldToken is IERC20Metadata, IRewardManager, IPInterestManagerYT {\n    event NewInterestIndex(uint256 indexed newIndex);\n\n    event Mint(\n        address indexed caller,\n        address indexed receiverPT,\n        address indexed receiverYT,\n        uint256 amountSyToMint,\n        uint256 amountPYOut\n    );\n\n    event Burn(\n        address indexed caller,\n        address indexed receiver,\n        uint256 amountPYToRedeem,\n        uint256 amountSyOut\n    );\n\n    event RedeemRewards(address indexed user, uint256[] amountRewardsOut);\n\n    event RedeemInterest(address indexed user, uint256 interestOut);\n\n    event WithdrawFeeToTreasury(uint256[] amountRewardsOut, uint256 syOut);\n\n    function mintPY(address receiverPT, address receiverYT) external returns (uint256 amountPYOut);\n\n    function redeemPY(address receiver) external returns (uint256 amountSyOut);\n\n    function redeemPYMulti(address[] calldata receivers, uint256[] calldata amountPYToRedeems)\n        external\n        returns (uint256[] memory amountSyOuts);\n\n    function redeemDueInterestAndRewards(\n        address user,\n        bool redeemInterest,\n        bool redeemRewards\n    ) external returns (uint256 interestOut, uint256[] memory rewardsOut);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory);\n\n    function pyIndexCurrent() external returns (uint256);\n\n    function pyIndexStored() external view returns (uint256);\n\n    function getRewardTokens() external view returns (address[] memory);\n\n    function SY() external view returns (address);\n\n    function PT() external view returns (address);\n\n    function factory() external view returns (address);\n\n    function expiry() external view returns (uint256);\n\n    function isExpired() external view returns (bool);\n\n    function doCacheIndexSameBlock() external view returns (bool);\n}\n"
    },
    "contracts/pendle/contracts/interfaces/IRewardManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IRewardManager {\n    function userReward(address token, address user)\n        external\n        view\n        returns (uint128 index, uint128 accrued);\n}\n"
    },
    "contracts/pendle/contracts/router/base/MarketApproxLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../../core/libraries/math/Math.sol\";\nimport \"../../core/Market/MarketMathCore.sol\";\n\nstruct ApproxParams {\n    uint256 guessMin;\n    uint256 guessMax;\n    uint256 guessOffchain; // pass 0 in to skip this variable\n    uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n    uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n    // to 1e15 (1e18/1000 = 0.1%)\n\n    /// Further explanation of the eps. Take swapExactSyForPt for example. To calc the corresponding amount of Pt to swap out,\n    /// it's necessary to run an approximation algorithm, because by default there only exists the Pt to Sy formula\n    /// To approx, the 5 values above will have to be provided, and the approx process will run as follows:\n    /// mid = (guessMin + guessMax) / 2 // mid here is the current guess of the amount of Pt out\n    /// netSyNeed = calcSwapSyForExactPt(mid)\n    /// if (netSyNeed > exactSyIn) guessMax = mid - 1 // since the maximum Sy in can't exceed the exactSyIn\n    /// else guessMin = mid (1)\n    /// For the (1), since netSyNeed <= exactSyIn, the result might be usable. If the netSyNeed is within eps of\n    /// exactSyIn (ex eps=0.1% => we have used 99.9% the amount of Sy specified), mid will be chosen as the final guess result\n\n    /// for guessOffchain, this is to provide a shortcut to guessing. The offchain SDK can precalculate the exact result\n    /// before the tx is sent. When the tx reaches the contract, the guessOffchain will be checked first, and if it satisfies the\n    /// approximation, it will be used (and save all the guessing). It's expected that this shortcut will be used in most cases\n    /// except in cases that there is a trade in the same market right before the tx\n}\n\nlibrary MarketApproxPtInLib {\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using Math for uint256;\n    using Math for int256;\n    using LogExpMath for int256;\n\n    struct ApproxParamsPtIn {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain;\n        uint256 maxIteration;\n        uint256 eps;\n        //\n        uint256 biggestGoodGuess;\n    }\n\n    struct Args1 {\n        MarketState market;\n        PYIndex index;\n        uint256 minSyOut;\n        uint256 blockTime;\n    }\n\n    /**\n     * @dev algorithm:\n        - Bin search the amount of PT to swap in\n        - Try swapping & get netSyOut\n        - Stop when netSyOut greater & approx minSyOut\n        - guess & approx is for netPtIn\n     */\n    function approxSwapPtForExactSy(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _minSyOut,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    )\n        internal\n        pure\n        returns (\n            uint256, /*netPtIn*/\n            uint256, /*netSyOut*/\n            uint256 /*netSyFee*/\n        )\n    {\n        Args1 memory a = Args1(_market, _index, _minSyOut, _blockTime);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        ApproxParamsPtIn memory p = newApproxParamsPtIn(_approx, 0, calcMaxPtIn(comp.totalAsset));\n\n        for (uint256 iter = 0; iter < p.maxIteration; ++iter) {\n            (bool isGoodSlope, uint256 guess) = nextGuess(p, comp, a.market.totalPt, iter);\n            if (!isGoodSlope) {\n                p.guessMax = guess;\n                continue;\n            }\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(a.market, comp, a.index, guess);\n\n            if (netSyOut >= a.minSyOut) {\n                p.guessMax = guess;\n                bool isAnswerAccepted = Math.isAGreaterApproxB(netSyOut, a.minSyOut, p.eps);\n                if (isAnswerAccepted) {\n                    return (guess, netSyOut, netSyFee);\n                }\n            } else {\n                p.guessMin = guess;\n            }\n        }\n        revert Errors.ApproxFail();\n    }\n\n    struct Args2 {\n        MarketState market;\n        PYIndex index;\n        uint256 exactSyIn;\n        uint256 blockTime;\n    }\n\n    /**\n     * @dev algorithm:\n        - Bin search the amount of PT to swap in\n        - Flashswap the corresponding amount of SY out\n        - Pair those amount with exactSyIn SY to tokenize into PT & YT\n        - PT to repay the flashswap, YT transferred to user\n        - Stop when the amount of SY to be pulled to tokenize PT to repay loan approx the exactSyIn\n        - guess & approx is for netYtOut (also netPtIn)\n     */\n    function approxSwapExactSyForYt(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _exactSyIn,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    )\n        internal\n        pure\n        returns (\n            uint256, /*netYtOut*/\n            uint256 /*netSyFee*/\n        )\n    {\n        Args2 memory a = Args2(_market, _index, _exactSyIn, _blockTime);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n\n        // at minimum we will flashswap exactSyIn since we have enough SY to payback the PT loan\n        ApproxParamsPtIn memory p = newApproxParamsPtIn(\n            _approx,\n            a.index.syToAsset(a.exactSyIn),\n            calcMaxPtIn(comp.totalAsset)\n        );\n\n        for (uint256 iter = 0; iter < p.maxIteration; ++iter) {\n            (bool isGoodSlope, uint256 guess) = nextGuess(p, comp, a.market.totalPt, iter);\n            if (!isGoodSlope) {\n                p.guessMax = guess;\n                continue;\n            }\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(a.market, comp, a.index, guess);\n\n            uint256 netSyToTokenizePt = a.index.assetToSyUp(guess);\n\n            // for sure netSyToTokenizePt >= netSyOut since we are swapping PT to SY\n            uint256 netSyToPull = netSyToTokenizePt - netSyOut;\n\n            if (netSyToPull <= a.exactSyIn) {\n                p.guessMin = guess;\n                bool isAnswerAccepted = Math.isASmallerApproxB(netSyToPull, a.exactSyIn, p.eps);\n                if (isAnswerAccepted) return (guess, netSyFee);\n            } else {\n                p.guessMax = guess - 1;\n            }\n        }\n        revert Errors.ApproxFail();\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalPtIn;\n        uint256 blockTime;\n    }\n\n    /**\n     * @dev algorithm:\n        - Bin search the amount of PT to swap to SY\n        - Swap PT to SY\n        - Pair the remaining PT with the SY to add liquidity\n        - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n        - guess & approx is for netPtSwap\n     */\n    function approxSwapPtToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalPtIn,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    )\n        internal\n        pure\n        returns (\n            uint256, /*netPtSwap*/\n            uint256, /*netSyFromSwap*/\n            uint256 /*netSyFee*/\n        )\n    {\n        Args6 memory a = Args6(_market, _index, _totalPtIn, _blockTime);\n        require(a.market.totalLp != 0, \"no existing lp\");\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        ApproxParamsPtIn memory p = newApproxParamsPtIn(\n            _approx,\n            0,\n            Math.min(a.totalPtIn, calcMaxPtIn(comp.totalAsset))\n        );\n\n        p.guessMax = Math.min(p.guessMax, a.totalPtIn);\n\n        for (uint256 iter = 0; iter < p.maxIteration; ++iter) {\n            (bool isGoodSlope, uint256 guess) = nextGuess(p, comp, a.market.totalPt, iter);\n\n            if (!isGoodSlope) {\n                p.guessMax = guess;\n                continue;\n            }\n\n            (uint256 netSyOut, uint256 netSyFee, uint256 netSyToReserve) = calcSyOut(\n                a.market,\n                comp,\n                a.index,\n                guess\n            );\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n            {\n                uint256 newTotalPt = a.market.totalPt.Uint() + guess;\n                uint256 newTotalSy = (a.market.totalSy.Uint() - netSyOut - netSyToReserve);\n\n                // it is desired that\n                // netSyOut / newTotalSy = netPtRemaining / newTotalPt\n                // which is equivalent to\n                // netSyOut * newTotalPt = netPtRemaining * newTotalSy\n\n                syNumerator = netSyOut * newTotalPt;\n                ptNumerator = (a.totalPtIn - guess) * newTotalSy;\n            }\n\n            if (Math.isAApproxB(syNumerator, ptNumerator, p.eps)) {\n                return (guess, netSyOut, netSyFee);\n            }\n\n            if (syNumerator <= ptNumerator) {\n                // needs more SY --> swap more PT\n                p.guessMin = guess + 1;\n            } else {\n                // needs less SY --> swap less PT\n                p.guessMax = guess - 1;\n            }\n        }\n        revert Errors.ApproxFail();\n    }\n\n    struct Args7 {\n        MarketState market;\n        PYIndex index;\n        uint256 exactPtIn;\n        uint256 blockTime;\n    }\n\n    /**\n     * @dev algorithm:\n        - Bin search the amount of PT to swap to SY\n        - Flashswap the corresponding amount of SY out\n        - Tokenize all the SY into PT + YT\n        - PT to repay the flashswap, YT transferred to user\n        - Stop when the additional amount of PT to pull to repay the loan approx the exactPtIn\n        - guess & approx is for totalPtToSwap\n     */\n    function approxSwapExactPtForYt(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _exactPtIn,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    )\n        internal\n        pure\n        returns (\n            uint256, /*netYtOut*/\n            uint256, /*totalPtToSwap*/\n            uint256 /*netSyFee*/\n        )\n    {\n        Args7 memory a = Args7(_market, _index, _exactPtIn, _blockTime);\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        ApproxParamsPtIn memory p = newApproxParamsPtIn(\n            _approx,\n            a.exactPtIn,\n            calcMaxPtIn(comp.totalAsset)\n        );\n\n        for (uint256 iter = 0; iter < p.maxIteration; ++iter) {\n            (bool isGoodSlope, uint256 guess) = nextGuess(p, comp, a.market.totalPt, iter);\n\n            if (!isGoodSlope) {\n                p.guessMax = guess;\n                continue;\n            }\n\n            (uint256 netSyOut, uint256 netSyFee, ) = calcSyOut(a.market, comp, a.index, guess);\n\n            uint256 netAssetOut = a.index.syToAsset(netSyOut);\n\n            // guess >= netAssetOut since we are swapping PT to SY\n            uint256 netPtToPull = guess - netAssetOut;\n\n            if (netPtToPull <= a.exactPtIn) {\n                p.guessMin = guess;\n                if (Math.isASmallerApproxB(netPtToPull, a.exactPtIn, p.eps)) {\n                    return (netAssetOut, guess, netSyFee);\n                }\n            } else {\n                p.guessMax = guess - 1;\n            }\n        }\n        revert Errors.ApproxFail();\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyOut(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtIn\n    )\n        internal\n        pure\n        returns (\n            uint256 netSyOut,\n            uint256 netSyFee,\n            uint256 netSyToReserve\n        )\n    {\n        (int256 _netSyOut, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(\n            comp,\n            index,\n            netPtIn.neg()\n        );\n        netSyOut = _netSyOut.Uint();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function newApproxParamsPtIn(\n        ApproxParams memory _approx,\n        uint256 minGuessMin,\n        uint256 maxGuessMax\n    ) internal pure returns (ApproxParamsPtIn memory res) {\n        res.guessMin = Math.max(_approx.guessMin, minGuessMin);\n        res.guessMax = Math.min(_approx.guessMax, maxGuessMax);\n\n        if (res.guessMin > res.guessMax || _approx.eps > Math.ONE)\n            revert Errors.ApproxParamsInvalid(_approx.guessMin, _approx.guessMax, _approx.eps);\n\n        res.guessOffchain = _approx.guessOffchain;\n        res.maxIteration = _approx.maxIteration;\n        res.eps = _approx.eps;\n    }\n\n    function calcMaxPtIn(int256 totalAsset) internal pure returns (uint256) {\n        return totalAsset.Uint() - 1;\n    }\n\n    function nextGuess(\n        ApproxParamsPtIn memory p,\n        MarketPreCompute memory comp,\n        int256 totalPt,\n        uint256 iter\n    ) internal pure returns (bool, uint256) {\n        uint256 guess = _nextGuessPrivate(p, iter);\n        if (guess <= p.biggestGoodGuess) return (true, guess);\n\n        int256 slope = calcSlope(comp, totalPt, guess.Int());\n        if (slope < 0) return (false, guess);\n\n        p.biggestGoodGuess = guess;\n        return (true, guess);\n    }\n\n    /**\n     * @dev it is safe to assume that p.guessMin <= p.guessMax from the initialization of p\n     * So once guessMin becomes larger, it should always be the case of ApproxFail\n     */\n    function _nextGuessPrivate(ApproxParamsPtIn memory p, uint256 iter)\n        private\n        pure\n        returns (uint256)\n    {\n        if (iter == 0 && p.guessOffchain != 0) return p.guessOffchain;\n        if (p.guessMin <= p.guessMax) return (p.guessMin + p.guessMax) / 2;\n        revert Errors.ApproxFail();\n    }\n\n    function calcSlope(\n        MarketPreCompute memory comp,\n        int256 totalPt,\n        int256 ptToMarket //\n    ) internal pure returns (int256) {\n        int256 diffAssetPtToMarket = comp.totalAsset - ptToMarket;\n        int256 sumPt = ptToMarket + totalPt; // probably can skip sumPt check\n\n        require(diffAssetPtToMarket > 0 && sumPt > 0, \"invalid ptToMarket\");\n\n        int256 part1 = (ptToMarket * (totalPt + comp.totalAsset)).divDown(\n            sumPt * diffAssetPtToMarket\n        );\n\n        int256 part2 = sumPt.divDown(diffAssetPtToMarket).ln();\n        int256 part3 = Math.IONE.divDown(comp.rateScalar);\n\n        return comp.rateAnchor - (part1 - part2).mulDown(part3);\n    }\n}\n\nlibrary MarketApproxPtOutLib {\n    using MarketMathCore for MarketState;\n    using PYIndexLib for PYIndex;\n    using Math for uint256;\n    using Math for int256;\n    using LogExpMath for int256;\n\n    struct ApproxParamsPtOut {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain;\n        uint256 maxIteration;\n        uint256 eps;\n    }\n\n    struct Args4 {\n        MarketState market;\n        PYIndex index;\n        uint256 exactSyIn;\n        uint256 blockTime;\n    }\n\n    /**\n     * @dev algorithm:\n        - Bin search the amount of PT to swapExactOut\n        - Calculate the amount of SY needed\n        - Stop when the netSyIn is smaller approx exactSyIn\n        - guess & approx is for netSyIn\n     */\n    function approxSwapExactSyForPt(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _exactSyIn,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    )\n        internal\n        pure\n        returns (\n            uint256, /*netPtOut*/\n            uint256 /*netSyFee*/\n        )\n    {\n        Args4 memory a = Args4(_market, _index, _exactSyIn, _blockTime);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        ApproxParamsPtOut memory p = newApproxParamsPtOut(\n            _approx,\n            0,\n            calcMaxPtOut(comp, a.market.totalPt)\n        );\n\n        for (uint256 iter = 0; iter < p.maxIteration; ++iter) {\n            uint256 guess = nextGuess(p, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, ) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyIn <= a.exactSyIn) {\n                p.guessMin = guess;\n                bool isAnswerAccepted = Math.isASmallerApproxB(netSyIn, a.exactSyIn, p.eps);\n                if (isAnswerAccepted) return (guess, netSyFee);\n            } else {\n                p.guessMax = guess - 1;\n            }\n        }\n\n        revert Errors.ApproxFail();\n    }\n\n    struct Args5 {\n        MarketState market;\n        PYIndex index;\n        uint256 minSyOut;\n        uint256 blockTime;\n    }\n\n    /**\n     * @dev algorithm:\n        - Bin search the amount of PT to swapExactOut\n        - Flashswap that amount of PT & pair with YT to redeem SY\n        - Use the SY to repay the flashswap debt and the remaining is transferred to user\n        - Stop when the netSyOut is greater approx the minSyOut\n        - guess & approx is for netSyOut\n     */\n    function approxSwapYtForExactSy(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _minSyOut,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    )\n        internal\n        pure\n        returns (\n            uint256, /*netYtIn*/\n            uint256, /*netSyOut*/\n            uint256 /*netSyFee*/\n        )\n    {\n        Args5 memory a = Args5(_market, _index, _minSyOut, _blockTime);\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        ApproxParamsPtOut memory p = newApproxParamsPtOut(\n            _approx,\n            0,\n            calcMaxPtOut(comp, a.market.totalPt)\n        );\n\n        for (uint256 iter = 0; iter < p.maxIteration; ++iter) {\n            uint256 guess = nextGuess(p, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(a.market, comp, a.index, guess);\n\n            uint256 netAssetToRepay = a.index.syToAssetUp(netSyOwed);\n            uint256 netSyOut = a.index.assetToSy(guess - netAssetToRepay);\n\n            if (netSyOut >= a.minSyOut) {\n                p.guessMax = guess;\n                if (Math.isAGreaterApproxB(netSyOut, a.minSyOut, p.eps)) {\n                    return (guess, netSyOut, netSyFee);\n                }\n            } else {\n                p.guessMin = guess + 1;\n            }\n        }\n        revert Errors.ApproxFail();\n    }\n\n    struct Args6 {\n        MarketState market;\n        PYIndex index;\n        uint256 totalSyIn;\n        uint256 blockTime;\n    }\n\n    /**\n     * @dev algorithm:\n        - Bin search the amount of PT to swapExactOut\n        - Swap that amount of PT out\n        - Pair the remaining PT with the SY to add liquidity\n        - Stop when the ratio of PT / totalPt & SY / totalSy is approx\n        - guess & approx is for netPtFromSwap\n     */\n    function approxSwapSyToAddLiquidity(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _totalSyIn,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    )\n        internal\n        pure\n        returns (\n            uint256, /*netPtFromSwap*/\n            uint256, /*netSySwap*/\n            uint256 /*netSyFee*/\n        )\n    {\n        Args6 memory a = Args6(_market, _index, _totalSyIn, _blockTime);\n        require(a.market.totalLp != 0, \"no existing lp\");\n\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        ApproxParamsPtOut memory p = newApproxParamsPtOut(\n            _approx,\n            0,\n            calcMaxPtOut(comp, a.market.totalPt)\n        );\n\n        for (uint256 iter = 0; iter < p.maxIteration; ++iter) {\n            uint256 guess = nextGuess(p, iter);\n\n            (uint256 netSyIn, uint256 netSyFee, uint256 netSyToReserve) = calcSyIn(\n                a.market,\n                comp,\n                a.index,\n                guess\n            );\n\n            if (netSyIn > a.totalSyIn) {\n                p.guessMax = guess - 1;\n                continue;\n            }\n\n            uint256 syNumerator;\n            uint256 ptNumerator;\n\n            {\n                uint256 newTotalPt = a.market.totalPt.Uint() - guess;\n                uint256 netTotalSy = a.market.totalSy.Uint() + netSyIn - netSyToReserve;\n\n                // it is desired that\n                // netPtFromSwap / newTotalPt = netSyRemaining / netTotalSy\n                // which is equivalent to\n                // netPtFromSwap * netTotalSy = netSyRemaining * newTotalPt\n\n                ptNumerator = guess * netTotalSy;\n                syNumerator = (a.totalSyIn - netSyIn) * newTotalPt;\n            }\n\n            if (Math.isAApproxB(ptNumerator, syNumerator, p.eps)) {\n                return (guess, netSyIn, netSyFee);\n            }\n\n            if (ptNumerator <= syNumerator) {\n                // needs more PT\n                p.guessMin = guess + 1;\n            } else {\n                // needs less PT\n                p.guessMax = guess - 1;\n            }\n        }\n        revert Errors.ApproxFail();\n    }\n\n    struct Args8 {\n        MarketState market;\n        PYIndex index;\n        uint256 exactYtIn;\n        uint256 blockTime;\n        uint256 maxSyPayable;\n    }\n\n    /**\n     * @dev algorithm:\n        - Bin search the amount of PT to swapExactOut\n        - Flashswap that amount of PT out\n        - Pair all the PT with the YT to redeem SY\n        - Use the SY to repay the flashswap debt\n        - Stop when the amount of SY owed is smaller approx the amount of SY to repay the flashswap\n        - guess & approx is for netPtFromSwap\n     */\n    function approxSwapExactYtForPt(\n        MarketState memory _market,\n        PYIndex _index,\n        uint256 _exactYtIn,\n        uint256 _blockTime,\n        ApproxParams memory _approx\n    )\n        internal\n        pure\n        returns (\n            uint256, /*netPtOut*/\n            uint256, /*totalPtSwapped*/\n            uint256 /*netSyFee*/\n        )\n    {\n        Args8 memory a = Args8(\n            _market,\n            _index,\n            _exactYtIn,\n            _blockTime,\n            _index.assetToSy(_exactYtIn)\n        );\n        MarketPreCompute memory comp = a.market.getMarketPreCompute(a.index, a.blockTime);\n        ApproxParamsPtOut memory p = newApproxParamsPtOut(\n            _approx,\n            a.exactYtIn,\n            calcMaxPtOut(comp, a.market.totalPt)\n        );\n\n        for (uint256 iter = 0; iter < p.maxIteration; ++iter) {\n            uint256 guess = nextGuess(p, iter);\n\n            (uint256 netSyOwed, uint256 netSyFee, ) = calcSyIn(a.market, comp, a.index, guess);\n\n            if (netSyOwed <= a.maxSyPayable) {\n                p.guessMin = guess;\n\n                if (Math.isASmallerApproxB(netSyOwed, a.maxSyPayable, p.eps)) {\n                    return (guess - a.exactYtIn, guess, netSyFee);\n                }\n            } else {\n                p.guessMax = guess - 1;\n            }\n        }\n        revert Errors.ApproxFail();\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n\n    function calcSyIn(\n        MarketState memory market,\n        MarketPreCompute memory comp,\n        PYIndex index,\n        uint256 netPtOut\n    )\n        internal\n        pure\n        returns (\n            uint256 netSyIn,\n            uint256 netSyFee,\n            uint256 netSyToReserve\n        )\n    {\n        (int256 _netSyIn, int256 _netSyFee, int256 _netSyToReserve) = market.calcTrade(\n            comp,\n            index,\n            netPtOut.Int()\n        );\n\n        netSyIn = _netSyIn.abs();\n        netSyFee = _netSyFee.Uint();\n        netSyToReserve = _netSyToReserve.Uint();\n    }\n\n    function newApproxParamsPtOut(\n        ApproxParams memory _approx,\n        uint256 minGuessMin,\n        uint256 maxGuessMax\n    ) internal pure returns (ApproxParamsPtOut memory res) {\n        if (_approx.guessMin > _approx.guessMax || _approx.eps > Math.ONE)\n            revert Errors.ApproxParamsInvalid(_approx.guessMin, _approx.guessMax, _approx.eps);\n\n        res.guessMin = Math.max(_approx.guessMin, minGuessMin);\n        res.guessMax = Math.min(_approx.guessMax, maxGuessMax);\n\n        if (res.guessMin > res.guessMax)\n            revert Errors.ApproxBinarySearchInputInvalid(\n                _approx.guessMin,\n                _approx.guessMax,\n                minGuessMin,\n                maxGuessMax\n            );\n\n        res.guessOffchain = _approx.guessOffchain;\n        res.maxIteration = _approx.maxIteration;\n        res.eps = _approx.eps;\n    }\n\n    function calcMaxPtOut(MarketPreCompute memory comp, int256 totalPt)\n        internal\n        pure\n        returns (uint256)\n    {\n        int256 logitP = (comp.feeRate - comp.rateAnchor).mulDown(comp.rateScalar).exp();\n        int256 proportion = logitP.divDown(logitP + Math.IONE);\n        int256 numerator = proportion.mulDown(totalPt + comp.totalAsset);\n        int256 maxPtOut = totalPt - numerator;\n        // only get 99.9% of the theoretical max to accommodate some precision issues\n        return (maxPtOut.Uint() * 999) / 1000;\n    }\n\n    /**\n     * @dev it is safe to assume that p.guessMin <= p.guessMax from the initialization of p\n     * So once guessMin becomes larger, it should always be the case of ApproxFail\n     */\n    function nextGuess(ApproxParamsPtOut memory p, uint256 iter) private pure returns (uint256) {\n        if (iter == 0 && p.guessOffchain != 0) return p.guessOffchain;\n        if (p.guessMin <= p.guessMax) return (p.guessMin + p.guessMax) / 2;\n        revert Errors.ApproxFail();\n    }\n}\n"
    },
    "contracts/pendle/contracts/router/kyberswap/IAggregatorRouterHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.17;\n\ninterface IAggregationRouterHelper {\n    function getScaledInputData(bytes calldata kybercall, uint256 newAmount)\n        external\n        pure\n        returns (bytes memory);\n}\n"
    },
    "contracts/pendle/contracts/router/kyberswap/KyberSwapHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../core/libraries/TokenHelper.sol\";\nimport \"./IAggregatorRouterHelper.sol\";\nimport \"../../core/libraries/Errors.sol\";\n\nstruct TokenInput {\n    // Token/Sy data\n    address tokenIn;\n    uint256 netTokenIn;\n    address tokenMintSy;\n    address bulk;\n    // Kyber data\n    address kyberRouter;\n    bytes kybercall;\n}\n\nstruct TokenOutput {\n    // Token/Sy data\n    address tokenOut;\n    uint256 minTokenOut;\n    address tokenRedeemSy;\n    address bulk;\n    // Kyber data\n    address kyberRouter;\n    bytes kybercall;\n}\n\nabstract contract KyberSwapHelper is TokenHelper {\n    using Address for address;\n\n    address public immutable kyberScalingLib;\n\n    constructor(address _kyberScalingLib) {\n        kyberScalingLib = _kyberScalingLib;\n    }\n\n    function _kyberswap(\n        address tokenIn,\n        uint256 amountIn,\n        address kyberRouter,\n        bytes memory rawKybercall\n    ) internal {\n        if (kyberRouter == address(0) || rawKybercall.length == 0)\n            revert Errors.RouterKyberSwapDataZero();\n\n        _safeApproveInf(tokenIn, kyberRouter);\n\n        bytes memory kybercall = IAggregationRouterHelper(kyberScalingLib).getScaledInputData(\n            rawKybercall,\n            amountIn\n        );\n        kyberRouter.functionCallWithValue(kybercall, tokenIn == NATIVE ? amountIn : 0);\n    }\n}\n"
    },
    "contracts/pendle/contracts/router/PendleRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"../interfaces/IPAllAction.sol\";\nimport \"../interfaces/IPMarketSwapCallback.sol\";\nimport \"../core/libraries/Errors.sol\";\n\n/// @dev this contract will be deployed behind an ERC1967 proxy\n/// calls to the ERC1967 proxy will be resolved at this contract, and proxied again to the\n/// corresponding implementation contracts\n\n// solhint-disable no-empty-blocks\ncontract PendleRouter is Proxy {\n    address public immutable ACTION_MINT_REDEEM;\n    address public immutable ACTION_ADD_REMOVE_LIQ;\n    address public immutable ACTION_SWAP_PT;\n    address public immutable ACTION_SWAP_YT;\n    address public immutable ACTION_SWAP_PTYT;\n    address public immutable ACTION_CALLBACK;\n    address public immutable ACTION_MISC;\n\n    constructor(\n        address _ACTION_MINT_REDEEM,\n        address _ACTION_ADD_REMOVE_LIQ,\n        address _ACTION_SWAP_PT,\n        address _ACTION_SWAP_YT,\n        address _ACTION_SWAP_PTYT,\n        address _ACTION_CALLBACK,\n        address _ACTION_MISC\n    ) {\n        ACTION_MINT_REDEEM = _ACTION_MINT_REDEEM;\n        ACTION_ADD_REMOVE_LIQ = _ACTION_ADD_REMOVE_LIQ;\n        ACTION_SWAP_PT = _ACTION_SWAP_PT;\n        ACTION_SWAP_YT = _ACTION_SWAP_YT;\n        ACTION_SWAP_PTYT = _ACTION_SWAP_PTYT;\n        ACTION_CALLBACK = _ACTION_CALLBACK;\n        ACTION_MISC = _ACTION_MISC;\n    }\n\n    receive() external payable virtual override {}\n\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\n        if (\n            sig == IPActionMintRedeem.mintSyFromToken.selector ||\n            sig == IPActionMintRedeem.redeemSyToToken.selector ||\n            sig == IPActionMintRedeem.mintPyFromToken.selector ||\n            sig == IPActionMintRedeem.redeemPyToToken.selector ||\n            sig == IPActionMintRedeem.mintPyFromSy.selector ||\n            sig == IPActionMintRedeem.redeemPyToSy.selector ||\n            sig == IPActionMintRedeem.redeemDueInterestAndRewards.selector ||\n            sig == IPActionMintRedeem.redeemDueInterestAndRewardsThenSwapAll.selector\n        ) {\n            return ACTION_MINT_REDEEM;\n        } else if (\n            sig == IPActionAddRemoveLiq.addLiquidityDualSyAndPt.selector ||\n            sig == IPActionAddRemoveLiq.addLiquidityDualTokenAndPt.selector ||\n            sig == IPActionAddRemoveLiq.addLiquiditySinglePt.selector ||\n            sig == IPActionAddRemoveLiq.addLiquiditySingleSy.selector ||\n            sig == IPActionAddRemoveLiq.addLiquiditySingleToken.selector ||\n            sig == IPActionAddRemoveLiq.removeLiquidityDualSyAndPt.selector ||\n            sig == IPActionAddRemoveLiq.removeLiquidityDualTokenAndPt.selector ||\n            sig == IPActionAddRemoveLiq.removeLiquiditySinglePt.selector ||\n            sig == IPActionAddRemoveLiq.removeLiquiditySingleSy.selector ||\n            sig == IPActionAddRemoveLiq.removeLiquiditySingleToken.selector\n        ) {\n            return ACTION_ADD_REMOVE_LIQ;\n        } else if (\n            sig == IPActionSwapPT.swapExactPtForSy.selector ||\n            sig == IPActionSwapPT.swapPtForExactSy.selector ||\n            sig == IPActionSwapPT.swapSyForExactPt.selector ||\n            sig == IPActionSwapPT.swapExactSyForPt.selector ||\n            sig == IPActionSwapPT.swapExactTokenForPt.selector ||\n            sig == IPActionSwapPT.swapExactPtForToken.selector\n        ) {\n            return ACTION_SWAP_PT;\n        } else if (\n            sig == IPActionSwapYT.swapExactYtForSy.selector ||\n            sig == IPActionSwapYT.swapSyForExactYt.selector ||\n            sig == IPActionSwapYT.swapExactSyForYt.selector ||\n            sig == IPActionSwapYT.swapExactTokenForYt.selector ||\n            sig == IPActionSwapYT.swapExactYtForToken.selector ||\n            sig == IPActionSwapYT.swapYtForExactSy.selector\n        ) {\n            return ACTION_SWAP_YT;\n        } else if (\n            sig == IPActionSwapPTYT.swapExactPtForYt.selector ||\n            sig == IPActionSwapPTYT.swapExactYtForPt.selector\n        ) {\n            return ACTION_SWAP_PTYT;\n        } else if (sig == IPMarketSwapCallback.swapCallback.selector) {\n            return ACTION_CALLBACK;\n        } else if (sig == IPActionMisc.consult.selector) {\n            return ACTION_MISC;\n        }\n        revert Errors.RouterInvalidAction(sig);\n    }\n\n    function _implementation() internal view override returns (address) {\n        return getRouterImplementation(msg.sig);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 90000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}