{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/TPL/TPLMech/TPLMechCrafter.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {ERC165, IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport {ITPLRevealedParts} from \"../TPLRevealedParts/ITPLRevealedParts.sol\";\n\n/// @title TPLMechCrafter\n/// @author CyberBrokers\n/// @author dev by @dievardump\n/// @notice Contract containing the Mech Crafting logic: use 6 parts + one afterglow to get a mech!\ncontract TPLMechCrafter is Ownable {\n    error UserNotPartsOwner();\n    error InvalidBodyPart();\n    error InvalidPartsAmount();\n    error InvalidModelAmount();\n    error DelegationInactive();\n    error NotAuthorized();\n    error InvalidFees();\n\n    error ErrorWithdrawing();\n    error NothingToWithdraw();\n\n    error ErrorDisassemblyFeePayment();\n\n    error CraftingDisabled();\n    error InvalidLength();\n\n    /// @notice Emitted when a mech is assembled\n    /// @param id the mech id\n    /// @param partsIds the parts (body parts, afterglow) bitpacked\n    /// @param extraData extra data used when crafting\n    event MechAssembly(uint256 indexed id, uint256 partsIds, uint256 extraData);\n\n    address public immutable TPL_REVEALED;\n    address public immutable TPL_AFTERGLOW;\n    address public immutable TPL_MECH;\n    address public immutable TPL_PARTS_ESCROW;\n    address public immutable DELEGATE_REGISTRY;\n\n    uint256 public disassemblyFee;\n\n    address public disassemblyFeeRecipient;\n\n    bool public delegationActive;\n\n    bool public craftingPublic;\n\n    mapping(address => bool) public allowedCrafters;\n\n    /// @notice Mech IDs linked to Engine ID; Once an engine is used, it will always mint the same Mech ID\n    mapping(uint256 => uint256) public engineIds;\n\n    modifier craftingAllowed() {\n        if (!craftingPublic) {\n            if (!allowedCrafters[msg.sender]) {\n                revert CraftingDisabled();\n            }\n        }\n        _;\n    }\n\n    constructor(\n        address tplRevealed,\n        address tplAfterglow,\n        address tplMech,\n        address tplPartsEscrow,\n        address delegateRegistry,\n        address disassemblyFeeRecipient_,\n        uint256 disassemblyFee_\n    ) {\n        TPL_REVEALED = tplRevealed;\n        TPL_AFTERGLOW = tplAfterglow;\n        TPL_MECH = tplMech;\n        TPL_PARTS_ESCROW = tplPartsEscrow;\n\n        DELEGATE_REGISTRY = delegateRegistry;\n\n        disassemblyFeeRecipient = disassemblyFeeRecipient_;\n        disassemblyFee = disassemblyFee_;\n    }\n\n    /// @notice function allowing to parse the ExtraData sent with the mech build\n    /// @param extraData the extra data\n    /// @return seed the seed used for the name\n    /// @return colors the colors used for the parts\n    /// @return colorsActive the colors used for the parts\n    /// @return emissive whether emissive is topToBottom or bottomToTop\n    function parseExtraData(\n        uint256 extraData\n    ) external pure returns (uint256 seed, uint256[] memory colors, bool[] memory colorsActive, bool emissive) {\n        seed = extraData & 0xffffff;\n        extraData = extraData >> 24;\n\n        colors = new uint256[](5);\n        for (uint256 i; i < 5; i++) {\n            colors[i] = extraData & 0xffffff;\n            extraData = extraData >> 24;\n        }\n\n        colorsActive = new bool[](5);\n        for (uint256 i; i < 5; i++) {\n            colorsActive[i] = 1 == (extraData & 1);\n            extraData = extraData >> 4;\n        }\n\n        emissive = (extraData & 1) == 1;\n    }\n\n    /////////////////////////////////////////////////////////\n    // Actions                                             //\n    /////////////////////////////////////////////////////////\n\n    /// @notice Warning: This function should not be used directly from the contract. MechCrafting requires off-chain interactions\n    ///         before the crafting.\n    ///\n    ///         Allows a TPL Revealed Mech Parts owner to craft a new Mech by using their parts\n    /// @dev partsIds must be in the order of crafting (ARM_LEFT, ARM_RIGHT, ...) in order to make it less expensive\n    /// @param partsIds the token ids to use to craft the mech\n    /// @param afterglowId the afterglow id used on the mech\n    /// @param extraData the data about seed for name, colors, emissive, ...\n    function craft(uint256[] calldata partsIds, uint256 afterglowId, uint256 extraData) external craftingAllowed {\n        _craft(partsIds, afterglowId, msg.sender, extraData);\n    }\n\n    /// @notice Warning: This function should not be used directly from the contract. MechCrafting requires off-chain interactions\n    ///         before the crafting.\n    ///\n    ///         Allows a TPL Revealed Mech Parts owner to craft a new Mech by using their parts, with support of DelegateCash\n    ///\n    ///         requirements:\n    ///             - All parts MUST be owned by the vault\n    ///             - The afterglow MUST be owned by the vault\n    ///             - The caller must be delegate for `vault` globally or on the current contract\n    ///\n    ///         Note that the Mech will be minted to the Vault directly\n    ///\n    /// @dev partsIds must be in the order of crafting (ARM_LEFT, ARM_RIGHT, ...) in order to make it less expensive\n    /// @param partsIds the token ids to use to craft the mech\n    /// @param afterglowId the afterglow id used on the mech\n    /// @param extraData the data about seed for name, colors, emissive, ...\n    /// @param vault the vault the current wallet tries to mint for\n    function craftFor(\n        uint256[] calldata partsIds,\n        uint256 afterglowId,\n        uint256 extraData,\n        address vault\n    ) external craftingAllowed {\n        if (!delegationActive) {\n            revert DelegationInactive();\n        }\n\n        _requireDelegate(vault);\n\n        _craft(partsIds, afterglowId, vault, extraData);\n    }\n\n    /// @notice Allows a mech owner to dissasemble `mechId` and get back the parts & afterglow\n    /// @param mechId the mech id\n    function disassemble(uint256 mechId) external payable {\n        _disassemble(mechId, msg.sender);\n    }\n\n    /// @notice Allows a mech owner to dissasemble `mechId` and get back the parts & afterglow, with support of DelegateCash\n    /// @param mechId the mech id\n    function disassembleFor(uint256 mechId, address vault) external payable {\n        if (!delegationActive) {\n            revert DelegationInactive();\n        }\n\n        _requireDelegate(vault);\n\n        _disassemble(mechId, vault);\n    }\n\n    /////////////////////////////////////////////////////////\n    // Owner                                               //\n    /////////////////////////////////////////////////////////\n\n    /// @notice Allows owner to set the disassembly fee & fee recipient\n    /// @param newDisassemblyFeeRecipient the new fee recipient\n    /// @param newFee the new fee\n    function setDisassemblyFee(address newDisassemblyFeeRecipient, uint256 newFee) external onlyOwner {\n        disassemblyFeeRecipient = newDisassemblyFeeRecipient;\n        disassemblyFee = newFee;\n    }\n\n    /// @notice allows owner to activate or not interaction through delegate cash delegates\n    /// @param isActive if we activate or not\n    function setDelegationActive(bool isActive) external onlyOwner {\n        delegationActive = isActive;\n    }\n\n    /// @notice allows owner to add or remove addresses allowed to craft even when public crafting is not open\n    /// @param crafters the list of addresses to allow/disallow\n    /// @param allowed if we are giving or removing the right to craft\n    function setAllowedCrafters(address[] calldata crafters, bool allowed) external onlyOwner {\n        uint256 length = crafters.length;\n        if (length == 0) {\n            revert InvalidLength();\n        }\n\n        for (uint i; i < length; i++) {\n            allowedCrafters[crafters[i]] = allowed;\n        }\n    }\n\n    /// @notice allows owner to change the \"public crafting\" status\n    /// @param isPublic if the crafting is public or not\n    function setCraftingPublic(bool isPublic) external onlyOwner {\n        craftingPublic = isPublic;\n    }\n\n    /// @notice allows owner to withdraw the possible funds to `to`\n    function withdraw(address to) external onlyOwner {\n        uint256 balance = address(this).balance;\n\n        if (balance == 0) {\n            revert NothingToWithdraw();\n        }\n\n        (bool success, ) = to.call{value: balance}(\"\");\n        if (!success) {\n            revert ErrorWithdrawing();\n        }\n    }\n\n    /////////////////////////////////////////////////////////\n    // Internals                                           //\n    /////////////////////////////////////////////////////////\n\n    /// @dev crafts\n    function _craft(uint256[] calldata partsIds, uint256 afterglowId, address account, uint256 extraData) internal {\n        uint256 length = partsIds.length;\n        if (length != 6) {\n            revert InvalidPartsAmount();\n        }\n\n        // get all ids \"TokenData\"\n        ITPLRevealedParts.TokenData[] memory tokenPartsData = ITPLRevealedParts(TPL_REVEALED).partDataBatch(partsIds);\n\n        uint256 packedIds;\n        unchecked {\n            uint256 engineModel = tokenPartsData[5].model;\n            uint256 sameModelAsEngine;\n\n            // verifies we have all the needed body parts\n            // here we simply check that the bodyParts sent have the right types:\n            // [ARM, ARM, HEAD, BODY, LEGS, ENGINE] which is [0, 0, 1, 2, 3, 4]\n            // this is why they have to be sent in order\n            if (\n                tokenPartsData[0].bodyPart != 0 ||\n                tokenPartsData[1].bodyPart != 0 ||\n                tokenPartsData[2].bodyPart != 1 ||\n                tokenPartsData[3].bodyPart != 2 ||\n                tokenPartsData[4].bodyPart != 3 ||\n                tokenPartsData[5].bodyPart != 4\n            ) {\n                revert InvalidBodyPart();\n            }\n\n            do {\n                length--;\n                if (tokenPartsData[length].model == engineModel) {\n                    sameModelAsEngine++;\n                }\n\n                // builds the \"packedIds\" for the Mech to be able to store all the ids used to craft it\n                packedIds = packedIds | (partsIds[length] << (length * 32));\n            } while (length > 0);\n\n            // engine + at least 2 parts\n            if (sameModelAsEngine < 3) {\n                revert InvalidModelAmount();\n            }\n        }\n\n        // we add the afterglow id at the end\n        packedIds = packedIds | (afterglowId << (6 * 32));\n\n        // transfer all partsIds to TPL_PARTS_ESCROW\n        ITPLRevealedParts(TPL_REVEALED).batchTransferFrom(account, TPL_PARTS_ESCROW, partsIds);\n\n        // transfer the afterGlow to TPL_PARTS_ESCROW\n        IERC1155(TPL_AFTERGLOW).safeTransferFrom(account, TPL_PARTS_ESCROW, afterglowId, 1, \"\");\n\n        // then we mint the next Mech with the needed data\n        uint256 engineKnownId = engineIds[partsIds[5]];\n        if (engineKnownId != 0) {\n            ITPLMech(TPL_MECH).mintToken(engineKnownId, account, packedIds);\n        } else {\n            engineKnownId = ITPLMech(TPL_MECH).mintNext(account, packedIds);\n            engineIds[partsIds[5]] = engineKnownId;\n        }\n\n        emit MechAssembly(engineKnownId, packedIds, extraData);\n    }\n\n    function _disassemble(uint256 mechId, address account) internal {\n        if (msg.value != disassemblyFee) {\n            revert InvalidFees();\n        }\n\n        // make sure account is the owner of the mech.\n        if (account != ITPLMech(TPL_MECH).ownerOf(mechId)) {\n            revert NotAuthorized();\n        }\n\n        // get all ids used in the Mech assembly\n        (uint256[] memory partsIds, uint256 afterglowId) = ITPLMech(TPL_MECH).getMechPartsIds(mechId);\n\n        // burn the mech\n        ITPLMech(TPL_MECH).burn(mechId);\n\n        // batch transfer all IDs from ESCROW to account\n        ITPLRevealedParts(TPL_REVEALED).batchTransferFrom(TPL_PARTS_ESCROW, account, partsIds);\n\n        // transfer afterglow from ESCROW to account\n        IERC1155(TPL_AFTERGLOW).safeTransferFrom(TPL_PARTS_ESCROW, account, afterglowId, 1, \"\");\n\n        // if there is a fee\n        if (msg.value > 0) {\n            address disassemblyFeeRecipient_ = disassemblyFeeRecipient;\n            // and a fee recipient\n            if (disassemblyFeeRecipient_ != address(0)) {\n                // send directly\n                (bool success, ) = disassemblyFeeRecipient_.call{value: msg.value}(\"\");\n                if (!success) {\n                    revert ErrorDisassemblyFeePayment();\n                }\n            }\n        }\n    }\n\n    function _requireDelegate(address vault) internal view {\n        // checks that msg.sender is delegate for vault, either globally or for the current contract or for the RevealedParts contract\n        if (!IDelegateRegistry(DELEGATE_REGISTRY).checkDelegateForContract(msg.sender, vault, address(this))) {\n            if (!IDelegateRegistry(DELEGATE_REGISTRY).checkDelegateForContract(msg.sender, vault, TPL_REVEALED)) {\n                revert NotAuthorized();\n            }\n        }\n    }\n}\n\ninterface ITPLMech {\n    function mintNext(address to, uint256 packedIds) external returns (uint256);\n\n    function mintToken(uint256 tokenId, address to, uint256 packedIds) external;\n\n    function ownerOf(uint256 mechId) external view returns (address);\n\n    function burn(uint256 tokenId) external;\n\n    function getMechPartsIds(uint256 tokenId) external view returns (uint256[] memory, uint256);\n}\n\ninterface IDelegateRegistry {\n    /**\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param vault The cold wallet who issued the delegation\n     */\n    function checkDelegateForContract(address delegate, address vault, address contract_) external view returns (bool);\n}\n"
    },
    "src/TPL/TPLRevealedParts/ITPLRevealedParts.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {IBase721A} from \"../../utils/tokens/ERC721/IBase721A.sol\";\n\n/// @title ITPLRevealedParts\n/// @author CyberBrokers\n/// @author dev by @dievardump\n/// @notice Interface for the Revealed Parts contract.\ninterface ITPLRevealedParts is IBase721A {\n    struct TokenData {\n        uint256 generation;\n        uint256 originalId;\n        uint256 bodyPart;\n        uint256 model;\n        uint256[] stats;\n    }\n\n    /// @notice verifies that `account` owns all `tokenIds`\n    /// @param account the account\n    /// @param tokenIds the token ids to check\n    /// @return if account owns all tokens\n    function isOwnerOfBatch(address account, uint256[] calldata tokenIds) external view returns (bool);\n\n    /// @notice returns a Mech Part data (body part and original id)\n    /// @param tokenId the tokenId to check\n    /// @return the Mech Part data (body part and original id)\n    function partData(uint256 tokenId) external view returns (TokenData memory);\n\n    /// @notice returns a list of Mech Part data (body part and original id)\n    /// @param tokenIds the tokenIds to knoMechParts type of\n    /// @return a list of Mech Part data (body part and original id)\n    function partDataBatch(uint256[] calldata tokenIds) external view returns (TokenData[] memory);\n\n    /// @notice Allows to burn tokens in batch\n    /// @param tokenIds the tokens to burn\n    function burnBatch(uint256[] calldata tokenIds) external;\n\n    /// @notice Transfers the ownership of multiple NFTs from one address to another address\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenIds The NFTs to transfer\n    function batchTransferFrom(\n        address _from,\n        address _to,\n        uint256[] calldata _tokenIds\n    ) external;\n}\n"
    },
    "src/utils/tokens/ERC721/IBase721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ninterface IBase721A {\n    /// @notice Allows a `minter` to mint `amount` tokens to `to` with `extraData_`\n    /// @param to to whom we need to mint\n    /// @param amount how many to mint\n    /// @param extraData extraData for these items\n    function mintTo(\n        address to,\n        uint256 amount,\n        uint24 extraData\n    ) external;\n}\n"
    }
  }
}}