{{
  "language": "Solidity",
  "sources": {
    "contracts/collection/v2/arteQCollectionV2.sol": {
      "content": "/*\n * This file is part of the contracts written for artèQ Investment Fund (https://github.com/arteq-io/contracts).\n * Copyright (c) 2022 artèQ (https://arteq.io)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"../../arteq-tech/contracts/vaults/VaultsConfig.sol\";\nimport \"../../arteq-tech/contracts/diamond/DiamondV1.sol\";\nimport \"./arteQCollectionV2Config.sol\";\n\n/// @author Kam Amini <kam.cpp@gmail.com> <kam@arteq.io>\n///\n/// @notice Use at your own risk\n\n/* solhint-disable contract-name-camelcase */\ncontract arteQCollectionV2 is DiamondV1 {\n\n    string private _detailsURI;\n\n    modifier onlyAdmin {\n        RoleManagerLib._checkRole(arteQCollectionV2Config.ROLE_ADMIN);\n        _;\n    }\n\n    constructor(\n        address taskManager,\n        string memory detailsURI,\n        address[] memory admins,\n        address[] memory tokenManagers,\n        address[] memory vaultAdmins,\n        address[] memory diamondAdmins\n    ) DiamondV1(taskManager, diamondAdmins) {\n\n        // Admin role\n        for (uint i = 0; i < admins.length; i++) {\n            RoleManagerLib._grantRole(admins[i], arteQCollectionV2Config.ROLE_ADMIN);\n        }\n        // Token Manager role\n        for (uint i = 0; i < tokenManagers.length; i++) {\n            RoleManagerLib._grantRole(tokenManagers[i],arteQCollectionV2Config.ROLE_TOKEN_MANAGER);\n        }\n        // Vault Admin role\n        for (uint i = 0; i < vaultAdmins.length; i++) {\n            RoleManagerLib._grantRole(vaultAdmins[i], VaultsConfig.ROLE_VAULT_ADMIN);\n        }\n\n        _detailsURI = detailsURI;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n      public view override returns (bool) {\n        // We have to return true for OpenSea contract detection and caching mechanism\n        if (interfaceId == type(IERC721).interfaceId) {\n            return true;\n        }\n        return super.supportsInterface(interfaceId);\n    }\n\n    function getDetailsURI() external view returns (string memory) {\n        return _detailsURI;\n    }\n\n    function setDetailsURI(string memory newValue) external onlyAdmin {\n        _detailsURI = newValue;\n    }\n\n    /* solhint-disable no-complex-fallback */\n    fallback() external payable {\n        address facet = _findFacet(msg.sig);\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n\n    /* solhint-disable no-empty-blocks */\n    receive() external payable {\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/arteq-tech/contracts/vaults/VaultsConfig.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\nlibrary VaultsConfig {\n\n    uint256 public constant ROLE_VAULT_ADMIN = uint256(keccak256(bytes(\"ROLE_VAULT_ADMIN\")));\n}\n"
    },
    "contracts/arteq-tech/contracts/diamond/DiamondV1.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"../security/task-executor/TaskExecutorFacet.sol\";\nimport \"../security/task-executor/TaskExecutorLib.sol\";\nimport \"../security/role-manager/RoleManagerFacet.sol\";\nimport \"../security/role-manager/RoleManagerLib.sol\";\nimport \"./IDiamondFacet.sol\";\nimport \"./DiamondV1Config.sol\";\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\nabstract contract DiamondV1 is\n  IERC165,\n  TaskExecutorFacet,\n  RoleManagerFacet\n{\n    address[] private _facets;\n    mapping(address => uint256) private _facetArrayIndex;\n    mapping(bytes4 => address) private _selectorToFacetMap;\n    mapping(address => string[]) private _facetToFuncSigsMap;\n    mapping(address => mapping(bytes4 => bool)) private _removedFuncs;\n    mapping(bytes4 => bool) private _suppressedInterfaceIds;\n\n    modifier onlyDiamondAdmin() {\n        RoleManagerLib._checkRole(DiamondV1Config.ROLE_DIAMOND_ADMIN);\n        _;\n    }\n\n    constructor(\n        address taskManager,\n        address[] memory diamondAdmins\n    ) {\n        TaskExecutorLib._setTaskManager(taskManager);\n        for(uint i = 0; i < diamondAdmins.length; i++) {\n            RoleManagerLib._grantRole(diamondAdmins[i], DiamondV1Config.ROLE_DIAMOND_ADMIN);\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n      public view override virtual returns (bool) {\n        // Querying for IDiamondFacet must always return false\n        if (interfaceId == type(IDiamondFacet).interfaceId) {\n            return false;\n        }\n        if (_suppressedInterfaceIds[interfaceId]) {\n            return false;\n        }\n        // Always return true\n        if (interfaceId == type(IERC165).interfaceId) {\n            return true;\n        }\n        for (uint256 i = 0; i < _facets.length; i++) {\n            address facet = _facets[i];\n            if (IDiamondFacet(facet).supportsInterface(interfaceId)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isInterfaceIdSuppressed(bytes4 interfaceId)\n      external view onlyDiamondAdmin returns (bool) {\n        return _suppressedInterfaceIds[interfaceId];\n    }\n\n    function suppressInterfaceId(bytes4 interfaceId, bool suppress)\n      external onlyDiamondAdmin {\n        _suppressedInterfaceIds[interfaceId] = suppress;\n    }\n\n    function getFuncs()\n      external view onlyDiamondAdmin returns (string[] memory, address[] memory) {\n        return _getFuncs();\n    }\n\n    function getFacetFuncs(address facet)\n      external view onlyDiamondAdmin returns (string[] memory) {\n        return _getFacetFuncs(facet);\n    }\n\n    function addFuncs(\n        string[] memory funcSigs,\n        address[] memory facets\n    ) external onlyDiamondAdmin {\n        require(funcSigs.length > 0, \"DV1:ZL\");\n        require(funcSigs.length == facets.length, \"DV1:NEQL\");\n        for (uint256 i = 0; i < funcSigs.length; i++) {\n            string memory funcSig = funcSigs[i];\n            address facet = facets[i];\n            _addFunc(funcSig, facet);\n        }\n    }\n\n    function removeFuncs(\n        string[] memory funcSigs\n    ) external onlyDiamondAdmin {\n        require(funcSigs.length > 0, \"DV1:ZL\");\n        for (uint256 i = 0; i < funcSigs.length; i++) {\n            string memory funcSig = funcSigs[i];\n            _removeFunc(funcSig);\n        }\n    }\n\n    function _getFuncs() internal view returns (string[] memory, address[] memory) {\n        uint256 length = 0;\n        for (uint256 i = 0; i < _facets.length; i++) {\n            address facet = _facets[i];\n            string[] memory facetFuncs = _getFacetFuncs(facet);\n            for (uint256 j = 0; j < facetFuncs.length; j++) {\n                length += 1;\n            }\n        }\n        string[] memory funcSigs = new string[](length);\n        address[] memory facets = new address[](length);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _facets.length; i++) {\n            address facet = _facets[i];\n            string[] memory facetFuncs = _getFacetFuncs(facet);\n            for (uint256 j = 0; j < facetFuncs.length; j++) {\n                funcSigs[index] = facetFuncs[j];\n                facets[index] = facet;\n                index += 1;\n            }\n        }\n        return (funcSigs, facets);\n    }\n\n    function _getFacetFuncs(address facet) internal view returns (string[] memory) {\n        uint256 length = 0;\n        for (uint256 j = 0; j < _facetToFuncSigsMap[facet].length; j++) {\n            string memory funcSig = _facetToFuncSigsMap[facet][j];\n            bytes4 selector = __getSelector(funcSig);\n            if (!_removedFuncs[facet][selector]) {\n                length += 1;\n            }\n        }\n        string[] memory funcSigs = new string[](length);\n        uint256 index = 0;\n        for (uint256 j = 0; j < _facetToFuncSigsMap[facet].length; j++) {\n            string memory funcSig = _facetToFuncSigsMap[facet][j];\n            bytes4 selector = __getSelector(funcSig);\n            if (!_removedFuncs[facet][selector]) {\n                funcSigs[index] = funcSig;\n                index += 1;\n            }\n        }\n        return funcSigs;\n    }\n\n    function _addFunc(\n        string memory funcSig,\n        address facet\n    ) internal {\n        require(facet != address(0), \"DV1:ZF\");\n        require(\n            IDiamondFacet(facet).supportsInterface(type(IDiamondFacet).interfaceId),\n            \"DV1:IF\"\n        );\n        bytes4 selector = __getSelector(funcSig);\n        address oldFacet = _selectorToFacetMap[selector];\n\n         // overrides the previously set selector\n        _selectorToFacetMap[selector] = facet;\n\n        bool found = false;\n        for (uint256 i = 0; i < _facetToFuncSigsMap[facet].length; i++) {\n            bytes32 s = __getSelector(_facetToFuncSigsMap[facet][i]);\n            if (s == selector) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            _facetToFuncSigsMap[facet].push(funcSig); // add the func-sig to facet's map\n        }\n\n        _removedFuncs[facet][selector] = false; // revive the selector if already removed\n        if (oldFacet != address(0) && oldFacet != facet) {\n            _removedFuncs[oldFacet][selector] = true; // remove from the old facet\n        }\n\n        // update facets array\n        if (_facetArrayIndex[facet] == 0) {\n            _facets.push(facet);\n            _facetArrayIndex[facet] = _facets.length;\n        }\n    }\n\n    function _removeFunc(\n        string memory funcSig\n    ) internal {\n        bytes4 selector = __getSelector(funcSig);\n        address facet = _selectorToFacetMap[selector];\n        if (facet != address(0)) {\n            _removedFuncs[facet][selector] = true;\n        }\n    }\n\n    function _findFacet(bytes4 selector) internal view returns (address) {\n        address facet = _selectorToFacetMap[selector];\n        require(facet != address(0), \"DV1:FNF\");\n        require(!_removedFuncs[facet][selector], \"DV1:FR\");\n        return facet;\n    }\n\n    function __getSelector(string memory funcSig) private pure returns (bytes4) {\n        bytes memory funcSigBytes = bytes(funcSig);\n        for (uint256 i = 0; i < funcSigBytes.length; i++) {\n            bytes1 b = funcSigBytes[i];\n            if (\n                !(b >= 0x30 && b <= 0x39) && // [0-9]\n                !(b >= 0x41 && b <= 0x5a) && // [A-Z]\n                !(b >= 0x61 && b <= 0x7a) && // [a-z]\n                 b != 0x24 && // $\n                 b != 0x5f && // _\n                 b != 0x2c && // ,\n                 b != 0x28 && // (\n                 b != 0x29 && // )\n                 b != 0x5b && // [\n                 b != 0x5d    // ]\n            ) {\n                revert(\"DV1:IFS\");\n            }\n        }\n        return bytes4(keccak256(bytes(funcSig)));\n    }\n}\n"
    },
    "contracts/collection/v2/arteQCollectionV2Config.sol": {
      "content": "/*\n * This file is part of the contracts written for artèQ Investment Fund (https://github.com/arteq-io/contracts).\n * Copyright (c) 2022 artèQ (https://arteq.io)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\n\n/* solhint-disable contract-name-camelcase */\nlibrary arteQCollectionV2Config {\n\n    uint256 constant public ROLE_ADMIN = uint256(keccak256(bytes(\"ROLE_ADMIN\")));\n\n    uint256 constant public ROLE_TOKEN_MANAGER = uint256(keccak256(bytes(\"ROLE_TOKEN_MANAGER\")));\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "contracts/arteq-tech/contracts/security/task-executor/TaskExecutorFacet.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\nimport \"./TaskExecutorInternal.sol\";\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\ncontract TaskExecutorFacet {\n\n    function getTaskManager() external view returns (address) {\n        return TaskExecutorInternal._getTaskManager();\n    }\n\n    function setTaskManager(\n        uint256 adminTaskId,\n        address newTaskManager\n    ) external {\n        address oldTaskManager = TaskExecutorInternal._getTaskManager();\n        TaskExecutorInternal._setTaskManager(newTaskManager);\n        if (oldTaskManager != address(0)) {\n            ITaskExecutor(oldTaskManager).executeAdminTask(msg.sender, adminTaskId);\n        }\n    }\n}\n"
    },
    "contracts/arteq-tech/contracts/security/task-executor/TaskExecutorLib.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\nimport \"./TaskExecutorInternal.sol\";\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\nlibrary TaskExecutorLib {\n\n    function _setTaskManager(address newTaskManager) internal {\n        TaskExecutorInternal._setTaskManager(newTaskManager);\n    }\n\n    function _executeTask(uint256 taskId) internal {\n        TaskExecutorInternal._executeTask(taskId);\n    }\n}\n"
    },
    "contracts/arteq-tech/contracts/security/role-manager/RoleManagerFacet.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\nimport \"../task-executor/TaskExecutorLib.sol\";\nimport \"./RoleManagerInternal.sol\";\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\ncontract RoleManagerFacet {\n\n    function hasRole(\n        address account,\n        uint256 role\n    ) external view returns (bool) {\n        return RoleManagerInternal._hasRole2(account, role);\n    }\n\n    function grantRole(\n        uint256 taskId,\n        address account,\n        uint256 role\n    ) external {\n        RoleManagerInternal._grantRole(account, role);\n        TaskExecutorLib._executeTask(taskId);\n    }\n\n    function revokeRole(\n        uint256 taskId,\n        address account,\n        uint256 role\n    ) external {\n        RoleManagerInternal._revokeRole(account, role);\n        TaskExecutorLib._executeTask(taskId);\n    }\n}\n"
    },
    "contracts/arteq-tech/contracts/security/role-manager/RoleManagerLib.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\nimport \"./RoleManagerInternal.sol\";\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\nlibrary RoleManagerLib {\n\n    function _checkRole(uint256 role) internal view {\n        RoleManagerInternal._checkRole(role);\n    }\n\n    function _hasRole(uint256 role) internal view returns (bool) {\n        return RoleManagerInternal._hasRole(role);\n    }\n\n    function _grantRole(\n        address account,\n        uint256 role\n    ) internal {\n        RoleManagerInternal._grantRole(account, role);\n    }\n}\n"
    },
    "contracts/arteq-tech/contracts/diamond/IDiamondFacet.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\ninterface IDiamondFacet {\n\n    function getVersion() external view returns (string memory);\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/arteq-tech/contracts/diamond/DiamondV1Config.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\nlibrary DiamondV1Config {\n\n    uint256 public constant ROLE_DIAMOND_ADMIN = uint256(keccak256(bytes(\"ROLE_DIAMOND_ADMIN\")));\n}\n"
    },
    "contracts/arteq-tech/contracts/security/task-executor/TaskExecutorInternal.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"../../interfaces/ITaskExecutor.sol\";\nimport \"./TaskExecutorStorage.sol\";\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\nlibrary TaskExecutorInternal {\n\n    event TaskManagerChanged(address newTaskManager);\n\n    function _getTaskManager() internal view returns (address) {\n        return __s().taskManager;\n    }\n\n    function _setTaskManager(address newTaskManager) internal {\n        require(newTaskManager != address(0), \"TE:ZA\");\n        require(IERC165(newTaskManager).supportsInterface(type(ITaskExecutor).interfaceId),\n            \"TE:IC\");\n        __s().taskManager = newTaskManager;\n        emit TaskManagerChanged(__s().taskManager);\n    }\n\n    function _executeTask(uint256 taskId) internal {\n        require(__s().taskManager != address(0), \"TE:NTM\");\n        ITaskExecutor(__s().taskManager).executeTask(msg.sender, taskId);\n    }\n\n    function __s() private pure returns (TaskExecutorStorage.Layout storage) {\n        return TaskExecutorStorage.layout();\n    }\n}\n"
    },
    "contracts/arteq-tech/contracts/interfaces/ITaskExecutor.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\ninterface ITaskExecutor {\n\n    event TaskExecuted(address finalizer, address executor, uint256 taskId);\n\n    function executeTask(address executor, uint256 taskId) external;\n\n    function executeAdminTask(address executor, uint256 taskId) external;\n}\n"
    },
    "contracts/arteq-tech/contracts/security/task-executor/TaskExecutorStorage.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk. Just got the basic\n///         idea from: https://github.com/solidstate-network/solidstate-solidity\nlibrary TaskExecutorStorage {\n\n    struct Layout {\n        address taskManager;\n        mapping(uint256 => uint256) extra;\n    }\n\n    // Storage Slot: de1b6f91cd9572e4381a8b8d203bdc268664230f56599f11d2ca9df8d397fb6f\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"arteq-tech.contracts.security.task-executor.storage\");\n\n    function layout() internal pure returns (Layout storage s) {\n        bytes32 slot = STORAGE_SLOT;\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            s.slot := slot\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    },
    "contracts/arteq-tech/contracts/security/role-manager/RoleManagerInternal.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\nimport \"./RoleManagerStorage.sol\";\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk\nlibrary RoleManagerInternal {\n\n    event RoleGrant(uint256 role, address account);\n    event RoleRevoke(uint256 role, address account);\n\n    function _checkRole(uint256 role) internal view {\n        require(__s().roles[role][msg.sender], \"RM:MR\");\n    }\n\n    function _hasRole(uint256 role) internal view returns (bool) {\n        return __s().roles[role][msg.sender];\n    }\n\n    function _hasRole2(\n        address account,\n        uint256 role\n    ) internal view returns (bool) {\n        return __s().roles[role][account];\n    }\n\n    function _grantRole(\n        address account,\n        uint256 role\n    ) internal {\n        require(!__s().roles[role][account], \"RM:AHR\");\n        __s().roles[role][account] = true;\n        emit RoleGrant(role, account);\n    }\n\n    function _revokeRole(\n        address account,\n        uint256 role\n    ) internal {\n        require(__s().roles[role][account], \"RM:DNHR\");\n        __s().roles[role][account] = false;\n        emit RoleRevoke(role, account);\n    }\n\n    function __s() private pure returns (RoleManagerStorage.Layout storage) {\n        return RoleManagerStorage.layout();\n    }\n}\n"
    },
    "contracts/arteq-tech/contracts/security/role-manager/RoleManagerStorage.sol": {
      "content": "/*\n * This file is part of the artèQ Technologies contracts (https://github.com/arteq-tech/contracts).\n * Copyright (c) 2022 artèQ Technologies (https://arteq.tech)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n// SPDX-License-Identifier: GNU General Public License v3.0\n\npragma solidity 0.8.1;\n\n/// @author Kam Amini <kam@arteq.io>\n///\n/// @notice Use at your own risk. Just got the basic\n///         idea from: https://github.com/solidstate-network/solidstate-solidity\nlibrary RoleManagerStorage {\n\n    struct Layout {\n        mapping (uint256 => mapping(address => bool)) roles;\n        mapping(uint256 => uint256) extra;\n    }\n\n    // Storage Slot: d6cfccebecf684bbc10a5019ad1aed91fbc4f7461f5cd03e8c71240be4ca6bea\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256(\"arteq-tech.contracts.security.role-manager.storage\");\n\n    function layout() internal pure returns (Layout storage s) {\n        bytes32 slot = STORAGE_SLOT;\n        /* solhint-disable no-inline-assembly */\n        assembly {\n            s.slot := slot\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}