{{
  "language": "Solidity",
  "sources": {
    "contracts/common/EIP2535/Diamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport { IDiamondLoupe } from \"./interfaces/IDiamondLoupe.sol\";\nimport { IERC173 } from \"./interfaces/IERC173.sol\";\nimport { IERC165 } from \"./interfaces/IERC165.sol\";\n\n// solhint-disable no-complex-fallback\n// solhint-disable no-inline-assembly\n// solhint-disable no-empty-blocks\n\n// When no function exists for function called\nerror FunctionNotFound(bytes4 _functionSelector);\n\n// This is used in diamond constructor\n// more arguments are added to this struct\n// this avoids stack too deep errors\nstruct DiamondArgs {\n  address owner;\n  address init;\n  bytes initCalldata;\n}\n\ncontract Diamond {\n  constructor(IDiamondCut.FacetCut[] memory _diamondCut, DiamondArgs memory _args) payable {\n    LibDiamond.setContractOwner(_args.owner);\n    LibDiamond.diamondCut(_diamondCut, _args.init, _args.initCalldata);\n\n    // Code can be added here to perform actions and set state variables.\n  }\n\n  // Find facet for function that is called and execute the\n  // function if a facet is found and return any value.\n  fallback() external payable {\n    LibDiamond.DiamondStorage storage ds;\n    bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n    // get diamond storage\n    assembly {\n      ds.slot := position\n    }\n    // get facet from function selector\n    address facet = ds.facetAddressAndSelectorPosition[msg.sig].facetAddress;\n    if (facet == address(0)) {\n      revert FunctionNotFound(msg.sig);\n    }\n    // Execute external function from facet using delegatecall and return any value.\n    assembly {\n      // copy function selector and any arguments\n      calldatacopy(0, 0, calldatasize())\n      // execute function call using the facet\n      let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n      // get any return value\n      returndatacopy(0, 0, returndatasize())\n      // return any return value or error back to the caller\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  receive() external payable {}\n}\n"
    },
    "contracts/common/EIP2535/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n/******************************************************************************/\nimport { IDiamond } from \"../interfaces/IDiamond.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror NoSelectorsGivenToAdd();\nerror NotContractOwner(address _user, address _contractOwner);\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\nerror NoBytecodeAtAddress(address _contractAddress, string _message);\nerror IncorrectFacetCutAction(uint8 _action);\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\nerror CannotReplaceImmutableFunction(bytes4 _selector);\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\nerror CannotRemoveImmutableFunction(bytes4 _selector);\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n  bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n  struct FacetAddressAndSelectorPosition {\n    address facetAddress;\n    uint16 selectorPosition;\n  }\n\n  struct DiamondStorage {\n    // function selector => facet address and selector position in selectors array\n    mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\n    bytes4[] selectors;\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address contractOwner;\n  }\n\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n    bytes32 position = DIAMOND_STORAGE_POSITION;\n    assembly {\n      ds.slot := position\n    }\n  }\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function setContractOwner(address _newOwner) internal {\n    DiamondStorage storage ds = diamondStorage();\n    address previousOwner = ds.contractOwner;\n    ds.contractOwner = _newOwner;\n    emit OwnershipTransferred(previousOwner, _newOwner);\n  }\n\n  function contractOwner() internal view returns (address contractOwner_) {\n    contractOwner_ = diamondStorage().contractOwner;\n  }\n\n  function enforceIsContractOwner() internal view {\n    if (msg.sender != diamondStorage().contractOwner) {\n      revert NotContractOwner(msg.sender, diamondStorage().contractOwner);\n    }\n  }\n\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n  // Internal function version of diamondCut\n  function diamondCut(\n    IDiamondCut.FacetCut[] memory _diamondCut,\n    address _init,\n    bytes memory _calldata\n  ) internal {\n    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n      bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\n      address facetAddress = _diamondCut[facetIndex].facetAddress;\n      if (functionSelectors.length == 0) {\n        revert NoSelectorsProvidedForFacetForCut(facetAddress);\n      }\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n      if (action == IDiamond.FacetCutAction.Add) {\n        addFunctions(facetAddress, functionSelectors);\n      } else if (action == IDiamond.FacetCutAction.Replace) {\n        replaceFunctions(facetAddress, functionSelectors);\n      } else if (action == IDiamond.FacetCutAction.Remove) {\n        removeFunctions(facetAddress, functionSelectors);\n      } else {\n        revert IncorrectFacetCutAction(uint8(action));\n      }\n    }\n    emit DiamondCut(_diamondCut, _init, _calldata);\n    initializeDiamondCut(_init, _calldata);\n  }\n\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    if (_facetAddress == address(0)) {\n      revert CannotAddSelectorsToZeroAddress(_functionSelectors);\n    }\n    DiamondStorage storage ds = diamondStorage();\n    uint16 selectorCount = uint16(ds.selectors.length);\n    enforceHasContractCode(_facetAddress, \"LibDiamondCut: Add facet has no code\");\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n      if (oldFacetAddress != address(0)) {\n        revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\n      }\n      ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(_facetAddress, selectorCount);\n      ds.selectors.push(selector);\n      selectorCount++;\n    }\n  }\n\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    DiamondStorage storage ds = diamondStorage();\n    if (_facetAddress == address(0)) {\n      revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\n    }\n    enforceHasContractCode(_facetAddress, \"LibDiamondCut: Replace facet has no code\");\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n      // can't replace immutable functions -- functions defined directly in the diamond in this case\n      if (oldFacetAddress == address(this)) {\n        revert CannotReplaceImmutableFunction(selector);\n      }\n      if (oldFacetAddress == _facetAddress) {\n        revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\n      }\n      if (oldFacetAddress == address(0)) {\n        revert CannotReplaceFunctionThatDoesNotExists(selector);\n      }\n      // replace old facet address\n      ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\n    }\n  }\n\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n    DiamondStorage storage ds = diamondStorage();\n    uint256 selectorCount = ds.selectors.length;\n    if (_facetAddress != address(0)) {\n      revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\n    }\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n      bytes4 selector = _functionSelectors[selectorIndex];\n      FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds.facetAddressAndSelectorPosition[\n        selector\n      ];\n      if (oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\n        revert CannotRemoveFunctionThatDoesNotExist(selector);\n      }\n\n      // can't remove immutable functions -- functions defined directly in the diamond\n      if (oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\n        revert CannotRemoveImmutableFunction(selector);\n      }\n      // replace selector with last selector\n      selectorCount--;\n      if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\n        bytes4 lastSelector = ds.selectors[selectorCount];\n        ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\n        ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition\n          .selectorPosition;\n      }\n      // delete last selector\n      ds.selectors.pop();\n      delete ds.facetAddressAndSelectorPosition[selector];\n    }\n  }\n\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n    if (_init == address(0)) {\n      return;\n    }\n    enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\n    if (!success) {\n      if (error.length > 0) {\n        // bubble up error\n        /// @solidity memory-safe-assembly\n        assembly {\n          let returndata_size := mload(error)\n          revert(add(32, error), returndata_size)\n        }\n      } else {\n        revert InitializationFunctionReverted(_init, _calldata);\n      }\n    }\n  }\n\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n    uint256 contractSize;\n    assembly {\n      contractSize := extcodesize(_contract)\n    }\n    if (contractSize == 0) {\n      revert NoBytecodeAtAddress(_contract, _errorMessage);\n    }\n  }\n}\n"
    },
    "contracts/common/EIP2535/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n  /// @dev This emits when ownership of a contract changes.\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /// @notice Get the address of the owner\n  /// @return owner_ The address of the owner.\n  function owner() external view returns (address owner_);\n\n  /// @notice Set the address of the new owner of the contract\n  /// @dev Set _newOwner to address(0) to renounce any ownership.\n  /// @param _newOwner The address of the new owner of the contract\n  function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/common/EIP2535/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n  /// These functions are expected to be called frequently\n  /// by tools.\n\n  struct Facet {\n    address facetAddress;\n    bytes4[] functionSelectors;\n  }\n\n  /// @notice Gets all facet addresses and their four byte function selectors.\n  /// @return facets_ Facet\n  function facets() external view returns (Facet[] memory facets_);\n\n  /// @notice Gets all the function selectors supported by a specific facet.\n  /// @param _facet The facet address.\n  /// @return facetFunctionSelectors_\n  function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n  /// @notice Get all the facet addresses used by a diamond.\n  /// @return facetAddresses_\n  function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n  /// @notice Gets the facet that supports the given selector.\n  /// @dev If facet is not found return address(0).\n  /// @param _functionSelector The function selector.\n  /// @return facetAddress_ The facet address.\n  function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/common/EIP2535/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceId The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/common/EIP2535/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n/******************************************************************************/\n\nimport { IDiamond } from \"./IDiamond.sol\";\n\ninterface IDiamondCut is IDiamond {\n  /// @notice Add/replace/remove any number of functions and optionally execute\n  ///         a function with delegatecall\n  /// @param _diamondCut Contains the facet addresses and function selectors\n  /// @param _init The address of the contract or facet to execute _calldata\n  /// @param _calldata A function call, including function selector and arguments\n  ///                  _calldata is executed with delegatecall on _init\n  function diamondCut(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata\n  ) external;\n}\n"
    },
    "contracts/common/EIP2535/interfaces/IDiamond.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com>, Twitter/Github: @mudgen\n* EIP-2535 Diamonds\n/******************************************************************************/\n\ninterface IDiamond {\n  enum FacetCutAction {\n    Add,\n    Replace,\n    Remove\n  }\n  // Add=0, Replace=1, Remove=2\n\n  struct FacetCut {\n    address facetAddress;\n    FacetCutAction action;\n    bytes4[] functionSelectors;\n  }\n\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}