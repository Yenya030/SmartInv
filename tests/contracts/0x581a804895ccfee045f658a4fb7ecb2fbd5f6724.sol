{{
  "language": "Solidity",
  "sources": {
    "/contracts/SatoshiblesStacksBridgeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n *      ____        _            _     _ _     _\n *     / ___|  __ _| |_ ___  ___| |__ (_) |__ | | ___  ___\n *     \\___ \\ / _` | __/ _ \\/ __| '_ \\| | '_ \\| |/ _ \\/ __|\n *      ___) | (_| | || (_) \\__ \\ | | | | |_) | |  __/\\__ \\\n *     |____/ \\__,_|\\__\\___/|___/_| |_|_|_.__/|_|\\___||___/\n *      ____  _             _        ____       _     _\n *     / ___|| |_ __ _  ___| | _____| __ ) _ __(_) __| | __ _  ___\n *     \\___ \\| __/ _` |/ __| |/ / __|  _ \\| '__| |/ _` |/ _` |/ _ \\\n *      ___) | || (_| | (__|   <\\__ \\ |_) | |  | | (_| | (_| |  __/\n *     |____/ \\__\\__,_|\\___|_|\\_\\___/____/|_|  |_|\\__,_|\\__, |\\___|\n *                                                      |___/\n */\n\nimport \"./ERC721Receiver.sol\";\nimport \"./Interfaces.sol\";\nimport \"./MerkleProof.sol\";\nimport \"./OwnableSafe.sol\";\n\n/**\n * @title Satoshibles Stacks Bridge Lock\n * @notice NFT locker for the ethereum side of the Satoshibles Stacks Bridge\n * @author Aaron Hanson <coffee.becomes.code@gmail.com>\n * The StacksBridge can be used at https://stacksbridge.com/\n */\ncontract SatoshiblesStacksBridgeLock is OwnableSafe, ERC721Receiver {\n\n    /// Maximum number of tokens that can be locked/released in one tx\n    uint256 public constant MAX_BATCH_SIZE = 50;\n\n    /// Satoshibles contract instance\n    IERC721 public immutable SATOSHIBLE_CONTRACT;\n\n    /// Bridge worker address\n    address public worker;\n\n    /// Whether the bridge is open overall\n    bool public bridgeIsOpen;\n\n    /// Whether the bridge is open to the public\n    bool public bridgeIsOpenToPublic;\n\n    /// Gas escrow fee paid per locked token, to cover gas when releasing\n    uint256 public gasEscrowFee;\n\n    /// Merkle root summarizing all accounts with early access\n    bytes32 public earlyAccessMerkleRoot;\n\n    /// Tracks number of early access tickets used per address\n    mapping(address => uint256) public earlyAccessTicketsUsed;\n\n    /**\n     * @notice Emitted when the bridgeIsOpen flag changes\n     * @param isOpen Whether the bridge is now open overall\n     */\n    event BridgeStateChanged(\n        bool indexed isOpen\n    );\n\n    /**\n     * @notice Emitted when the bridgeIsOpenToPublic flag changes\n     * @param isOpenToPublic Whether the bridge is now open to the public\n     */\n    event BridgePublicStateChanged(\n        bool indexed isOpenToPublic\n    );\n\n    /**\n     * @notice Emitted when a Satoshible is locked (bridging to Stacks)\n     * @param tokenId The satoshible token ID\n     * @param ethereumSender The sender's eth address\n     * @param stacksReceiver The receiver's stacks address\n     */\n    event Locked(\n        uint256 indexed tokenId,\n        address indexed ethereumSender,\n        string stacksReceiver\n    );\n\n    /**\n     * @notice Requires the bridge to be open\n     */\n    modifier onlyWhenBridgeIsOpen()\n    {\n        require(\n            bridgeIsOpen == true,\n            \"Bridge is not open\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Requires the bridge to be open to the public\n     */\n    modifier onlyWhenBridgeIsOpenToPublic()\n    {\n        require(\n            bridgeIsOpen == true && bridgeIsOpenToPublic == true,\n            \"Bridge is not open to public\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Requires msg.sender to be the bridge worker address\n     */\n    modifier onlyWorker()\n    {\n        require(\n             _msgSender() == worker,\n            \"Caller is not the worker\"\n        );\n        _;\n    }\n\n    /**\n     * @param _immutableSatoshible The Satoshible contract address\n     * @param _worker The bridge worker address\n     * @param _earlyAccessMerkleRoot The initial early access merkle root\n     */\n    constructor(\n        address _immutableSatoshible,\n        address _worker,\n        bytes32 _earlyAccessMerkleRoot\n    ) {\n        SATOSHIBLE_CONTRACT = IERC721(\n            _immutableSatoshible\n        );\n\n        worker = _worker;\n        earlyAccessMerkleRoot = _earlyAccessMerkleRoot;\n        bridgeIsOpen = true;\n    }\n\n    /**\n     * @notice Locks one or more satoshibles to bridge to Stacks\n     * @param _tokenIds The satoshible token IDs\n     * @param _stacksReceiver The stacks address to receive the satoshibles\n     */\n    function lock(\n        uint256[] calldata _tokenIds,\n        string calldata _stacksReceiver\n    )\n        external\n        payable\n        onlyWhenBridgeIsOpenToPublic\n    {\n        _lock(\n            _tokenIds,\n            _stacksReceiver\n        );\n    }\n\n    /**\n     * @notice Locks one or more satoshibles to bridge to Stacks (early access)\n     * @param _tokenIds The satoshible token IDs\n     * @param _stacksReceiver The stacks address to receive the satoshibles\n     * @param _earlyAccessTickets The total early access tickets for _account\n     * @param _proof The merkle proof to be verified\n     */\n    function lockEarlyAccess(\n        uint256[] calldata _tokenIds,\n        string calldata _stacksReceiver,\n        uint256 _earlyAccessTickets,\n        bytes32[] calldata _proof\n    )\n        external\n        payable\n        onlyWhenBridgeIsOpen\n    {\n        require(\n            verifyEarlyAccessTickets(\n                _msgSender(),\n                _earlyAccessTickets,\n                _proof\n            ) == true,\n            \"Invalid early access proof\"\n        );\n\n        unchecked {\n            require(\n                earlyAccessTicketsUsed[_msgSender()] + _tokenIds.length\n                    <= _earlyAccessTickets,\n                \"Not enough tickets remaining\"\n            );\n\n            earlyAccessTicketsUsed[_msgSender()] += _tokenIds.length;\n        }\n\n        _lock(\n            _tokenIds,\n            _stacksReceiver\n        );\n    }\n\n    /**\n     * @notice Releases one or more satoshibles after bridging from Stacks\n     * @param _tokenIds The satoshible token IDs\n     * @param _receiver The eth address to receive the satoshibles\n     */\n    function release(\n        uint256[] calldata _tokenIds,\n        address _receiver\n    )\n        external\n        onlyWorker\n        onlyWhenBridgeIsOpen\n    {\n        require(\n            _tokenIds.length > 0,\n            \"No token IDs specified\"\n        );\n\n        require(\n            _tokenIds.length <= MAX_BATCH_SIZE,\n            \"Too many token IDs (max 50)\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _tokenIds.length; i++) {\n                SATOSHIBLE_CONTRACT.safeTransferFrom(\n                    address(this),\n                    _receiver,\n                    _tokenIds[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Opens or closes the bridge overall\n     * @param _isOpen Whether to open or close the bridge overall\n     */\n    function setBridgeIsOpen(\n        bool _isOpen\n    )\n        external\n        onlyOwner\n    {\n        bridgeIsOpen = _isOpen;\n\n        emit BridgeStateChanged(\n            _isOpen\n        );\n    }\n\n    /**\n     * @notice Opens or closes the bridge to the public\n     * @param _isOpenToPublic Whether to open or close the bridge to the public\n     */\n    function setBridgeIsOpenToPublic(\n        bool _isOpenToPublic\n    )\n        external\n        onlyOwner\n    {\n        bridgeIsOpenToPublic = _isOpenToPublic;\n\n        emit BridgePublicStateChanged(\n            _isOpenToPublic\n        );\n    }\n\n    /**\n     * @notice Sets a new earlyAccessMerkleRoot\n     * @param _newMerkleRoot The new merkle root\n     */\n    function setEarlyAccessMerkleRoot(\n        bytes32 _newMerkleRoot\n    )\n        external\n        onlyOwner\n    {\n        earlyAccessMerkleRoot = _newMerkleRoot;\n    }\n\n    /**\n     * @notice Sets a new worker address\n     * @param _newWorker The new worker address\n     */\n    function setWorker(\n        address _newWorker\n    )\n        external\n        onlyOwner\n    {\n        worker = _newWorker;\n    }\n\n    /**\n     * @notice Sets a new gas escrow fee\n     * @param _newGasEscrowFee The new gas escrow fee amount (in wei)\n     */\n    function setGasEscrowFee(\n        uint256 _newGasEscrowFee\n    )\n        external\n        onlyOwner\n    {\n        gasEscrowFee = _newGasEscrowFee;\n    }\n\n    /**\n     * @notice Transfers gas escrow ether to worker address\n     * @param _amount The amount to transfer (in wei)\n     */\n    function transferGasEscrowToWorker(\n        uint256 _amount\n    )\n        external\n        onlyOwner\n    {\n        payable(worker).transfer(\n            _amount\n        );\n    }\n\n    /**\n     * @notice Withdraws any ERC20 tokens in case of accidental transfers\n     * @dev WARNING: Double check token transfer function\n     * @param _token The contract address of token\n     * @param _to The address to which to withdraw\n     * @param _amount The amount to withdraw\n     * @param _hasVerifiedToken Must be true (sanity check)\n     */\n    function withdrawERC20(\n        address _token,\n        address _to,\n        uint256 _amount,\n        bool _hasVerifiedToken\n    )\n        external\n        onlyOwner\n    {\n        require(\n            _hasVerifiedToken == true,\n            \"Need to verify token\"\n        );\n\n        IERC20(_token).transfer(\n            _to,\n            _amount\n        );\n    }\n\n    /**\n     * @notice Withdraws any ERC721 tokens in case of accidental transfers\n     * @dev WARNING: Double check token safeTransferFrom function\n     * @param _token The contract address of token\n     * @param _to The address to which to withdraw\n     * @param _tokenIds The token IDs to withdraw\n     * @param _hasVerifiedToken Must be true (sanity check)\n     */\n    function withdrawERC721(\n        address _token,\n        address _to,\n        uint256[] calldata _tokenIds,\n        bool _hasVerifiedToken\n    )\n        external\n        onlyOwner\n    {\n        require(\n            _hasVerifiedToken == true,\n            \"Need to verify token\"\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < _tokenIds.length; i++) {\n                IERC721(_token).safeTransferFrom(\n                    address(this),\n                    _to,\n                    _tokenIds[i]\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Verifies the merkle proof of an account's early access tickets\n     * @param _account The account to verify\n     * @param _earlyAccessTickets The total early access tickets for _account\n     * @param _proof The merkle proof to be verified\n     * @return isVerified True if the merkle proof is verified\n     */\n    function verifyEarlyAccessTickets(\n        address _account,\n        uint256 _earlyAccessTickets,\n        bytes32[] calldata _proof\n    )\n        public\n        view\n        returns (bool isVerified)\n    {\n        bytes32 node = keccak256(\n            abi.encodePacked(\n                _account,\n                _earlyAccessTickets\n            )\n        );\n\n        isVerified = MerkleProof.verify(\n            _proof,\n            earlyAccessMerkleRoot,\n            node\n        );\n    }\n\n    /**\n     * @dev Locks one or more satoshibles to bridge to Stacks\n     * @param _tokenIds The satoshible token IDs\n     * @param _stacksReceiver The stacks address to receive the satoshibles\n     */\n    function _lock(\n        uint256[] calldata _tokenIds,\n        string calldata _stacksReceiver\n    )\n        private\n    {\n        require(\n            _tokenIds.length > 0,\n            \"No token IDs specified\"\n        );\n\n        require(\n            _tokenIds.length <= MAX_BATCH_SIZE,\n            \"Too many token IDs (max 50)\"\n        );\n\n        unchecked {\n            require(\n                msg.value == gasEscrowFee * _tokenIds.length,\n                \"Incorrect gas escrow ether\"\n            );\n\n            for (uint256 i = 0; i < _tokenIds.length; i++) {\n                uint256 tokenId = _tokenIds[i];\n\n                SATOSHIBLE_CONTRACT.safeTransferFrom(\n                    _msgSender(),\n                    address(this),\n                    tokenId\n                );\n\n                emit Locked(\n                    tokenId,\n                    _msgSender(),\n                    _stacksReceiver\n                );\n            }\n        }\n    }\n}\n"
    },
    "/contracts/OwnableSafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n// With renounceOwnership() removed\n\npragma solidity ^0.8.10;\n\nimport \"./ContextSimple.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableSafe is ContextSimple {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "/contracts/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nlibrary MerkleProof {\n    /**\n     * @dev Verifies a merkle proof for a root and leaf node\n     * @param _proof The merkle proof to verify\n     * @param _root The merkle root\n     * @param _leaf The leaf node\n     * @return isVerified True if the merkle proof is verified\n     */\n    function verify(\n        bytes32[] memory _proof,\n        bytes32 _root,\n        bytes32 _leaf\n    )\n        internal\n        pure\n        returns (bool isVerified)\n    {\n        bytes32 computedHash = _leaf;\n\n        unchecked {\n            for (uint256 i = 0; i < _proof.length; i++) {\n                bytes32 proofElement = _proof[i];\n\n                if (computedHash <= proofElement) {\n                    computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n                } else {\n                    computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n                }\n            }\n        }\n\n        isVerified = computedHash == _root;\n    }\n}"
    },
    "/contracts/Interfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\ninterface IERC20 {\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\ninterface IERC721 {\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n}"
    },
    "/contracts/ERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @notice ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract ERC721Receiver {\n\n    /**\n     * @notice ERC721 token receiver interface\n     * @dev Interface for any contract that wants to support safeTransfers\n     * from ERC721 asset contracts.\n     */\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (bytes4)\n    {\n        return 0x150b7a02;\n    }\n}\n"
    },
    "/contracts/ContextSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Based on OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n// With _msgData() removed\n\npragma solidity ^0.8.10;\n\n/**\n * @dev Provides the msg.sender in the current execution context.\n */\nabstract contract ContextSimple {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}