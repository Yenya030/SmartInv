{{
  "language": "Solidity",
  "sources": {
    "/src/contracts/SaleUtopiaNFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./AggregatorV3Interface.sol\";\nimport \"./Ownable.sol\";\nimport \"./ReentrancyGuard.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./MerkleProof.sol\";\n\ninterface IUtopia {\n    function mint(address to, uint256 qty) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n}\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ninterface IERC721 {\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n}\n\ncontract SaleUtopiaNFTV2 is Ownable, ReentrancyGuard, IERC721Receiver {\n    // treasuryAddr\n    address public treasuryAddr;\n    // Utopia SC collection\n    IUtopia public immutable utopia;\n    // Price Feed\n    AggregatorV3Interface public priceFeed;\n    // Current Phase\n    uint8 public currentPhaseId;\n    // Info of each phase.\n    struct PhaseInfo {\n        uint256 priceInUSDPerNFT;\n        uint256 priceInUSDPerNFTWithoutWhiteList;\n        uint256 maxTotalSales;\n        uint256 maxSalesPerWallet;\n        bool whiteListRequired;\n        bool phasePriceInUSD;\n        uint256 priceInWeiPerNFT;\n        uint256 priceInWeiPerNFTWithoutWhiteList;\n    }\n    // Phases Info\n    PhaseInfo[] public phasesInfo;\n    // Phases Total Sales\n    mapping(uint256 => uint256) public phasesTotalSales;\n    // Phases Wallet Sales\n    mapping(uint256 => mapping(address => uint256)) public phasesWalletSales;\n    // AllowList\n    bytes32 public allowlistMerkleRoot;\n    // AllowedToBuyWithCreditCard\n    mapping(address => bool) public allowedToBuyWithCreditCard;\n\n    event AddPhase(uint256 indexed _priceInUSDPerNFT, uint256 indexed _priceInUSDPerNFTWithoutWhiteList, uint256 _maxTotalSales, uint256 _maxSalesPerWallet, bool _whiteListRequired, bool _phasePriceInUSD, uint256 _priceInWeiPerNFT, uint256 _priceInWeiPerNFTWithoutWhiteList);\n    event EditPhase(uint8 indexed _phaseId, uint256 indexed _priceInUSDPerNFT, uint256 _priceInUSDPerNFTWithoutWhiteList, uint256 _maxTotalSales, uint256 _maxSalesPerWallet, bool _whiteListRequired, bool _phasePriceInUSD, uint256 _priceInWeiPerNFT, uint256 _priceInWeiPerNFTWithoutWhiteList);\n    event ChangeCurrentPhase(uint8 indexed _phaseId);\n    event ChangePriceFeedAddress(address indexed _priceFeedAddress);\n    event Buy(uint256 indexed quantity, address indexed to);\n    event BuyWithCreditCard(uint256 indexed quantity, address indexed to);\n    event SetAllowlistMerkleRoot(bytes32 indexed _allowlistMerkleRoot);\n    event SetTreasury(address indexed _treasuryAddr);\n    event WithdrawMoney();\n    event SetAddressToBuyWithCreditCardAllowed(address indexed _account, bool indexed _canBuy);\n\n    modifier onlyAllowListed(bytes32[] calldata _merkleProof, address _to) {\n        PhaseInfo storage phase = phasesInfo[currentPhaseId];\n\n        if (phase.whiteListRequired) {\n            require(_to == msg.sender, \"In this phase it is mandatory that you can only mint to your own wallet\");\n            bool passMerkle = checkMerkleProof(_merkleProof, _to);\n            require(passMerkle, \"Not allowListed\");\n        }\n        _;\n    }\n\n    modifier onlyBuyWithCreditCardAllowedUsers() {\n        require(allowedToBuyWithCreditCard[msg.sender], \"You can't buy with credit card ;)\");\n        _;\n    }\n\n    constructor(\n        IUtopia _utopia,\n        address _treasuryAddr,\n        address _priceFeedAddress,\n        uint8 _currentPhaseId\n    ) {\n        require(address(_utopia) != address(0));\n        require(_treasuryAddr != address(0));\n        require(_priceFeedAddress != address(0));\n\n        utopia = _utopia;\n        treasuryAddr = _treasuryAddr;\n        priceFeed = AggregatorV3Interface(_priceFeedAddress);\n        currentPhaseId = _currentPhaseId;\n    }\n\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    function phasesInfoLength() public view returns (uint256) {\n        return phasesInfo.length;\n    }\n\n    function checkMerkleProof(bytes32[] calldata _merkleProof, address _to) public view virtual returns (bool) {\n        bytes32 leaf = keccak256(abi.encodePacked(_to));\n        return MerkleProof.verify(_merkleProof, allowlistMerkleRoot, leaf);\n    }\n\n    function setCurrentPhase(uint8 _currentPhaseId) external onlyOwner {\n        require(_currentPhaseId < phasesInfoLength(), \"you cannot activate a phase that does not yet exist\");\n        currentPhaseId = _currentPhaseId;\n        emit ChangeCurrentPhase(_currentPhaseId);\n    }\n\n    function changePriceFeedAddress(address _priceFeedAddress) external onlyOwner {\n        require(_priceFeedAddress != address(0));\n        priceFeed = AggregatorV3Interface(_priceFeedAddress);\n        emit ChangePriceFeedAddress(_priceFeedAddress);\n    }\n\n    function addPhase(uint256 _priceInUSDPerNFT, uint256 _priceInUSDPerNFTWithoutWhiteList, uint256 _maxTotalSales, uint256 _maxSalesPerWallet, bool _whiteListRequired, bool _phasePriceInUSD, uint256 _priceInWeiPerNFT, uint256 _priceInWeiPerNFTWithoutWhiteList) external onlyOwner {\n        phasesInfo.push(PhaseInfo({\n            priceInUSDPerNFT: _priceInUSDPerNFT,\n            priceInUSDPerNFTWithoutWhiteList: _priceInUSDPerNFTWithoutWhiteList,\n            maxTotalSales: _maxTotalSales,\n            maxSalesPerWallet: _maxSalesPerWallet,\n            whiteListRequired: _whiteListRequired,\n            phasePriceInUSD: _phasePriceInUSD,\n            priceInWeiPerNFT: _priceInWeiPerNFT,\n            priceInWeiPerNFTWithoutWhiteList: _priceInWeiPerNFTWithoutWhiteList\n        }));\n\n        emit AddPhase(_priceInUSDPerNFT, _priceInUSDPerNFTWithoutWhiteList, _maxTotalSales, _maxSalesPerWallet, _whiteListRequired, _phasePriceInUSD, _priceInWeiPerNFT, _priceInWeiPerNFTWithoutWhiteList);\n    }\n\n    function editPhase(uint8 _phaseId, uint256 _priceInUSDPerNFT, uint256 _priceInUSDPerNFTWithoutWhiteList, uint256 _maxTotalSales, uint256 _maxSalesPerWallet, bool _whiteListRequired, bool _phasePriceInUSD, uint256 _priceInWeiPerNFT, uint256 _priceInWeiPerNFTWithoutWhiteList) external onlyOwner {\n        require(_phaseId < phasesInfoLength(), \"you cannot edit a phase that does not exist\");\n        require(phasesInfo[_phaseId].priceInUSDPerNFT >= _priceInUSDPerNFT, \"Utopia:priceInUSDPerNFT: the price must be equal to or below the previous price\");\n        require(phasesInfo[_phaseId].priceInUSDPerNFTWithoutWhiteList >= _priceInUSDPerNFTWithoutWhiteList, \"Utopia:priceInUSDPerNFTWithoutWhiteList: the price must be equal to or below the previous price\");\n        require(phasesInfo[_phaseId].priceInWeiPerNFT >= _priceInWeiPerNFT, \"Utopia:priceInWeiPerNFT: the price must be equal to or below the previous price\");\n        require(phasesInfo[_phaseId].priceInWeiPerNFTWithoutWhiteList >= _priceInWeiPerNFTWithoutWhiteList, \"Utopia:priceInWeiPerNFTWithoutWhiteList: the price must be equal to or below the previous price\");\n\n        phasesInfo[_phaseId].priceInUSDPerNFT = _priceInUSDPerNFT;\n        phasesInfo[_phaseId].priceInUSDPerNFTWithoutWhiteList = _priceInUSDPerNFTWithoutWhiteList;\n        phasesInfo[_phaseId].maxTotalSales = _maxTotalSales;\n        phasesInfo[_phaseId].maxSalesPerWallet = _maxSalesPerWallet;\n        phasesInfo[_phaseId].whiteListRequired = _whiteListRequired;\n        phasesInfo[_phaseId].phasePriceInUSD = _phasePriceInUSD;\n        phasesInfo[_phaseId].priceInWeiPerNFT = _priceInWeiPerNFT;\n        phasesInfo[_phaseId].priceInWeiPerNFTWithoutWhiteList = _priceInWeiPerNFTWithoutWhiteList;\n\n        emit EditPhase(_phaseId, _priceInUSDPerNFT, _priceInUSDPerNFTWithoutWhiteList, _maxTotalSales, _maxSalesPerWallet, _whiteListRequired, _phasePriceInUSD, _priceInWeiPerNFT, _priceInWeiPerNFTWithoutWhiteList);\n    }\n\n    function getLatestPrice() public view returns (int) {\n        (\n            ,\n            int price,\n            ,\n            ,\n\n        ) = priceFeed.latestRoundData();\n\n        return (\n            price\n        );\n    }\n\n    function setAllowlistMerkleRoot(bytes32 _allowlistMerkleRoot) external onlyOwner {\n        allowlistMerkleRoot = _allowlistMerkleRoot;\n        emit SetAllowlistMerkleRoot(_allowlistMerkleRoot);\n    }\n\n    function setAddressToBuyWithCreditCardAllowed(address _account, bool _canBuy) external onlyOwner {\n        allowedToBuyWithCreditCard[_account] = _canBuy;\n        emit SetAddressToBuyWithCreditCardAllowed(_account, _canBuy);\n    }\n\n    function setTreasury(address _treasuryAddr) external onlyOwner {\n        treasuryAddr = _treasuryAddr;\n        emit SetTreasury(_treasuryAddr);\n    }\n\n    function withdrawMoney() external onlyOwner {\n        (bool success, ) = treasuryAddr.call{value: address(this).balance}(\"\");\n        require(success, \"Transfer failed.\");\n        emit WithdrawMoney();\n    }\n\n    function transferGuardedNfts(uint256[] memory tokensId, address[] memory addresses) external onlyOwner\n    {\n        require(\n            addresses.length == tokensId.length,\n            \"addresses does not match tokensId length\"\n        );\n\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            utopia.transferFrom(address(this), addresses[i], tokensId[i]);\n        }\n    }\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external virtual onlyOwner {\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\n    }\n\n    function recoverERC721TransferFrom(address nftAddress, address to, uint256 tokenId) external virtual onlyOwner {\n        IERC721(nftAddress).transferFrom(address(this), to, tokenId);\n    }\n\n    function buyWithCreditCard(uint256 _quantity, address _to) external onlyBuyWithCreditCardAllowedUsers nonReentrant {\n        PhaseInfo storage phase = phasesInfo[currentPhaseId];\n\n        require(phase.maxTotalSales >= phasesTotalSales[currentPhaseId] + _quantity, \"this phase does not allow this purchase\");\n\n        phasesTotalSales[currentPhaseId] = phasesTotalSales[currentPhaseId] + _quantity;\n\n        utopia.mint(_to, _quantity);\n\n        emit BuyWithCreditCard(_quantity, _to);\n    }\n\n    function buy(uint256 _quantity, address _to, bytes32[] calldata _merkleProof) external payable nonReentrant onlyAllowListed(_merkleProof, _to) {\n        uint256 totalPrice;\n        uint256 priceInUSD;\n        uint256 priceInWei;\n\n        require(phasesInfo[currentPhaseId].maxTotalSales >= phasesTotalSales[currentPhaseId] + _quantity, \"this phase does not allow this purchase\");\n        require(phasesInfo[currentPhaseId].maxSalesPerWallet >= phasesWalletSales[currentPhaseId][_to] + _quantity, \"you can not buy as many NFTs in this phase\");\n\n        if (checkMerkleProof(_merkleProof, _to)) {\n            priceInUSD = phasesInfo[currentPhaseId].priceInUSDPerNFT;\n            priceInWei = phasesInfo[currentPhaseId].priceInWeiPerNFT;\n        } else {\n            priceInUSD = phasesInfo[currentPhaseId].priceInUSDPerNFTWithoutWhiteList;\n            priceInWei = phasesInfo[currentPhaseId].priceInWeiPerNFTWithoutWhiteList;\n        }\n\n        if (phasesInfo[currentPhaseId].phasePriceInUSD) {\n            uint256 totalPriceInUSD = priceInUSD * _quantity * 1e8 * 1e18;\n\n            (\n            int ethPrice\n            ) = getLatestPrice();\n\n            uint256 ethPrice256 = uint256(ethPrice);\n            totalPrice = (totalPriceInUSD * 1e24) / (ethPrice256 * 1e24);\n        } else {\n            totalPrice = priceInWei * _quantity;\n        }\n\n        phasesTotalSales[currentPhaseId] = phasesTotalSales[currentPhaseId] + _quantity;\n        phasesWalletSales[currentPhaseId][_to] = phasesWalletSales[currentPhaseId][_to] + _quantity;\n\n        refundIfOver(totalPrice);\n        (bool success, ) = treasuryAddr.call{value: address(this).balance}(\"\");\n        require(success);\n        utopia.mint(_to, _quantity);\n\n        emit Buy(_quantity, _to);\n    }\n\n    function refundIfOver(uint256 price) private {\n        require(msg.value >= price, \"Need to send more ETH.\");\n        if (msg.value > price) {\n            (bool success, ) = msg.sender.call{value: msg.value - price}(\"\");\n            require(success);\n        }\n    }\n\n}"
    },
    "/src/contracts/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    "/src/contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"
    },
    "/src/contracts/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.13;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "/src/contracts/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.13;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "/src/contracts/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}"
    },
    "/src/contracts/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    );\n\n    function latestRoundData()\n    external\n    view\n    returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    );\n}"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "evmVersion": "london",
    "libraries": {},
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}