{{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/gauges/AbsGauge.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/ILT.sol\";\nimport \"../interfaces/IGaugeController.sol\";\nimport \"../interfaces/IVotingEscrow.sol\";\nimport \"../interfaces/IMinter.sol\";\nimport \"light-lib/contracts/LibTime.sol\";\n\nabstract contract AbsGauge is Ownable2Step {\n    event Deposit(address indexed provider, uint256 value);\n    event Withdraw(address indexed provider, uint256 value);\n    event UpdateLiquidityLimit(\n        address user,\n        uint256 originalBalance,\n        uint256 originalSupply,\n        uint256 workingBalance,\n        uint256 workingSupply,\n        uint256 votingBalance,\n        uint256 votingTotal\n    );\n    event SetPermit2Address(address oldAddress, address newAddress);\n\n    uint256 internal constant _TOKENLESS_PRODUCTION = 40;\n    uint256 internal constant _DAY = 86400;\n    uint256 internal constant _WEEK = _DAY * 7;\n\n    bool public isKilled;\n    // pool lp token\n    address public lpToken;\n\n    //Contracts\n    IMinter public minter;\n    // lt_token\n    ILT public ltToken;\n    //IERC20 public template;\n    IGaugeController public controller;\n    IVotingEscrow public votingEscrow;\n\n    uint256 public futureEpochTime;\n\n    mapping(address => uint256) public workingBalances;\n    uint256 public workingSupply;\n\n    // The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\n    // All values are kept in units of being multiplied by 1e18\n    uint256 public period; //modified from \"int256 public period\" since it never be minus.\n\n    // uint256[100000000000000000000000000000] public period_timestamp;\n    mapping(uint256 => uint256) public periodTimestamp;\n\n    //uint256[100_000_000_000_000_000_000_000_000_000] public periodTimestamp;\n\n    // 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\n    // bump epoch when rate() changes\n    mapping(uint256 => uint256) integrateInvSupply;\n\n    // 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\n    mapping(address => uint256) public integrateInvSupplyOf;\n    mapping(address => uint256) public integrateCheckpointOf;\n\n    // ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n    // Units rate * t = already number of coins per address to issue\n    mapping(address => uint256) public integrateFraction; //Mintable Token amount (include minted amount)\n\n    uint256 public inflationRate;\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    function _init(address _lpAddr, address _minter, address _owner) internal {\n        require(_lpAddr != address(0), \"CE000\");\n        require(_minter != address(0), \"CE000\");\n        require(_owner != address(0), \"CE000\");\n        require(!_initialized, \"Initializable: contract is already initialized\");\n        _initialized = true;\n\n        _transferOwnership(_owner);\n\n        lpToken = _lpAddr;\n        minter = IMinter(_minter);\n        address _ltToken = minter.token();\n        ltToken = ILT(_ltToken);\n        controller = IGaugeController(minter.controller());\n        votingEscrow = IVotingEscrow(controller.votingEscrow());\n        periodTimestamp[0] = block.timestamp;\n        inflationRate = ltToken.rate();\n        futureEpochTime = ltToken.futureEpochTimeWrite();\n    }\n\n    /***\n     * @notice Calculate limits which depend on the amount of lp Token per-user.\n     *        Effectively it calculates working balances to apply amplification\n     *        of LT production by LT\n     * @param _addr User address\n     * @param _l User's amount of liquidity (LP tokens)\n     * @param _L Total amount of liquidity (LP tokens)\n     */\n    function _updateLiquidityLimit(address _addr, uint256 _l, uint256 _L) internal {\n        // To be called after totalSupply is updated\n        uint256 _votingBalance = votingEscrow.balanceOfAtTime(_addr, block.timestamp);\n        uint256 _votingTotal = votingEscrow.totalSupplyAtTime(block.timestamp);\n\n        uint256 _lim = (_l * _TOKENLESS_PRODUCTION) / 100;\n        if (_votingTotal > 0) {\n            // 0.4 * _l + 0.6 * _L * balance/total\n            _lim += (_L * _votingBalance * (100 - _TOKENLESS_PRODUCTION)) / _votingTotal / 100;\n        }\n\n        _lim = Math.min(_l, _lim);\n        uint256 _oldBal = workingBalances[_addr];\n        workingBalances[_addr] = _lim;\n        uint256 _workingSupply = workingSupply + _lim - _oldBal;\n        workingSupply = _workingSupply;\n\n        emit UpdateLiquidityLimit(_addr, _l, _L, _lim, _workingSupply, _votingBalance, _votingTotal);\n    }\n\n    //to avoid \"stack too deep\"\n    struct CheckPointParameters {\n        uint256 _period;\n        uint256 _periodTime;\n        uint256 _integrateInvSupply;\n        uint256 rate;\n        uint256 newRate;\n        uint256 prevFutureEpoch;\n    }\n\n    /***\n     * @notice Checkpoint for a user\n     * @param _addr User address\n     *\n     *This function does,\n     *1. Calculate Iis for All: Calc and add Iis for every week. Iis only increses over time.\n     *2. Calculate Iu for _addr: Calc by (defferece between Iis(last time) and Iis(this time))* LP deposit amount of _addr(include  locking boost)\n     *\n     * working_supply & working_balance = total_supply & total_balance with  locking boost。\n     * Check whitepaper about Iis and Iu.\n     */\n    function _checkpoint(address _addr) internal {\n        CheckPointParameters memory _st;\n\n        _st._period = period;\n        _st._periodTime = periodTimestamp[_st._period];\n        _st._integrateInvSupply = integrateInvSupply[_st._period];\n        _st.rate = inflationRate;\n        _st.newRate = _st.rate;\n        _st.prevFutureEpoch = futureEpochTime;\n        if (_st.prevFutureEpoch >= _st._periodTime) {\n            //update future_epoch_time & inflation_rate\n            futureEpochTime = ltToken.futureEpochTimeWrite();\n            _st.newRate = ltToken.rate();\n            inflationRate = _st.newRate;\n        }\n        controller.checkpointGauge(address(this));\n\n        if (isKilled) {\n            // Stop distributing inflation as soon as killed\n            _st.rate = 0;\n        }\n\n        // Update integral of 1/supply\n        if (block.timestamp > _st._periodTime) {\n            uint256 _workingSupply = workingSupply;\n            uint256 _prevWeekTime = _st._periodTime;\n            uint256 _weekTime = Math.min(LibTime.timesRoundedByWeek(_st._periodTime + _WEEK), block.timestamp);\n            for (uint256 i; i < 500; i++) {\n                uint256 _dt = _weekTime - _prevWeekTime;\n                uint256 _w = controller.gaugeRelativeWeight(address(this), LibTime.timesRoundedByWeek(_prevWeekTime));\n\n                if (_workingSupply > 0) {\n                    if (_st.prevFutureEpoch >= _prevWeekTime && _st.prevFutureEpoch < _weekTime) {\n                        // If we went across one or multiple epochs, apply the rate\n                        // of the first epoch until it ends, and then the rate of\n                        // the last epoch.\n                        // If more than one epoch is crossed - the gauge gets less,\n                        // but that'd meen it wasn't called for more than 1 year\n                        _st._integrateInvSupply += (_st.rate * _w * (_st.prevFutureEpoch - _prevWeekTime)) / _workingSupply;\n                        _st.rate = _st.newRate;\n                        _st._integrateInvSupply += (_st.rate * _w * (_weekTime - _st.prevFutureEpoch)) / _workingSupply;\n                    } else {\n                        _st._integrateInvSupply += (_st.rate * _w * _dt) / _workingSupply;\n                    }\n                    // On precisions of the calculation\n                    // rate ~= 10e18\n                    // last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n                    // _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n                    // The largest loss is at dt = 1\n                    // Loss is 1e-9 - acceptable\n                }\n                if (_weekTime == block.timestamp) {\n                    break;\n                }\n                _prevWeekTime = _weekTime;\n                _weekTime = Math.min(_weekTime + _WEEK, block.timestamp);\n            }\n        }\n\n        _st._period += 1;\n        period = _st._period;\n        periodTimestamp[_st._period] = block.timestamp;\n        integrateInvSupply[_st._period] = _st._integrateInvSupply;\n\n        uint256 _workingBalance = workingBalances[_addr];\n        // Update user-specific integrals\n        // Calc the ΔIu of _addr and add it to Iu.\n        integrateFraction[_addr] += (_workingBalance * (_st._integrateInvSupply - integrateInvSupplyOf[_addr])) / 10 ** 18;\n        integrateInvSupplyOf[_addr] = _st._integrateInvSupply;\n        integrateCheckpointOf[_addr] = block.timestamp;\n    }\n\n    /***\n     * @notice Record a checkpoint for `_addr`\n     * @param _addr User address\n     * @return bool success\n     */\n    function userCheckpoint(address _addr) external returns (bool) {\n        require((msg.sender == _addr) || (msg.sender == address(minter)), \"GP000\");\n        _checkpoint(_addr);\n        _updateLiquidityLimit(_addr, lpBalanceOf(_addr), lpTotalSupply());\n        return true;\n    }\n\n    /***\n     * @notice Get the number of claimable tokens per user\n     * @dev This function should be manually changed to \"view\" in the ABI\n     * @return uint256 number of claimable tokens per user\n     */\n    function claimableTokens(address _addr) external returns (uint256) {\n        _checkpoint(_addr);\n        return (integrateFraction[_addr] - minter.minted(_addr, address(this)));\n    }\n\n    /***\n     * @notice Kick `_addr` for abusing their boost\n     * @dev Only if either they had another voting event, or their voting escrow lock expired\n     * @param _addr Address to kick\n     */\n    function kick(address _addr) external {\n        uint256 _tLast = integrateCheckpointOf[_addr];\n        uint256 _tVe = votingEscrow.userPointHistoryTs(_addr, votingEscrow.userPointEpoch(_addr));\n        uint256 _balance = lpBalanceOf(_addr);\n\n        require(votingEscrow.balanceOfAtTime(_addr, block.timestamp) == 0 || _tVe > _tLast, \"GP001\");\n        require(workingBalances[_addr] > (_balance * _TOKENLESS_PRODUCTION) / 100, \"GP001\");\n\n        _checkpoint(_addr);\n        _updateLiquidityLimit(_addr, lpBalanceOf(_addr), lpTotalSupply());\n    }\n\n    function integrateCheckpoint() external view returns (uint256) {\n        return periodTimestamp[period];\n    }\n\n    /***\n     * @notice Set the killed status for this contract\n     * @dev When killed, the gauge always yields a rate of 0 and so cannot mint LT\n     * @param _is_killed Killed status to set\n     */\n    function setKilled(bool _isKilled) external onlyOwner {\n        isKilled = _isKilled;\n    }\n\n    /***\n     * @notice The total amount of LP tokens that are currently deposited into the Gauge.\n     */\n    function lpBalanceOf(address _addr) public view virtual returns (uint256);\n\n    /***\n     * @notice The total amount of LP tokens that are currently deposited into the Gauge.\n     */\n    function lpTotalSupply() public view virtual returns (uint256);\n}\n"
    },
    "contracts/gauges/PoolGauge.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {TransferHelper} from \"light-lib/contracts/TransferHelper.sol\";\nimport \"./AbsGauge.sol\";\nimport {TransferHelper} from \"light-lib/contracts/TransferHelper.sol\";\n\ncontract PoolGauge is AbsGauge, ReentrancyGuard {\n    uint256 private constant _MAX_REWARDS = 8;\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n    // permit2 contract\n    address public permit2Address;\n    mapping(address => uint256) public balanceOf;\n    uint256 public totalSupply;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    // user -> [uint128 claimable amount][uint128 claimed amount]\n    mapping(address => mapping(address => uint256)) public claimData;\n    // For tracking external rewards\n    uint256 public rewardCount;\n    address[_MAX_REWARDS] public rewardTokens;\n    mapping(address => Reward) public rewardData;\n    // reward token -> claiming address -> integral\n    mapping(address => mapping(address => uint256)) public rewardIntegralFor;\n    // claimant -> default reward receiver\n    mapping(address => address) public rewardsReceiver;\n    address public factory;\n\n    struct Reward {\n        address token;\n        address distributor;\n        uint256 periodFinish;\n        uint256 rate;\n        uint256 lastUpdate;\n        uint256 integral;\n    }\n\n    // Claim pending rewards and checkpoint rewards for a user\n    struct CheckPointRewardsVars {\n        uint256 userBalance;\n        address receiver;\n        uint256 _rewardCount;\n        address token;\n        uint256 integral;\n        uint256 lastUpdate;\n        uint256 duration;\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event AddReward(address indexed sender, address indexed rewardToken, address indexed distributorAddress);\n    event ChangeRewardDistributor(\n        address sender,\n        address indexed rewardToken,\n        address indexed newDistributorAddress,\n        address oldDistributorAddress\n    );\n\n    constructor() {\n        factory = address(0xdead);\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _lpAddr, address _minter, address _permit2Address, address _owner) external {\n        require(factory == address(0), \"GP002\");\n        // sufficient check\n        factory = msg.sender;\n\n        _init(_lpAddr, _minter, _owner);\n\n        permit2Address = _permit2Address;\n        symbol = IERC20Metadata(_lpAddr).symbol();\n        decimals = IERC20Metadata(_lpAddr).decimals();\n        name = string(abi.encodePacked(symbol, \" Gauge\"));\n    }\n\n    /***\n     * @notice Deposit `_value` LP tokens\n     * @dev Depositting also claims pending reward tokens\n     * @param _value Number of tokens to deposit\n     * @param _addr Address to deposit for\n     */\n    function _deposit(\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _deadline,\n        bytes memory _signature,\n        address _addr,\n        bool _claimRewards_\n    ) private {\n        _checkpoint(_addr);\n\n        if (_value != 0) {\n            bool isRewards = rewardCount != 0;\n            uint256 _totalSupply = totalSupply;\n            if (isRewards) {\n                _checkpointRewards(_addr, _totalSupply, _claimRewards_, address(0));\n            }\n\n            _totalSupply += _value;\n            uint256 newBalance = balanceOf[_addr] + _value;\n            balanceOf[_addr] = newBalance;\n            totalSupply = _totalSupply;\n\n            _updateLiquidityLimit(_addr, newBalance, _totalSupply);\n\n            TransferHelper.doTransferIn(permit2Address, lpToken, _value, msg.sender, _nonce, _deadline, _signature);\n        }\n\n        emit Deposit(_addr, _value);\n        emit Transfer(address(0), _addr, _value);\n    }\n\n    /***\n     * @notice Deposit `_value` LP tokens\n     * @dev Depositting also claims pending reward tokens\n     * @param _value Number of tokens to deposit\n     * @param _nonce\n     * @param _deadline\n     * @param _signature\n     */\n    function deposit(uint256 _value, uint256 _nonce, uint256 _deadline, bytes memory _signature) external nonReentrant {\n        _deposit(_value, _nonce, _deadline, _signature, msg.sender, false);\n    }\n\n    /***\n     * @notice Deposit `_value` LP tokens\n     * @dev Depositting also claims pending reward tokens\n     * @param _value Number of tokens to deposit\n     * @param _nonce\n     * @param _deadline\n     * @param _signature\n     * @param _addr Address to deposit for\n     */\n    function deposit(uint256 _value, uint256 _nonce, uint256 _deadline, bytes memory _signature, address _addr) external nonReentrant {\n        _deposit(_value, _nonce, _deadline, _signature, _addr, false);\n    }\n\n    /***\n     * @notice Deposit `_value` LP tokens\n     * @dev Depositting also claims pending reward tokens\n     * @param _value Number of tokens to deposit\n     * @param _nonce\n     * @param _deadline\n     * @param _signature\n     * @param _addr Address to deposit for\n     * @param _claimRewards_ receiver\n     */\n    function deposit(\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _deadline,\n        bytes memory _signature,\n        address _addr,\n        bool _claimRewards_\n    ) external nonReentrant {\n        _deposit(_value, _nonce, _deadline, _signature, _addr, _claimRewards_);\n    }\n\n    /***\n     * @notice Withdraw `_value` LP tokens\n     * @dev Withdrawing also claims pending reward tokens\n     * @param _value Number of tokens to withdraw\n     */\n    function _withdraw(uint256 _value, bool _claimRewards_) private {\n        _checkpoint(msg.sender);\n\n        if (_value != 0) {\n            bool isRewards = rewardCount != 0;\n            uint256 _totalSupply = totalSupply;\n            if (isRewards) {\n                _checkpointRewards(msg.sender, _totalSupply, _claimRewards_, address(0));\n            }\n\n            _totalSupply -= _value;\n            uint256 newBalance = balanceOf[msg.sender] - _value;\n            balanceOf[msg.sender] = newBalance;\n            totalSupply = _totalSupply;\n\n            _updateLiquidityLimit(msg.sender, newBalance, _totalSupply);\n\n            TransferHelper.doTransferOut(lpToken, msg.sender, _value);\n        }\n\n        emit Withdraw(msg.sender, _value);\n        emit Transfer(msg.sender, address(0), _value);\n    }\n\n    function withdraw(uint256 _value) external nonReentrant {\n        _withdraw(_value, false);\n    }\n\n    function withdraw(uint256 _value, bool _claimRewards_) external nonReentrant {\n        _withdraw(_value, _claimRewards_);\n    }\n\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        _checkpoint(_from);\n        _checkpoint(_to);\n        if (_value != 0) {\n            uint256 _totalSupply = totalSupply;\n            bool isRewards = rewardCount != 0;\n            if (isRewards) {\n                _checkpointRewards(_from, _totalSupply, false, address(0));\n            }\n            uint256 newBalance = balanceOf[_from] - _value;\n            balanceOf[_from] = newBalance;\n            _updateLiquidityLimit(_from, newBalance, _totalSupply);\n\n            if (isRewards) {\n                _checkpointRewards(_to, _totalSupply, false, address(0));\n            }\n            newBalance = balanceOf[_to] + _value;\n            balanceOf[_to] = newBalance;\n            _updateLiquidityLimit(_to, newBalance, _totalSupply);\n        }\n\n        emit Transfer(_from, _to, _value);\n    }\n\n    /***\n     * @notice Transfer token for a specified address\n     * @dev Transferring claims pending reward tokens for the sender and receiver\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     */\n    function transfer(address _to, uint256 _value) external nonReentrant returns (bool) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /***\n    * @notice Transfer tokens from one address to another.\n    * @dev Transferring claims pending reward tokens for the sender and receiver\n    * @param _from address The address which you want to send tokens from\n    * @param _to address The address which you want to transfer to\n    * @param _value uint256 the amount of tokens to be transferred\n    \"\"\"\n    */\n    function transferFrom(address _from, address _to, uint256 _value) external nonReentrant returns (bool) {\n        uint256 _allowance = allowance[_from][msg.sender];\n        if (_allowance != type(uint256).max) {\n            allowance[_from][msg.sender] = _allowance - _value;\n        }\n\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /***\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"CE000\");\n        require(spender != address(0), \"CE000\");\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /***\n     * @notice Approve the passed address to transfer the specified amount of\n            tokens on behalf of msg.sender\n     * @dev Beware that changing an allowance via this method brings the risk\n         that someone may use both the old and new allowance by unfortunate\n         transaction ordering. This may be mitigated with the use of\n         {incraseAllowance} and {decreaseAllowance}.\n         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param _spender The address which will transfer the funds\n     * @param _value The amount of tokens that may be transferred\n     * @return bool success\n    */\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, _spender, _value);\n        return true;\n    }\n\n    /***\n     * @notice Increase the allowance granted to `_spender` by the caller\n     * @dev This is alternative to {approve} that can be used as a mitigation for the potential race condition\n     * @param _spender The address which will transfer the funds\n     * @param _addedValue The amount of to increase the allowance\n     * @return bool success\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        address owner = msg.sender;\n        _approve(owner, _spender, allowance[owner][_spender] + _addedValue);\n        return true;\n    }\n\n    /***\n     * @notice Decrease the allowance granted to `_spender` by the caller\n     * @dev This is alternative to {approve} that can be used as a mitigation for\n         the potential race condition\n     * @param _spender The address which will transfer the funds\n     * @param _subtractedValue The amount of to decrease the allowance\n     * @return bool success\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        address owner = msg.sender;\n        uint256 currentAllowance = allowance[owner][_spender];\n        require(currentAllowance >= _subtractedValue, \"GP003\");\n        unchecked {\n            _approve(owner, _spender, currentAllowance - _subtractedValue);\n        }\n        return true;\n    }\n\n    /***\n     * @notice Set the active reward contract\n     */\n    function addReward(address _rewardToken, address _distributor) external onlyOwner {\n        uint256 _rewardCount = rewardCount;\n        require(_rewardCount < _MAX_REWARDS, \"GP004\");\n        require(rewardData[_rewardToken].distributor == address(0), \"GP005\");\n        rewardData[_rewardToken].distributor = _distributor;\n        rewardTokens[_rewardCount] = _rewardToken;\n        rewardCount = _rewardCount + 1;\n        emit AddReward(msg.sender, _rewardToken, _distributor);\n    }\n\n    function setRewardDistributor(address _rewardToken, address _distributor) external {\n        address currentDistributor = rewardData[_rewardToken].distributor;\n        require(msg.sender == currentDistributor || msg.sender == owner(), \"GP006\");\n        require(currentDistributor != address(0), \"GP007\");\n        require(_distributor != address(0), \"GP008\");\n        rewardData[_rewardToken].distributor = _distributor;\n        emit ChangeRewardDistributor(msg.sender, _rewardToken, _distributor, currentDistributor);\n    }\n\n    function depositRewardToken(address _rewardToken, uint256 _amount) external payable nonReentrant {\n        require(msg.sender == rewardData[_rewardToken].distributor, \"GP009\");\n\n        _checkpointRewards(address(0), totalSupply, false, address(0));\n\n        uint256 spendAmount = TransferHelper.doTransferFrom(_rewardToken, msg.sender, address(this), _amount);\n\n        uint256 periodFinish = rewardData[_rewardToken].periodFinish;\n        if (block.timestamp >= periodFinish) {\n            rewardData[_rewardToken].rate = spendAmount / _WEEK;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardData[_rewardToken].rate;\n            rewardData[_rewardToken].rate = (spendAmount + leftover) / _WEEK;\n        }\n\n        rewardData[_rewardToken].lastUpdate = block.timestamp;\n        rewardData[_rewardToken].periodFinish = block.timestamp + _WEEK;\n    }\n\n    function _checkpointRewards(address _user, uint256 _totalSupply, bool _claim, address _receiver) internal {\n        CheckPointRewardsVars memory vars;\n        vars.userBalance = 0;\n        vars.receiver = _receiver;\n        if (_user != address(0)) {\n            vars.userBalance = balanceOf[_user];\n            if (_claim && _receiver == address(0)) {\n                // if receiver is not explicitly declared, check if a default receiver is set\n                vars.receiver = rewardsReceiver[_user];\n                if (vars.receiver == address(0)) {\n                    // if no default receiver is set, direct claims to the user\n                    vars.receiver = _user;\n                }\n            }\n        }\n\n        vars._rewardCount = rewardCount;\n        for (uint256 i = 0; i < _MAX_REWARDS; i++) {\n            if (i == vars._rewardCount) {\n                break;\n            }\n            vars.token = rewardTokens[i];\n\n            vars.integral = rewardData[vars.token].integral;\n            vars.lastUpdate = Math.min(block.timestamp, rewardData[vars.token].periodFinish);\n            vars.duration = vars.lastUpdate - rewardData[vars.token].lastUpdate;\n            if (vars.duration != 0) {\n                rewardData[vars.token].lastUpdate = vars.lastUpdate;\n                if (_totalSupply != 0) {\n                    vars.integral += (vars.duration * rewardData[vars.token].rate * 10 ** 18) / _totalSupply;\n                    rewardData[vars.token].integral = vars.integral;\n                }\n            }\n\n            if (_user != address(0)) {\n                uint256 _integralFor = rewardIntegralFor[vars.token][_user];\n                uint256 newClaimable = 0;\n\n                if (_integralFor < vars.integral) {\n                    rewardIntegralFor[vars.token][_user] = vars.integral;\n                    newClaimable = (vars.userBalance * (vars.integral - _integralFor)) / 10 ** 18;\n                }\n\n                uint256 _claimData = claimData[_user][vars.token];\n                uint256 totalClaimable = (_claimData >> 128) + newClaimable;\n                // shift(claim_data, -128)\n                if (totalClaimable > 0) {\n                    uint256 totalClaimed = _claimData % 2 ** 128;\n                    if (_claim) {\n                        claimData[_user][vars.token] = totalClaimed + totalClaimable;\n                        TransferHelper.doTransferOut(vars.token, vars.receiver, totalClaimable);\n                    } else if (newClaimable > 0) {\n                        claimData[_user][vars.token] = totalClaimed + (totalClaimable << 128);\n                    }\n                }\n            }\n        }\n    }\n\n    /***\n     * @notice Get the number of already-claimed reward tokens for a user\n     * @param _addr Account to get reward amount for\n     * @param _token Token to get reward amount for\n     * @return uint256 Total amount of `_token` already claimed by `_addr`\n     */\n    function claimedReward(address _addr, address _token) external view returns (uint256) {\n        return claimData[_addr][_token] % 2 ** 128;\n    }\n\n    /***\n     * @notice Get the number of claimable reward tokens for a user\n     * @param _user Account to get reward amount for\n     * @param _reward_token Token to get reward amount for\n     * @return uint256 Claimable reward token amount\n     */\n    function claimableReward(address _user, address _reward_token) external view returns (uint256) {\n        uint256 integral = rewardData[_reward_token].integral;\n        uint256 _totalSupply = totalSupply;\n        if (_totalSupply != 0) {\n            uint256 lastUpdate = Math.min(block.timestamp, rewardData[_reward_token].periodFinish);\n            uint256 duration = lastUpdate - rewardData[_reward_token].lastUpdate;\n            integral += ((duration * rewardData[_reward_token].rate * 10 ** 18) / _totalSupply);\n        }\n\n        uint256 integralFor = rewardIntegralFor[_reward_token][_user];\n        uint256 newClaimable = (balanceOf[_user] * (integral - integralFor)) / 10 ** 18;\n\n        return (claimData[_user][_reward_token] >> 128) + newClaimable;\n    }\n\n    /***\n     * @notice Set the default reward receiver for the caller.\n     * @dev When set to ZERO_ADDRESS, rewards are sent to the caller\n     * @param _receiver Receiver address for any rewards claimed via `claim_rewards`\n     */\n    function setRewardsReceiver(address _receiver) external {\n        rewardsReceiver[msg.sender] = _receiver;\n    }\n\n    /**\n     * @dev Set permit2 address, onlyOwner\n     * @param newAddress New permit2 address\n     */\n    function setPermit2Address(address newAddress) external onlyOwner {\n        require(newAddress != address(0), \"CE000\");\n        address oldAddress = permit2Address;\n        permit2Address = newAddress;\n        emit SetPermit2Address(oldAddress, newAddress);\n    }\n\n    /***\n     * @notice Claim available reward tokens for `_addr`\n     * @param _addr Address to claim for\n     * @param _receiver Address to transfer rewards to - if set to\n                     ZERO_ADDRESS, uses the default reward receiver\n                     for the caller\n     */\n    function _claimRewards(address _addr, address _receiver) private {\n        if (_receiver != address(0)) {\n            require(_addr == msg.sender, \"GP011\");\n            // dev: cannot redirect when claiming for another user\n        }\n        _checkpointRewards(_addr, totalSupply, true, _receiver);\n    }\n\n    function claimRewards() external nonReentrant {\n        _claimRewards(msg.sender, address(0));\n    }\n\n    function claimRewards(address _addr) external nonReentrant {\n        _claimRewards(_addr, address(0));\n    }\n\n    function claimRewards(address _addr, address _receiver) external nonReentrant {\n        _claimRewards(_addr, _receiver);\n    }\n\n    function lpBalanceOf(address addr) public view override returns (uint256) {\n        return balanceOf[addr];\n    }\n\n    function lpTotalSupply() public view override returns (uint256) {\n        return totalSupply;\n    }\n}\n"
    },
    "contracts/interfaces/IGaugeController.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\ninterface IGaugeController {\n    struct Point {\n        uint256 bias;\n        uint256 slope;\n    }\n\n    struct VotedSlope {\n        uint256 slope;\n        uint256 power;\n        uint256 end;\n    }\n\n    struct UserPoint {\n        uint256 bias;\n        uint256 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n\n    event AddType(string name, int128 type_id);\n\n    event NewTypeWeight(int128 indexed type_id, uint256 time, uint256 weight, uint256 total_weight);\n\n    event NewGaugeWeight(address indexed gauge_address, uint256 time, uint256 weight, uint256 total_weight);\n\n    event VoteForGauge(address indexed user, address indexed gauge_address, uint256 time, uint256 weight);\n\n    event NewGauge(address indexed gauge_address, int128 gauge_type, uint256 weight);\n\n    /**\n     * @notice Get gauge type for address\n     *  @param _addr Gauge address\n     * @return Gauge type id\n     */\n    function gaugeTypes(address _addr) external view returns (int128);\n\n    /**\n     * @notice Add gauge `addr` of type `gauge_type` with weight `weight`\n     * @param addr Gauge address\n     * @param gaugeType Gauge type\n     * @param weight Gauge weight\n     */\n    function addGauge(address addr, int128 gaugeType, uint256 weight) external;\n\n    /**\n     * @notice Checkpoint to fill data common for all gauges\n     */\n    function checkpoint() external;\n\n    /**\n     * @notice Checkpoint to fill data for both a specific gauge and common for all gauge\n     * @param addr Gauge address\n     */\n    function checkpointGauge(address addr) external;\n\n    /**\n     * @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18(e.g. 1.0 == 1e18). Inflation which will be received by\n     * it is inflation_rate * relative_weight / 1e18\n     * @param gaugeAddress Gauge address\n     * @param time Relative weight at the specified timestamp in the past or present\n     * @return Value of relative weight normalized to 1e18\n     */\n    function gaugeRelativeWeight(address gaugeAddress, uint256 time) external view returns (uint256);\n\n    /**\n     *  @notice Get gauge weight normalized to 1e18 and also fill all the unfilled values for type and gauge records\n     * @dev Any address can call, however nothing is recorded if the values are filled already\n     * @param gaugeAddress Gauge address\n     * @param time Relative weight at the specified timestamp in the past or present\n     * @return Value of relative weight normalized to 1e18\n     */\n    function gaugeRelativeWeightWrite(address gaugeAddress, uint256 time) external returns (uint256);\n\n    /**\n     * @notice Add gauge type with name `_name` and weight `weight`\n     * @dev only owner call\n     * @param _name Name of gauge type\n     * @param weight Weight of gauge type\n     */\n    function addType(string memory _name, uint256 weight) external;\n\n    /**\n     * @notice Change gauge type `type_id` weight to `weight`\n     * @dev only owner call\n     * @param type_id Gauge type id\n     * @param weight New Gauge weight\n     */\n    function changeTypeWeight(int128 type_id, uint256 weight) external;\n\n    /**\n     * @notice Change weight of gauge `addr` to `weight`\n     * @param gaugeAddress `Gauge` contract address\n     * @param weight New Gauge weight\n     */\n    function changeGaugeWeight(address gaugeAddress, uint256 weight) external;\n\n    /**\n     * @notice Allocate voting power for changing pool weights\n     * @param gaugeAddress Gauge which `msg.sender` votes for\n     * @param userWeight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0.\n     *        example: 10%=1000,3%=300,0.01%=1,100%=10000\n     */\n    function voteForGaugeWeights(address gaugeAddress, uint256 userWeight) external;\n\n    /**\n     * @notice Get current gauge weight\n     * @param addr Gauge address\n     * @return Gauge weight\n     */\n\n    function getGaugeWeight(address addr) external view returns (uint256);\n\n    /**\n     * @notice Get current type weight\n     * @param type_id Type id\n     * @return Type weight\n     */\n    function getTypeWeight(int128 type_id) external view returns (uint256);\n\n    /**\n     * @notice Get current total (type-weighted) weight\n     * @return Total weight\n     */\n    function getTotalWeight() external view returns (uint256);\n\n    /**\n     * @notice Get sum of gauge weights per type\n     * @param type_id Type id\n     * @return Sum of gauge weights\n     */\n    function getWeightsSumPreType(int128 type_id) external view returns (uint256);\n\n    function votingEscrow() external view returns (address);\n}\n"
    },
    "contracts/interfaces/ILT.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\ninterface ILT {\n    /**\n     * @dev Emitted when LT inflation rate update\n     *\n     * Note once a year\n     */\n    event UpdateMiningParameters(uint256 time, uint256 rate, uint256 supply);\n\n    /**\n     * @dev Emitted when set LT minter,can set the minter only once, at creation\n     */\n    event SetMinter(address indexed minter);\n\n    function rate() external view returns (uint256);\n\n    /**\n     * @notice Update mining rate and supply at the start of the epoch\n     * @dev   Callable by any address, but only once per epoch\n     *        Total supply becomes slightly larger if this function is called late\n     */\n    function updateMiningParameters() external;\n\n    /**\n     * @notice Get timestamp of the next mining epoch start while simultaneously updating mining parameters\n     * @return Timestamp of the next epoch\n     */\n    function futureEpochTimeWrite() external returns (uint256);\n\n    /**\n     * @notice Current number of tokens in existence (claimed or unclaimed)\n     */\n    function availableSupply() external view returns (uint256);\n\n    /**\n     * @notice How much supply is mintable from start timestamp till end timestamp\n     * @param start Start of the time interval (timestamp)\n     * @param end End of the time interval (timestamp)\n     * @return Tokens mintable from `start` till `end`\n     */\n    function mintableInTimeframe(uint256 start, uint256 end) external view returns (uint256);\n\n    /**\n     *  @notice Set the minter address\n     *  @dev Only callable once, when minter has not yet been set\n     *  @param _minter Address of the minter\n     */\n    function setMinter(address _minter) external;\n\n    /**\n     *  @notice Mint `value` tokens and assign them to `to`\n     *   @dev Emits a Transfer event originating from 0x00\n     *   @param to The account that will receive the created tokens\n     *   @param value The amount that will be created\n     *   @return bool success\n     */\n    function mint(address to, uint256 value) external returns (bool);\n\n    /**\n     * @notice Burn `value` tokens belonging to `msg.sender`\n     * @dev Emits a Transfer event with a destination of 0x00\n     * @param value The amount that will be burned\n     * @return bool success\n     */\n    function burn(uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IMinter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\ninterface IMinter {\n    function token() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function minted(address user, address gauge) external view returns (uint256);\n\n    function mint(address gaugeAddress) external;\n}\n"
    },
    "contracts/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity 0.8.17;\n\ninterface IVotingEscrow {\n    struct Point {\n        int256 bias;\n        int256 slope;\n        uint256 ts;\n        uint256 blk;\n    }\n\n    struct LockedBalance {\n        int256 amount;\n        uint256 end;\n    }\n\n    event Deposit(\n        address indexed provider,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 afterAmount,\n        uint256 indexed locktime,\n        uint256 _type,\n        uint256 ts\n    );\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\n\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    event SetSmartWalletChecker(address sender, address indexed newChecker, address oldChecker);\n\n    event SetPermit2Address(address oldAddress, address newAddress);\n\n    /***\n     * @dev Get the most recently recorded rate of voting power decrease for `_addr`\n     * @param _addr Address of the user wallet\n     * @return Value of the slope\n     */\n    function getLastUserSlope(address _addr) external view returns (int256);\n\n    /***\n     * @dev Get the timestamp for checkpoint `_idx` for `_addr`\n     * @param _addr User wallet address\n     * @param _idx User epoch number\n     * @return Epoch time of the checkpoint\n     */\n    function userPointHistoryTs(address _addr, uint256 _idx) external view returns (uint256);\n\n    /***\n     * @dev Get timestamp when `_addr`'s lock finishes\n     * @param _addr User wallet\n     * @return Epoch time of the lock end\n     */\n    function lockedEnd(address _addr) external view returns (uint256);\n\n    function createLock(uint256 _value, uint256 _unlockTime, uint256 nonce, uint256 deadline, bytes memory signature) external;\n\n    function createLockFor(\n        address _beneficiary,\n        uint256 _value,\n        uint256 _unlockTime,\n        uint256 nonce,\n        uint256 deadline,\n        bytes memory signature\n    ) external;\n\n    function increaseAmount(uint256 _value, uint256 nonce, uint256 deadline, bytes memory signature) external;\n\n    function increaseAmountFor(address _beneficiary, uint256 _value, uint256 nonce, uint256 deadline, bytes memory signature) external;\n\n    function increaseUnlockTime(uint256 _unlockTime) external;\n\n    function checkpointSupply() external;\n\n    function withdraw() external;\n\n    function epoch() external view returns (uint256);\n\n    function getUserPointHistory(address _userAddress, uint256 _index) external view returns (Point memory);\n\n    function supplyPointHistory(uint256 _index) external view returns (int256 bias, int256 slope, uint256 ts, uint256 blk);\n\n    /***\n     * @notice Get the current voting power for `msg.sender`\n     * @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n     * @param _addr User wallet address\n     * @param _t Epoch time to return voting power at\n     * @return User voting power\n     * @dev return the present voting power if _t is 0\n     */\n    function balanceOfAtTime(address _addr, uint256 _t) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function totalSupplyAtTime(uint256 _t) external view returns (uint256);\n\n    function userPointEpoch(address _user) external view returns (uint256);\n}\n"
    },
    "light-lib/contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "light-lib/contracts/IPermit2.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\ninterface IPermit2 {\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"
    },
    "light-lib/contracts/LibTime.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.17;\n\nlibrary LibTime {\n\n    // 7 * 86400 seconds - all future times are rounded by week\n    uint256 public constant DAY = 86400;\n    uint256 public constant WEEK = DAY * 7;\n\n    /**\n     * @dev times are rounded by week\n     * @param time time\n     */\n    function timesRoundedByWeek(uint256 time) internal pure returns (uint256) {\n        return (time / WEEK) * WEEK;\n    }\n}"
    },
    "light-lib/contracts/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\nimport \"./IPermit2.sol\";\n\nlibrary TransferHelper {\n    \n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     */\n    function doTransferFrom(address tokenAddress, address from, address to, uint256 amount) internal returns(uint256) {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 balanceBefore = token.balanceOf(to);\n        safeTransferFrom(token, from, to, amount);\n        uint256 balanceAfter = token.balanceOf(to);\n        uint256 actualAmount = balanceAfter - balanceBefore;\n        assert(actualAmount <= amount);\n        return actualAmount;\n    }\n\n    /**\n     * @dev transfer with permit2\n     */\n    function doTransferIn(\n        address permit2Address,\n        address tokenAddress,\n        uint256 _value,\n        address from,\n        uint256 nonce,\n        uint256 deadline,\n        bytes memory signature\n    ) internal returns (uint256) {\n        IPermit2.PermitTransferFrom memory permit = IPermit2.PermitTransferFrom({\n            permitted: IPermit2.TokenPermissions({token: tokenAddress, amount: _value}),\n            nonce: nonce,\n            deadline: deadline\n        });\n        IPermit2.SignatureTransferDetails memory transferDetails = IPermit2.SignatureTransferDetails({\n            to: address(this),\n            requestedAmount: _value\n        });\n        // Read from storage once\n        IERC20 token = IERC20(permit.permitted.token);\n        uint256 balanceBefore = token.balanceOf(transferDetails.to);\n        if (nonce == 0 && deadline == 0) {\n            safeTransferFrom(token, from, transferDetails.to, transferDetails.requestedAmount);\n        } else {\n            IPermit2(permit2Address).permitTransferFrom(permit, transferDetails, from, signature);\n        }\n        // Calculate the amount that was *actually* transferred\n        uint256 balanceAfter = IERC20(permit.permitted.token).balanceOf(address(this));\n        uint256 actualAmount = balanceAfter - balanceBefore;\n        assert(actualAmount <= transferDetails.requestedAmount);\n        \n        return actualAmount;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     */\n    function doTransferOut(address tokenAddress, address to, uint256 amount) internal returns(uint256) {\n        IERC20 token = IERC20(tokenAddress);\n        uint256 balanceBefore = token.balanceOf(to);\n        safeTransfer(token, to, amount);\n        uint256 balanceAfter = token.balanceOf(to);\n        uint256 actualAmount = balanceAfter - balanceBefore;\n        assert(actualAmount <= amount);\n        return actualAmount;\n    }\n\n    function doApprove(address tokenAddress, address to, uint256 amount) internal {\n        IERC20 token = IERC20(tokenAddress);\n        safeApprove(token, to, amount);\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}