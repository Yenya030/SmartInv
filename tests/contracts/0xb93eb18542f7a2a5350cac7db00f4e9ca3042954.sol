{{
  "language": "Solidity",
  "sources": {
    "@lambdalf-dev/ethereum-contracts/contracts/interfaces/IContractState.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IContractState {\r\n  /**\r\n  * @dev Thrown when a function is called with the wrong contract state.\r\n  * \r\n  * @param currentState the current state of the contract\r\n  */\r\n  error ContractState_INCORRECT_STATE(uint8 currentState);\r\n  /**\r\n  * @dev Thrown when trying to set the contract state to an invalid value.\r\n  * \r\n  * @param invalidState the invalid contract state\r\n  */\r\n  error ContractState_INVALID_STATE(uint8 invalidState);\r\n\r\n  /**\r\n  * @dev Emitted when the sale state changes\r\n  * \r\n  * @param previousState the previous state of the contract\r\n  * @param newState the new state of the contract\r\n  */\r\n  event ContractStateChanged(uint8 indexed previousState, uint8 indexed newState);\r\n\r\n  /**\r\n  * @dev Returns the current contract state.\r\n  */\r\n  function getContractState() external view returns (uint8);\r\n}\r\n"
    },
    "@lambdalf-dev/ethereum-contracts/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n// import \"./IERC165.sol\";\r\n\r\n/**\r\n* @dev Required interface of an ERC173 compliant contract, as defined in the\r\n* https://eips.ethereum.org/EIPS/eip-173[EIP].\r\n*/\r\ninterface IERC173 /* is IERC165 */ {\r\n  /**\r\n  * @dev This emits when ownership of a contract changes.\r\n  * \r\n  * @param previousOwner the previous contract owner\r\n  * @param newOwner the new contract owner\r\n  */\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n  * @notice Set the address of the new owner of the contract.\r\n  * @dev Set newOwner_ to address(0) to renounce any ownership.\r\n  */\r\n  function transferOwnership(address newOwner_) external; \r\n\r\n  /**\r\n  * @notice Returns the address of the owner.\r\n  */\r\n  function owner() external view returns(address);\r\n}\r\n"
    },
    "@lambdalf-dev/ethereum-contracts/contracts/interfaces/IERC173Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IERC173Errors {\r\n  /**\r\n  * @dev Thrown when `operator` is not the contract owner.\r\n  * \r\n  * @param operator address trying to use a function reserved to contract owner without authorization\r\n  */\r\n  error IERC173_NOT_OWNER(address operator);\r\n}\r\n"
    },
    "@lambdalf-dev/ethereum-contracts/contracts/interfaces/IEtherErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IEtherErrors {\r\n  /**\r\n  * @dev Thrown when an incorrect amount of eth is being sent for a payable operation.\r\n  * \r\n  * @param amountReceived the amount the contract received\r\n  * @param amountExpected the actual amount the contract expected to receive\r\n  */\r\n  error ETHER_INCORRECT_PRICE(uint256 amountReceived, uint256 amountExpected);\r\n  /**\r\n  * @dev Thrown when trying to withdraw from the contract with no balance.\r\n  */\r\n  error ETHER_NO_BALANCE();\r\n  /**\r\n  * @dev Thrown when contract fails to send ether to recipient.\r\n  * \r\n  * @param to the recipient of the ether\r\n  * @param amount the amount of ether being sent\r\n  */\r\n  error ETHER_TRANSFER_FAIL(address to, uint256 amount);\r\n}\r\n"
    },
    "@lambdalf-dev/ethereum-contracts/contracts/interfaces/INFTSupplyErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface INFTSupplyErrors {\r\n  /**\r\n  * @dev Thrown when trying to mint 0 token.\r\n  */\r\n  error NFT_INVALID_QTY();\r\n  /**\r\n  * @dev Thrown when trying to set max supply to an invalid amount.\r\n  */\r\n  error NFT_INVALID_SUPPLY();\r\n  /**\r\n  * @dev Thrown when trying to mint more tokens than the max allowed per transaction.\r\n  * \r\n  * @param qtyRequested the amount of tokens requested\r\n  * @param maxBatch the maximum amount that can be minted per transaction\r\n  */\r\n  error NFT_MAX_BATCH(uint256 qtyRequested, uint256 maxBatch);\r\n  /**\r\n  * @dev Thrown when trying to mint more tokens from the reserve than the amount left.\r\n  * \r\n  * @param qtyRequested the amount of tokens requested\r\n  * @param reserveLeft the amount of tokens left in the reserve\r\n  */\r\n  error NFT_MAX_RESERVE(uint256 qtyRequested, uint256 reserveLeft);\r\n  /**\r\n  * @dev Thrown when trying to mint more tokens than the amount left to be minted (except reserve).\r\n  * \r\n  * @param qtyRequested the amount of tokens requested\r\n  * @param remainingSupply the amount of tokens left in the reserve\r\n  */\r\n  error NFT_MAX_SUPPLY(uint256 qtyRequested, uint256 remainingSupply);\r\n}\r\n"
    },
    "@lambdalf-dev/ethereum-contracts/contracts/utils/ContractState.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"../interfaces/IContractState.sol\";\r\n\r\nabstract contract ContractState is IContractState {\r\n  // Enum to represent the sale state, defaults to ``PAUSED``.\r\n  uint8 public constant PAUSED = 0;\r\n\r\n  // The current state of the contract\r\n  uint8 private _contractState;\r\n\r\n  // **************************************\r\n  // *****          MODIFIER          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Ensures that contract state is `expectedState_`.\r\n    * \r\n    * @param expectedState_ : the desirable contract state\r\n    */\r\n    modifier isState(uint8 expectedState_) {\r\n      if (_contractState != expectedState_) {\r\n        revert ContractState_INCORRECT_STATE(_contractState);\r\n      }\r\n      _;\r\n    }\r\n    /**\r\n    * @dev Ensures that contract state is not `unexpectedState_`.\r\n    * \r\n    * @param unexpectedState_ : the undesirable contract state\r\n    */\r\n    modifier isNotState(uint8 unexpectedState_) {\r\n      if (_contractState == unexpectedState_) {\r\n        revert ContractState_INCORRECT_STATE(_contractState);\r\n      }\r\n      _;\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****          INTERNAL          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Internal function setting the contract state to `newState_`.\r\n    * \r\n    * Note: Contract state defaults to ``PAUSED``.\r\n    *   To maintain extendability, this value kept as uint8 instead of enum.\r\n    *   As a result, it is possible to set the state to an incorrect value.\r\n    *   To avoid issues, `newState_` should be validated before calling this function\r\n    */\r\n    function _setContractState(uint8 newState_) internal virtual {\r\n      uint8 _previousState_ = _contractState;\r\n      _contractState = newState_;\r\n      emit ContractStateChanged(_previousState_, newState_);\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****            VIEW            *****\r\n  // **************************************\r\n    /**\r\n    * @dev Returns the current contract state.\r\n    * \r\n    * @return uint8 : the current contract state\r\n    */\r\n    function getContractState() public virtual view override returns (uint8) {\r\n      return _contractState;\r\n    }\r\n  // **************************************\r\n}\r\n"
    },
    "@lambdalf-dev/ethereum-contracts/contracts/utils/ERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"../interfaces/IERC173.sol\";\r\nimport \"../interfaces/IERC173Errors.sol\";\r\n\r\n/**\r\n* @dev Contract module which provides a basic access control mechanism, where\r\n* there is an account (an owner) that can be granted exclusive access to\r\n* specific functions.\r\n*\r\n* By default, the owner account will be the one that deploys the contract. This\r\n* can later be changed with {transferOwnership}.\r\n*\r\n* This module is used through inheritance. It will make available the modifier\r\n* `onlyOwner`, which can be applied to your functions to restrict their use to\r\n* the owner.\r\n*/\r\nabstract contract ERC173 is IERC173, IERC173Errors {\r\n  // The owner of the contract\r\n  address private _owner;\r\n\r\n  // **************************************\r\n  // *****          MODIFIER          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n      if (owner() != msg.sender) {\r\n        revert IERC173_NOT_OWNER(msg.sender);\r\n      }\r\n      _;\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****          INTERNAL          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Sets the contract owner.\r\n    * \r\n    * Note: This function needs to be called in the contract constructor to initialize the contract owner, \r\n    * if it is not, then parts of the contract might be non functional\r\n    * \r\n    * @param owner_ : address that owns the contract\r\n    */\r\n    function _setOwner(address owner_) internal {\r\n      _owner = owner_;\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****       CONTRACT OWNER       *****\r\n  // **************************************\r\n    /**\r\n    * @dev Transfers ownership of the contract to `newOwner_`.\r\n    * \r\n    * @param newOwner_ : address of the new contract owner\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function transferOwnership(address newOwner_) public virtual onlyOwner {\r\n      address _oldOwner_ = _owner;\r\n      _owner = newOwner_;\r\n      emit OwnershipTransferred(_oldOwner_, newOwner_);\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****            VIEW            *****\r\n  // **************************************\r\n    /**\r\n    * @dev Returns the address of the current contract owner.\r\n    * \r\n    * @return address : the current contract owner\r\n    */\r\n    function owner() public view virtual returns (address) {\r\n      return _owner;\r\n    }\r\n  // **************************************\r\n}\r\n"
    },
    "@lambdalf-dev/ethereum-contracts/contracts/utils/Whitelist_ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Whitelist_ECDSA {\r\n  // Errors\r\n  /**\r\n  * @dev Thrown when trying to query the whitelist while it\"s not set\r\n  */\r\n  error Whitelist_NOT_SET();\r\n  /**\r\n  * @dev Thrown when `account` has consumed their alloted access and tries to query more\r\n  * \r\n  * @param account address trying to access the whitelist\r\n  */\r\n  error Whitelist_CONSUMED(address account);\r\n  /**\r\n  * @dev Thrown when `account` does not have enough alloted access to fulfil their query\r\n  * \r\n  * @param account address trying to access the whitelist\r\n  */\r\n  error Whitelist_FORBIDDEN(address account);\r\n\r\n  /**\r\n  * @dev A structure representing a signature proof to be decoded by the contract\r\n  */\r\n  struct Proof {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8   v;\r\n  }\r\n\r\n  address private _adminSigner;\r\n  mapping(uint8 => mapping(address => uint256)) private _consumed;\r\n\r\n  // **************************************\r\n  // *****          MODIFIER          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Ensures that `account_` has `qty_` alloted access on the `whitelistId_` whitelist.\r\n    * \r\n    * @param account_ the address to validate access\r\n    * @param whitelistId_ the identifier of the whitelist being queried\r\n    * @param alloted_ the max amount of whitelist spots allocated\r\n    * @param proof_ the signature proof to validate whitelist allocation\r\n    * @param qty_ the amount of whitelist access requested\r\n    */\r\n    modifier isWhitelisted(address account_, uint8 whitelistId_, uint256 alloted_, Proof memory proof_, uint256 qty_) {\r\n      uint256 _allowed_ = checkWhitelistAllowance(account_, whitelistId_, alloted_, proof_);\r\n      if (_allowed_ < qty_) {\r\n        revert Whitelist_FORBIDDEN(account_);\r\n      }\r\n      _;\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****          INTERNAL          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Consumes `amount_` whitelist access passes from `account_`.\r\n    * \r\n    * @param account_ the address to consume access from\r\n    * @param whitelistId_ the identifier of the whitelist being queried\r\n    * @param qty_ the amount of whitelist access consumed\r\n    * \r\n    * Note: Before calling this function, eligibility should be checked through {Whitelistable-checkWhitelistAllowance}.\r\n    */\r\n    function _consumeWhitelist(address account_, uint8 whitelistId_, uint256 qty_) internal {\r\n      unchecked {\r\n        _consumed[ whitelistId_ ][ account_ ] += qty_;\r\n      }\r\n    }\r\n    /**\r\n    * @dev Sets the pass to protect the whitelist.\r\n    * \r\n    * @param adminSigner_ : the address validating the whitelist signatures\r\n    */\r\n    function _setWhitelist(address adminSigner_) internal virtual {\r\n      _adminSigner = adminSigner_;\r\n    }\r\n    /**\r\n    * @dev Internal function to decode a signature and compare it with the `_adminSigner`.\r\n    * \r\n    * @param account_ the address to validate access\r\n    * @param whitelistId_ the identifier of the whitelist being queried\r\n    * @param alloted_ the max amount of whitelist spots allocated\r\n    * @param proof_ the signature proof to validate whitelist allocation\r\n    * \r\n    * @return bool whether the signature is valid or not\r\n    */ \r\n    function _validateProof(\r\n      address account_,\r\n      uint8 whitelistId_,\r\n      uint256 alloted_,\r\n      Proof memory proof_\r\n    ) private view returns (bool) {\r\n      bytes32 _digest_ = keccak256(abi.encode(whitelistId_, alloted_, account_));\r\n      address _signer_ = ecrecover(_digest_, proof_.v, proof_.r, proof_.s);\r\n      return _signer_ == _adminSigner;\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****            VIEW            *****\r\n  // **************************************\r\n    /**\r\n    * @dev Returns the amount that `account_` is allowed to access from the whitelist.\r\n    * \r\n    * @param account_ the address to validate access\r\n    * @param whitelistId_ the identifier of the whitelist being queried\r\n    * @param alloted_ the max amount of whitelist spots allocated\r\n    * @param proof_ the signature proof to validate whitelist allocation\r\n    * \r\n    * @return uint256 : the total amount of whitelist allocation remaining for `account_`\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - `_adminSigner` must be set.\r\n    */\r\n    function checkWhitelistAllowance(\r\n      address account_,\r\n      uint8 whitelistId_,\r\n      uint256 alloted_,\r\n      Proof memory proof_\r\n    ) public view returns (uint256) {\r\n      if (_adminSigner == address(0)) {\r\n        revert Whitelist_NOT_SET();\r\n      }\r\n\r\n      if (_consumed[ whitelistId_ ][ account_ ] >= alloted_) {\r\n        revert Whitelist_CONSUMED(account_);\r\n      }\r\n\r\n      if (! _validateProof(account_, whitelistId_, alloted_, proof_)) {\r\n        revert Whitelist_FORBIDDEN(account_);\r\n      }\r\n\r\n      return alloted_ - _consumed[ whitelistId_ ][ account_ ];\r\n    }\r\n  // **************************************\r\n}\r\n"
    },
    "contracts/AsteriaAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n* Team: Asteria Labs\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"@lambdalf-dev/ethereum-contracts/contracts/interfaces/IEtherErrors.sol\";\r\nimport \"@lambdalf-dev/ethereum-contracts/contracts/interfaces/INFTSupplyErrors.sol\";\r\nimport \"@lambdalf-dev/ethereum-contracts/contracts/utils/ERC173.sol\";\r\nimport \"@lambdalf-dev/ethereum-contracts/contracts/utils/ContractState.sol\";\r\nimport \"@lambdalf-dev/ethereum-contracts/contracts/utils/Whitelist_ECDSA.sol\";\r\n\r\ninterface IAsteriaPass {\r\n  function airdrop(address account_, uint256 tokenId_) external;\r\n}\r\n\r\ncontract AsteriaAuction is IEtherErrors, INFTSupplyErrors, ERC173, ContractState, Whitelist_ECDSA {\r\n  // **************************************\r\n  // *****    BYTECODE  VARIABLES     *****\r\n  // **************************************\r\n  \tuint8 public constant AUCTION = 1;\r\n  \tuint8 public constant PRESALE = 2;\r\n  \tuint8 public constant REFUND = 3;\r\n  \tuint8 public constant WHITELIST = 4;\r\n    uint256 public constant MAX_AMOUNT = 1;\r\n    uint256 private constant _RESERVE = 5;\r\n    uint256 public immutable DEPOSIT_PRICE; // 0.5 ETH\r\n    uint256 public immutable MAX_SUPPLY;\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****     STORAGE VARIABLES      *****\r\n  // **************************************\r\n    mapping (address => uint256) public depositedAmount;\r\n    mapping (address => bool) public hasPurchased;\r\n    IAsteriaPass public asteriaPass;\r\n    uint256 public salePrice;\r\n    address payable private _asteria;\r\n    address payable private _stable;\r\n    uint256 private _nextWaitlist;\r\n    uint256 private _nextPurchase = 1;\r\n    mapping (uint256 => address) private _waitlist;\r\n    mapping (uint256 => address) private _purchasers;\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****           ERROR            *****\r\n  // **************************************\r\n    /**\r\n    * @dev Thrown when user who already deposited tries to make a new deposit.\r\n    * \r\n    * @param account the address trying to make a deposit\r\n    */\r\n    error AA_ALREADY_DEPOSITED(address account);\r\n    /**\r\n    * @dev Thrown when user who already purchased a pass tries to claim a refund or complete a purchase.\r\n    * \r\n    * @param account the address trying to claim a refund or completing a purchase\r\n    */\r\n    error AA_ALREADY_PURCHASED(address account);\r\n    /**\r\n    * @dev Thrown when new sale price is lower than {DEPOSIT_PRICE}\r\n    */\r\n    error AA_INVALID_PRICE();\r\n    /**\r\n    * @dev Thrown when trying to airdrop tokens when none are due.\r\n    */\r\n    error AA_NO_AIRDROP_DUE();\r\n    /**\r\n    * @dev Thrown when user with no deposit tries to claim a refund or complete a purchase.\r\n    * \r\n    * @param account the address trying to claim a refund or completing a purchase\r\n    */\r\n    error AA_NO_DEPOSIT(address account);\r\n    /**\r\n    * @dev Thrown when trying to airdrop tokens while pass contract is not set.\r\n    */\r\n    error AA_PASS_NOT_SET();\r\n    /**\r\n    * @dev Thrown when trying to airdrop waitlist before finishing to airdrop purchases.\r\n    */\r\n    error AA_PURCHASES_PENDING();\r\n    /**\r\n    * @dev Thrown when trying to join the waitlist when it's full\r\n    */\r\n    error AA_WAITLIST_FULL();\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****           EVENT            *****\r\n  // **************************************\r\n    /**\r\n    * Emitted when a user deposits money for presale\r\n    * \r\n    * @param account the address purchasing a pass\r\n    * @param amount the amount deposited\r\n    */\r\n    event Deposited(address indexed account, uint256 indexed amount);\r\n    /**\r\n    * Emitted when a user purchases a pass\r\n    * \r\n    * @param account the address purchasing a pass\r\n    */\r\n    event Purchased(address indexed account);\r\n    /**\r\n    * Emitted when a user gets refunded their presale deposit\r\n    * \r\n    * @param account the address purchasing a pass\r\n    * @param amount the amount refunded\r\n    */\r\n    event Refunded(address indexed account, uint256 indexed amount);\r\n  // **************************************\r\n\r\n  constructor(address asteria_, address stable_, address signer_, uint256 maxSupply_, uint256 depositPrice_, uint256 salePrice_) {\r\n    _asteria = payable(asteria_);\r\n    _stable = payable(stable_);\r\n    MAX_SUPPLY = maxSupply_;\r\n    DEPOSIT_PRICE = depositPrice_;\r\n    salePrice = salePrice_;\r\n    _nextWaitlist = maxSupply_ + 1;\r\n    _setWhitelist(signer_);\r\n    _setOwner(msg.sender);\r\n  }\r\n\r\n  // **************************************\r\n  // *****          MODIFIER          *****\r\n  // **************************************\r\n  \t/**\r\n  \t* @dev Ensures that the caller has not already deposited.\r\n  \t*/\r\n  \tmodifier hasNotDeposited() {\r\n    \tif (depositedAmount[msg.sender] != 0) {\r\n    \t\trevert AA_ALREADY_DEPOSITED(msg.sender);\r\n    \t}\r\n    \t_;\r\n  \t}\r\n  \t/**\r\n  \t* @dev Ensures that the caller has not already purchased a pass.\r\n  \t*/\r\n  \tmodifier hasNotPurchased() {\r\n    \tif (hasPurchased[msg.sender]) {\r\n    \t\trevert AA_ALREADY_PURCHASED(msg.sender);\r\n    \t}\r\n    \t_;\r\n  \t}\r\n  \t/**\r\n  \t* @dev Ensures that the pass contract is set.\r\n  \t*/\r\n  \tmodifier passIsSet() {\r\n  \t\tif (address(asteriaPass) == address(0)) {\r\n  \t\t\trevert AA_PASS_NOT_SET();\r\n  \t\t}\r\n  \t\t_;\r\n  \t}\r\n  \t/**\r\n  \t* @dev Ensures that the correct amount of ETH has been sent to cover a purchase or deposit.\r\n  \t* \r\n  \t* @param totalPrice_ the amount of Eth required for this payment\r\n  \t*/\r\n  \tmodifier validateEthAmount(uint256 totalPrice_) {\r\n  \t\tuint256 _expected_ = depositedAmount[msg.sender] > 0 ?\r\n  \t\t\ttotalPrice_ - depositedAmount[msg.sender] : totalPrice_;\r\n    \tif (msg.value != _expected_) {\r\n    \t\trevert ETHER_INCORRECT_PRICE(msg.value, _expected_);\r\n    \t}\r\n    \t_;\r\n  \t}\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****          INTERNAL          *****\r\n  // **************************************\r\n    /**\r\n    * @dev Internal function processing an ether payment.\r\n    * \r\n    * @param recipient_ the address receiving the payment\r\n    * @param amount_ the amount sent\r\n    */\r\n    function _processEthPayment(address payable recipient_, uint256 amount_) internal {\r\n      // solhint-disable-next-line\r\n      (bool _success_,) = recipient_.call{ value: amount_ }(\"\");\r\n      if (! _success_) {\r\n        revert ETHER_TRANSFER_FAIL(recipient_, amount_);\r\n      }\r\n    }\r\n  \t/**\r\n  \t* @dev Internal function processing a purchase.\r\n  \t* \r\n    * @param account_ the address purchasing a token\r\n  \t*/\r\n  \tfunction _processPurchase(address account_) internal {\r\n  \t\tif (_nextPurchase > MAX_SUPPLY) {\r\n  \t\t\trevert NFT_MAX_SUPPLY(1, 0);\r\n  \t\t}\r\n  \t\thasPurchased[account_] = true;\r\n    \t_purchasers[_nextPurchase] = account_;\r\n    \tunchecked {\r\n    \t\t++_nextPurchase;\r\n    \t}\r\n    \temit Purchased(account_);\r\n      uint256 _share_ = salePrice / 2;\r\n      _processEthPayment(_stable, _share_);\r\n      _processEthPayment(_asteria, _share_);\r\n  \t}\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****           PUBLIC           *****\r\n  // **************************************\r\n    /**\r\n    * @notice Claims a refund of a deposit.\r\n    * \r\n    * @param proof_ Signature confirming that the caller is eligible for a refund\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Contract state must be {REFUND}.\r\n    * - Caller must have deposited some preorder funds.\r\n    * - Caller must be eligible for a refund.\r\n    * - Caller must be able to receive ETH.\r\n    * - Emits a {Refunded} event.\r\n    */\r\n    function claimRefund(Proof calldata proof_) external isState(REFUND) {\r\n    \tuint256 _balance_ = depositedAmount[msg.sender];\r\n      if (_balance_ == 0) {\r\n      \trevert AA_NO_DEPOSIT(msg.sender);\r\n      }\r\n      checkWhitelistAllowance(msg.sender, REFUND, MAX_AMOUNT, proof_);\r\n      depositedAmount[msg.sender] = 0;\r\n      emit Refunded(msg.sender, _balance_);\r\n      _processEthPayment(payable(msg.sender), _balance_);\r\n    }\r\n    /**\r\n    * @notice Completes a winning bid purchase.\r\n    * \r\n    * @param proof_ Signature confirming that the caller is eligible for a purchase\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Contract state must be {PRESALE}.\r\n    * - Caller must be eligible for a direct purchase.\r\n    * - Caller must not have already purchased a pass.\r\n    * - Caller must send enough ETH to complete the purchase.\r\n    * - Emits a {Purchased} event.\r\n    * - Transfers {salePrice} directly to withdrawal addresses.\r\n    */\r\n    function completePurchase(Proof calldata proof_)\r\n    external\r\n    payable\r\n    isState(PRESALE)\r\n    hasNotPurchased\r\n    validateEthAmount(salePrice) {\r\n      checkWhitelistAllowance(msg.sender, PRESALE, MAX_AMOUNT, proof_);\r\n    \tdepositedAmount[msg.sender] = 0;\r\n    \t_processPurchase(msg.sender);\r\n    }\r\n    /**\r\n    * @notice Deposits a portion of the sale price.\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Contract state must be {AUCTION}.\r\n    * - Caller must not already have made a deposit.\r\n    * - Caller must send enough ETH to cover the deposit price.\r\n    * - Emits a {Deposited} event.\r\n    */\r\n    function depositBid() external payable isState(AUCTION) hasNotDeposited validateEthAmount(DEPOSIT_PRICE) {\r\n    \tdepositedAmount[msg.sender] = msg.value;\r\n    \temit Deposited(msg.sender, msg.value);\r\n    }\r\n    /**\r\n    * @notice Deposits the purchase price to join the waitlist.\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Contract state must be {PRESALE}.\r\n    * - Caller must not have already purchased a pass.\r\n    * - Caller must send enough ETH to complete the purchase.\r\n    * - Emits a {Deposited} event.\r\n    */\r\n    function joinWaitlist() external payable isState(PRESALE) hasNotPurchased validateEthAmount(salePrice) {\r\n    \tif (_nextWaitlist == 1) {\r\n    \t\trevert AA_WAITLIST_FULL();\r\n    \t}\r\n    \tunchecked {\r\n    \t\t--_nextWaitlist;\r\n    \t\tdepositedAmount[msg.sender] += msg.value;\r\n    \t}\r\n    \t_waitlist[_nextWaitlist] = msg.sender;\r\n    \temit Deposited(msg.sender, msg.value);\r\n    }\r\n    /**\r\n    * @notice Purchases a Pass.\r\n    * \r\n    * @param proof_ Signature confirming that the caller is eligible for a purchase\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Contract state must be {PRESALE}.\r\n    * - Caller must not have already purchased a pass.\r\n    * - Caller must send enough ETH to cover the purchase.\r\n    * - Caller must be eligible for a direct purchase.\r\n    * - Emits a {Purchased} event.\r\n    * - Transfers {salePrice} directly to withdrawal addresses.\r\n    */\r\n    function purchasePresale(Proof calldata proof_)\r\n    external\r\n    payable\r\n    isState(PRESALE)\r\n    hasNotPurchased\r\n    validateEthAmount(salePrice) {\r\n      checkWhitelistAllowance(msg.sender, WHITELIST, MAX_AMOUNT, proof_);\r\n    \t_processPurchase(msg.sender);\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****       CONTRACT OWNER       *****\r\n  // **************************************\r\n    /**\r\n    * @notice Claims a purchased pass for `to_`.\r\n    * Note: This function allows the team to mint a pass that hasn't been claimed during the claim period\r\n    *   The recipient may be a different address than the purchaser, for example,\r\n    *   if the purchasing wallet has been compromised\r\n    * \r\n    * @param for_ address that purchased the pass\r\n    * @param to_ address receiving the pass\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `for_` must have purchased a pass.\r\n    */\r\n    // function airdropClaim(address for_, address to_) external onlyOwner {}\r\n    /**\r\n    * @notice Distributes purchased passes.\r\n    * \tNote: It is preferable to not airdrop more than 50 tokens at a time.\r\n    * \r\n    * @param amount_ the number of passes to distribute\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - Asteria pass contract must be set.\r\n    * - Contract state must be {REFUND}.\r\n    */\r\n    function distributePurchasedPass(uint256 amount_) external onlyOwner passIsSet isState(REFUND) {\r\n    \tif (_nextPurchase == 1) {\r\n    \t\trevert AA_NO_AIRDROP_DUE();\r\n    \t}\r\n    \tuint256 _count_;\r\n    \tuint256 _index_ = _nextPurchase;\r\n    \twhile (_index_ > 0 && _count_ < amount_) {\r\n    \t\tunchecked {\r\n    \t\t\t--_index_;\r\n    \t\t}\r\n    \t\taddress _account_ = _purchasers[_index_];\r\n    \t\tif (_account_ != address(0)) {\r\n\t    \t\tunchecked {\r\n\t    \t\t\t++_count_;\r\n\t    \t\t}\r\n\t    \t\tdelete _purchasers[_index_];\r\n\t\t    \ttry asteriaPass.airdrop(_account_, _index_) {}\r\n\t\t      catch Error(string memory reason) {\r\n\t\t        revert(reason);\r\n\t\t      }\r\n    \t\t}\r\n    \t}\r\n    }\r\n    /**\r\n    * @notice Distributes waitlisted passes.\r\n    * \tNote: It is preferable to not airdrop more than 50 tokens at a time.\r\n    * \r\n    * @param amount_ the number of passes to distribute\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - Asteria pass contract must be set.\r\n    * - Contract state must be {REFUND}.\r\n    * - All purchased passes must be distributed.\r\n    */\r\n    function distributeWaitlistedPass(uint256 amount_) external onlyOwner passIsSet isState(REFUND) {\r\n    \tif (_nextWaitlist > MAX_SUPPLY) {\r\n    \t\trevert AA_NO_AIRDROP_DUE();\r\n    \t}\r\n    \tif (_purchasers[_nextPurchase - 1] != address(0) && _purchasers[1] != address(0)) {\r\n    \t\trevert AA_PURCHASES_PENDING();\r\n    \t}\r\n    \tuint256 _count_;\r\n    \tuint256 _index_ = MAX_SUPPLY + 1;\r\n    \twhile (_index_ > 0 && _count_ < amount_) {\r\n    \t\tunchecked {\r\n    \t\t\t--_index_;\r\n    \t\t}\r\n    \t\taddress _account_ = _waitlist[_index_];\r\n    \t\tif (_account_ != address(0)) {\r\n\t    \t\tunchecked {\r\n\t    \t\t\t++_count_;\r\n\t    \t\t}\r\n\t    \t\tdelete _waitlist[_index_];\r\n\t\t    \ttry asteriaPass.airdrop(_account_, _index_) {}\r\n\t\t      catch Error(string memory reason) {\r\n\t\t        revert(reason);\r\n\t\t      }\r\n    \t\t}\r\n    \t}\r\n    }\r\n    /**\r\n    * @notice Sets the Asteria Pass contract address.\r\n    * \r\n    * @param contractAddress_ the Asteria Pass contract address\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setAsteriaPass(address contractAddress_) external onlyOwner {\r\n      asteriaPass = IAsteriaPass(contractAddress_);\r\n    }\r\n    /**\r\n    * @notice Updates the contract state.\r\n    * \r\n    * @param newState_ the new sale state\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `newState_` must be a valid state.\r\n    */\r\n    function setContractState(uint8 newState_) external onlyOwner {\r\n      if (newState_ > REFUND) {\r\n        revert ContractState_INVALID_STATE(newState_);\r\n      }\r\n      _setContractState(newState_);\r\n    }\r\n    /**\r\n    * @notice Updates the sale price.\r\n    * \r\n    * @param newSalePrice_ the new private price\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - `newSalePrice_` must be lower than or equal to {DEPOSIT_PRICE}.\r\n    */\r\n    function setPrice(uint256 newSalePrice_) external onlyOwner {\r\n    \tif (DEPOSIT_PRICE > newSalePrice_) {\r\n    \t\trevert AA_INVALID_PRICE();\r\n    \t}\r\n      salePrice = newSalePrice_;\r\n    }\r\n    /**\r\n    * @notice Updates the whitelist signer.\r\n    * \r\n    * @param newAdminSigner_ the new whitelist signer\r\n    *  \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function setWhitelist(address newAdminSigner_) external onlyOwner {\r\n      _setWhitelist(newAdminSigner_);\r\n    }\r\n    /**\r\n    * @notice Updates Asteria and Stable addresses\r\n    * \r\n    * @param newAsteria_ the new Asteria address\r\n    * @param newStable_ the new Stable address\r\n    *  \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    */\r\n    function updateAddresses(address newAsteria_, address newStable_) external onlyOwner {\r\n      _asteria = payable(newAsteria_);\r\n      _stable = payable(newStable_);\r\n    }\r\n    /**\r\n    * @notice Withdraws all the money stored in the contract and splits it between `_asteria` and `_stable`.\r\n    * \r\n    * Requirements:\r\n    * \r\n    * - Caller must be the contract owner.\r\n    * - Contract state must be {PAUSED}.\r\n    * - Contract must have a positive balance.\r\n    * - `_asteria` must be able to receive funds.\r\n    * - `_stable` must be able to receive funds.\r\n    */\r\n    function withdraw() public onlyOwner isState(PAUSED) {\r\n      uint256 _amount_ = address(this).balance;\r\n      if (_amount_ == 0) {\r\n        revert ETHER_NO_BALANCE();\r\n      }\r\n      uint256 _share_ = _amount_ / 2;\r\n      _processEthPayment(_stable, _share_);\r\n      _processEthPayment(_asteria, _share_);\r\n    }\r\n  // **************************************\r\n\r\n  // **************************************\r\n  // *****            VIEW            *****\r\n  // **************************************\r\n  \t/**\r\n  \t* @notice Returns the number of passes purchased.\r\n  \t* \r\n  \t* @return the number of passes purchased\r\n  \t*/\r\n  \tfunction totalPurchased() public view returns (uint256) {\r\n  \t\treturn _nextPurchase - 1;\r\n  \t}\r\n  \t/**\r\n  \t* @notice Returns the number of addresses on the waitlist.\r\n  \t* \r\n  \t* @return the number of passes purchased\r\n  \t*/\r\n  \tfunction totalWaitlisted() public view returns (uint256) {\r\n  \t\treturn MAX_SUPPLY + 1 - _nextWaitlist;\r\n  \t}\r\n  // **************************************\r\n}\r\n"
    }
  },
  "settings": {
    "viaIR": false,
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}