{{
  "language": "Solidity",
  "sources": {
    "src/tokens/GMCRoot.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {OwnableUDS} from \"UDS/auth/OwnableUDS.sol\";\r\nimport {LibCrumbMap} from \"../lib/LibCrumbMap.sol\";\r\nimport {FxERC721MRoot} from \"ERC721M/extensions/FxERC721MRoot.sol\";\r\nimport {ERC20UDS as ERC20} from \"UDS/tokens/ERC20UDS.sol\";\r\n\r\nimport \"solady/utils/ECDSA.sol\";\r\nimport \"solady/utils/LibString.sol\";\r\n\r\nerror ExceedsLimit();\r\nerror TransferFailed();\r\nerror TimelockActive();\r\nerror IncorrectValue();\r\nerror MaxSupplyLocked();\r\nerror InvalidSignature();\r\nerror InvalidPriceUnits();\r\nerror WhitelistNotActive();\r\nerror PublicSaleNotActive();\r\nerror ContractCallNotAllowed();\r\n\r\n/// @title Gangsta Mice City Root\r\n/// @author phaze (https://github.com/0xPhaze)\r\ncontract GMC is OwnableUDS, FxERC721MRoot {\r\n    using ECDSA for bytes32;\r\n    using LibString for uint256;\r\n    using LibCrumbMap for LibCrumbMap.CrumbMap;\r\n\r\n    event SaleStateUpdate();\r\n    event FirstLegendaryRaffleEntered(address user);\r\n    event SecondLegendaryRaffleEntered(address user);\r\n\r\n    uint16 public constant MAX_PER_WALLET = 20;\r\n    uint256 public constant PURCHASE_LIMIT = 5;\r\n    uint256 public constant BRIDGE_RAFFLE_LOCK_DURATION = 24 hours;\r\n    uint256 private constant PRICE_UNIT = 0.001 ether;\r\n    uint256 private constant GENESIS_CLAIM = 555;\r\n    uint256 private immutable DEPLOY_TIMESTAMP;\r\n\r\n    bool public maxSupplyLocked;\r\n    uint16 public supply;\r\n    uint16 public maxSupply;\r\n    uint32 public mintStart;\r\n    uint8 private publicPriceUnits;\r\n    uint8 private whitelistPriceUnits;\r\n    address private signer;\r\n\r\n    string private baseURI;\r\n    string private postFixURI = \".json\";\r\n    string private unrevealedURI = \"ipfs://QmTv9VoXgkZxFcomTW3kN6CRryUPMfgeUkVekFszcd79gK/\";\r\n\r\n    LibCrumbMap.CrumbMap gangs;\r\n\r\n    constructor(address checkpointManager, address fxRoot)\r\n        FxERC721MRoot(\"Gangsta Mice City\", \"GMC\", checkpointManager, fxRoot)\r\n    {\r\n        __Ownable_init();\r\n\r\n        maxSupply = 6666;\r\n        signer = msg.sender;\r\n        DEPLOY_TIMESTAMP = block.timestamp;\r\n\r\n        publicPriceUnits = toPriceUnits(0.049 ether);\r\n        whitelistPriceUnits = toPriceUnits(0.039 ether);\r\n    }\r\n\r\n    /* ------------- view ------------- */\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return supply;\r\n    }\r\n\r\n    function publicPrice() public view returns (uint256) {\r\n        return toPrice(publicPriceUnits);\r\n    }\r\n\r\n    function whitelistPrice() public view returns (uint256) {\r\n        return toPrice(whitelistPriceUnits);\r\n    }\r\n\r\n    function gangOf(uint256 id) public view returns (uint256) {\r\n        return gangs.get(id);\r\n    }\r\n\r\n    /* ------------- external ------------- */\r\n\r\n    function mint(uint256 quantity, bool lock)\r\n        external\r\n        payable\r\n        onlyEOA\r\n        requireMintableSupply(quantity)\r\n        requireMintableByUser(quantity, MAX_PER_WALLET)\r\n    {\r\n        unchecked {\r\n            if (msg.value != publicPrice() * quantity) revert IncorrectValue();\r\n            if (block.timestamp < mintStart + 2 hours || mintStart == 0) revert PublicSaleNotActive();\r\n\r\n            mintWithPerks(msg.sender, quantity, lock);\r\n        }\r\n    }\r\n\r\n    function whitelistMint(\r\n        uint256 quantity,\r\n        bool lock,\r\n        uint256 limit,\r\n        bytes calldata signature\r\n    ) external payable onlyEOA requireMintableSupply(quantity) requireMintableByUser(quantity, limit) {\r\n        unchecked {\r\n            if (!validSignature(signature, limit)) revert InvalidSignature();\r\n            if (mintStart + 2 hours < block.timestamp) revert WhitelistNotActive();\r\n            if (msg.value != whitelistPrice() * quantity) revert IncorrectValue();\r\n\r\n            mintWithPerks(msg.sender, quantity, lock);\r\n        }\r\n    }\r\n\r\n    function lockAndTransmit(address from, uint256[] calldata tokenIds) external {\r\n        unchecked {\r\n            if (tokenIds.length > 20) revert ExceedsLimit();\r\n            // don't repeat an unnecessary sload if we can avoid it\r\n            if (\r\n                tokenIds.length != 0 &&\r\n                block.timestamp < DEPLOY_TIMESTAMP + 1 weeks &&\r\n                block.timestamp < mintStart + 2 hours\r\n            ) {\r\n                emit SecondLegendaryRaffleEntered(from);\r\n            }\r\n\r\n            _lockAndTransmit(from, tokenIds);\r\n        }\r\n    }\r\n\r\n    function unlockAndTransmit(address from, uint256[] calldata tokenIds) external {\r\n        if (tokenIds.length > 20) revert ExceedsLimit();\r\n        if (block.timestamp < DEPLOY_TIMESTAMP + 1 weeks && block.timestamp < mintStart + BRIDGE_RAFFLE_LOCK_DURATION) {\r\n            revert TimelockActive();\r\n        }\r\n\r\n        _unlockAndTransmit(from, tokenIds);\r\n    }\r\n\r\n    /* ------------- private ------------- */\r\n\r\n    function validSignature(bytes calldata signature, uint256 limit) private view returns (bool) {\r\n        bytes32 hash = keccak256(abi.encode(address(this), msg.sender, limit));\r\n        address recovered = hash.toEthSignedMessageHash().recover(signature);\r\n\r\n        return recovered != address(0) && recovered == signer;\r\n    }\r\n\r\n    function toPrice(uint16 priceUnits) private pure returns (uint256) {\r\n        unchecked {\r\n            return uint256(priceUnits) * PRICE_UNIT;\r\n        }\r\n    }\r\n\r\n    function toPriceUnits(uint256 price) private pure returns (uint8) {\r\n        unchecked {\r\n            uint256 units;\r\n\r\n            if (price % PRICE_UNIT != 0) revert InvalidPriceUnits();\r\n            if ((units = price / PRICE_UNIT) > type(uint8).max) revert InvalidPriceUnits();\r\n\r\n            return uint8(units);\r\n        }\r\n    }\r\n\r\n    function mintWithPerks(\r\n        address to,\r\n        uint256 quantity,\r\n        bool lock\r\n    ) private {\r\n        unchecked {\r\n            if (quantity > 2) {\r\n                emit FirstLegendaryRaffleEntered(to);\r\n\r\n                if (supply < 500 + GENESIS_CLAIM) ++quantity;\r\n            }\r\n\r\n            if (lock && block.timestamp < mintStart + 2 hours) emit SecondLegendaryRaffleEntered(to);\r\n\r\n            if (lock) _mintLockedAndTransmit(to, quantity);\r\n            else _mint(to, quantity);\r\n        }\r\n    }\r\n\r\n    /* ------------- owner ------------- */\r\n\r\n    function pause() external onlyOwner {\r\n        mintStart = 0;\r\n    }\r\n\r\n    function lockMaxSupply() external onlyOwner {\r\n        maxSupplyLocked = true;\r\n    }\r\n\r\n    function setSigner(address addr) external onlyOwner {\r\n        signer = addr;\r\n    }\r\n\r\n    function setMaxSupply(uint16 value) external onlyOwner {\r\n        if (maxSupplyLocked) revert MaxSupplyLocked();\r\n\r\n        maxSupply = value;\r\n    }\r\n\r\n    function setMintStart(uint32 time) external onlyOwner {\r\n        mintStart = time;\r\n    }\r\n\r\n    function setPublicPrice(uint256 value) external onlyOwner {\r\n        publicPriceUnits = toPriceUnits(value);\r\n    }\r\n\r\n    function setBaseURI(string calldata uri) external onlyOwner {\r\n        baseURI = uri;\r\n    }\r\n\r\n    function setPostFixURI(string calldata postFix) external onlyOwner {\r\n        postFixURI = postFix;\r\n    }\r\n\r\n    function setWhitelistPrice(uint256 value) external onlyOwner {\r\n        whitelistPriceUnits = toPriceUnits(value);\r\n    }\r\n\r\n    function setUnrevealedURI(string calldata uri) external onlyOwner {\r\n        unrevealedURI = uri;\r\n    }\r\n\r\n    function setGangs(uint256[] calldata chunkIndices, uint256[] calldata chunks) external onlyOwner {\r\n        for (uint256 i; i < chunkIndices.length; ++i) gangs.set32BytesChunk(chunkIndices[i], chunks[i]);\r\n    }\r\n\r\n    function airdrop(\r\n        address[] calldata users,\r\n        uint256 quantity,\r\n        bool locked\r\n    ) external onlyOwner requireMintableSupply(quantity * users.length) {\r\n        if (locked) for (uint256 i; i < users.length; ++i) _mintLockedAndTransmit(users[i], quantity);\r\n        else for (uint256 i; i < users.length; ++i) _mint(users[i], quantity);\r\n    }\r\n\r\n    function withdraw() external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        (bool success, ) = msg.sender.call{value: balance}(\"\");\r\n\r\n        if (!success) revert TransferFailed();\r\n    }\r\n\r\n    function recoverToken(ERC20 token) external onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n\r\n        token.transfer(msg.sender, balance);\r\n    }\r\n\r\n    /* ------------- override ------------- */\r\n\r\n    function _authorizeTunnelController() internal override onlyOwner {}\r\n\r\n    function _increaseTotalSupply(uint256 amount) internal override {\r\n        supply += uint16(amount);\r\n    }\r\n\r\n    /* ------------- modifier ------------- */\r\n\r\n    modifier onlyEOA() {\r\n        if (tx.origin != msg.sender) revert ContractCallNotAllowed();\r\n        _;\r\n    }\r\n\r\n    modifier requireMintableByUser(uint256 quantity, uint256 limit) {\r\n        unchecked {\r\n            if (quantity > PURCHASE_LIMIT) revert ExceedsLimit();\r\n            if (quantity + numMinted(msg.sender) > limit) revert ExceedsLimit();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier requireMintableSupply(uint256 quantity) {\r\n        unchecked {\r\n            if (quantity + supply > maxSupply) revert ExceedsLimit();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /* ------------- ERC721 ------------- */\r\n\r\n    function tokenURI(uint256 id) public view override returns (string memory) {\r\n        return \r\n            bytes(baseURI).length == 0 \r\n              ? unrevealedURI \r\n              : string.concat(baseURI, id.toString(), postFixURI); // prettier-ignore\r\n    }\r\n}\r\n"
    },
    "lib/UDS/src/auth/OwnableUDS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"../utils/Context.sol\";\nimport {Initializable} from \"../utils/Initializable.sol\";\n\n// ------------- storage\n\nbytes32 constant DIAMOND_STORAGE_OWNABLE = keccak256(\"diamond.storage.ownable\");\n\nfunction s() pure returns (OwnableDS storage diamondStorage) {\n    bytes32 slot = DIAMOND_STORAGE_OWNABLE;\n    assembly { diamondStorage.slot := slot } // prettier-ignore\n}\n\nstruct OwnableDS {\n    address owner;\n}\n\n// ------------- errors\n\nerror CallerNotOwner();\n\n/// @title Ownable (Upgradeable Diamond Storage)\n/// @author phaze (https://github.com/0xPhaze/UDS)\n/// @dev Requires `__Ownable_init` to be called in proxy\nabstract contract OwnableUDS is Context, Initializable {\n    OwnableDS private __storageLayout; // storage layout for upgrade compatibility checks\n\n    event OwnerChanged(address oldOwner, address newOwner);\n\n    function __Ownable_init() internal initializer {\n        s().owner = _msgSender();\n    }\n\n    /* ------------- external ------------- */\n\n    function owner() public view returns (address) {\n        return s().owner;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        s().owner = newOwner;\n\n        emit OwnerChanged(_msgSender(), newOwner);\n    }\n\n    /* ------------- modifier ------------- */\n\n    modifier onlyOwner() {\n        if (_msgSender() != s().owner) revert CallerNotOwner();\n        _;\n    }\n}\n"
    },
    "src/lib/LibCrumbMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nusing LibCrumbMap for LibCrumbMap.CrumbMap;\r\n\r\n\r\n/// @notice Efficient crumb map library for mapping integers to crumbs.\r\n/// @author phaze (https://github.com/0xPhaze)\r\n/// @author adapted from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytemap.sol)\r\nlibrary LibCrumbMap {\r\n    struct CrumbMap {\r\n        mapping(uint256 => uint256) map;\r\n    }\r\n\r\n    /* ------------- CrumbMap ------------- */\r\n\r\n    function get(CrumbMap storage crumbMap, uint256 index) internal view returns (uint256 result) {\r\n        assembly {\r\n            mstore(0x20, crumbMap.slot)\r\n            mstore(0x00, shr(7, index))\r\n            result := and(shr(shl(1, and(index, 0x7f)), sload(keccak256(0x00, 0x20))), 0x03)\r\n        }\r\n    }\r\n\r\n    function get32BytesChunk(CrumbMap storage crumbMap, uint256 bytesIndex) internal view returns (uint256 result) {\r\n        assembly {\r\n            mstore(0x20, crumbMap.slot)\r\n            mstore(0x00, bytesIndex)\r\n            result := sload(keccak256(0x00, 0x20))\r\n        }\r\n    }\r\n\r\n    function set32BytesChunk(\r\n        CrumbMap storage crumbMap,\r\n        uint256 bytesIndex,\r\n        uint256 value\r\n    ) internal {\r\n        assembly {\r\n            mstore(0x20, crumbMap.slot)\r\n            mstore(0x00, bytesIndex)\r\n            sstore(keccak256(0x00, 0x20), value)\r\n        }\r\n    }\r\n\r\n    function set(\r\n        CrumbMap storage crumbMap,\r\n        uint256 index,\r\n        uint256 value\r\n    ) internal {\r\n        require(value < 4);\r\n\r\n        assembly {\r\n            mstore(0x20, crumbMap.slot)\r\n            mstore(0x00, shr(7, index))\r\n            let storageSlot := keccak256(0x00, 0x20)\r\n            let shift := shl(1, and(index, 0x7f))\r\n            // Unset crumb at index and store.\r\n            let chunkValue := and(sload(storageSlot), not(shl(shift, 0x03)))\r\n            // Set crumb to `value` at index and store.\r\n            chunkValue := or(chunkValue, shl(shift, value))\r\n            sstore(storageSlot, chunkValue)\r\n        }\r\n    }\r\n\r\n    /* ------------- mapping(uint256 => uint256) ------------- */\r\n\r\n    function get(mapping(uint256 => uint256) storage crumbMap, uint256 index) internal view returns (uint256 result) {\r\n        assembly {\r\n            mstore(0x20, crumbMap.slot)\r\n            mstore(0x00, shr(7, index))\r\n            result := and(shr(shl(1, and(index, 0x7f)), sload(keccak256(0x00, 0x20))), 0x03)\r\n        }\r\n    }\r\n\r\n    function get32BytesChunk(mapping(uint256 => uint256) storage crumbMap, uint256 bytesIndex) internal view returns (uint256 result) {\r\n        assembly {\r\n            mstore(0x20, crumbMap.slot)\r\n            mstore(0x00, bytesIndex)\r\n            result := sload(keccak256(0x00, 0x20))\r\n        }\r\n    }\r\n\r\n    function set32BytesChunk(\r\n        mapping(uint256 => uint256) storage crumbMap,\r\n        uint256 bytesIndex,\r\n        uint256 value\r\n    ) internal {\r\n        assembly {\r\n            mstore(0x20, crumbMap.slot)\r\n            mstore(0x00, bytesIndex)\r\n            sstore(keccak256(0x00, 0x20), value)\r\n        }\r\n    }\r\n\r\n    function set(\r\n        mapping(uint256 => uint256) storage crumbMap,\r\n        uint256 index,\r\n        uint256 value\r\n    ) internal {\r\n        require(value < 4);\r\n\r\n        assembly {\r\n            mstore(0x20, crumbMap.slot)\r\n            mstore(0x00, shr(7, index))\r\n            let storageSlot := keccak256(0x00, 0x20)\r\n            let shift := shl(1, and(index, 0x7f))\r\n            // Unset crumb at index and store.\r\n            let chunkValue := and(sload(storageSlot), not(shl(shift, 0x03)))\r\n            // Set crumb to `value` at index and store.\r\n            chunkValue := or(chunkValue, shl(shift, value))\r\n            sstore(storageSlot, chunkValue)\r\n        }\r\n    }\r\n}\r\n"
    },
    "lib/ERC721M/src/extensions/FxERC721MRoot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC721M} from \"../ERC721M.sol\";\nimport {ERC721MQuery} from \"./ERC721MQuery.sol\";\nimport {FxERC721Root} from \"fx-contracts/FxERC721Root.sol\";\n\n/// @title ERC721M FxPortal extension\n/// @author phaze (https://github.com/0xPhaze/ERC721M)\nabstract contract FxERC721MRoot is FxERC721Root, ERC721M, ERC721MQuery {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address checkpointManager,\n        address fxRoot\n    ) ERC721M(name, symbol) FxERC721Root(checkpointManager, fxRoot) {}\n\n    /* ------------- virtual ------------- */\n\n    function tokenURI(uint256 id) external view virtual override returns (string memory);\n\n    function _authorizeTunnelController() internal virtual override;\n\n    /* ------------- internal ------------- */\n\n    function _mintLockedAndTransmit(address to, uint256 quantity) internal virtual {\n        _mintLockedAndTransmit(to, quantity, 0);\n    }\n\n    function _mintLockedAndTransmit(\n        address to,\n        uint256 quantity,\n        uint48 auxData\n    ) internal virtual {\n        uint256 startId = _nextTokenId();\n\n        _mintAndLock(to, quantity, true, auxData);\n\n        uint256[] memory ids = new uint256[](quantity);\n\n        unchecked {\n            for (uint256 i; i < quantity; ++i) {\n                ids[i] = startId + i;\n            }\n        }\n\n        _registerERC721IdsWithChildMem(to, ids);\n    }\n\n    function _lockAndTransmit(address from, uint256[] calldata ids) internal virtual {\n        unchecked {\n            for (uint256 i; i < ids.length; ++i) {\n                _lock(from, ids[i]);\n            }\n        }\n\n        _registerERC721IdsWithChild(from, ids);\n    }\n\n    // @notice using `_unlockAndTransmit` is simple and easy\n    // this assumes L1 state as the single source of truth\n    // messages are always pushed L1 -> L2 without knowing state on L2\n    // this means that NFTs should not be allowed to be traded/sold on L2\n    // alternatively `_unlockWithProof` should be implemented requiring\n    // a MPT inclusion proof.\n    function _unlockAndTransmit(address from, uint256[] calldata ids) internal virtual {\n        unchecked {\n            for (uint256 i; i < ids.length; ++i) _unlock(from, ids[i]);\n        }\n\n        _registerERC721IdsWithChild(address(0), ids);\n    }\n}\n"
    },
    "lib/UDS/src/tokens/ERC20UDS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"../utils/Context.sol\";\nimport {Initializable} from \"../utils/Initializable.sol\";\nimport {EIP712PermitUDS} from \"../auth/EIP712PermitUDS.sol\";\n\n// ------------- storage\n\nbytes32 constant DIAMOND_STORAGE_ERC20 = keccak256(\"diamond.storage.erc20\");\n\nfunction s() pure returns (ERC20DS storage diamondStorage) {\n    bytes32 slot = DIAMOND_STORAGE_ERC20;\n    assembly { diamondStorage.slot := slot } // prettier-ignore\n}\n\nstruct ERC20DS {\n    string name;\n    string symbol;\n    uint8 decimals;\n    uint256 totalSupply;\n    mapping(address => uint256) balanceOf;\n    mapping(address => mapping(address => uint256)) allowance;\n}\n\n/// @title ERC20 (Upgradeable Diamond Storage)\n/// @author phaze (https://github.com/0xPhaze/UDS)\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate)\nabstract contract ERC20UDS is Context, Initializable, EIP712PermitUDS {\n    ERC20DS private __storageLayout; // storage layout for upgrade compatibility checks\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed operator, uint256 amount);\n\n    /* ------------- init ------------- */\n\n    function __ERC20_init(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) internal initializer {\n        s().name = _name;\n        s().symbol = _symbol;\n        s().decimals = _decimals;\n    }\n\n    /* ------------- view ------------- */\n\n    function name() external view virtual returns (string memory) {\n        return s().name;\n    }\n\n    function symbol() external view virtual returns (string memory) {\n        return s().symbol;\n    }\n\n    function decimals() external view virtual returns (uint8) {\n        return s().decimals;\n    }\n\n    function totalSupply() external view virtual returns (uint256) {\n        return s().totalSupply;\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        return s().balanceOf[owner];\n    }\n\n    function allowance(address owner, address operator) public view virtual returns (uint256) {\n        return s().allowance[owner][operator];\n    }\n\n    /* ------------- public ------------- */\n\n    function approve(address operator, uint256 amount) public virtual returns (bool) {\n        s().allowance[_msgSender()][operator] = amount;\n\n        emit Approval(_msgSender(), operator, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        s().balanceOf[_msgSender()] -= amount;\n\n        unchecked {\n            s().balanceOf[to] += amount;\n        }\n\n        emit Transfer(_msgSender(), to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = s().allowance[from][_msgSender()];\n\n        if (allowed != type(uint256).max) s().allowance[from][_msgSender()] = allowed - amount;\n\n        s().balanceOf[from] -= amount;\n\n        unchecked {\n            s().balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    // EIP-2612 permit\n    function permit(\n        address owner,\n        address operator,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s_\n    ) public virtual {\n        _usePermit(owner, operator, value, deadline, v, r, s_);\n\n        s().allowance[owner][operator] = value;\n\n        emit Approval(owner, operator, value);\n    }\n\n    /* ------------- internal ------------- */\n\n    function _mint(address to, uint256 amount) internal virtual {\n        s().totalSupply += amount;\n\n        unchecked {\n            s().balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        s().balanceOf[from] -= amount;\n\n        unchecked {\n            s().totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solady/src/utils/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\nlibrary ECDSA {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The number which `s` must not exceed in order for\n    /// the signature to be non-malleable.\n    bytes32 private constant _MALLEABILITY_THRESHOLD =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the `signature`.\n    ///\n    /// This function does NOT accept EIP-2098 short form signatures.\n    /// Use `recover(bytes32 hash, bytes32 r, bytes32 vs)` for EIP-2098\n    /// short form signatures instead.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address result) {\n        assembly {\n            if eq(signature.length, 65) {\n                // Copy the free memory pointer so that we can restore it later.\n                let m := mload(0x40)\n                // Directly copy `r` and `s` from the calldata.\n                calldatacopy(0x40, signature.offset, 0x40)\n\n                // If `s` in lower half order, such that the signature is not malleable.\n                if iszero(gt(mload(0x60), _MALLEABILITY_THRESHOLD)) {\n                    mstore(0x00, hash)\n                    // Compute `v` and store it in the scratch space.\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40))))\n                    pop(\n                        staticcall(\n                            gas(), // Amount of gas left for the transaction.\n                            0x01, // Address of `ecrecover`.\n                            0x00, // Start of input.\n                            0x80, // Size of input.\n                            0x40, // Start of output.\n                            0x20 // Size of output.\n                        )\n                    )\n                    // Restore the zero slot.\n                    mstore(0x60, 0)\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                    result := mload(sub(0x60, returndatasize()))\n                }\n                // Restore the free memory pointer.\n                mstore(0x40, m)\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    ///\n    /// This function only accepts EIP-2098 short form signatures.\n    /// See: https://eips.ethereum.org/EIPS/eip-2098\n    ///\n    /// To be honest, I do not recommend using EIP-2098 signatures\n    /// for simplicity, performance, and security reasons. Most if not\n    /// all clients support traditional non EIP-2098 signatures by default.\n    /// As such, this method is intentionally not fully inlined.\n    /// It is merely included for completeness.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (address result) {\n        uint8 v;\n        bytes32 s;\n        assembly {\n            s := shr(1, shl(1, vs))\n            v := add(shr(255, vs), 27)\n        }\n        result = recover(hash, v, r, s);\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    ///\n    /// WARNING!\n    /// The `result` will be the zero address upon recovery failure.\n    /// As such, it is extremely important to ensure that the address which\n    /// the `result` is compared against is never zero.\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address result) {\n        assembly {\n            // Copy the free memory pointer so that we can restore it later.\n            let m := mload(0x40)\n\n            // If `s` in lower half order, such that the signature is not malleable.\n            if iszero(gt(s, _MALLEABILITY_THRESHOLD)) {\n                mstore(0x00, hash)\n                mstore(0x20, v)\n                mstore(0x40, r)\n                mstore(0x60, s)\n                pop(\n                    staticcall(\n                        gas(), // Amount of gas left for the transaction.\n                        0x01, // Address of `ecrecover`.\n                        0x00, // Start of input.\n                        0x80, // Size of input.\n                        0x40, // Start of output.\n                        0x20 // Size of output.\n                    )\n                )\n                // Restore the zero slot.\n                mstore(0x60, 0)\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(sub(0x60, returndatasize()))\n            }\n            // Restore the free memory pointer.\n            mstore(0x40, m)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        assembly {\n            // Store into scratch space for keccak256.\n            mstore(0x20, hash)\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\")\n            // 0x40 - 0x04 = 0x3c\n            result := keccak256(0x04, 0x3c)\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        assembly {\n            // We need at most 128 bytes for Ethereum signed message header.\n            // The max length of the ASCII reprenstation of a uint256 is 78 bytes.\n            // The length of \"\\x19Ethereum Signed Message:\\n\" is 26 bytes (i.e. 0x1a).\n            // The next multiple of 32 above 78 + 26 is 128 (i.e. 0x80).\n\n            // Instead of allocating, we temporarily copy the 128 bytes before the\n            // start of `s` data to some variables.\n            let m3 := mload(sub(s, 0x60))\n            let m2 := mload(sub(s, 0x40))\n            let m1 := mload(sub(s, 0x20))\n            // The length of `s` is in bytes.\n            let sLength := mload(s)\n\n            let ptr := add(s, 0x20)\n\n            // `end` marks the end of the memory which we will compute the keccak256 of.\n            let end := add(ptr, sLength)\n\n            // Convert the length of the bytes to ASCII decimal representation\n            // and store it into the memory.\n            // prettier-ignore\n            for { let temp := sLength } 1 {} {\n                ptr := sub(ptr, 1)\n                mstore8(ptr, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Copy the header over to the memory.\n            mstore(sub(ptr, 0x20), \"\\x00\\x00\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n\")\n            // Compute the keccak256 of the memory.\n            result := keccak256(sub(ptr, 0x1a), sub(end, sub(ptr, 0x1a)))\n\n            // Restore the previous memory.\n            mstore(s, sLength)\n            mstore(sub(s, 0x20), m1)\n            mstore(sub(s, 0x40), m2)\n            mstore(sub(s, 0x60), m3)\n        }\n    }\n}\n"
    },
    "lib/solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for {} 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := add(sub(end, str), 2)\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 0x20)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            let m := add(start, 0xa0)\n            // Allocate the memory.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := add(sub(end, str), 2)\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 0x20)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        assembly {\n            let start := mload(0x40)\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\n            // and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\n            str := add(start, 0x60)\n\n            // Allocate the memory.\n            mstore(0x40, str)\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let length := 20\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 2)\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                length := sub(length, 1)\n                // prettier-ignore\n                if iszero(length) { break }\n            }\n\n            // Move the pointer and write the \"0x\" prefix.\n            str := sub(str, 32)\n            mstore(str, 0x3078)\n            // Move the pointer and write the length.\n            str := sub(str, 2)\n            mstore(str, 42)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   OTHER STRING OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\n    function replace(\n        string memory subject,\n        string memory search,\n        string memory replacement\n    ) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        // prettier-ignore\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            // prettier-ignore\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            // prettier-ignore\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            // Zeroize the slot after the string.\n            let last := add(add(result, 0x20), k)\n            mstore(last, 0)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n            // Store the length of the result.\n            mstore(result, k)\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(\n        string memory subject,\n        string memory search,\n        uint256 from\n    ) internal pure returns (uint256 result) {\n        assembly {\n            // prettier-ignore\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    // `result = min(from, subjectLength)`.\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)    \n                \n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(add(search, 0x20))\n\n                // prettier-ignore\n                if iszero(lt(subject, subjectSearchEnd)) { break }\n\n                if iszero(lt(searchLength, 32)) {\n                    // prettier-ignore\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        // prettier-ignore\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\n                    }\n                    break\n                }\n                // prettier-ignore\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(\n        string memory subject,\n        string memory search,\n        uint256 from\n    ) internal pure returns (uint256 result) {\n        assembly {\n            // prettier-ignore\n            for {} 1 {} {\n                let searchLength := mload(search)\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) {\n                    from := fromMax\n                }\n                if iszero(mload(search)) {\n                    result := from\n                    break\n                }\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\n\n                subject := add(add(subject, 0x20), from)\n                // prettier-ignore\n                if iszero(gt(subject, subjectSearchEnd)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                // prettier-ignore\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(subjectSearchEnd, 1))\n                        break\n                    }\n                    subject := sub(subject, 1)\n                    // prettier-ignore\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search) internal pure returns (uint256 result) {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(keccak256(add(subject, 0x20), searchLength), keccak256(add(search, 0x20), searchLength))\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search) internal pure returns (bool result) {\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                // prettier-ignore\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    // prettier-ignore\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        // prettier-ignore\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    // prettier-ignore\n                    if iszero(times) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(output, 0)\n                // Store the length.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(\n        string memory subject,\n        uint256 start,\n        uint256 end\n    ) internal pure returns (string memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) {\n                end := subjectLength\n            }\n            if iszero(gt(subjectLength, start)) {\n                start := subjectLength\n            }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                // Copy the `subject` one word at a time, backwards.\n                // prettier-ignore\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := sub(o, 0x20)\n                    // prettier-ignore\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory result) {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search) internal pure returns (uint256[] memory result) {\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 32)) {\n                    h := keccak256(search, searchLength)\n                }\n                let m := shl(3, sub(32, and(searchLength, 31)))\n                let s := mload(search)\n                // prettier-ignore\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of \n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                // prettier-ignore\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            // prettier-ignore\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    // prettier-ignore\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter) internal pure returns (string[] memory result) {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        assembly {\n            if mload(indices) {\n                let indexPtr := add(indices, 0x20)\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n                mstore(sub(indicesEnd, 0x20), mload(subject))\n                mstore(indices, add(mload(indices), 1))\n                let prevIndex := 0\n                // prettier-ignore\n                for {} 1 {} {\n                    let index := mload(indexPtr)\n                    mstore(indexPtr, 0x60)                        \n                    if iszero(eq(index, prevIndex)) {\n                        let element := mload(0x40)\n                        let elementLength := sub(index, prevIndex)\n                        mstore(element, elementLength)\n                        // Copy the `subject` one word at a time, backwards.\n                        // prettier-ignore\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                            o := sub(o, 0x20)\n                            // prettier-ignore\n                            if iszero(o) { break }\n                        }\n                        // Zeroize the slot after the string.\n                        mstore(add(add(element, 0x20), elementLength), 0)\n                        // Allocate memory for the length and the bytes,\n                        // rounded up to a multiple of 32.\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\n                        // Store the `element` into the array.\n                        mstore(indexPtr, element)                        \n                    }\n                    prevIndex := add(index, mload(delimiter))\n                    indexPtr := add(indexPtr, 0x20)\n                    // prettier-ignore\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\n                }\n                result := indices\n                if iszero(mload(delimiter)) {\n                    result := add(indices, 0x20)\n                    mstore(result, sub(mload(indices), 2))\n                }\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory result) {\n        assembly {\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := sub(o, 0x20)\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, mload(a))\n            // Copy `b` one word at a time, backwards.\n            // prettier-ignore\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := sub(o, 0x20)\n                // prettier-ignore\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 31), not(31)))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes.\n                mload(add(a, 0x1f)),\n                // `length != 0 && length < 32`. Abuses underflow.\n                // Assumes that the length is valid and within the block gas limit.\n                lt(sub(mload(a), 1), 0x1f)\n            )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result := mul(\n                // Load the length and the bytes of `a` and `b`.\n                or(shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))), mload(sub(add(b, 0x1e), aLength))),\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                // Assumes that the lengths are valid and within the block gas limit.\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\n            )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\n    function unpackTwo(bytes32 packed) internal pure returns (string memory resultA, string memory resultB) {\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(add(a, 0x20), mload(a)), 0)\n            // Store the return offset.\n            // Assumes that the string does not start from the scratch space.\n            mstore(sub(a, 0x20), 0x20)\n            // End the transaction, returning the string.\n            return(sub(a, 0x20), add(mload(a), 0x40))\n        }\n    }\n}\n"
    },
    "lib/UDS/src/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Context\n/// @notice Overridable context for meta-transactions\n/// @author OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts)\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/UDS/src/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {s as erc1967ds} from \"../proxy/ERC1967Proxy.sol\";\n\n// ------------- errors\n\nerror ProxyCallRequired();\nerror AlreadyInitialized();\n\n/// @title Initializable\n/// @author phaze (https://github.com/0xPhaze/UDS)\n/// @dev functions using the `initializer` modifier are only callable during proxy deployment\n/// @dev functions using the `reinitializer` modifier are only callable through a proxy\n/// @dev and only before a proxy upgrade migration has completed\n/// @dev (only when `upgradeToAndCall`'s `initCalldata` is being executed)\n/// @dev allows re-initialization during upgrades\nabstract contract Initializable {\n    address private immutable __implementation = address(this);\n\n    /* ------------- modifier ------------- */\n\n    modifier initializer() {\n        if (address(this).code.length != 0) revert AlreadyInitialized();\n        _;\n    }\n\n    modifier reinitializer() {\n        if (address(this) == __implementation) revert ProxyCallRequired();\n        if (erc1967ds().implementation == __implementation) revert AlreadyInitialized();\n        _;\n    }\n}\n"
    },
    "lib/ERC721M/src/ERC721M.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EIP712PermitUDS} from \"UDS/auth/EIP712PermitUDS.sol\";\nimport {UserDataOps, TokenDataOps} from \"./ERC721MLibrary.sol\";\n\n// ------------- storage\n\nstruct ERC721MStorage {\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    mapping(address => uint256) userData;\n    mapping(uint256 => uint256) tokenData;\n    mapping(uint256 => address) getApproved;\n    mapping(address => mapping(address => bool)) isApprovedForAll;\n}\n\nbytes32 constant DIAMOND_STORAGE_ERC721M_LOCKABLE = keccak256(\"diamond.storage.erc721m.lockable\");\n\nfunction s() pure returns (ERC721MStorage storage diamondStorage) {\n    bytes32 slot = DIAMOND_STORAGE_ERC721M_LOCKABLE;\n    assembly { diamondStorage.slot := slot } // prettier-ignore\n}\n\n// ------------- errors\n\nerror IncorrectOwner();\nerror TokenIdUnlocked();\nerror NonexistentToken();\nerror MintZeroQuantity();\nerror MintToZeroAddress();\nerror TransferFromInvalidTo();\nerror TransferToZeroAddress();\nerror CallerNotOwnerNorApproved();\nerror TransferFromIncorrectOwner();\nerror TransferToNonERC721Receiver();\n\n/// @title ERC721M (Integrated Token Locking)\n/// @author phaze (https://github.com/0xPhaze/ERC721M)\n/// @author modified from ERC721A (https://github.com/chiru-labs/ERC721A)\n/// @author modified from Solmate (https://github.com/Rari-Capital/solmate)\n/// @notice Integrates EIP712Permit\nabstract contract ERC721M is EIP712PermitUDS {\n    using UserDataOps for uint256;\n    using TokenDataOps for uint256;\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    uint256 constant startingIndex = 1;\n\n    constructor(string memory name_, string memory symbol_) {\n        __ERC721_init(name_, symbol_);\n    }\n\n    /* ------------- init ------------- */\n\n    function __ERC721_init(string memory name_, string memory symbol_) internal {\n        s().name = name_;\n        s().symbol = symbol_;\n    }\n\n    /* ------------- virtual ------------- */\n\n    function tokenURI(uint256 id) external view virtual returns (string memory);\n\n    /* ------------- view ------------- */\n\n    function name() external view virtual returns (string memory) {\n        return s().name;\n    }\n\n    function symbol() external view virtual returns (string memory) {\n        return s().symbol;\n    }\n\n    function balanceOf(address user) public view virtual returns (uint256) {\n        return s().userData[user].balance();\n    }\n\n    function getApproved(uint256 id) external view virtual returns (address) {\n        return s().getApproved[id];\n    }\n\n    function isApprovedForAll(address owner, address spender) external view virtual returns (bool) {\n        return s().isApprovedForAll[owner][spender];\n    }\n\n    function ownerOf(uint256 id) public view virtual returns (address) {\n        return _tokenDataOf(id).owner();\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return s().totalSupply;\n    }\n\n    function getAux(uint256 id) public view returns (uint256) {\n        return _tokenDataOf(id).aux();\n    }\n\n    function getLockStart(uint256 id) public view returns (uint256) {\n        return _tokenDataOf(id).tokenLockStart();\n    }\n\n    function numMinted(address user) public view virtual returns (uint256) {\n        return s().userData[user].numMinted();\n    }\n\n    function numLocked(address user) public view virtual returns (uint256) {\n        return s().userData[user].numLocked();\n    }\n\n    function getLockStart(address user) public view virtual returns (uint256) {\n        return s().userData[user].userLockStart();\n    }\n\n    function trueOwnerOf(uint256 id) public view virtual returns (address) {\n        return _tokenDataOf(id).trueOwner();\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /* ------------- public ------------- */\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _tokenDataOf(id).owner();\n\n        if (msg.sender != owner && !s().isApprovedForAll[owner][msg.sender]) revert CallerNotOwnerNorApproved();\n\n        s().getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        s().isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function _isApprovedOrOwner(address from, uint256 id) private view returns (bool) {\n        return (msg.sender == from || s().isApprovedForAll[from][msg.sender] || s().getApproved[id] == msg.sender);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        if (to == address(this)) revert TransferFromInvalidTo();\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        uint256 tokenData = _tokenDataOf(id);\n\n        bool isApprovedOrOwner = (msg.sender == from ||\n            s().isApprovedForAll[from][msg.sender] ||\n            s().getApproved[id] == msg.sender);\n\n        if (!isApprovedOrOwner) revert CallerNotOwnerNorApproved();\n        if (tokenData.owner() != from) revert TransferFromIncorrectOwner();\n\n        delete s().getApproved[id];\n\n        unchecked {\n            _ensureTokenDataSet(id + 1, tokenData);\n        }\n\n        s().tokenData[id] = tokenData.setOwner(to).flagNextTokenDataSet();\n\n        s().userData[to] = s().userData[to].increaseBalance(1);\n        s().userData[from] = s().userData[from].decreaseBalance(1);\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        safeTransferFrom(from, to, id, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n        if (\n            to.code.length != 0 &&\n            IERC721Receiver(to).onERC721Received(msg.sender, from, id, data) !=\n            IERC721Receiver(to).onERC721Received.selector\n        ) revert TransferToNonERC721Receiver();\n    }\n\n    // EIP-4494 permit; differs from the current EIP\n    function permit(\n        address owner,\n        address operator,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s_\n    ) public virtual {\n        _usePermit(owner, operator, 1, deadline, v, r, s_);\n\n        s().isApprovedForAll[owner][operator] = true;\n\n        emit ApprovalForAll(owner, operator, true);\n    }\n\n    /* ------------- internal ------------- */\n\n    function _exists(uint256 id) internal view virtual returns (bool) {\n        return startingIndex <= id && id < _nextTokenId();\n    }\n\n    function _nextTokenId() internal view virtual returns (uint256) {\n        return startingIndex + totalSupply();\n    }\n\n    function _increaseTotalSupply(uint256 amount) internal virtual {\n        if (amount != 0) s().totalSupply = _nextTokenId() + amount - 1;\n    }\n\n    function _tokenDataOf(uint256 id) internal view virtual returns (uint256 out) {\n        if (!_exists(id)) revert NonexistentToken();\n\n        unchecked {\n            uint256 tokenData;\n\n            for (uint256 curr = id; ; curr--) {\n                tokenData = s().tokenData[curr];\n\n                if (tokenData != 0) return tokenData;\n            }\n        }\n    }\n\n    function _ensureTokenDataSet(uint256 id, uint256 tokenData) internal virtual {\n        if (!tokenData.nextTokenDataSet() && s().tokenData[id] == 0 && _exists(id)) s().tokenData[id] = tokenData;\n    }\n\n    function _mint(address to, uint256 quantity) internal virtual {\n        _mintAndLock(to, quantity, false, 0);\n    }\n\n    function _mint(\n        address to,\n        uint256 quantity,\n        uint48 auxData\n    ) internal virtual {\n        _mintAndLock(to, quantity, false, auxData);\n    }\n\n    function _mintAndLock(\n        address to,\n        uint256 quantity,\n        bool lock\n    ) internal virtual {\n        _mintAndLock(to, quantity, lock, 0);\n    }\n\n    function _mintAndLock(\n        address to,\n        uint256 quantity,\n        bool lock,\n        uint48 auxData\n    ) internal virtual {\n        unchecked {\n            if (quantity == 0) revert MintZeroQuantity();\n            if (to == address(0)) revert MintToZeroAddress();\n\n            uint256 startTokenId = _nextTokenId();\n            uint256 tokenData = uint256(uint160(to)).setAux(auxData);\n            uint256 userData = s().userData[to];\n\n            // don't have to care about next token data if only minting one\n            if (quantity == 1) tokenData = tokenData.flagNextTokenDataSet();\n            if (lock) {\n                tokenData = tokenData.setConsecutiveLocked().lock();\n\n                userData = userData.increaseNumLocked(quantity).setUserLockStart(block.timestamp);\n\n                for (uint256 i; i < quantity; ++i) {\n                    emit Transfer(address(0), to, startTokenId + i);\n                    emit Transfer(to, address(this), startTokenId + i);\n                }\n            } else {\n                for (uint256 i; i < quantity; ++i) {\n                    emit Transfer(address(0), to, startTokenId + i);\n                }\n            }\n\n            s().userData[to] = userData.increaseNumMinted(quantity).increaseBalance(quantity);\n            s().tokenData[startTokenId] = tokenData;\n\n            _increaseTotalSupply(quantity);\n        }\n    }\n\n    function _setAux(uint256 id, uint48 aux) internal virtual {\n        uint256 tokenData = _tokenDataOf(id);\n\n        unchecked {\n            _ensureTokenDataSet(id + 1, tokenData);\n        }\n\n        s().tokenData[id] = tokenData.setAux(aux);\n    }\n\n    function _lock(address from, uint256 id) internal virtual {\n        uint256 tokenData = _tokenDataOf(id);\n\n        bool isApprovedOrOwner = (msg.sender == from ||\n            s().isApprovedForAll[from][msg.sender] ||\n            s().getApproved[id] == msg.sender);\n\n        if (!isApprovedOrOwner) revert CallerNotOwnerNorApproved();\n        if (tokenData.owner() != from) revert IncorrectOwner();\n\n        delete s().getApproved[id];\n\n        unchecked {\n            _ensureTokenDataSet(id + 1, tokenData);\n        }\n\n        s().tokenData[id] = tokenData.lock().unsetConsecutiveLocked().flagNextTokenDataSet();\n        s().userData[from] = s().userData[from].increaseNumLocked(1).setUserLockStart(block.timestamp);\n\n        emit Transfer(from, address(this), id);\n    }\n\n    function _unlock(address from, uint256 id) internal virtual {\n        uint256 tokenData = _tokenDataOf(id);\n\n        bool isApprovedOrOwner = (msg.sender == from ||\n            s().isApprovedForAll[from][msg.sender] ||\n            s().getApproved[id] == msg.sender);\n\n        if (!isApprovedOrOwner) revert CallerNotOwnerNorApproved();\n        if (!tokenData.locked()) revert TokenIdUnlocked();\n        if (tokenData.trueOwner() != from) revert IncorrectOwner();\n\n        // if isConsecutiveLocked flag is set, we need to make sure that next tokenData is set\n        // because tokenData in this case is implicit and needs to carry over\n        if (tokenData.isConsecutiveLocked()) {\n            unchecked {\n                _ensureTokenDataSet(id + 1, tokenData);\n\n                tokenData = tokenData.unsetConsecutiveLocked().flagNextTokenDataSet();\n            }\n        }\n\n        s().tokenData[id] = tokenData.unlock();\n        s().userData[from] = s().userData[from].decreaseNumLocked(1).setUserLockStart(block.timestamp);\n\n        emit Transfer(address(this), from, id);\n    }\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "lib/ERC721M/src/extensions/ERC721MQuery.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ERC721MLibrary.sol\";\nimport {ERC721M, s} from \"../ERC721M.sol\";\n\n/// @title ERC721M Query Extension\n/// @author phaze (https://github.com/0xPhaze/ERC721M)\nabstract contract ERC721MQuery is ERC721M {\n    using UserDataOps for uint256;\n    using TokenDataOps for uint256;\n\n    /* ------------- O(n) read-only ------------- */\n\n    function getOwnedIds(address user) external view returns (uint256[] memory) {\n        return utils.getOwnedIds(s().tokenData, user, startingIndex, totalSupply());\n    }\n\n    function getLockedIds(address user) external view returns (uint256[] memory) {\n        return utils.getLockedIds(s().tokenData, user, startingIndex, totalSupply());\n    }\n\n    function getUnlockedIds(address user) external view returns (uint256[] memory) {\n        return utils.getUnlockedIds(s().tokenData, user, startingIndex, totalSupply());\n    }\n\n    function totalNumLocked() external view returns (uint256) {\n        uint256 data;\n        uint256 count;\n        uint256 endIndex = _nextTokenId();\n        uint256 currentData;\n\n        unchecked {\n            for (uint256 i = startingIndex; i < endIndex; ++i) {\n                data = s().tokenData[i];\n                if (data != 0) currentData = data;\n                if (currentData.locked()) ++count;\n            }\n        }\n\n        return count;\n    }\n}\n\n/// @title ERC721M Query Utils\n/// @author phaze (https://github.com/0xPhaze/ERC721M)\nlibrary utils {\n    using TokenDataOps for uint256;\n\n    function getOwnedIds(\n        mapping(uint256 => uint256) storage tokenDataOf,\n        address user,\n        uint256 start,\n        uint256 collectionSize\n    ) internal view returns (uint256[] memory ids) {\n        uint256 memPtr;\n\n        assembly {\n            ids := mload(0x40)\n            memPtr := add(ids, 0x20)\n        }\n\n        unchecked {\n            uint256 data;\n            uint256 currentData;\n            uint256 end = collectionSize + start;\n            for (uint256 id = start; id < end; ++id) {\n                data = tokenDataOf[id];\n                if (data != 0) currentData = data;\n                if (user == address(uint160(currentData))) {\n                    assembly {\n                        mstore(memPtr, id)\n                        memPtr := add(memPtr, 0x20)\n                    }\n                }\n            }\n        }\n\n        assembly {\n            mstore(ids, shr(5, sub(sub(memPtr, ids), 0x20)))\n            mstore(0x40, memPtr)\n        }\n    }\n\n    function getLockedIds(\n        mapping(uint256 => uint256) storage tokenDataOf,\n        address user,\n        uint256 start,\n        uint256 collectionSize\n    ) internal view returns (uint256[] memory ids) {\n        uint256 memPtr;\n\n        assembly {\n            ids := mload(0x40)\n            memPtr := add(ids, 0x20)\n        }\n\n        unchecked {\n            uint256 data;\n            uint256 currentData;\n            uint256 end = collectionSize + start;\n            for (uint256 id = start; id < end; ++id) {\n                data = tokenDataOf[id];\n                if (data != 0) currentData = data;\n                if (user == address(uint160(currentData)) && currentData.locked()) {\n                    assembly {\n                        mstore(memPtr, id)\n                        memPtr := add(memPtr, 0x20)\n                    }\n                }\n            }\n        }\n\n        assembly {\n            mstore(ids, shr(5, sub(sub(memPtr, ids), 0x20)))\n            mstore(0x40, memPtr)\n        }\n    }\n\n    function getUnlockedIds(\n        mapping(uint256 => uint256) storage tokenDataOf,\n        address user,\n        uint256 start,\n        uint256 collectionSize\n    ) internal view returns (uint256[] memory ids) {\n        uint256 memPtr;\n\n        assembly {\n            ids := mload(0x40)\n            memPtr := add(ids, 0x20)\n        }\n\n        unchecked {\n            uint256 data;\n            uint256 currentData;\n            uint256 end = collectionSize + start;\n            for (uint256 id = start; id < end; ++id) {\n                data = tokenDataOf[id];\n                if (data != 0) currentData = data;\n                if (user == address(uint160(currentData)) && !currentData.locked()) {\n                    assembly {\n                        mstore(memPtr, id)\n                        memPtr := add(memPtr, 0x20)\n                    }\n                }\n            }\n        }\n\n        assembly {\n            mstore(ids, shr(5, sub(sub(memPtr, ids), 0x20)))\n            mstore(0x40, memPtr)\n        }\n    }\n}\n"
    },
    "lib/fx-contracts/src/FxERC721Root.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {FxBaseRootTunnel} from \"./base/FxBaseRootTunnel.sol\";\n\nbytes4 constant REGISTER_ERC721_IDS_SELECTOR = bytes4(keccak256(\"registerERC721IdsWithChild(address,uint256[])\"));\nbytes4 constant DEREGISTER_ERC721_IDS_SELECTOR = bytes4(keccak256(\"deregisterERC721IdsWithChild(uint256[])\"));\n\n/// @title ERC721 FxRootTunnel\n/// @author phaze (https://github.com/0xPhaze/fx-contracts)\nabstract contract FxERC721Root is FxBaseRootTunnel {\n    constructor(address checkpointManager, address fxRoot) FxBaseRootTunnel(checkpointManager, fxRoot) {}\n\n    /* ------------- virtual ------------- */\n\n    function _authorizeTunnelController() internal virtual override;\n\n    /* ------------- internal ------------- */\n\n    function _registerERC721IdsWithChild(address to, uint256[] calldata ids) internal virtual {\n        _sendMessageToChild(abi.encodeWithSelector(REGISTER_ERC721_IDS_SELECTOR, to, ids));\n    }\n\n    function _registerERC721IdsWithChildMem(address to, uint256[] memory ids) internal virtual {\n        _sendMessageToChild(abi.encodeWithSelector(REGISTER_ERC721_IDS_SELECTOR, to, ids));\n    }\n}\n"
    },
    "lib/UDS/src/auth/EIP712PermitUDS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// ------------- storage\n\nbytes32 constant DIAMOND_STORAGE_EIP_712_PERMIT = keccak256(\"diamond.storage.eip.712.permit\");\n\nfunction s() pure returns (EIP2612DS storage diamondStorage) {\n    bytes32 slot = DIAMOND_STORAGE_EIP_712_PERMIT;\n    assembly { diamondStorage.slot := slot } // prettier-ignore\n}\n\nstruct EIP2612DS {\n    mapping(address => uint256) nonces;\n}\n\n// ------------- errors\n\nerror InvalidSigner();\nerror DeadlineExpired();\n\n/// @title EIP712Permit (Upgradeable Diamond Storage)\n/// @author phaze (https://github.com/0xPhaze/UDS)\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate)\n/// @dev `DOMAIN_SEPARATOR` needs to be re-computed every time\n/// @dev for use with a proxy due to `address(this)`\nabstract contract EIP712PermitUDS {\n    EIP2612DS private __storageLayout; // storage layout for upgrade compatibility checks\n\n    /* ------------- public ------------- */\n\n    function nonces(address owner) public view returns (uint256) {\n        return s().nonces[owner];\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(\"EIP712\"),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /* ------------- internal ------------- */\n\n    function _usePermit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v_,\n        bytes32 r_,\n        bytes32 s_\n    ) internal virtual {\n        if (deadline < block.timestamp) revert DeadlineExpired();\n\n        unchecked {\n            uint256 nonce = s().nonces[owner]++;\n\n            address recovered = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonce,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v_,\n                r_,\n                s_\n            );\n\n            if (recovered == address(0) || recovered != owner) revert InvalidSigner();\n        }\n    }\n}\n"
    },
    "lib/UDS/src/proxy/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// ------------- storage\n\n// keccak256(\"eip1967.proxy.implementation\") - 1\nbytes32 constant ERC1967_PROXY_STORAGE_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\nfunction s() pure returns (ERC1967UpgradeDS storage diamondStorage) {\n    assembly { diamondStorage.slot := ERC1967_PROXY_STORAGE_SLOT } // prettier-ignore\n}\n\nstruct ERC1967UpgradeDS {\n    address implementation;\n}\n\n// ------------- errors\n\nerror InvalidUUID();\nerror NotAContract();\n\n/// @title ERC1967\n/// @author phaze (https://github.com/0xPhaze/UDS)\nabstract contract ERC1967 {\n    event Upgraded(address indexed implementation);\n\n    function _upgradeToAndCall(address logic, bytes memory data) internal {\n        if (logic.code.length == 0) revert NotAContract();\n\n        if (ERC1822(logic).proxiableUUID() != ERC1967_PROXY_STORAGE_SLOT) revert InvalidUUID();\n\n        if (data.length != 0) {\n            (bool success, ) = logic.delegatecall(data);\n\n            if (!success) {\n                assembly {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n\n        s().implementation = logic;\n\n        emit Upgraded(logic);\n    }\n}\n\n/// @title Minimal ERC1967Proxy\n/// @author phaze (https://github.com/0xPhaze/UDS)\ncontract ERC1967Proxy is ERC1967 {\n    constructor(address logic, bytes memory data) payable {\n        _upgradeToAndCall(logic, data);\n    }\n\n    fallback() external payable {\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let success := delegatecall(gas(), sload(ERC1967_PROXY_STORAGE_SLOT), 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            if success {\n                return(0, returndatasize())\n            }\n\n            revert(0, returndatasize())\n        }\n    }\n}\n\n/// @title ERC1822\n/// @author phaze (https://github.com/0xPhaze/UDS)\nabstract contract ERC1822 {\n    function proxiableUUID() external view virtual returns (bytes32);\n}\n"
    },
    "lib/ERC721M/src/ERC721MLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Library used for bitmap manipulation for ERC721M\n/// @author phaze (https://github.com/0xPhaze/ERC721M)\nlibrary UserDataOps {\n    /* ------------- balance: [0, 20) ------------- */\n\n    function balance(uint256 userData) internal pure returns (uint256) {\n        return userData & 0xFFFFF;\n    }\n\n    function increaseBalance(uint256 userData, uint256 amount) internal pure returns (uint256) {\n        unchecked {\n            return userData + amount;\n        }\n    }\n\n    function decreaseBalance(uint256 userData, uint256 amount) internal pure returns (uint256) {\n        unchecked {\n            return userData - amount;\n        }\n    }\n\n    /* ------------- numMinted: [20, 40) ------------- */\n\n    function numMinted(uint256 userData) internal pure returns (uint256) {\n        return (userData >> 20) & 0xFFFFF;\n    }\n\n    function increaseNumMinted(uint256 userData, uint256 amount) internal pure returns (uint256) {\n        unchecked {\n            return userData + (amount << 20);\n        }\n    }\n\n    /* ------------- numLocked: [40, 60) ------------- */\n\n    function numLocked(uint256 userData) internal pure returns (uint256) {\n        return (userData >> 40) & 0xFFFFF;\n    }\n\n    function increaseNumLocked(uint256 userData, uint256 amount) internal pure returns (uint256) {\n        unchecked {\n            return userData + (amount << 40);\n        }\n    }\n\n    function decreaseNumLocked(uint256 userData, uint256 amount) internal pure returns (uint256) {\n        unchecked {\n            return userData - (amount << 40);\n        }\n    }\n\n    /* ------------- lockStart: [60, 100) ------------- */\n\n    function userLockStart(uint256 userData) internal pure returns (uint256) {\n        return (userData >> 60) & 0xFFFFFFFFFF;\n    }\n\n    function setUserLockStart(uint256 userData, uint256 timestamp) internal pure returns (uint256) {\n        return (userData & ~uint256(0xFFFFFFFFFF << 60)) | (timestamp << 60);\n    }\n\n    // /* ------------- aux: [100, 256) ------------- */\n\n    // function aux(uint256 userData) internal pure returns (uint256) {\n    //     return (userData >> 100) & 0xFFFFFFFFFF;\n    // }\n\n    // function setAux(uint256 userData, uint256 aux_) internal pure returns (uint256) {\n    //     return (userData & ~((uint256(1) << 100) - 1)) | (aux_ << 100);\n    // }\n}\n\nlibrary TokenDataOps {\n    /// @dev Big question whether copy should transfer over data, such as,\n    ///      aux data and timestamps\n    function copy(uint256 tokenData) internal pure returns (uint256) {\n        return tokenData;\n    }\n\n    // return tokenData & ((uint256(1) << (160 + (((tokenData >> 160) & 1) << 1))) - 1);\n    /// ^ equivalent code:\n    // function copy2(uint256 tokenData) internal pure returns (uint256) {\n    //     uint256 copiedData = uint160(tokenData);\n    //     if (isConsecutiveLocked(tokenData)) {\n    //         copiedData = setConsecutiveLocked(copiedData);\n    //         if (locked(tokenData)) copiedData = lock(copiedData);\n    //     }\n    //     return copiedData;\n    // }\n\n    /* ------------- owner: [0, 160) ------------- */\n\n    function owner(uint256 tokenData) internal view returns (address) {\n        return locked(tokenData) ? address(this) : trueOwner(tokenData);\n    }\n\n    function setOwner(uint256 tokenData, address owner_) internal pure returns (uint256) {\n        return (tokenData & 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000) | uint160(owner_);\n    }\n\n    function trueOwner(uint256 tokenData) internal pure returns (address) {\n        return address(uint160(tokenData));\n    }\n\n    /* ------------- consecutiveLock: [160, 161) ------------- */\n\n    function isConsecutiveLocked(uint256 tokenData) internal pure returns (bool) {\n        return ((tokenData >> 160) & uint256(1)) != 0;\n    }\n\n    function setConsecutiveLocked(uint256 tokenData) internal pure returns (uint256) {\n        return tokenData | (uint256(1) << 160);\n    }\n\n    function unsetConsecutiveLocked(uint256 tokenData) internal pure returns (uint256) {\n        return tokenData & ~(uint256(1) << 160);\n    }\n\n    /* ------------- locked: [161, 162) ------------- */\n\n    function locked(uint256 tokenData) internal pure returns (bool) {\n        return ((tokenData >> 161) & uint256(1)) != 0; // Note: this is not masked and can carry over when calling 'ownerOf'\n    }\n\n    function lock(uint256 tokenData) internal view returns (uint256) {\n        return setTokenLockStart(tokenData, block.timestamp) | (uint256(1) << 161);\n    }\n\n    function unlock(uint256 tokenData) internal view returns (uint256) {\n        return setTokenLockStart(tokenData, block.timestamp) & ~(uint256(1) << 161);\n    }\n\n    /* ------------- nextTokenDataSet: [162, 163) ------------- */\n\n    function nextTokenDataSet(uint256 tokenData) internal pure returns (bool) {\n        return ((tokenData >> 162) & uint256(1)) != 0;\n    }\n\n    function flagNextTokenDataSet(uint256 tokenData) internal pure returns (uint256) {\n        return tokenData | (uint256(1) << 162); // nextTokenDatatSet flag (don't repeat the read/write)\n    }\n\n    /* ------------- lockStart: [168, 208) ------------- */\n\n    function tokenLockStart(uint256 tokenData) internal pure returns (uint256) {\n        return (tokenData >> 168) & 0xFFFFFFFFFF;\n    }\n\n    function setTokenLockStart(uint256 tokenData, uint256 timestamp) internal pure returns (uint256) {\n        return (tokenData & ~uint256(0xFFFFFFFFFF << 168)) | (timestamp << 168);\n    }\n\n    /* ------------- aux: [208, 256) ------------- */\n\n    function aux(uint256 tokenData) internal pure returns (uint256) {\n        return tokenData >> 208;\n    }\n\n    function setAux(uint256 tokenData, uint256 auxData) internal pure returns (uint256) {\n        return (tokenData & ~uint256(0xFFFFFFFFFFFF << 208)) | (auxData << 208);\n    }\n}\n"
    },
    "lib/fx-contracts/src/base/FxBaseRootTunnel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Merkle} from \"../lib/Merkle.sol\";\nimport {RLPReader} from \"../lib/RLPReader.sol\";\nimport {ExitPayloadReader} from \"../lib/ExitPayloadReader.sol\";\nimport {MerklePatriciaProof} from \"../lib/MerklePatriciaProof.sol\";\n\n// ------------- interfaces\n\ninterface IFxStateSender {\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\n}\n\ninterface ICheckpointManager {\n    function headerBlocks(uint256 headerNumber)\n        external\n        view\n        returns (\n            bytes32 root,\n            uint256 start,\n            uint256 end,\n            uint256 createdAt,\n            address proposer\n        );\n}\n\n// ------------- storage\n\nbytes32 constant DIAMOND_STORAGE_FX_BASE_ROOT_TUNNEL = keccak256(\"diamond.storage.fx.base.root.tunnel\");\n\nfunction s() pure returns (FxBaseRootTunnelDS storage diamondStorage) {\n    bytes32 slot = DIAMOND_STORAGE_FX_BASE_ROOT_TUNNEL;\n    assembly { diamondStorage.slot := slot } // prettier-ignore\n}\n\nstruct FxBaseRootTunnelDS {\n    address fxChildTunnel;\n    mapping(bytes32 => bool) processedExits;\n}\n\n// ------------- errors\n\nerror FxChildUnset();\nerror InvalidHeader();\nerror InvalidSelector();\nerror InvalidReceiptProof();\nerror InvalidFxChildTunnel();\nerror ExitAlreadyProcessed();\n\nabstract contract FxBaseRootTunnel {\n    using RLPReader for RLPReader.RLPItem;\n    using Merkle for bytes32;\n    using ExitPayloadReader for bytes;\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\n    using ExitPayloadReader for ExitPayloadReader.Log;\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\n\n    bytes32 private constant SEND_MESSAGE_EVENT_SELECTOR =\n        0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\n\n    IFxStateSender public immutable fxRoot;\n    ICheckpointManager public immutable checkpointManager;\n\n    constructor(address checkpointManager_, address fxRoot_) {\n        checkpointManager = ICheckpointManager(checkpointManager_);\n        fxRoot = IFxStateSender(fxRoot_);\n    }\n\n    /* ------------- virtual ------------- */\n\n    function _authorizeTunnelController() internal virtual;\n\n    /* ------------- view ------------- */\n\n    function fxChildTunnel() public view virtual returns (address) {\n        return s().fxChildTunnel;\n    }\n\n    function processedExits(bytes32 exitHash) public view virtual returns (bool) {\n        return s().processedExits[exitHash];\n    }\n\n    function setFxChildTunnel(address fxChildTunnel_) public virtual {\n        _authorizeTunnelController();\n\n        s().fxChildTunnel = fxChildTunnel_;\n    }\n\n    /* ------------- internal ------------- */\n\n    function _sendMessageToChild(bytes memory message) internal virtual {\n        if (s().fxChildTunnel == address(0)) revert FxChildUnset();\n\n        fxRoot.sendMessageToChild(s().fxChildTunnel, message);\n    }\n\n    /**\n     * @notice receive message from  L2 to L1, validated by proof\n     * @dev This function verifies if the transaction actually happened on child chain\n     *\n     * @param proofData RLP encoded data of the reference tx containing following list of fields\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\n     *  2 - blockNumber - Block number containing the reference tx on child chain\n     *  3 - blockTime - Reference tx block time\n     *  4 - txRoot - Transactions root of block\n     *  5 - receiptRoot - Receipts root of block\n     *  6 - receipt - Receipt of the reference transaction\n     *  7 - receiptProof - Merkle proof of the reference receipt\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\n     *  9 - receiptLogIndex - Log Index to read from the receipt\n     */\n    function _validateAndExtractMessage(bytes memory proofData) internal returns (bytes memory) {\n        address childTunnel = s().fxChildTunnel;\n\n        if (childTunnel == address(0)) revert FxChildUnset();\n\n        ExitPayloadReader.ExitPayload memory payload = proofData.toExitPayload();\n\n        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\n        uint256 blockNumber = payload.getBlockNumber();\n        // checking if exit has already been processed\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\n        bytes32 exitHash = keccak256(\n            abi.encodePacked(\n                blockNumber,\n                // first 2 nibbles are dropped while generating nibble array\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\n                // so converting to nibble array and then hashing it\n                MerklePatriciaProof._getNibbleArray(branchMaskBytes),\n                payload.getReceiptLogIndex()\n            )\n        );\n\n        if (s().processedExits[exitHash]) revert ExitAlreadyProcessed();\n\n        s().processedExits[exitHash] = true;\n\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\n        ExitPayloadReader.Log memory log = receipt.getLog();\n\n        // check child tunnel\n        if (childTunnel != log.getEmitter()) revert InvalidFxChildTunnel();\n\n        bytes32 receiptRoot = payload.getReceiptRoot();\n        // verify receipt inclusion\n        if (!MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot))\n            revert InvalidReceiptProof();\n\n        (bytes32 headerRoot, uint256 startBlock, , , ) = checkpointManager.headerBlocks(payload.getHeaderNumber());\n\n        bytes32 leaf = keccak256(\n            abi.encodePacked(blockNumber, payload.getBlockTime(), payload.getTxRoot(), receiptRoot)\n        );\n\n        if (!leaf.checkMembership(blockNumber - startBlock, headerRoot, payload.getBlockProof()))\n            revert InvalidHeader();\n\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\n\n        if (bytes32(topics.getField(0).toUint()) != SEND_MESSAGE_EVENT_SELECTOR) revert InvalidSelector();\n\n        // received message data\n        bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\n\n        return message;\n    }\n}\n"
    },
    "lib/fx-contracts/src/lib/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Merkle {\n    function checkMembership(\n        bytes32 leaf,\n        uint256 index,\n        bytes32 rootHash,\n        bytes memory proof\n    ) internal pure returns (bool) {\n        require(proof.length % 32 == 0, \"Invalid proof length\");\n        uint256 proofHeight = proof.length / 32;\n        // Proof of size n means, height of the tree is n+1.\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\n        require(index < 2**proofHeight, \"Leaf index is too big\");\n\n        bytes32 proofElement;\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            assembly {\n                proofElement := mload(add(proof, i))\n            }\n\n            if (index % 2 == 0) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n\n            index = index / 2;\n        }\n        return computedHash == rootHash;\n    }\n}\n"
    },
    "lib/fx-contracts/src/lib/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n */\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START = 0xb8;\n    uint8 constant LIST_SHORT_START = 0xc0;\n    uint8 constant LIST_LONG_START = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 memPtr = item.memPtr + offset;\n        uint256 len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        return result == 0 ? false : true;\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len == 0) return;\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\n\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "lib/fx-contracts/src/lib/ExitPayloadReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary ExitPayloadReader {\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    uint8 constant WORD_SIZE = 32;\n\n    struct ExitPayload {\n        RLPReader.RLPItem[] data;\n    }\n\n    struct Receipt {\n        RLPReader.RLPItem[] data;\n        bytes raw;\n        uint256 logIndex;\n    }\n\n    struct Log {\n        RLPReader.RLPItem data;\n        RLPReader.RLPItem[] list;\n    }\n\n    struct LogTopics {\n        RLPReader.RLPItem[] data;\n    }\n\n    // copy paste of private copy() from RLPReader to avoid changing of existing contracts\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {\n        RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();\n\n        return ExitPayload(payloadData);\n    }\n\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[0].toUint();\n    }\n\n    function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[1].toBytes();\n    }\n\n    function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[2].toUint();\n    }\n\n    function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[3].toUint();\n    }\n\n    function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {\n        return bytes32(payload.data[4].toUint());\n    }\n\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {\n        return bytes32(payload.data[5].toUint());\n    }\n\n    function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {\n        receipt.raw = payload.data[6].toBytes();\n        RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\n\n        if (receiptItem.isList()) {\n            // legacy tx\n            receipt.data = receiptItem.toList();\n        } else {\n            // pop first byte before parsting receipt\n            bytes memory typedBytes = receipt.raw;\n            bytes memory result = new bytes(typedBytes.length - 1);\n            uint256 srcPtr;\n            uint256 destPtr;\n            assembly {\n                srcPtr := add(33, typedBytes)\n                destPtr := add(0x20, result)\n            }\n\n            copy(srcPtr, destPtr, result.length);\n            receipt.data = result.toRlpItem().toList();\n        }\n\n        receipt.logIndex = getReceiptLogIndex(payload);\n        return receipt;\n    }\n\n    function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[7].toBytes();\n    }\n\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {\n        return payload.data[8].toBytes();\n    }\n\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[8].toUint();\n    }\n\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {\n        return payload.data[9].toUint();\n    }\n\n    // Receipt methods\n    function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {\n        return receipt.raw;\n    }\n\n    function getLog(Receipt memory receipt) internal pure returns (Log memory) {\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\n        return Log(logData, logData.toList());\n    }\n\n    // Log methods\n    function getEmitter(Log memory log) internal pure returns (address) {\n        return RLPReader.toAddress(log.list[0]);\n    }\n\n    function getTopics(Log memory log) internal pure returns (LogTopics memory) {\n        return LogTopics(log.list[1].toList());\n    }\n\n    function getData(Log memory log) internal pure returns (bytes memory) {\n        return log.list[2].toBytes();\n    }\n\n    function toRlpBytes(Log memory log) internal pure returns (bytes memory) {\n        return log.data.toRlpBytes();\n    }\n\n    // LogTopics methods\n    function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {\n        return topics.data[index];\n    }\n}\n"
    },
    "lib/fx-contracts/src/lib/MerklePatriciaProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {RLPReader} from \"./RLPReader.sol\";\n\nlibrary MerklePatriciaProof {\n    /*\n     * @dev Verifies a merkle patricia proof.\n     * @param value The terminating value in the trie.\n     * @param encodedPath The path in the trie leading to value.\n     * @param rlpParentNodes The rlp encoded stack of nodes.\n     * @param root The root hash of the trie.\n     * @return The boolean validity of the proof.\n     */\n    function verify(\n        bytes memory value,\n        bytes memory encodedPath,\n        bytes memory rlpParentNodes,\n        bytes32 root\n    ) internal pure returns (bool) {\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\n\n        bytes memory currentNode;\n        RLPReader.RLPItem[] memory currentNodeList;\n\n        bytes32 nodeKey = root;\n        uint256 pathPtr = 0;\n\n        bytes memory path = _getNibbleArray(encodedPath);\n        if (path.length == 0) {\n            return false;\n        }\n\n        for (uint256 i = 0; i < parentNodes.length; i++) {\n            if (pathPtr > path.length) {\n                return false;\n            }\n\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\n            if (nodeKey != keccak256(currentNode)) {\n                return false;\n            }\n            currentNodeList = RLPReader.toList(parentNodes[i]);\n\n            if (currentNodeList.length == 17) {\n                if (pathPtr == path.length) {\n                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                uint8 nextPathNibble = uint8(path[pathPtr]);\n                if (nextPathNibble > 16) {\n                    return false;\n                }\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\n                pathPtr += 1;\n            } else if (currentNodeList.length == 2) {\n                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\n                if (pathPtr + traversed == path.length) {\n                    //leaf node\n                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n\n                //extension node\n                if (traversed == 0) {\n                    return false;\n                }\n\n                pathPtr += traversed;\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\n            } else {\n                return false;\n            }\n        }\n\n        return false;\n    }\n\n    function _nibblesToTraverse(\n        bytes memory encodedPartialPath,\n        bytes memory path,\n        uint256 pathPtr\n    ) private pure returns (uint256) {\n        uint256 len = 0;\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\n        // and slicedPath have elements that are each one hex character (1 nibble)\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\n        bytes memory slicedPath = new bytes(partialPath.length);\n\n        // pathPtr counts nibbles in path\n        // partialPath.length is a number of nibbles\n        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\n            bytes1 pathNibble = path[i];\n            slicedPath[i - pathPtr] = pathNibble;\n        }\n\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\n            len = partialPath.length;\n        } else {\n            len = 0;\n        }\n        return len;\n    }\n\n    // bytes b must be hp encoded\n    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {\n        bytes memory nibbles = \"\";\n        if (b.length > 0) {\n            uint8 offset;\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\n            if (hpNibble == 1 || hpNibble == 3) {\n                nibbles = new bytes(b.length * 2 - 1);\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\n                nibbles[0] = oddNibble;\n                offset = 1;\n            } else {\n                nibbles = new bytes(b.length * 2 - 2);\n                offset = 0;\n            }\n\n            for (uint256 i = offset; i < nibbles.length; i++) {\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\n            }\n        }\n        return nibbles;\n    }\n\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\n        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "/=src/",
      "ERC721M/=lib/ERC721M/src/",
      "UDS/=lib/UDS/src/",
      "ds-test/=lib/ERC721M/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "futils/=lib/futils/src/",
      "fx-contracts/=lib/fx-contracts/src/",
      "fx-portal/=lib/ERC721M/lib/fx-portal/contracts/",
      "solady/=lib/solady/src/",
      "solmate/=lib/solmate/src/",
      "upgrade-scripts/=lib/upgrade-scripts/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}