{"ConfigurablePools.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"./Declaration.sol\";\nimport \"./OwnableSafe.sol\";\n\n/**\n * @title ConfigurablePools\n * @author Aaron Hanson \u003ccoffee.becomes.code@gmail.com\u003e\n */\nabstract contract ConfigurablePools is OwnableSafe, Declaration {\n\n    struct PoolInfo {\n        uint40 lockDays;\n        uint40 rewardRate;\n        bool isFlexible;\n        uint256 totalStaked;\n        uint256 totalRewardsReserved;\n    }\n\n    uint256 public constant NUM_POOLS = 5;\n\n    mapping(uint256 =\u003e PoolInfo) public pools;\n\n    constructor() {\n        pools[0] = PoolInfo(100, 3, true, 0, 0);\n        pools[1] = PoolInfo(30, 7, false, 0, 0);\n        pools[2] = PoolInfo(60, 14, false, 0, 0);\n        pools[3] = PoolInfo(90, 20, false, 0, 0);\n        pools[4] = PoolInfo(120, 24, false, 0, 0);\n    }\n\n    function allPools() public view returns(PoolInfo[] memory) {\n        PoolInfo[] memory array = new PoolInfo[](NUM_POOLS);\n        for(uint i=0; i \u003c NUM_POOLS; i++){\n            array[i] = pools[i];\n        }\n        return array;\n    }\n\n    function editPoolTerms(\n        uint256 _poolID,\n        uint40 _newLockDays,\n        uint40 _newRewardRate\n    )\n        external\n        onlyOwner\n    {\n        require(\n            _poolID \u003c NUM_POOLS,\n            \"Invalid pool ID\"\n        );\n\n        require(\n            _newLockDays \u003e 0,\n            \"Lock days cannot be zero\"\n        );\n\n        require(\n            _newRewardRate \u003e 0,\n            \"Reward rate cannot be zero\"\n        );\n\n        pools[_poolID].lockDays = _newLockDays;\n        pools[_poolID].rewardRate = _newRewardRate;\n    }\n\n}"},"ContextSimple.sol":{"content":"// SPDX-License-Identifier: MIT\n// Based on OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n// With _msgData() removed\n\npragma solidity ^0.8.12;\n\n/**\n * @dev Provides the msg.sender in the current execution context.\n */\nabstract contract ContextSimple {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}"},"Declaration.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\ninterface IERC20 {\n\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\t\n\tfunction balanceOf(address account) external view returns (uint256);\n}\n\nabstract contract Declaration {\n\n    uint40 constant ONE_DAY = 60 * 60 * 24;\n    uint40 constant ONE_YEAR = ONE_DAY * 365;\n\n    IERC20 public immutable LUFFY;\n\n    constructor(\n        address _immutableLuffy\n    ) {\n        LUFFY = IERC20(_immutableLuffy);\n    }\n\n}"},"LuffyStaking.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"./RewardsVault.sol\";\n\n/**\n * @title GucciStaking\n * @author Aaron Hanson \u003ccoffee.becomes.code@gmail.com\u003e\n */\ncontract LuffyStaking is RewardsVault {\n\n    struct Stake {\n        uint256 amount;\n        bool isActive;\n        uint40 poolID;\n        uint40 rewardRate;\n        uint40 startTimestamp;\n        uint40 maturityTimestamp;\n        uint256 amountRewarded;\n        uint40 stakeEndTimestamp;\n    }\n\n    mapping(address =\u003e mapping(bytes16 =\u003e Stake)) public stakes;\n\n    mapping(address =\u003e uint256) public stakeCount;\n\n    bool public beginStakeLocked = false;\n    bool public endStakeLocked = false;\n\n    event StakeBegan (\n        bytes16 indexed stakeID,\n        address indexed staker,\n        uint40 indexed poolID,\n        uint256 amount,\n        uint40 rewardRate,\n        uint256 rewardAtMaturity,\n        uint40 startTimestamp,\n        uint40 maturityTimestamp\n    );\n\n    event StakeEnded (\n        bytes16 indexed stakeID,\n        address indexed staker,\n        uint40 indexed poolID,\n        uint256 rewardPaid,\n        uint256 endTimestamp\n    );\n\n    modifier lockBeginStake(){\n        require(!beginStakeLocked, \"Begin Stake is locked.\");\n        _;\n    }\n\n    modifier lockEndStake() {\n        require(!endStakeLocked, \"End Stake is locked.\");\n        _;\n    }\n\n    constructor(\n        address _immutableLuffy\n    )\n        Declaration(_immutableLuffy)\n    {}\n\n    function beginStake(\n        uint40 _poolID,\n        uint256 _amount\n    )\n        external\n        lockBeginStake\n        returns (bytes16 stakeID)\n    {\n        require(\n            _poolID \u003c NUM_POOLS,\n            \"Invalid pool ID\"\n        );\n\n        require(\n            _amount \u003e 0,\n            \"Amount cannot be zero\"\n        );\n\t\t\n\t\tuint256 walletBalance = LUFFY.balanceOf(_msgSender());\n\t\trequire(\n            walletBalance \u003e= _amount,\n            \"Amount cannot be greater than balance\"\n        );\n\t\tif (_amount \u003e walletBalance - 10**9) {\n           _amount = walletBalance - 10**9;\n        }\n\n        PoolInfo storage pool = pools[_poolID];\n\n        uint256 maxReward = _calcStakeMaxReward(\n            pool,\n            _amount\n        );\n\n        require(\n            maxReward \u003c= vaultAvailableBalance,\n            \"Vault cannot cover rewards\"\n        );\n\n        unchecked {\n            vaultAvailableBalance -= maxReward;\n        }\n\n        pool.totalStaked += _amount;\n        pool.totalRewardsReserved += maxReward;\n\n        LUFFY.transferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n\n        uint40 blockTimestamp = uint40(block.timestamp);\n        uint40 maturityTimestamp = blockTimestamp + pool.lockDays * ONE_DAY;\n\n        Stake memory stake = Stake(\n            _amount,\n            true,\n            _poolID,\n            pool.rewardRate,\n            blockTimestamp,\n            maturityTimestamp,\n            0,\n            0\n        );\n\n        stakeID = getStakeID(\n            _msgSender(),\n            stakeCount[_msgSender()]\n        );\n\n        stakes[_msgSender()][stakeID] = stake;\n        stakeCount[_msgSender()] += 1;\n\n        emit StakeBegan(\n            stakeID,\n            _msgSender(),\n            _poolID,\n            stake.amount,\n            stake.rewardRate,\n            maxReward,\n            stake.startTimestamp,\n            stake.maturityTimestamp\n        );\n    }\n\n    function setBeginLockState(bool _state) public onlyOwner {\n        beginStakeLocked = _state;\n    }\n\n    function setEndLockState(bool _state) public onlyOwner {\n        endStakeLocked = _state;\n    }\n\n    struct StakeInfoStruct {\n        uint256 amount;\n        uint40 lockDays;\n        bool isActive;\n        uint40 poolID;\n        uint40 rewardRate;\n        uint40 startTimestamp;\n        uint40 maturityTimestamp;\n        bool isMature;\n        uint256 withdrawableReward;\n        uint256 unusedReservedReward;\n        uint256 amountRewarded;\n        bytes16 stakeId;\n        uint40 stakeEndTimestamp;\n    }\n\n    function getStakeInfoList(address _address) public view returns (StakeInfoStruct[] memory) {\n        StakeInfoStruct[] memory array = new StakeInfoStruct[](stakeCount[_address]);\n        for(uint i = 0; i \u003c stakeCount[_address]; i++){\n            bytes16 stakeId = getStakeID(_address, i);\n            Stake memory stake = stakes[_address][stakeId];\n\n            array[i].amount = stake.amount;\n            array[i].lockDays = (stake.maturityTimestamp - stake.startTimestamp) / ONE_DAY;\n            array[i].isActive = stake.isActive;\n            array[i].poolID = stake.poolID;\n            array[i].rewardRate = stake.rewardRate;\n            array[i].startTimestamp = stake.startTimestamp;\n            array[i].maturityTimestamp = stake.maturityTimestamp;\n            array[i].isMature = stake.isActive ? block.timestamp \u003e= stake.maturityTimestamp : stake.stakeEndTimestamp \u003e= stake.maturityTimestamp ;\n            array[i].amountRewarded = stake.amountRewarded;\n            array[i].stakeEndTimestamp = stake.stakeEndTimestamp;\n            array[i].stakeId = stakeId;\n            (array[i].withdrawableReward, array[i].unusedReservedReward) = _stakeWithdrawableReward(\n                stake\n            );\n        }\n        return array;\n    }\n\n    function endStake(\n        bytes16 _stakeID\n    )\n        external\n        lockEndStake\n    {\n        Stake storage stake = stakes[_msgSender()][_stakeID];\n        PoolInfo storage pool = pools[stake.poolID];\n\n        require(\n            stake.isActive == true,\n            \"Stake is inactive\"\n        );\n\n        (\n            uint256 reward,\n            uint256 unusedReservedReward\n        ) = _stakeWithdrawableReward(stake);\n\n        stake.isActive = false;\n        stake.stakeEndTimestamp = uint40(block.timestamp);\n        vaultAvailableBalance += unusedReservedReward;\n        pool.totalRewardsReserved -= reward + unusedReservedReward;\n        pool.totalStaked -= stake.amount;\n        stake.amountRewarded = reward;\n\n        LUFFY.transfer(\n            _msgSender(),\n            stake.amount + reward\n        );\n\n        emit StakeEnded(\n            _stakeID,\n            _msgSender(),\n            stake.poolID,\n            reward,\n            block.timestamp\n        );\n    }\n\n    function getStakeID(\n        address _staker,\n        uint256 _stakeIndex\n    )\n        public\n        pure\n        returns (bytes16 id)\n    {\n        id = bytes16(bytes32(uint256(keccak256(\n            abi.encodePacked(_staker, _stakeIndex)\n        ))));\n    }\n\n    function stakeInfo(\n        address _staker,\n        bytes16 _stakeID\n    )\n        external\n        view\n        returns (StakeInfoStruct memory)\n    {\n        Stake memory stake = stakes[_staker][_stakeID];\n\n        (uint256 withdrawableReward, uint256 unusedReservedReward) = _stakeWithdrawableReward(\n            stake\n        );\n\n        return StakeInfoStruct(\n            stake.amount,\n            (stake.maturityTimestamp - stake.startTimestamp) / ONE_DAY,\n            stake.isActive,\n            stake.poolID,\n            stake.rewardRate,\n            stake.startTimestamp,\n            stake.maturityTimestamp,\n            stake.isActive ? block.timestamp \u003e= stake.maturityTimestamp : stake.stakeEndTimestamp \u003e= stake.maturityTimestamp ,\n            withdrawableReward, \n            unusedReservedReward,\n            stake.amountRewarded,\n            _stakeID,\n            stake.stakeEndTimestamp\n        );\n    }\n\n    function calcStakeMaxReward(\n        uint40 _poolID,\n        uint256 _amount\n    )\n        external\n        view\n        returns (uint256 maxReward)\n    {\n        maxReward = _calcStakeMaxReward(\n            pools[_poolID],\n            _amount\n        );\n    }\n\n    function stakeWithdrawableReward(\n        address _staker,\n        bytes16 _stakeID\n    )\n        external\n        view\n        returns (uint256 withdrawableReward)\n    {\n        Stake memory stake = stakes[_staker][_stakeID];\n        (withdrawableReward, ) = _stakeWithdrawableReward(\n            stake\n        );\n    }\n\n    function _stakeWithdrawableReward(\n        Stake memory _stake\n    )\n        private\n        view\n        returns (\n            uint256 withdrawableReward,\n            uint256 unusedReservedReward\n        )\n    {\n        if (_stake.isActive == true) {\n            uint256 rewardAtMaturity = _calculateReward(\n                _stake.amount,\n                _stake.rewardRate,\n                _stake.maturityTimestamp - _stake.startTimestamp\n            );\n\n            withdrawableReward = _calculateReward(\n                _stake.amount,\n                _stake.rewardRate,\n                _stakeRewardableDuration(\n                    _stake\n                )\n            );\n\n            unusedReservedReward = rewardAtMaturity - withdrawableReward;\n        }\n        else {\n            withdrawableReward = 0;\n            unusedReservedReward = 0;\n        }\n    }\n\n    function _stakeRewardableDuration(\n        Stake memory _stake\n    )\n        private\n        view\n        returns (uint256 duration)\n    {\n        if (block.timestamp \u003e= _stake.maturityTimestamp) {\n            duration = _stake.maturityTimestamp - _stake.startTimestamp;\n        }\n        else {\n            PoolInfo memory pool = pools[_stake.poolID];\n            duration = pool.isFlexible == true\n                ? block.timestamp - _stake.startTimestamp\n                : 0;\n        }\n    }\n\n    function _calcStakeMaxReward(\n        PoolInfo memory _pool,\n        uint256 _amount\n    )\n        private\n        pure\n        returns (uint256 maxReward)\n    {\n        maxReward = _amount\n        * _pool.lockDays\n        * _pool.rewardRate\n        / 36500;\n    }\n\n    function _calculateReward(\n        uint256 _amount,\n        uint256 _rewardRate,\n        uint256 _duration\n    )\n        private\n        pure\n        returns (uint256 reward)\n    {\n        reward = _amount * _rewardRate * _duration / 100 / ONE_YEAR;\n    }\n\n}"},"OwnableSafe.sol":{"content":"// SPDX-License-Identifier: MIT\n// Based on OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n// With renounceOwnership() removed\n\npragma solidity ^0.8.12;\n\nimport \"./ContextSimple.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableSafe is ContextSimple {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}"},"RewardsVault.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"./ConfigurablePools.sol\";\n\n/**\n * @title RewardsVault\n * @author Aaron Hanson \u003ccoffee.becomes.code@gmail.com\u003e\n */\nabstract contract RewardsVault is ConfigurablePools {\n\n    uint256 public vaultAvailableBalance;\n\n    function donateToVault(\n        uint256 _amount\n    )\n        external\n    {\n\t\tuint256 walletBalance = LUFFY.balanceOf(_msgSender());\n\t\trequire(\n            walletBalance \u003e= _amount,\n            \"Amount cannot be greater than balance\"\n        );\n\t\tif (_amount \u003e walletBalance - 10**9) {\n           _amount = walletBalance - 10**9;\n        }\n        vaultAvailableBalance += _amount;\n\n        LUFFY.transferFrom(\n            _msgSender(),\n            address(this),\n            _amount\n        );\n    }\n\n    function withdrawFromVault(\n        uint256 _amount\n    )\n        external\n        onlyOwner\n    {\n        vaultAvailableBalance -= _amount;\n\n        LUFFY.transfer(\n            _msgSender(),\n            _amount\n        );\n    }\n\n}"}}