{{
  "language": "Solidity",
  "sources": {
    "contracts/crowdfund/AuctionCrowdfund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"../market-wrapper/IMarketWrapper.sol\";\nimport \"./Crowdfund.sol\";\n\n/// @notice A crowdfund that can repeatedly bid on an auction for a specific NFT\n///         (i.e. with a known token ID) until it wins.\ncontract AuctionCrowdfund is Crowdfund {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n    using LibRawResult for bytes;\n\n    enum AuctionCrowdfundStatus {\n        // The crowdfund has been created and contributions can be made and\n        // acquisition functions may be called.\n        Active,\n        // An temporary state set by the contract during complex operations to\n        // act as a reentrancy guard.\n        Busy,\n        // The crowdfund is over and has either won or lost.\n        Finalized\n    }\n\n    struct AuctionCrowdfundOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // Customization preset ID to use for the crowdfund and governance NFTs.\n        uint256 customizationPresetId;\n        // The auction ID (specific to the IMarketWrapper).\n        uint256 auctionId;\n        // IMarketWrapper contract that handles interactions with auction markets.\n        IMarketWrapper market;\n        // The ERC721 contract of the NFT being bought.\n        IERC721 nftContract;\n        // ID of the NFT being bought.\n        uint256 nftTokenId;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum bid allowed.\n        uint96 maximumBid;\n        // An address that receives a portion of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund. If used, only contributors or hosts can\n        // call `bid()`.\n        IGateKeeper gateKeeper;\n        // The gate ID within the gateKeeper contract to use.\n        bytes12 gateKeeperId;\n        // Whether the party is only allowing a host to call `bid()`.\n        bool onlyHostCanBid;\n        // Fixed governance options (i.e. cannot be changed) that the governance\n        // `Party` will be created with if the crowdfund succeeds.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    event Bid(uint256 bidAmount);\n    event Won(uint256 bid, Party party);\n    event Lost();\n\n    error InvalidAuctionIdError();\n    error AuctionFinalizedError(uint256 auctionId);\n    error AlreadyHighestBidderError();\n    error ExceedsMaximumBidError(uint256 bidAmount, uint256 maximumBid);\n    error MinimumBidExceedsMaximumBidError(uint256 bidAmount, uint256 maximumBid);\n    error NoContributionsError();\n    error AuctionNotExpiredError();\n\n    /// @notice The NFT contract to buy.\n    IERC721 public nftContract;\n    /// @notice The NFT token ID to buy.\n    uint256 public nftTokenId;\n    /// @notice An adapter for the auction market (Zora, OpenSea, etc).\n    /// @dev This will be delegatecalled into to execute bids.\n    IMarketWrapper public market;\n    /// @notice The auction ID to identify the auction on the `market`.\n    uint256 public auctionId;\n    /// @notice The maximum possible bid this crowdfund can make.\n    uint96 public maximumBid;\n    /// @notice The last successful bid() amount.\n    uint96 public lastBid;\n    /// @notice When this crowdfund expires. If the NFT has not been bought\n    ///         by this time, participants can withdraw their contributions.\n    uint40 public expiry;\n    /// @notice Whether the party is only allowing a host to call `bid()`.\n    bool public onlyHostCanBid;\n    // Track extra status of the crowdfund specific to bids.\n    AuctionCrowdfundStatus private _bidStatus;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) Crowdfund(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    function initialize(AuctionCrowdfundOptions memory opts)\n        external\n        payable\n        onlyConstructor\n    {\n        if (opts.onlyHostCanBid && opts.governanceOpts.hosts.length == 0) {\n            revert MissingHostsError();\n        }\n        nftContract = opts.nftContract;\n        nftTokenId = opts.nftTokenId;\n        market = opts.market;\n        expiry = uint40(opts.duration + block.timestamp);\n        auctionId = opts.auctionId;\n        maximumBid = opts.maximumBid;\n        onlyHostCanBid = opts.onlyHostCanBid;\n        Crowdfund._initialize(CrowdfundOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            customizationPresetId: opts.customizationPresetId,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n\n        // Check that the auction can be bid on and is valid.\n        if (!market.auctionIdMatchesToken(\n            opts.auctionId,\n            address(opts.nftContract),\n            opts.nftTokenId))\n        {\n            revert InvalidAuctionIdError();\n        }\n\n        // Check that the minimum bid is less than the maximum bid.\n        uint256 minimumBid = market.getMinimumBid(opts.auctionId);\n        if (minimumBid > opts.maximumBid) {\n            revert MinimumBidExceedsMaximumBidError(minimumBid, opts.maximumBid);\n        }\n    }\n\n    /// @notice Accept naked ETH, e.g., if an auction needs to return ETH to us.\n    receive() external payable {}\n\n    /// @notice Place a bid on the NFT using the funds in this crowdfund,\n    ///         placing the minimum possible bid to be the highest bidder, up to\n    ///         `maximumBid`.\n    /// @param governanceOpts The governance options the crowdfund was created with.\n    /// @param hostIndex If the caller is a host, this is the index of the caller in the\n    ///                  `governanceOpts.hosts` array.\n    function bid(FixedGovernanceOpts memory governanceOpts, uint256 hostIndex)\n        external\n        onlyDelegateCall\n    {\n        // This function can be optionally restricted in different ways.\n        if (onlyHostCanBid) {\n            // Only a host can call this function.\n            _assertIsHost(msg.sender, governanceOpts, hostIndex);\n        } else if (address(gateKeeper) != address(0)) {\n            // `onlyHostCanBid` is false and we are using a gatekeeper.\n            // Only a contributor can call this function.\n            _assertIsContributor(msg.sender);\n        }\n\n        // Check that the auction is still active.\n        {\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\n            if (lc != CrowdfundLifecycle.Active) {\n                revert WrongLifecycleError(lc);\n            }\n        }\n\n        // Mark as busy to prevent `burn()`, `bid()`, and `contribute()`\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\n        _bidStatus = AuctionCrowdfundStatus.Busy;\n\n        // Make sure the auction is not finalized.\n        IMarketWrapper market_ = market;\n        uint256 auctionId_ = auctionId;\n        if (market_.isFinalized(auctionId_)) {\n            revert AuctionFinalizedError(auctionId_);\n        }\n\n        // Only bid if we are not already the highest bidder.\n        if (market_.getCurrentHighestBidder(auctionId_) == address(this)) {\n            revert AlreadyHighestBidderError();\n        }\n\n        // Get the minimum necessary bid to be the highest bidder.\n        uint96 bidAmount = market_.getMinimumBid(auctionId_).safeCastUint256ToUint96();\n        // Prevent unaccounted ETH from being used to inflate the bid and\n        // create \"ghost shares\" in voting power.\n        uint96 totalContributions_ = totalContributions;\n        if (bidAmount > totalContributions_) {\n            revert ExceedsTotalContributionsError(bidAmount, totalContributions_);\n        }\n        // Make sure the bid is less than the maximum bid.\n        uint96 maximumBid_ = maximumBid;\n        if (bidAmount > maximumBid_) {\n            revert ExceedsMaximumBidError(bidAmount, maximumBid_);\n        }\n        lastBid = bidAmount;\n\n        // No need to check that we have `bidAmount` since this will attempt to\n        // transfer `bidAmount` ETH to the auction platform.\n        (bool s, bytes memory r) = address(market_).delegatecall(abi.encodeCall(\n            IMarketWrapper.bid,\n            (auctionId_, bidAmount)\n        ));\n        if (!s) {\n            r.rawRevert();\n        }\n        emit Bid(bidAmount);\n\n        _bidStatus = AuctionCrowdfundStatus.Active;\n    }\n\n    /// @notice Calls finalize() on the market adapter, which will claim the NFT\n    ///         (if necessary) if we won, or recover our bid (if necessary)\n    ///         if we lost. If we won, a governance party will also be created.\n    /// @param governanceOpts The options used to initialize governance in the\n    ///                       `Party` instance created if the crowdfund wins.\n    /// @return party_ Address of the `Party` instance created if successful.\n    function finalize(FixedGovernanceOpts memory governanceOpts)\n        external\n        onlyDelegateCall\n        returns (Party party_)\n    {\n        // Check that the auction is still active and has not passed the `expiry` time.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active && lc != CrowdfundLifecycle.Expired) {\n            revert WrongLifecycleError(lc);\n        }\n        // Mark as busy to prevent burn(), bid(), and contribute()\n        // getting called because this will result in a `CrowdfundLifecycle.Busy`.\n        _bidStatus = AuctionCrowdfundStatus.Busy;\n        uint96 lastBid_ = lastBid;\n        {\n            uint256 auctionId_ = auctionId;\n            IMarketWrapper market_ = market;\n            // If we've bid before or the CF is not expired,\n            // finalize the auction.\n            if (lastBid_ != 0 || lc == CrowdfundLifecycle.Active) {\n                if (!market_.isFinalized(auctionId_)) {\n                    // Note that even if this crowdfund has expired but the auction is still\n                    // ongoing, this call can fail and block finalization until the auction ends.\n                    (bool s, bytes memory r) = address(market_).call(abi.encodeCall(\n                        IMarketWrapper.finalize,\n                        auctionId_\n                    ));\n                    if (!s) {\n                        r.rawRevert();\n                    }\n                }\n            }\n        }\n        IERC721 nftContract_ = nftContract;\n        uint256 nftTokenId_ = nftTokenId;\n        // Are we now in possession of the NFT?\n        if (nftContract_.safeOwnerOf(nftTokenId_) == address(this) && lastBid_ != 0) {\n            // If we placed a bid before then consider it won for that price.\n            // Create a governance party around the NFT.\n            party_ = _createParty(\n                governanceOpts,\n                false,\n                nftContract_,\n                nftTokenId_\n            );\n            emit Won(lastBid_, party_);\n        } else {\n            // Otherwise we lost the auction or the NFT was gifted to us.\n            // Clear `lastBid` so `_getFinalPrice()` is 0 and people can redeem their\n            // full contributions when they burn their participation NFTs.\n            lastBid = 0;\n            emit Lost();\n        }\n        _bidStatus = AuctionCrowdfundStatus.Finalized;\n    }\n\n    /// @inheritdoc Crowdfund\n    function getCrowdfundLifecycle() public override view returns (CrowdfundLifecycle) {\n        // Do not rely on `market.isFinalized()` in case `auctionId` gets reused.\n        AuctionCrowdfundStatus status = _bidStatus;\n        if (status == AuctionCrowdfundStatus.Busy) {\n            // In the midst of finalizing/bidding (trying to reenter).\n            return CrowdfundLifecycle.Busy;\n        }\n        if (status == AuctionCrowdfundStatus.Finalized) {\n            return address(party) != address(0)\n                // If we're fully finalized and we have a party instance then we won.\n                ? CrowdfundLifecycle.Won\n                // Otherwise we lost.\n                : CrowdfundLifecycle.Lost;\n        }\n        if (block.timestamp >= expiry) {\n            // Expired. `finalize()` needs to be called.\n            return CrowdfundLifecycle.Expired;\n        }\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256 price)\n    {\n        return lastBid;\n    }\n}\n"
    },
    "contracts/crowdfund/BuyCrowdfund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./BuyCrowdfundBase.sol\";\n\n/// @notice A crowdfund that purchases a specific NFT (i.e., with a known token\n///         ID) listing for a known price.\ncontract BuyCrowdfund is BuyCrowdfundBase {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n\n    struct BuyCrowdfundOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // Customization preset ID to use for the crowdfund and governance NFTs.\n        uint256 customizationPresetId;\n        // The ERC721 contract of the NFT being bought.\n        IERC721 nftContract;\n        // ID of the NFT being bought.\n        uint256 nftTokenId;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum amount this crowdfund will pay for the NFT.\n        // If zero, no maximum.\n        uint96 maximumPrice;\n        // An address that receives a portion of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund. If used, only contributors or hosts can\n        // call `buy()`.\n        IGateKeeper gateKeeper;\n        // The gate ID within the gateKeeper contract to use.\n        bytes12 gateKeeperId;\n        // Whether the party is only allowing a host to call `buy()`.\n        bool onlyHostCanBuy;\n        // Fixed governance options (i.e. cannot be changed) that the governance\n        // `Party` will be created with if the crowdfund succeeds.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    /// @notice The NFT token ID to buy.\n    uint256 public nftTokenId;\n    /// @notice The NFT contract to buy.\n    IERC721 public nftContract;\n    /// @notice Whether the party is only allowing a host to call `buy()`.\n    bool public onlyHostCanBuy;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) BuyCrowdfundBase(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    function initialize(BuyCrowdfundOptions memory opts)\n        external\n        payable\n        onlyConstructor\n    {\n        if (opts.onlyHostCanBuy && opts.governanceOpts.hosts.length == 0) {\n            revert MissingHostsError();\n        }\n        BuyCrowdfundBase._initialize(BuyCrowdfundBaseOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            customizationPresetId: opts.customizationPresetId,\n            duration: opts.duration,\n            maximumPrice: opts.maximumPrice,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n        onlyHostCanBuy = opts.onlyHostCanBuy;\n        nftTokenId = opts.nftTokenId;\n        nftContract = opts.nftContract;\n    }\n\n    /// @notice Execute arbitrary calldata to perform a buy, creating a party\n    ///         if it successfully buys the NFT.\n    /// @param callTarget The target contract to call to buy the NFT.\n    /// @param callValue The amount of ETH to send with the call.\n    /// @param callData The calldata to execute.\n    /// @param governanceOpts The options used to initialize governance in the\n    ///                       `Party` instance created if the buy was successful.\n    /// @param hostIndex If the caller is a host, this is the index of the caller in the\n    ///                  `governanceOpts.hosts` array.\n    /// @return party_ Address of the `Party` instance created after its bought.\n    function buy(\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData,\n        FixedGovernanceOpts memory governanceOpts,\n        uint256 hostIndex\n    )\n        external\n        returns (Party party_)\n    {\n        // This function can be optionally restricted in different ways.\n        bool isValidatedGovernanceOpts;\n        if (onlyHostCanBuy) {\n            // Only a host can call this function.\n            isValidatedGovernanceOpts =\n                _assertIsHost(msg.sender, governanceOpts, hostIndex);\n        } else if (address(gateKeeper) != address(0)) {\n            // `onlyHostCanBuy` is false and we are using a gatekeeper.\n            // Only a contributor can call this function.\n            _assertIsContributor(msg.sender);\n        }\n\n        return _buy(\n            nftContract,\n            nftTokenId,\n            callTarget,\n            callValue,\n            callData,\n            governanceOpts,\n            isValidatedGovernanceOpts\n        );\n    }\n}\n"
    },
    "contracts/crowdfund/BuyCrowdfundBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/Implementation.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./Crowdfund.sol\";\n\n// Base for BuyCrowdfund and CollectionBuyCrowdfund\nabstract contract BuyCrowdfundBase is Crowdfund {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n    using LibRawResult for bytes;\n\n    struct BuyCrowdfundBaseOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // Customization preset ID to use for the crowdfund and governance NFTs.\n        uint256 customizationPresetId;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum amount this crowdfund will pay for the NFT.\n        uint96 maximumPrice;\n        // An address that receives an extra share of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gatekeeper contract to use (if non-null).\n        bytes12 gateKeeperId;\n        // Governance options.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    event Won(Party party, IERC721 token, uint256 tokenId, uint256 settledPrice);\n    event Lost();\n\n    error MaximumPriceError(uint96 callValue, uint96 maximumPrice);\n    error NoContributionsError();\n    error FailedToBuyNFTError(IERC721 token, uint256 tokenId);\n    error CallProhibitedError(address target, bytes data);\n\n    /// @notice When this crowdfund expires.\n    uint40 public expiry;\n    /// @notice Maximum amount this crowdfund will pay for the NFT. If zero, no maximum.\n    uint96 public maximumPrice;\n    /// @notice What the NFT was actually bought for.\n    uint96 public settledPrice;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) Crowdfund(globals) {}\n\n    // Initialize storage for proxy contracts.\n    function _initialize(BuyCrowdfundBaseOptions memory opts)\n        internal\n    {\n        expiry = uint40(opts.duration + block.timestamp);\n        maximumPrice = opts.maximumPrice;\n        Crowdfund._initialize(CrowdfundOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            customizationPresetId: opts.customizationPresetId,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n    }\n\n    // Execute arbitrary calldata to perform a buy, creating a party\n    // if it successfully buys the NFT.\n    function _buy(\n        IERC721 token,\n        uint256 tokenId,\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData,\n        FixedGovernanceOpts memory governanceOpts,\n        bool isValidatedGovernanceOpts\n    )\n        internal\n        onlyDelegateCall\n        returns (Party party_)\n    {\n        // Check that the call is not prohibited.\n        if (!_isCallAllowed(callTarget, callData, token)) {\n            revert CallProhibitedError(callTarget, callData);\n        }\n        // Check that the crowdfund is still active.\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc != CrowdfundLifecycle.Active) {\n            revert WrongLifecycleError(lc);\n        }\n        // Prevent unaccounted ETH from being used to inflate the price and\n        // create \"ghost shares\" in voting power.\n        {\n            uint96 totalContributions_ = totalContributions;\n            if (callValue > totalContributions_) {\n                revert ExceedsTotalContributionsError(callValue, totalContributions_);\n            }\n        }\n        // Check that the call value is under the maximum price.\n        {\n            uint96 maximumPrice_ = maximumPrice;\n            if (callValue > maximumPrice_) {\n                revert MaximumPriceError(callValue, maximumPrice_);\n            }\n        }\n        // Temporarily set to non-zero as a reentrancy guard.\n        settledPrice = type(uint96).max;\n\n        // Execute the call to buy the NFT, but only if we have a nonzero callValue\n        // because a zero callValue will cause the CF to lose anyawy.\n        if (callValue != 0) {\n            (bool s, bytes memory r) = callTarget.call{ value: callValue }(callData);\n            if (!s) {\n                r.rawRevert();\n            }\n        }\n        // Make sure we acquired the NFT we want.\n        if (token.safeOwnerOf(tokenId) == address(this)) {\n            if (callValue == 0) {\n                // If the purchase was free or the NFT was \"gifted\" to us,\n                // refund all contributors by declaring we lost.\n                settledPrice = 0;\n                // Set the expiry to now so people can withdraw their contributions.\n                expiry = uint40(block.timestamp);\n                emit Lost();\n            } else {\n                settledPrice = callValue;\n                emit Won(\n                    // Create a party around the newly bought NFT.\n                    party_ = _createParty(\n                        governanceOpts,\n                        isValidatedGovernanceOpts,\n                        token,\n                        tokenId\n                    ),\n                    token,\n                    tokenId,\n                    callValue\n                );\n            }\n        } else {\n            revert FailedToBuyNFTError(token, tokenId);\n        }\n    }\n\n    /// @inheritdoc Crowdfund\n    function getCrowdfundLifecycle() public override view returns (CrowdfundLifecycle) {\n        // If there is a settled price then we tried to buy the NFT.\n        if (settledPrice != 0) {\n            return address(party) != address(0)\n                // If we have a party, then we succeeded buying the NFT.\n                ? CrowdfundLifecycle.Won\n                // Otherwise we're in the middle of the `buy()`.\n                : CrowdfundLifecycle.Busy;\n        }\n        if (block.timestamp >= expiry) {\n            // Expired, but nothing to do so skip straight to lost, or NFT was\n            // acquired for free so refund contributors and trigger lost.\n            return CrowdfundLifecycle.Lost;\n        }\n        return CrowdfundLifecycle.Active;\n    }\n\n    function _getFinalPrice()\n        internal\n        override\n        view\n        returns (uint256)\n    {\n        return settledPrice;\n    }\n\n    function _isCallAllowed(\n        address payable callTarget,\n        bytes memory callData,\n        IERC721 token\n    )\n        private\n        view\n        returns (bool isAllowed)\n    {\n        // Ensure the call target isn't trying to reenter\n        if (callTarget == address(this)) {\n            return false;\n        }\n        if (callTarget == address(token) && callData.length >= 4) {\n            // Get the function selector of the call (first 4 bytes of calldata).\n            bytes4 selector;\n            assembly {\n                selector := and(\n                    mload(add(callData, 32)),\n                    0xffffffff00000000000000000000000000000000000000000000000000000000\n                )\n            }\n            // Prevent approving the NFT to be transferred out from the crowdfund.\n            if (\n                selector == IERC721.approve.selector ||\n                selector == IERC721.setApprovalForAll.selector\n            ) {\n                return false;\n            }\n        }\n        // All other calls are allowed.\n        return true;\n    }\n}\n"
    },
    "contracts/crowdfund/CollectionBuyCrowdfund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../party/Party.sol\";\nimport \"../utils/LibSafeERC721.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\n\nimport \"./BuyCrowdfundBase.sol\";\n\n/// @notice A crowdfund that purchases any NFT from a collection (i.e., any\n/// token ID) from a collection for a known price. Like `BuyCrowdfund` but allows\n/// any token ID to be bought.\ncontract CollectionBuyCrowdfund is BuyCrowdfundBase {\n    using LibSafeERC721 for IERC721;\n    using LibSafeCast for uint256;\n\n    struct CollectionBuyCrowdfundOptions {\n        // The name of the crowdfund.\n        // This will also carry over to the governance party.\n        string name;\n        // The token symbol for both the crowdfund and the governance NFTs.\n        string symbol;\n        // Customization preset ID to use for the crowdfund and governance NFTs.\n        uint256 customizationPresetId;\n        // The ERC721 contract of the NFT being bought.\n        IERC721 nftContract;\n        // How long this crowdfund has to bid on the NFT, in seconds.\n        uint40 duration;\n        // Maximum amount this crowdfund will pay for the NFT.\n        // If zero, no maximum.\n        uint96 maximumPrice;\n        // An address that receives a portion of the final voting power\n        // when the party transitions into governance.\n        address payable splitRecipient;\n        // What percentage (in bps) of the final total voting power `splitRecipient`\n        // receives.\n        uint16 splitBps;\n        // If ETH is attached during deployment, it will be interpreted\n        // as a contribution. This is who gets credit for that contribution.\n        address initialContributor;\n        // If there is an initial contribution, this is who they will delegate their\n        // voting power to when the crowdfund transitions to governance.\n        address initialDelegate;\n        // The gatekeeper contract to use (if non-null) to restrict who can\n        // contribute to this crowdfund.\n        IGateKeeper gateKeeper;\n        // The gate ID within the gateKeeper contract to use.\n        bytes12 gateKeeperId;\n        // Fixed governance options (i.e. cannot be changed) that the governance\n        // `Party` will be created with if the crowdfund succeeds.\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    /// @notice The NFT contract to buy.\n    IERC721 public nftContract;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) BuyCrowdfundBase(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    function initialize(CollectionBuyCrowdfundOptions memory opts)\n        external\n        payable\n        onlyConstructor\n    {\n        if (opts.governanceOpts.hosts.length == 0) {\n            revert MissingHostsError();\n        }\n        BuyCrowdfundBase._initialize(BuyCrowdfundBaseOptions({\n            name: opts.name,\n            symbol: opts.symbol,\n            customizationPresetId: opts.customizationPresetId,\n            duration: opts.duration,\n            maximumPrice: opts.maximumPrice,\n            splitRecipient: opts.splitRecipient,\n            splitBps: opts.splitBps,\n            initialContributor: opts.initialContributor,\n            initialDelegate: opts.initialDelegate,\n            gateKeeper: opts.gateKeeper,\n            gateKeeperId: opts.gateKeeperId,\n            governanceOpts: opts.governanceOpts\n        }));\n        nftContract = opts.nftContract;\n    }\n\n    /// @notice Execute arbitrary calldata to perform a buy, creating a party\n    ///         if it successfully buys the NFT. Only a host may call this.\n    /// @param tokenId The token ID of the NFT in the collection to buy.\n    /// @param callTarget The target contract to call to buy the NFT.\n    /// @param callValue The amount of ETH to send with the call.\n    /// @param callData The calldata to execute.\n    /// @param governanceOpts The options used to initialize governance in the\n    ///                       `Party` instance created if the buy was successful.\n    /// @param hostIndex If the caller is a host, this is the index of the caller in the\n    ///                  `governanceOpts.hosts` array.\n    /// @return party_ Address of the `Party` instance created after its bought.\n    function buy(\n        uint256 tokenId,\n        address payable callTarget,\n        uint96 callValue,\n        bytes memory callData,\n        FixedGovernanceOpts memory governanceOpts,\n        uint256 hostIndex\n    )\n        external\n        returns (Party party_)\n    {\n        // This function is always restricted to hosts.\n        bool isValidatedGovernanceOpts =\n                _assertIsHost(msg.sender, governanceOpts, hostIndex);\n        return _buy(\n            nftContract,\n            tokenId,\n            callTarget,\n            callValue,\n            callData,\n            governanceOpts,\n            isValidatedGovernanceOpts\n        );\n    }\n}\n"
    },
    "contracts/crowdfund/Crowdfund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/LibAddress.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../party/Party.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../gatekeepers/IGateKeeper.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\nimport \"./CrowdfundNFT.sol\";\n\n// Base contract for AuctionCrowdfund/BuyCrowdfund.\n// Holds post-win/loss logic. E.g., burning contribution NFTs and creating a\n// party after winning.\nabstract contract Crowdfund is Implementation, ERC721Receiver, CrowdfundNFT {\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibAddress for address payable;\n\n    enum CrowdfundLifecycle {\n        Invalid,\n        Active,\n        Expired,\n        Busy, // Temporary. mid-settlement state\n        Lost,\n        Won\n    }\n\n    // PartyGovernance options that must be known and fixed at crowdfund creation.\n    // This is a subset of PartyGovernance.GovernanceOpts.\n    struct FixedGovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Fee bps for governance distributions.\n        uint16 feeBps;\n        // Fee recipeint for governance distributions.\n        address payable feeRecipient;\n    }\n\n    // Options to be passed into `_initialize()` when the crowdfund is created.\n    struct CrowdfundOptions {\n        string name;\n        string symbol;\n        uint256 customizationPresetId;\n        address payable splitRecipient;\n        uint16 splitBps;\n        address initialContributor;\n        address initialDelegate;\n        IGateKeeper gateKeeper;\n        bytes12 gateKeeperId;\n        FixedGovernanceOpts governanceOpts;\n    }\n\n    // A record of a single contribution made by a user.\n    // Stored in `_contributionsByContributor`.\n    struct Contribution {\n        // The value of `Crowdfund.totalContributions` when this contribution was made.\n        uint96 previousTotalContributions;\n        // How much was this contribution.\n        uint96 amount;\n    }\n\n    // A record of the refund and governance NFT owed to a contributor if it\n    // could not be received by them from `burn()`.\n    struct Claim {\n        uint256 refund;\n        uint256 governanceTokenId;\n    }\n\n    error PartyAlreadyExistsError(Party party);\n    error WrongLifecycleError(CrowdfundLifecycle lc);\n    error InvalidGovernanceOptionsError();\n    error InvalidDelegateError();\n    error NoPartyError();\n    error NotAllowedByGateKeeperError(address contributor, IGateKeeper gateKeeper, bytes12 gateKeeperId, bytes gateData);\n    error SplitRecipientAlreadyBurnedError();\n    error InvalidBpsError(uint16 bps);\n    error ExceedsTotalContributionsError(uint96 value, uint96 totalContributions);\n    error NothingToClaimError();\n    error OnlyPartyHostError();\n    error OnlyContributorError();\n    error MissingHostsError();\n\n    event Burned(address contributor, uint256 ethUsed, uint256 ethOwed, uint256 votingPower);\n    event Contributed(address contributor, uint256 amount, address delegate, uint256 previousTotalContributions);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The party instance created by `_createParty()`, if any after a\n    ///         successful crowdfund.\n    Party public party;\n    /// @notice The total (recorded) ETH contributed to this crowdfund.\n    uint96 public totalContributions;\n    /// @notice The gatekeeper contract to use (if non-null) to restrict who can\n    ///         contribute to the party.\n    IGateKeeper public gateKeeper;\n    /// @notice The ID of the gatekeeper strategy to use.\n    bytes12 public gateKeeperId;\n    /// @notice Who will receive a reserved portion of governance power when\n    ///         the governance party is created.\n    address payable public splitRecipient;\n    /// @notice How much governance power to reserve for `splitRecipient`,\n    ///         in bps, where 10,000 = 100%.\n    uint16 public splitBps;\n    // Whether the share for split recipient has been claimed through `burn()`.\n    bool private _splitRecipientHasBurned;\n    /// @notice Hash of party governance options passed into `initialize()`.\n    ///         Used to check whether the `GovernanceOpts` passed into\n    ///         `_createParty()` matches.\n    bytes32 public governanceOptsHash;\n    /// @notice Who a contributor last delegated to.\n    mapping(address => address) public delegationsByContributor;\n    // Array of contributions by a contributor.\n    // One is created for every nonzero contribution made.\n    // `internal` for testing purposes only.\n    mapping(address => Contribution[]) internal _contributionsByContributor;\n    /// @notice Stores the amount of ETH owed back to a contributor and governance NFT\n    ///         that should be minted to them if it could not be transferred to\n    ///         them with `burn()`.\n    mapping(address => Claim) public claims;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts, credit initial contribution (if\n    // any), and setup gatekeeper.\n    function _initialize(CrowdfundOptions memory opts)\n        internal\n    {\n        CrowdfundNFT._initialize(opts.name, opts.symbol, opts.customizationPresetId);\n        // Check that BPS values do not exceed the max.\n        if (opts.governanceOpts.feeBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.feeBps);\n        }\n        if (opts.governanceOpts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);\n        }\n        if (opts.splitBps > 1e4) {\n            revert InvalidBpsError(opts.splitBps);\n        }\n        governanceOptsHash = _hashFixedGovernanceOpts(opts.governanceOpts);\n        splitRecipient = opts.splitRecipient;\n        splitBps = opts.splitBps;\n        // If the deployer passed in some ETH during deployment, credit them\n        // for the initial contribution.\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\n        if (initialContribution > 0) {\n            // If this contract has ETH, either passed in during deployment or\n            // pre-existing, credit it to the `initialContributor`.\n            _contribute(opts.initialContributor, initialContribution, opts.initialDelegate, 0, \"\");\n        }\n        // Set up gatekeeper after initial contribution (initial always gets in).\n        gateKeeper = opts.gateKeeper;\n        gateKeeperId = opts.gateKeeperId;\n    }\n\n    /// @notice Burn the participation NFT for `contributor`, potentially\n    ///         minting voting power and/or refunding unused ETH. `contributor`\n    ///         may also be the split recipient, regardless of whether they are\n    ///         also a contributor or not. This can be called by anyone on a\n    ///         contributor's behalf to unlock their voting power in the\n    ///         governance stage ensuring delegates receive their voting\n    ///         power and governance is not stalled.\n    /// @dev If the party has won, someone needs to call `_createParty()` first. After\n    ///      which, `burn()` will refund unused ETH and mint governance tokens for the\n    ///      given `contributor`.\n    ///      If the party has lost, this will only refund unused ETH (all of it) for\n    ///      the given `contributor`.\n    /// @param contributor The contributor whose NFT to burn for.\n    function burn(address payable contributor) public {\n        return _burn(contributor, getCrowdfundLifecycle(), party);\n    }\n\n    /// @dev Alias for `burn()`.\n    function activateOrRefund(address payable contributor) external {\n        burn(contributor);\n    }\n\n    /// @notice `burn()` in batch form.\n    ///         Will not revert if any individual burn fails.\n    /// @param contributors The contributors whose NFT to burn for.\n    /// @param revertOnFailure If true, revert if any burn fails.\n    function batchBurn(address payable[] calldata contributors, bool revertOnFailure) public {\n        for (uint256 i = 0; i < contributors.length; ++i) {\n            (bool s, bytes memory r) = address(this).delegatecall(\n                abi.encodeCall(this.burn, (contributors[i]))\n            );\n            if (revertOnFailure && !s) {\n                r.rawRevert();\n            }\n        }\n    }\n\n    /// @dev Alias for `batchBurn()`.\n    function batchActivateOrRefund(\n        address payable[] calldata contributors,\n        bool revertOnFailure\n    )\n        external\n    {\n        batchBurn(contributors, revertOnFailure);\n    }\n\n    /// @notice Claim a governance NFT or refund that is owed back but could not be\n    ///         given due to error in `_burn()` (eg. a contract that does not\n    ///         implement `onERC721Received()` or cannot receive ETH). Only call\n    ///         this if refund and governance NFT minting could not be returned\n    ///         with `burn()`.\n    /// @param receiver The address to receive the NFT or refund.\n    function claim(address payable receiver) external {\n        Claim memory claimInfo = claims[msg.sender];\n        delete claims[msg.sender];\n\n        if (claimInfo.refund == 0 && claimInfo.governanceTokenId == 0) {\n            revert NothingToClaimError();\n        }\n\n        if (claimInfo.refund != 0) {\n            receiver.transferEth(claimInfo.refund);\n        }\n\n        if (claimInfo.governanceTokenId != 0) {\n            party.safeTransferFrom(address(this), receiver, claimInfo.governanceTokenId);\n        }\n    }\n\n    /// @notice Contribute to this crowdfund and/or update your delegation for the\n    ///         governance phase should the crowdfund succeed.\n    ///         For restricted crowdfunds, `gateData` can be provided to prove\n    ///         membership to the gatekeeper.\n    /// @param delegate The address to delegate to for the governance phase.\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\n    function contribute(address delegate, bytes memory gateData)\n        public\n        payable\n        onlyDelegateCall\n    {\n        _contribute(\n            msg.sender,\n            msg.value.safeCastUint256ToUint96(),\n            delegate,\n            // We cannot use `address(this).balance - msg.value` as the previous\n            // total contributions in case someone forces (suicides) ETH into this\n            // contract. This wouldn't be such a big deal for open crowdfunds\n            // but private ones (protected by a gatekeeper) could be griefed\n            // because it would ultimately result in governance power that\n            // is unattributed/unclaimable, meaning that party will never be\n            // able to reach 100% consensus.\n            totalContributions,\n            gateData\n        );\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        override(ERC721Receiver, CrowdfundNFT)\n        pure\n        returns (bool)\n    {\n        return ERC721Receiver.supportsInterface(interfaceId) ||\n            CrowdfundNFT.supportsInterface(interfaceId);\n    }\n\n    /// @notice Retrieve info about a participant's contributions.\n    /// @dev This will only be called off-chain so doesn't have to be optimal.\n    /// @param contributor The contributor to retrieve contributions for.\n    /// @return ethContributed The total ETH contributed by `contributor`.\n    /// @return ethUsed The total ETH used by `contributor` to acquire the NFT.\n    /// @return ethOwed The total ETH refunded back to `contributor`.\n    /// @return votingPower The total voting power minted to `contributor`.\n    function getContributorInfo(address contributor)\n        external\n        view\n        returns (\n            uint256 ethContributed,\n            uint256 ethUsed,\n            uint256 ethOwed,\n            uint256 votingPower\n        )\n    {\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\n        if (lc == CrowdfundLifecycle.Won || lc == CrowdfundLifecycle.Lost) {\n            (ethUsed, ethOwed, votingPower) = _getFinalContribution(contributor);\n            ethContributed = ethUsed + ethOwed;\n        } else {\n            Contribution[] memory contributions =\n                _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            for (uint256 i; i < numContributions; ++i) {\n                ethContributed += contributions[i].amount;\n            }\n        }\n    }\n\n    /// @notice Get the current lifecycle of the crowdfund.\n    function getCrowdfundLifecycle() public virtual view returns (CrowdfundLifecycle lifecycle);\n\n    // Get the final sale price of the bought assets. This will also be the total\n    // voting power of the governance party.\n    function _getFinalPrice() internal virtual view returns (uint256);\n\n    // Assert that `who` is a host at `governanceOpts.hosts[hostIndex]` and,\n    // if so, assert that the governance opts is the same as the crowdfund\n    // was created with.\n    // Return true if `governanceOpts` was validated in the process.\n    function _assertIsHost(\n        address who,\n        FixedGovernanceOpts memory governanceOpts,\n        uint256 hostIndex\n    )\n        internal\n        view\n        returns (bool isValidatedGovernanceOpts)\n    {\n        if (who == governanceOpts.hosts[hostIndex]) {\n            _assertValidGovernanceOpts(governanceOpts);\n            return true;\n        }\n        revert OnlyPartyHostError();\n    }\n\n    // Assert that `who` is a contributor to the crowdfund.\n    function _assertIsContributor(address who)\n        internal\n        view\n    {\n        if (_contributionsByContributor[who].length == 0) {\n            revert OnlyContributorError();\n        }\n    }\n\n    // Can be called after a party has won.\n    // Deploys and initializes a `Party` instance via the `PartyFactory`\n    // and transfers the bought NFT to it.\n    // After calling this, anyone can burn CF tokens on a contributor's behalf\n    // with the `burn()` function.\n    function _createParty(\n        FixedGovernanceOpts memory governanceOpts,\n        bool governanceOptsAlreadyValidated,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        returns (Party party_)\n    {\n        if (party != Party(payable(0))) {\n            revert PartyAlreadyExistsError(party);\n        }\n        // If the governance opts haven't already been validated, make sure that\n        // it hasn't been tampered with.\n        if (!governanceOptsAlreadyValidated) {\n            _assertValidGovernanceOpts(governanceOpts);\n        }\n        // Create a party.\n        party = party_ = _getPartyFactory()\n            .createParty(\n                address(this),\n                Party.PartyOptions({\n                    name: name,\n                    symbol: symbol,\n                    // Indicates to the party to use the same customization preset as the crowdfund.\n                    customizationPresetId: 0,\n                    governance: PartyGovernance.GovernanceOpts({\n                        hosts: governanceOpts.hosts,\n                        voteDuration: governanceOpts.voteDuration,\n                        executionDelay: governanceOpts.executionDelay,\n                        passThresholdBps: governanceOpts.passThresholdBps,\n                        totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\n                        feeBps: governanceOpts.feeBps,\n                        feeRecipient: governanceOpts.feeRecipient\n                    })\n                }),\n                preciousTokens,\n                preciousTokenIds\n            );\n        // Transfer the acquired NFTs to the new party.\n        for (uint256 i; i < preciousTokens.length; ++i) {\n            preciousTokens[i].transferFrom(address(this), address(party_), preciousTokenIds[i]);\n        }\n    }\n\n    // Overloaded single token wrapper for _createParty()\n    function _createParty(\n        FixedGovernanceOpts memory governanceOpts,\n        bool governanceOptsAlreadyValidated,\n        IERC721 preciousToken,\n        uint256 preciousTokenId\n    )\n        internal\n        returns (Party party_)\n    {\n        IERC721[] memory tokens = new IERC721[](1);\n        tokens[0] = preciousToken;\n        uint256[] memory tokenIds = new uint256[](1);\n        tokenIds[0] = preciousTokenId;\n        return _createParty(governanceOpts, governanceOptsAlreadyValidated, tokens, tokenIds);\n    }\n\n    // Assert that the hash of `opts` matches the hash this crowdfund was initialized with.\n    function _assertValidGovernanceOpts(FixedGovernanceOpts memory governanceOpts)\n        private\n        view\n    {\n        bytes32 governanceOptsHash_ = _hashFixedGovernanceOpts(governanceOpts);\n        if (governanceOptsHash_ != governanceOptsHash) {\n            revert InvalidGovernanceOptionsError();\n        }\n    }\n\n    function _hashFixedGovernanceOpts(FixedGovernanceOpts memory opts)\n        internal\n        pure\n        returns (bytes32 h)\n    {\n        // Hash in place.\n        assembly {\n            // Replace the address[] hosts field with its hash temporarily.\n            let oldHostsFieldValue := mload(opts)\n            mstore(opts, keccak256(add(oldHostsFieldValue, 0x20), mul(mload(oldHostsFieldValue), 32)))\n            // Hash the entire struct.\n            h := keccak256(opts, 0xC0)\n            // Restore old hosts field value.\n            mstore(opts, oldHostsFieldValue)\n        }\n    }\n\n    function _getFinalContribution(address contributor)\n        internal\n        view\n        returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower)\n    {\n        uint256 totalEthUsed = _getFinalPrice();\n        {\n            Contribution[] memory contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            for (uint256 i; i < numContributions; ++i) {\n                Contribution memory c = contributions[i];\n                if (c.previousTotalContributions >= totalEthUsed) {\n                    // This entire contribution was not used.\n                    ethOwed += c.amount;\n                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {\n                    // This entire contribution was used.\n                    ethUsed += c.amount;\n                } else {\n                    // This contribution was partially used.\n                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;\n                    ethUsed += partialEthUsed;\n                    ethOwed = c.amount - partialEthUsed;\n                }\n            }\n        }\n        // one SLOAD with optimizer on\n        address splitRecipient_ = splitRecipient;\n        uint256 splitBps_ = splitBps;\n        if (splitRecipient_ == address(0)) {\n            splitBps_ = 0;\n        }\n        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;\n        if (splitRecipient_ == contributor) {\n            // Split recipient is also the contributor so just add the split\n            // voting power.\n            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up\n        }\n    }\n\n    function _contribute(\n        address contributor,\n        uint96 amount,\n        address delegate,\n        uint96 previousTotalContributions,\n        bytes memory gateData\n    )\n        private\n    {\n        // Require a non-null delegate.\n        if (delegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n        // Must not be blocked by gatekeeper.\n        IGateKeeper _gateKeeper = gateKeeper;\n        if (_gateKeeper != IGateKeeper(address(0))) {\n            if (!_gateKeeper.isAllowed(contributor, gateKeeperId, gateData)) {\n                revert NotAllowedByGateKeeperError(\n                    contributor,\n                    _gateKeeper,\n                    gateKeeperId,\n                    gateData\n                );\n            }\n        }\n\n        // Update delegate.\n        // OK if this happens out of cycle.\n        delegationsByContributor[contributor] = delegate;\n        emit Contributed(contributor, amount, delegate, previousTotalContributions);\n\n        // OK to contribute with zero just to update delegate.\n        if (amount != 0) {\n            // Only allow contributions while the crowdfund is active.\n            {\n                CrowdfundLifecycle lc = getCrowdfundLifecycle();\n                if (lc != CrowdfundLifecycle.Active) {\n                    revert WrongLifecycleError(lc);\n                }\n            }\n            // Increase total contributions.\n            totalContributions += amount;\n            // Create contributions entry for this contributor.\n            Contribution[] storage contributions = _contributionsByContributor[contributor];\n            uint256 numContributions = contributions.length;\n            if (numContributions >= 1) {\n                Contribution memory lastContribution = contributions[numContributions - 1];\n                // If no one else (other than this contributor) has contributed since,\n                // we can just reuse this contributor's last entry.\n                uint256 totalContributionsAmountForReuse =\n                    lastContribution.previousTotalContributions + lastContribution.amount;\n                if (totalContributionsAmountForReuse == previousTotalContributions) {\n                    lastContribution.amount += amount;\n                    contributions[numContributions - 1] = lastContribution;\n                    return;\n                }\n            }\n            // Add a new contribution entry.\n            contributions.push(Contribution({\n                previousTotalContributions: previousTotalContributions,\n                amount: amount\n            }));\n            // Mint a participation NFT if this is their first contribution.\n            if (numContributions == 0) {\n                _mint(contributor);\n            }\n        }\n    }\n\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_) private {\n        // If the CF has won, a party must have been created prior.\n        if (lc == CrowdfundLifecycle.Won) {\n            if (party_ == Party(payable(0))) {\n                revert NoPartyError();\n            }\n        } else if (lc != CrowdfundLifecycle.Lost) {\n            // Otherwise it must have lost.\n            revert WrongLifecycleError(lc);\n        }\n        // Split recipient can burn even if they don't have a token.\n        {\n            address splitRecipient_ = splitRecipient;\n            if (contributor == splitRecipient_) {\n                if (_splitRecipientHasBurned) {\n                    revert SplitRecipientAlreadyBurnedError();\n                }\n                _splitRecipientHasBurned = true;\n            }\n            // Revert if already burned or does not exist.\n            if (splitRecipient_ != contributor || _doesTokenExistFor(contributor)) {\n                CrowdfundNFT._burn(contributor);\n            }\n        }\n        // Compute the contributions used and owed to the contributor, along\n        // with the voting power they'll have in the governance stage.\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) =\n            _getFinalContribution(contributor);\n        if (votingPower > 0) {\n            // Get the address to delegate voting power to. If null, delegate to self.\n            address delegate = delegationsByContributor[contributor];\n            if (delegate == address(0)) {\n                // Delegate can be unset for the split recipient if they never\n                // contribute. Self-delegate if this occurs.\n                delegate = contributor;\n            }\n            // Mint governance NFT for the contributor.\n            try party_.mint(contributor, votingPower, delegate) returns (uint256) {\n                // OK\n            } catch {\n                // Mint to the crowdfund itself to escrow for contributor to\n                // come claim later on.\n                uint256 tokenId = party_.mint(address(this), votingPower, delegate);\n                claims[contributor].governanceTokenId = tokenId;\n            }\n        }\n        // Refund any ETH owed back to the contributor.\n        (bool s, ) = contributor.call{value: ethOwed}(\"\");\n        if (!s) {\n            // If the transfer fails, the contributor can still come claim it\n            // from the crowdfund.\n            claims[contributor].refund = ethOwed;\n        }\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\n    }\n\n    function _getPartyFactory() internal view returns (IPartyFactory) {\n        return IPartyFactory(_GLOBALS.getAddress(LibGlobals.GLOBAL_PARTY_FACTORY));\n    }\n}\n"
    },
    "contracts/crowdfund/CrowdfundFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/Proxy.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\nimport \"./AuctionCrowdfund.sol\";\nimport \"./BuyCrowdfund.sol\";\nimport \"./CollectionBuyCrowdfund.sol\";\n\n/// @notice Factory used to deploys new proxified `Crowdfund` instances.\ncontract CrowdfundFactory {\n    using LibRawResult for bytes;\n\n    event BuyCrowdfundCreated(BuyCrowdfund crowdfund, BuyCrowdfund.BuyCrowdfundOptions opts);\n    event AuctionCrowdfundCreated(AuctionCrowdfund crowdfund, AuctionCrowdfund.AuctionCrowdfundOptions opts);\n    event CollectionBuyCrowdfundCreated(CollectionBuyCrowdfund crowdfund, CollectionBuyCrowdfund.CollectionBuyCrowdfundOptions opts);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    /// @notice Create a new crowdfund to purchase a specific NFT (i.e., with a\n    ///         known token ID) listing for a known price.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    /// @param createGateCallData Encoded calldata used by `createGate()` to\n    ///                           create the crowdfund if one is specified in `opts`.\n    function createBuyCrowdfund(\n        BuyCrowdfund.BuyCrowdfundOptions memory opts,\n        bytes memory createGateCallData\n    )\n        public\n        payable\n        returns (BuyCrowdfund inst)\n    {\n        opts.gateKeeperId = _prepareGate(\n            opts.gateKeeper,\n            opts.gateKeeperId,\n            createGateCallData\n        );\n        inst = BuyCrowdfund(payable(new Proxy{ value: msg.value }(\n            _GLOBALS.getImplementation(LibGlobals.GLOBAL_BUY_CF_IMPL),\n            abi.encodeCall(BuyCrowdfund.initialize, (opts))\n        )));\n        emit BuyCrowdfundCreated(inst, opts);\n    }\n\n    /// @notice Create a new crowdfund to bid on an auction for a specific NFT\n    ///         (i.e. with a known token ID).\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\n    ///                           the crowdfund if one is specified in `opts`.\n    function createAuctionCrowdfund(\n        AuctionCrowdfund.AuctionCrowdfundOptions memory opts,\n        bytes memory createGateCallData\n    )\n        public\n        payable\n        returns (AuctionCrowdfund inst)\n    {\n        opts.gateKeeperId = _prepareGate(\n            opts.gateKeeper,\n            opts.gateKeeperId,\n            createGateCallData\n        );\n        inst = AuctionCrowdfund(payable(new Proxy{ value: msg.value }(\n            _GLOBALS.getImplementation(LibGlobals.GLOBAL_AUCTION_CF_IMPL),\n            abi.encodeCall(AuctionCrowdfund.initialize, (opts))\n        )));\n        emit AuctionCrowdfundCreated(inst, opts);\n    }\n\n    /// @notice Create a new crowdfund to purchase any NFT from a collection\n    ///         (i.e. any token ID) from a collection for a known price.\n    /// @param opts Options used to initialize the crowdfund. These are fixed\n    ///             and cannot be changed later.\n    /// @param createGateCallData Encoded calldata used by `createGate()` to create\n    ///                           the crowdfund if one is specified in `opts`.\n    function createCollectionBuyCrowdfund(\n        CollectionBuyCrowdfund.CollectionBuyCrowdfundOptions memory opts,\n        bytes memory createGateCallData\n    )\n        public\n        payable\n        returns (CollectionBuyCrowdfund inst)\n    {\n        opts.gateKeeperId = _prepareGate(\n            opts.gateKeeper,\n            opts.gateKeeperId,\n            createGateCallData\n        );\n        inst = CollectionBuyCrowdfund(payable(new Proxy{ value: msg.value }(\n            _GLOBALS.getImplementation(LibGlobals.GLOBAL_COLLECTION_BUY_CF_IMPL),\n            abi.encodeCall(CollectionBuyCrowdfund.initialize, (opts))\n        )));\n        emit CollectionBuyCrowdfundCreated(inst, opts);\n    }\n\n    function _prepareGate(\n        IGateKeeper gateKeeper,\n        bytes12 gateKeeperId,\n        bytes memory createGateCallData\n    )\n        private\n        returns (bytes12 newGateKeeperId)\n    {\n        if (\n            address(gateKeeper) == address(0) ||\n            gateKeeperId != bytes12(0)\n        ) {\n            // Using an existing gate on the gatekeeper\n            // or not using a gate at all.\n            return gateKeeperId;\n        }\n        // Call the gate creation function on the gatekeeper.\n        (bool s, bytes memory r) = address(gateKeeper).call(createGateCallData);\n        if (!s) {\n            r.rawRevert();\n        }\n        // Result is always a bytes12.\n        return abi.decode(r, (bytes12));\n    }\n}\n"
    },
    "contracts/crowdfund/CrowdfundNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../utils/EIP165.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\n/// @notice NFT functionality for crowdfund types. This NFT is soulbound and read-only.\ncontract CrowdfundNFT is IERC721, EIP165, ReadOnlyDelegateCall {\n    error AlreadyMintedError(address owner, uint256 tokenId);\n    error AlreadyBurnedError(address owner, uint256 tokenId);\n    error InvalidTokenError(uint256 tokenId);\n    error InvalidAddressError();\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice The name of the crowdfund. This will also carry over to the\n    ///         governance party.\n    string public name;\n    /// @notice The token symbol for the crowdfund. This will also carry over to\n    ///         the governance party.\n    string public symbol;\n\n    mapping (uint256 => address) private _owners;\n\n    modifier alwaysRevert() {\n        revert('ALWAYS FAILING');\n        _; // Compiler requires this.\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize name and symbol for crowdfund.\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint256 customizationPresetId\n    )\n        internal\n        virtual\n    {\n        name = name_;\n        symbol = symbol_;\n        if (customizationPresetId != 0) {\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\n                .useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\n    ///         Attempting to call this function will always fail.\n    function transferFrom(address, address, uint256)\n        external\n        pure\n        alwaysRevert\n    {}\n\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\n    ///         Attempting to call this function will always fail.\n    function safeTransferFrom(address, address, uint256)\n        external\n        pure\n        alwaysRevert\n    {}\n\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\n    ///         Attempting to call this function will always fail.\n    function safeTransferFrom(address, address, uint256, bytes calldata)\n        external\n        pure\n        alwaysRevert\n    {}\n\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\n    ///         Attempting to call this function will always fail.\n    function approve(address, uint256)\n        external\n        pure\n        alwaysRevert\n    {}\n\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\n    ///         Attempting to call this function will always fail.\n    function setApprovalForAll(address, bool)\n        external\n        pure\n        alwaysRevert\n    {}\n\n    /// @notice This is a soulbound NFT and cannot be transferred.\n    ///         Attempting to call this function will always return null.\n    function getApproved(uint256)\n        external\n        pure\n        returns (address)\n    {\n        return address(0);\n    }\n\n    /// @notice This is a soulbound NFT and cannot be transferred.\n    ///         Attempting to call this function will always return false.\n    function isApprovedForAll(address, address)\n        external\n        pure\n        returns (bool)\n    {\n        return false;\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        virtual\n        override\n        pure\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC721).interfaceId;\n    }\n\n    /// @notice Returns a URI to render the NFT.\n    function tokenURI(uint256) external view returns (string memory) {\n        return _delegateToRenderer();\n    }\n\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\n    function contractURI() external view returns (string memory) {\n        return _delegateToRenderer();\n    }\n\n    /// @inheritdoc IERC721\n    function ownerOf(uint256 tokenId) external view returns (address owner) {\n        owner = _owners[tokenId];\n        if (owner == address(0)) {\n            revert InvalidTokenError(tokenId);\n        }\n    }\n\n    /// @inheritdoc IERC721\n    function balanceOf(address owner) external view returns (uint256 numTokens) {\n        return _doesTokenExistFor(owner) ? 1 : 0;\n    }\n\n    function _doesTokenExistFor(address owner) internal view returns (bool) {\n        return _owners[uint256(uint160(owner))] != address(0);\n    }\n\n    function _mint(address owner) internal returns (uint256 tokenId) {\n        if (owner == address(0)) revert InvalidAddressError();\n        tokenId = uint256(uint160(owner));\n        if (_owners[tokenId] != owner) {\n            _owners[tokenId] = owner;\n            emit Transfer(address(0), owner, tokenId);\n        } else {\n            revert AlreadyMintedError(owner, tokenId);\n        }\n    }\n\n    function _burn(address owner) internal {\n        uint256 tokenId = uint256(uint160(owner));\n        if (_owners[tokenId] == owner) {\n            _owners[tokenId] = address(0);\n            emit Transfer(owner, address(0), tokenId);\n            return;\n        }\n        revert AlreadyBurnedError(owner, tokenId);\n    }\n\n    function _delegateToRenderer() private view returns (string memory) {\n        _readOnlyDelegateCall(\n            // Instance of IERC721Renderer.\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_CF_NFT_RENDER_IMPL),\n            msg.data\n        );\n        assert(false); // Will not be reached.\n        return \"\";\n    }\n}\n"
    },
    "contracts/distribution/ITokenDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC20.sol\";\n\nimport \"./ITokenDistributorParty.sol\";\n\n/// @notice Creates token distributions for parties.\ninterface ITokenDistributor {\n    enum TokenType {\n        Native,\n        Erc20\n    }\n\n    // Info on a distribution, created by createDistribution().\n    struct DistributionInfo {\n        // Type of distribution/token.\n        TokenType tokenType;\n        // ID of the distribution. Assigned by createDistribution().\n        uint256 distributionId;\n        // The party whose members can claim the distribution.\n        ITokenDistributorParty party;\n        // Who can claim `fee`.\n        address payable feeRecipient;\n        // The token being distributed.\n        address token;\n        // Total amount of `token` that can be claimed by party members.\n        uint128 memberSupply;\n        // Amount of `token` to be redeemed by `feeRecipient`.\n        uint128 fee;\n    }\n\n    event DistributionCreated(\n        ITokenDistributorParty indexed party,\n        DistributionInfo info\n    );\n    event DistributionFeeClaimed(\n        ITokenDistributorParty indexed party,\n        address indexed feeRecipient,\n        TokenType tokenType,\n        address token,\n        uint256 amount\n    );\n    event DistributionClaimedByPartyToken(\n        ITokenDistributorParty indexed party,\n        uint256 indexed partyTokenId,\n        address indexed owner,\n        TokenType tokenType,\n        address token,\n        uint256 amountClaimed\n    );\n\n    /// @notice Create a new distribution for an outstanding native token balance\n    ///         governed by a party.\n    /// @dev Native tokens should be transferred directly into this contract\n    ///      immediately prior (same tx) to calling `createDistribution()` or\n    ///      attached to the call itself.\n    /// @param party The party whose members can claim the distribution.\n    /// @param feeRecipient Who can claim `fee`.\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\n    /// @return info Information on the created distribution.\n    function createNativeDistribution(\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        payable\n        returns (DistributionInfo memory info);\n\n    /// @notice Create a new distribution for an outstanding ERC20 token balance\n    ///         governed by a party.\n    /// @dev ERC20 tokens should be transferred directly into this contract\n    ///      immediately prior (same tx) to calling `createDistribution()` or\n    ///      attached to the call itself.\n    /// @param token The ERC20 token to distribute.\n    /// @param party The party whose members can claim the distribution.\n    /// @param feeRecipient Who can claim `fee`.\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\n    /// @return info Information on the created distribution.\n    function createErc20Distribution(\n        IERC20 token,\n        ITokenDistributorParty party,\n        address payable feeRecipient,\n        uint16 feeBps\n    )\n        external\n        returns (DistributionInfo memory info);\n\n    /// @notice Claim a portion of a distribution owed to a `partyTokenId` belonging\n    ///         to the party that created the distribution. The caller\n    ///         must own this token.\n    /// @param info Information on the distribution being claimed.\n    /// @param partyTokenId The ID of the party token to claim for.\n    /// @return amountClaimed The amount of the distribution claimed.\n    function claim(DistributionInfo calldata info, uint256 partyTokenId)\n        external\n        returns (uint128 amountClaimed);\n\n    /// @notice Claim the fee for a distribution. Only a distribution's `feeRecipient`\n    ///         can call this.\n    /// @param info Information on the distribution being claimed.\n    /// @param recipient The address to send the fee to.\n    function claimFee(DistributionInfo calldata info, address payable recipient)\n        external;\n\n    /// @notice Batch version of `claim()`.\n    /// @param infos Information on the distributions being claimed.\n    /// @param partyTokenIds The ID of the party tokens to claim for.\n    /// @return amountsClaimed The amount of the distributions claimed.\n    function batchClaim(DistributionInfo[] calldata infos, uint256[] calldata partyTokenIds)\n        external\n        returns (uint128[] memory amountsClaimed);\n\n    /// @notice Batch version of `claimFee()`.\n    /// @param infos Information on the distributions to claim fees for.\n    /// @param recipients The addresses to send the fees to.\n    function batchClaimFee(DistributionInfo[] calldata infos, address payable[] calldata recipients)\n        external;\n\n    /// @notice Compute the amount of a distribution's token are owed to a party\n    ///         member, identified by the `partyTokenId`.\n    /// @param party The party to use for computing the claim amount.\n    /// @param memberSupply Total amount of tokens that can be claimed in the distribution.\n    /// @param partyTokenId The ID of the party token to claim for.\n    /// @return claimAmount The amount of the distribution owed to the party member.\n    function getClaimAmount(\n        ITokenDistributorParty party,\n        uint256 memberSupply,\n        uint256 partyTokenId\n    )\n        external\n        view\n        returns (uint128);\n\n    /// @notice Check whether the fee has been claimed for a distribution.\n    /// @param party The party to use for checking whether the fee has been claimed.\n    /// @param distributionId The ID of the distribution to check.\n    /// @return feeClaimed Whether the fee has been claimed.\n    function wasFeeClaimed(ITokenDistributorParty party, uint256 distributionId)\n        external\n        view\n        returns (bool);\n\n    /// @notice Check whether a `partyTokenId` has claimed their share of a distribution.\n    /// @param party The party to use for checking whether the `partyTokenId` has claimed.\n    /// @param partyTokenId The ID of the party token to check.\n    /// @param distributionId The ID of the distribution to check.\n    /// @return hasClaimed Whether the `partyTokenId` has claimed.\n    function hasPartyTokenIdClaimed(\n        ITokenDistributorParty party,\n        uint256 partyTokenId,\n        uint256 distributionId\n    )\n        external\n        view returns (bool);\n\n    /// @notice Get how much unclaimed member tokens are left in a distribution.\n    /// @param party The party to use for checking the unclaimed member tokens.\n    /// @param distributionId The ID of the distribution to check.\n    /// @return remainingMemberSupply The amount of distribution supply remaining.\n    function getRemainingMemberSupply(\n        ITokenDistributorParty party,\n        uint256 distributionId\n    )\n        external\n        view\n        returns (uint128);\n}\n"
    },
    "contracts/distribution/ITokenDistributorParty.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n// Interface the caller of `ITokenDistributor.createDistribution()` must implement.\ninterface ITokenDistributorParty {\n    /// @notice Return the owner of a token.\n    /// @param tokenId The token ID to query.\n    /// @return owner The owner of `tokenId`.\n    function ownerOf(uint256 tokenId) external view returns (address);\n    /// @notice Return the distribution share of a token. Denominated fractions\n    ///         of 1e18. I.e., 1e18 = 100%.\n    /// @param tokenId The token ID to query.\n    /// @return share The distribution percentage of `tokenId`.\n    function getDistributionShareOf(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "contracts/gatekeepers/IGateKeeper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n// Interface for a gatekeeper contract used for private crowdfund instances.\ninterface IGateKeeper {\n    /// @notice Check if a participant is eligible to participate in a crowdfund.\n    /// @param participant The address of the participant.\n    /// @param id The ID of the gate to eligibility against.\n    /// @param userData The data used to check eligibility.\n    /// @return `true` if the participant is allowed to participate, `false` otherwise.\n    function isAllowed(\n        address participant,\n        bytes12 id,\n        bytes memory userData\n    ) external view returns (bool);\n}\n"
    },
    "contracts/globals/IGlobals.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/Implementation.sol\";\n\n// Single registry of global values controlled by multisig.\n// See `LibGlobals` for all valid keys.\ninterface IGlobals {\n    function getBytes32(uint256 key) external view returns (bytes32);\n    function getUint256(uint256 key) external view returns (uint256);\n    function getBool(uint256 key) external view returns (bool);\n    function getAddress(uint256 key) external view returns (address);\n    function getImplementation(uint256 key) external view returns (Implementation);\n    function getIncludesBytes32(uint256 key, bytes32 value) external view returns (bool);\n    function getIncludesUint256(uint256 key, uint256 value) external view returns (bool);\n    function getIncludesAddress(uint256 key, address value) external view returns (bool);\n\n    function setBytes32(uint256 key, bytes32 value) external;\n    function setUint256(uint256 key, uint256 value) external;\n    function setBool(uint256 key, bool value) external;\n    function setAddress(uint256 key, address value) external;\n    function setIncludesBytes32(uint256 key, bytes32 value, bool isIncluded) external;\n    function setIncludesUint256(uint256 key, uint256 value, bool isIncluded) external;\n    function setIncludesAddress(uint256 key, address value, bool isIncluded) external;\n}\n"
    },
    "contracts/globals/LibGlobals.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n// Valid keys in `IGlobals`. Append-only.\nlibrary LibGlobals {\n    uint256 internal constant GLOBAL_PARTY_IMPL                     = 1;\n    uint256 internal constant GLOBAL_PROPOSAL_ENGINE_IMPL           = 2;\n    uint256 internal constant GLOBAL_PARTY_FACTORY                  = 3;\n    uint256 internal constant GLOBAL_GOVERNANCE_NFT_RENDER_IMPL     = 4;\n    uint256 internal constant GLOBAL_CF_NFT_RENDER_IMPL             = 5;\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_TIMEOUT        = 6;\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_DURATION       = 7;\n    uint256 internal constant GLOBAL_AUCTION_CF_IMPL                = 8;\n    uint256 internal constant GLOBAL_BUY_CF_IMPL                    = 9;\n    uint256 internal constant GLOBAL_COLLECTION_BUY_CF_IMPL         = 10;\n    uint256 internal constant GLOBAL_DAO_WALLET                     = 11;\n    uint256 internal constant GLOBAL_TOKEN_DISTRIBUTOR              = 12;\n    uint256 internal constant GLOBAL_OPENSEA_CONDUIT_KEY            = 13;\n    uint256 internal constant GLOBAL_OPENSEA_ZONE                   = 14;\n    uint256 internal constant GLOBAL_PROPOSAL_MAX_CANCEL_DURATION   = 15;\n    uint256 internal constant GLOBAL_ZORA_MIN_AUCTION_DURATION      = 16;\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_DURATION      = 17;\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_TIMEOUT       = 18;\n    uint256 internal constant GLOBAL_OS_MIN_ORDER_DURATION          = 19;\n    uint256 internal constant GLOBAL_OS_MAX_ORDER_DURATION          = 20;\n    uint256 internal constant GLOBAL_DISABLE_PARTY_ACTIONS          = 21;\n    uint256 internal constant GLOBAL_RENDERER_STORAGE               = 22;\n    uint256 internal constant GLOBAL_PROPOSAL_MIN_CANCEL_DURATION   = 23;\n}\n"
    },
    "contracts/market-wrapper/IMarketWrapper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.17;\n\n/**\n * @title IMarketWrapper\n * @author Anna Carroll\n * @notice IMarketWrapper provides a common interface for\n * interacting with NFT auction markets.\n * Contracts can abstract their interactions with\n * different NFT markets using IMarketWrapper.\n * NFT markets can become compatible with any contract\n * using IMarketWrapper by deploying a MarketWrapper contract\n * that implements this interface using the logic of their Market.\n *\n * WARNING: MarketWrapper contracts should NEVER write to storage!\n * When implementing a MarketWrapper, exercise caution; a poorly implemented\n * MarketWrapper contract could permanently lose access to the NFT or user funds.\n */\ninterface IMarketWrapper {\n    /**\n     * @notice Given the auctionId, nftContract, and tokenId, check that:\n     * 1. the auction ID matches the token\n     * referred to by tokenId + nftContract\n     * 2. the auctionId refers to an *ACTIVE* auction\n     * (e.g. an auction that will accept bids)\n     * within this market contract\n     * 3. any additional validation to ensure that\n     * a PartyBid can bid on this auction\n     * (ex: if the market allows arbitrary bidding currencies,\n     * check that the auction currency is ETH)\n     * Note: This function probably should have been named \"isValidAuction\"\n     * @dev Called in PartyBid.sol in `initialize` at line 174\n     * @return TRUE if the auction is valid\n     */\n    function auctionIdMatchesToken(\n        uint256 auctionId,\n        address nftContract,\n        uint256 tokenId\n    ) external view returns (bool);\n\n    /**\n     * @notice Calculate the minimum next bid for this auction.\n     * PartyBid contracts always submit the minimum possible\n     * bid that will be accepted by the Market contract.\n     * usually, this is either the reserve price (if there are no bids)\n     * or a certain percentage increase above the current highest bid\n     * @dev Called in PartyBid.sol in `bid` at line 251\n     * @return minimum bid amount\n     */\n    function getMinimumBid(uint256 auctionId) external view returns (uint256);\n\n    /**\n     * @notice Query the current highest bidder for this auction\n     * It is assumed that there is always 1 winning highest bidder for an auction\n     * This is used to ensure that PartyBid cannot outbid itself if it is already winning\n     * @dev Called in PartyBid.sol in `bid` at line 241\n     * @return highest bidder\n     */\n    function getCurrentHighestBidder(uint256 auctionId)\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice Submit bid to Market contract\n     * @dev Called in PartyBid.sol in `bid` at line 259\n     */\n    function bid(uint256 auctionId, uint256 bidAmount) external;\n\n    /**\n     * @notice Determine whether the auction has been finalized\n     * Used to check if it is still possible to bid\n     * And to determine whether the PartyBid should finalize the auction\n     * @dev Called in PartyBid.sol in `bid` at line 247\n     * @dev and in `finalize` at line 288\n     * @return TRUE if the auction has been finalized\n     */\n    function isFinalized(uint256 auctionId) external view returns (bool);\n\n    /**\n     * @notice Finalize the results of the auction\n     * on the Market contract\n     * It is assumed  that this operation is performed once for each auction,\n     * that after it is done the auction is over and the NFT has been\n     * transferred to the auction winner.\n     * @dev Called in PartyBid.sol in `finalize` at line 289\n     */\n    function finalize(uint256 auctionId) external;\n}\n"
    },
    "contracts/party/IPartyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../globals/IGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\n\nimport \"./Party.sol\";\n\n// Creates generic Party instances.\ninterface IPartyFactory {\n    event PartyCreated(\n        Party indexed party,\n        Party.PartyOptions opts,\n        IERC721[] preciousTokens,\n        uint256[] preciousTokenIds,\n        address creator\n    );\n\n    /// @notice Deploy a new party instance. Afterwards, governance NFTs can be minted\n    ///         for party members using the `mint()` function from the newly\n    ///         created party.\n    /// @param authority The address that can call `mint()`.\n    /// @param opts Options used to initialize the party. These are fixed\n    ///             and cannot be changed later.\n    /// @param preciousTokens The tokens that are considered precious by the\n    ///                       party.These are protected assets and are subject\n    ///                       to extra restrictions in proposals vs other\n    ///                       assets.\n    /// @param preciousTokenIds The IDs associated with each token in `preciousTokens`.\n    /// @return party The newly created `Party` instance.\n    function createParty(\n        address authority,\n        Party.PartyOptions calldata opts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        external\n        returns (Party party);\n\n    /// @notice The `Globals` contract storing global configuration values. This contract\n    ///         is immutable and it’s address will never change.\n    function GLOBALS() external view returns (IGlobals);\n}\n"
    },
    "contracts/party/Party.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\n\nimport \"./PartyGovernanceNFT.sol\";\nimport \"./PartyGovernance.sol\";\n\n/// @notice The governance contract that also custodies the precious NFTs. This\n///         is also the Governance NFT 721 contract.\ncontract Party is PartyGovernanceNFT {\n    // Arguments used to initialize the party.\n    struct PartyOptions {\n        PartyGovernance.GovernanceOpts governance;\n        string name;\n        string symbol;\n        uint256 customizationPresetId;\n    }\n\n    // Arguments used to initialize the `PartyGovernanceNFT`.\n    struct PartyInitData {\n        PartyOptions options;\n        IERC721[] preciousTokens;\n        uint256[] preciousTokenIds;\n        address mintAuthority;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) PartyGovernanceNFT(globals) {}\n\n    /// @notice Initializer to be delegatecalled by `Proxy` constructor. Will\n    ///         revert if called outside the constructor.\n    /// @param initData Options used to initialize the party governance.\n    function initialize(PartyInitData memory initData)\n        external\n        onlyConstructor\n    {\n        PartyGovernanceNFT._initialize(\n            initData.options.name,\n            initData.options.symbol,\n            initData.options.customizationPresetId,\n            initData.options.governance,\n            initData.preciousTokens,\n            initData.preciousTokenIds,\n            initData.mintAuthority\n        );\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/party/PartyGovernance.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../distribution/ITokenDistributorParty.sol\";\nimport \"../distribution/ITokenDistributor.sol\";\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../tokens/IERC20.sol\";\nimport \"../tokens/IERC1155.sol\";\nimport \"../tokens/ERC721Receiver.sol\";\nimport \"../tokens/ERC1155Receiver.sol\";\nimport \"../utils/LibERC20Compat.sol\";\nimport \"../utils/LibRawResult.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../globals/LibGlobals.sol\";\nimport \"../proposals/IProposalExecutionEngine.sol\";\nimport \"../proposals/LibProposal.sol\";\nimport \"../proposals/ProposalStorage.sol\";\n\nimport \"./IPartyFactory.sol\";\n\n/// @notice Base contract for a Party encapsulating all governance functionality.\nabstract contract PartyGovernance is\n    ITokenDistributorParty,\n    ERC721Receiver,\n    ERC1155Receiver,\n    ProposalStorage,\n    Implementation,\n    ReadOnlyDelegateCall\n{\n    using LibERC20Compat for IERC20;\n    using LibRawResult for bytes;\n    using LibSafeCast for uint256;\n    using LibSafeCast for int192;\n    using LibSafeCast for uint96;\n\n    // States a proposal can be in.\n    enum ProposalStatus {\n        // The proposal does not exist.\n        Invalid,\n        // The proposal has been proposed (via `propose()`), has not been vetoed\n        // by a party host, and is within the voting window. Members can vote on\n        // the proposal and party hosts can veto the proposal.\n        Voting,\n        // The proposal has either exceeded its voting window without reaching\n        // `passThresholdBps` of votes or was vetoed by a party host.\n        Defeated,\n        // The proposal reached at least `passThresholdBps` of votes but is still\n        // waiting for `executionDelay` to pass before it can be executed. Members\n        // can continue to vote on the proposal and party hosts can veto at this time.\n        Passed,\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\n        // has arrived.\n        Ready,\n        // The proposal has been executed at least once but has further steps to\n        // complete so it needs to be executed again. No other proposals may be\n        // executed while a proposal is in the `InProgress` state. No voting or\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\n        InProgress,\n        // The proposal was executed and completed all its steps. No voting or\n        // vetoing can occur and it cannot be cancelled nor executed again.\n        Complete,\n        // The proposal was executed at least once but did not complete before\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\n        Cancelled\n    }\n\n    struct GovernanceOpts {\n        // Address of initial party hosts.\n        address[] hosts;\n        // How long people can vote on a proposal.\n        uint40 voteDuration;\n        // How long to wait after a proposal passes before it can be\n        // executed.\n        uint40 executionDelay;\n        // Minimum ratio of accept votes to consider a proposal passed,\n        // in bps, where 10,000 == 100%.\n        uint16 passThresholdBps;\n        // Total voting power of governance NFTs.\n        uint96 totalVotingPower;\n        // Fee bps for distributions.\n        uint16 feeBps;\n        // Fee recipeint for distributions.\n        address payable feeRecipient;\n    }\n\n    // Subset of `GovernanceOpts` that are commonly read together for\n    // efficiency.\n    struct GovernanceValues {\n        uint40 voteDuration;\n        uint40 executionDelay;\n        uint16 passThresholdBps;\n        uint96 totalVotingPower;\n    }\n\n    // A snapshot of voting power for a member.\n    struct VotingPowerSnapshot {\n        // The timestamp when the snapshot was taken.\n        uint40 timestamp;\n        // Voting power that was delegated to this user by others.\n        uint96 delegatedVotingPower;\n        // The intrinsic (not delegated from someone else) voting power of this user.\n        uint96 intrinsicVotingPower;\n        // Whether the user was delegated to another at this snapshot.\n        bool isDelegated;\n    }\n\n    // Proposal details chosen by proposer.\n    struct Proposal {\n        // Time beyond which the proposal can no longer be executed.\n        // If the proposal has already been executed, and is still InProgress,\n        // this value is ignored.\n        uint40 maxExecutableTime;\n        // The minimum seconds this proposal can remain in the InProgress status\n        // before it can be cancelled.\n        uint40 cancelDelay;\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\n        // by encoded proposal args specific to the proposal type. See\n        // ProposalExecutionEngine for details.\n        bytes proposalData;\n    }\n\n    // Accounting and state tracking values for a proposal.\n    // Fits in a word.\n    struct ProposalStateValues {\n        // When the proposal was proposed.\n        uint40 proposedTime;\n        // When the proposal passed the vote.\n        uint40 passedTime;\n        // When the proposal was first executed.\n        uint40 executedTime;\n        // When the proposal completed.\n        uint40 completedTime;\n        // Number of accept votes.\n        uint96 votes; // -1 == vetoed\n    }\n\n    // Storage states for a proposal.\n    struct ProposalState {\n        // Accounting and state tracking values.\n        ProposalStateValues values;\n        // Hash of the proposal.\n        bytes32 hash;\n        // Whether a member has voted for (accepted) this proposal already.\n        mapping (address => bool) hasVoted;\n    }\n\n    event Proposed(\n        uint256 proposalId,\n        address proposer,\n        Proposal proposal\n    );\n    event ProposalAccepted(\n        uint256 proposalId,\n        address voter,\n        uint256 weight\n    );\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\n\n    event ProposalPassed(uint256 indexed proposalId);\n    event ProposalVetoed(uint256 indexed proposalId, address host);\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\n    event ProposalCancelled(uint256 indexed proposalId);\n    event DistributionCreated(ITokenDistributor.TokenType tokenType, address token, uint256 tokenId);\n    event VotingPowerDelegated(address indexed owner, address indexed delegate);\n    event HostStatusTransferred(address oldHost, address newHost);\n    event EmergencyExecuteDisabled();\n\n    error MismatchedPreciousListLengths();\n    error BadProposalStatusError(ProposalStatus status);\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\n    error OnlyPartyHostError();\n    error OnlyActiveMemberError();\n    error InvalidDelegateError();\n    error BadPreciousListError();\n    error OnlyPartyDaoError(address notDao, address partyDao);\n    error OnlyPartyDaoOrHostError(address notDao, address partyDao);\n    error OnlyWhenEmergencyActionsAllowedError();\n    error OnlyWhenEnabledError();\n    error AlreadyVotedError(address voter);\n    error InvalidNewHostError();\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\n    error InvalidBpsError(uint16 bps);\n\n    uint256 constant private UINT40_HIGH_BIT = 1 << 39;\n    uint96 constant private VETO_VALUE = type(uint96).max;\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Whether the DAO has emergency powers for this party.\n    bool public emergencyExecuteDisabled;\n    /// @notice Distribution fee bps.\n    uint16 public feeBps;\n    /// @notice Distribution fee recipient.\n    address payable public feeRecipient;\n    /// @notice The hash of the list of precious NFTs guarded by the party.\n    bytes32 public preciousListHash;\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\n    uint256 public lastProposalId;\n    /// @notice Whether an address is a party host.\n    mapping(address => bool) public isHost;\n    /// @notice The last person a voter delegated its voting power to.\n    mapping(address => address) public delegationsByVoter;\n    // Constant governance parameters, fixed from the inception of this party.\n    GovernanceValues internal _governanceValues;\n    // ProposalState by proposal ID.\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\n    // Snapshots of voting power per user, each sorted by increasing time.\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\n\n    modifier onlyHost() {\n        if (!isHost[msg.sender]) {\n            revert OnlyPartyHostError();\n        }\n        _;\n    }\n\n    // Caller must have voting power at the current time.\n    modifier onlyActiveMember() {\n        {\n            VotingPowerSnapshot memory snap =\n                _getLastVotingPowerSnapshotForVoter(msg.sender);\n            // Must have either delegated voting power or intrinsic voting power.\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        _;\n    }\n\n    // Caller must have voting power at the current time or be the `Party` instance.\n    modifier onlyActiveMemberOrSelf() {\n        // Ignore if the party is calling functions on itself, like with\n        // `FractionalizeProposal` calling `distribute()`.\n        if (msg.sender != address(this)) {\n            VotingPowerSnapshot memory snap =\n                _getLastVotingPowerSnapshotForVoter(msg.sender);\n            // Must have either delegated voting power or intrinsic voting power.\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\n                revert OnlyActiveMemberError();\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig can call.\n    modifier onlyPartyDao() {\n        {\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n            if (msg.sender != partyDao) {\n                revert OnlyPartyDaoError(msg.sender, partyDao);\n            }\n        }\n        _;\n    }\n\n    // Only the party DAO multisig or a party host can call.\n    modifier onlyPartyDaoOrHost() {\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\n            revert OnlyPartyDaoOrHostError(msg.sender, partyDao);\n        }\n        _;\n    }\n\n    // Only if `emergencyExecuteDisabled` is not true.\n    modifier onlyWhenEmergencyExecuteAllowed() {\n        if (emergencyExecuteDisabled) {\n            revert OnlyWhenEmergencyActionsAllowedError();\n        }\n        _;\n    }\n\n    modifier onlyWhenNotGloballyDisabled() {\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\n            revert OnlyWhenEnabledError();\n        }\n        _;\n    }\n\n    // Set the `Globals` contract.\n    constructor(IGlobals globals) {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\n    function _initialize(\n        GovernanceOpts memory opts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        virtual\n    {\n        // Check BPS are valid.\n        if (opts.feeBps > 1e4) {\n            revert InvalidBpsError(opts.feeBps);\n        }\n        if (opts.passThresholdBps > 1e4) {\n            revert InvalidBpsError(opts.passThresholdBps);\n        }\n        // Initialize the proposal execution engine.\n        _initProposalImpl(\n            IProposalExecutionEngine(\n                _GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)\n            ),\n            \"\"\n        );\n        // Set the governance parameters.\n        _governanceValues = GovernanceValues({\n            voteDuration: opts.voteDuration,\n            executionDelay: opts.executionDelay,\n            passThresholdBps: opts.passThresholdBps,\n            totalVotingPower: opts.totalVotingPower\n        });\n        // Set fees.\n        feeBps = opts.feeBps;\n        feeRecipient = opts.feeRecipient;\n        // Set the precious list.\n        _setPreciousList(preciousTokens, preciousTokenIds);\n        // Set the party hosts.\n        for (uint256 i=0; i < opts.hosts.length; ++i) {\n            isHost[opts.hosts[i]] = true;\n        }\n    }\n\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\n    ///      Initial use case is to facilitate eip-1271 signatures.\n    fallback() external {\n        _readOnlyDelegateCall(\n            address(_getProposalExecutionEngine()),\n            msg.data\n        );\n    }\n\n    /// @inheritdoc EIP165\n    /// @dev Combined logic for `ERC721Receiver` and `ERC1155Receiver`.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        override(ERC721Receiver, ERC1155Receiver)\n        virtual\n        pure\n        returns (bool)\n    {\n        return ERC721Receiver.supportsInterface(interfaceId) ||\n            ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    /// @notice Get the current `ProposalExecutionEngine` instance.\n    function getProposalExecutionEngine()\n        external\n        view\n        returns (IProposalExecutionEngine)\n    {\n        return _getProposalExecutionEngine();\n    }\n\n    /// @notice Get the total voting power of `voter` at a `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(address voter, uint40 timestamp)\n        external\n        view\n        returns (uint96 votingPower)\n    {\n        return getVotingPowerAt(voter, timestamp, type(uint256).max);\n    }\n\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the voting power at.\n    /// @param snapIndex The index of the snapshot to get the voting power at.\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\n    function getVotingPowerAt(address voter, uint40 timestamp, uint256 snapIndex)\n        public\n        view\n        returns (uint96 votingPower)\n    {\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\n    }\n\n    /// @notice Get the state of a proposal.\n    /// @param proposalId The ID of the proposal.\n    /// @return status The status of the proposal.\n    /// @return values The state of the proposal.\n    function getProposalStateInfo(uint256 proposalId)\n        external\n        view\n        returns (ProposalStatus status, ProposalStateValues memory values)\n    {\n        values = _proposalStateByProposalId[proposalId].values;\n        status = _getProposalStatus(values);\n    }\n\n    /// @notice Retrieve fixed governance parameters.\n    /// @return gv The governance parameters of this party.\n    function getGovernanceValues() external view returns (GovernanceValues memory gv) {\n        return _governanceValues;\n    }\n\n    /// @notice Get the hash of a proposal.\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\n    ///      consistency between calls.\n    /// @param proposal The proposal to hash.\n    /// @return proposalHash The hash of the proposal.\n    function getProposalHash(Proposal memory proposal)\n        public\n        pure\n        returns (bytes32 proposalHash)\n    {\n        // Hash the proposal in-place. Equivalent to:\n        // keccak256(abi.encode(\n        //   proposal.maxExecutableTime,\n        //   proposal.cancelDelay,\n        //   keccak256(proposal.proposalData)\n        // ))\n        bytes32 dataHash = keccak256(proposal.proposalData);\n        assembly {\n            // Overwrite the data field with the hash of its contents and then\n            // hash the struct.\n            let dataPos := add(proposal, 0x40)\n            let t := mload(dataPos)\n            mstore(dataPos, dataHash)\n            proposalHash := keccak256(proposal, 0x60)\n            // Restore the data field.\n            mstore(dataPos, t)\n        }\n    }\n\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\n    /// @param voter The address of the voter.\n    /// @param timestamp The timestamp to get the snapshot index at.\n    /// @return index The index of the snapshot.\n    function findVotingPowerSnapshotIndex(address voter, uint40 timestamp)\n        public\n        view\n        returns (uint256 index)\n    {\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\n\n        // Derived from Open Zeppelin binary search\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\n        uint256 high = snaps.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = (low + high) / 2;\n            if (snaps[mid].timestamp > timestamp) {\n                // Entry is too recent.\n                high = mid;\n            } else {\n                // Entry is older. This is our best guess for now.\n                low = mid + 1;\n            }\n        }\n\n        // Return `type(uint256).max` if no valid voting snapshots found.\n        return high == 0 ? type(uint256).max : high - 1;\n    }\n\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\n    ///         the old one (if any).\n    /// @param delegate The address to delegating voting power to.\n    function delegateVotingPower(address delegate) external onlyDelegateCall {\n        _adjustVotingPower(msg.sender, 0, delegate);\n        emit VotingPowerDelegated(msg.sender, delegate);\n    }\n\n    /// @notice Transfer party host status to another.\n    /// @param newPartyHost The address of the new host.\n    function abdicate(address newPartyHost) external onlyHost onlyDelegateCall {\n        // 0 is a special case burn address.\n        if (newPartyHost != address(0)) {\n            // Cannot transfer host status to an existing host.\n            if(isHost[newPartyHost]) {\n                revert InvalidNewHostError();\n            }\n            isHost[newPartyHost] = true;\n        }\n        isHost[msg.sender] = false;\n        emit HostStatusTransferred(msg.sender, newPartyHost);\n    }\n\n    /// @notice Create a token distribution by moving the party's entire balance\n    ///         to the `TokenDistributor` contract and immediately creating a\n    ///         distribution governed by this party.\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\n    ///      propagated to the distribution. Party members are entitled to a\n    ///      share of the distribution's tokens proportionate to their relative\n    ///      voting power in this party (less the fee).\n    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.\n    /// @param tokenType The type of token to distribute.\n    /// @param token The address of the token to distribute.\n    /// @param tokenId The ID of the token to distribute. Currently unused but\n    ///                may be used in the future to support other distribution types.\n    /// @return distInfo The information about the created distribution.\n    function distribute(\n        ITokenDistributor.TokenType tokenType,\n        address token,\n        uint256 tokenId\n    )\n        external\n        onlyActiveMemberOrSelf\n        onlyWhenNotGloballyDisabled\n        onlyDelegateCall\n        returns (ITokenDistributor.DistributionInfo memory distInfo)\n    {\n        // Get the address of the token distributor.\n        ITokenDistributor distributor = ITokenDistributor(\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)\n        );\n        emit DistributionCreated(tokenType, token, tokenId);\n        // Create a native token distribution.\n        address payable feeRecipient_ = feeRecipient;\n        uint16 feeBps_ = feeBps;\n        if (tokenType == ITokenDistributor.TokenType.Native) {\n            return distributor.createNativeDistribution\n                { value: address(this).balance }(this, feeRecipient_, feeBps_);\n        }\n        // Otherwise must be an ERC20 token distribution.\n        assert(tokenType == ITokenDistributor.TokenType.Erc20);\n        IERC20(token).compatTransfer(\n            address(distributor),\n            IERC20(token).balanceOf(address(this))\n        );\n        return distributor.createErc20Distribution(\n            IERC20(token),\n            this,\n            feeRecipient_,\n            feeBps_\n        );\n    }\n\n    /// @notice Make a proposal for members to vote on and cast a vote to accept it\n    ///         as well.\n    /// @dev Only an active member (has voting power) can call this.\n    ///      Afterwards, members can vote to support it with `accept()` or a party\n    ///      host can unilaterally reject the proposal with `veto()`.\n    /// @param proposal The details of the proposal.\n    /// @param latestSnapIndex The index of the caller's most recent voting power\n    ///                        snapshot before the proposal was created. Should\n    ///                        be retrieved off-chain and passed in.\n    function propose(Proposal memory proposal, uint256 latestSnapIndex)\n        external\n        onlyActiveMember\n        onlyDelegateCall\n        returns (uint256 proposalId)\n    {\n        proposalId = ++lastProposalId;\n        // Store the time the proposal was created and the proposal hash.\n        (\n            _proposalStateByProposalId[proposalId].values,\n            _proposalStateByProposalId[proposalId].hash\n        ) = (\n            ProposalStateValues({\n                proposedTime: uint40(block.timestamp),\n                passedTime: 0,\n                executedTime: 0,\n                completedTime: 0,\n                votes: 0\n            }),\n            getProposalHash(proposal)\n        );\n        emit Proposed(proposalId, msg.sender, proposal);\n        accept(proposalId, latestSnapIndex);\n    }\n\n    /// @notice Vote to support a proposed proposal.\n    /// @dev The voting power cast will be the effective voting power of the caller\n    ///      just before `propose()` was called (see `getVotingPowerAt()`).\n    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the\n    ///      proposal will be in the `Passed` state and will be executable after\n    ///      the `executionDelay` has passed, putting it in the `Ready` state.\n    /// @param proposalId The ID of the proposal to accept.\n    /// @param snapIndex The index of the caller's last voting power snapshot\n    ///                  before the proposal was created. Should be retrieved\n    ///                  off-chain and passed in.\n    /// @return totalVotes The total votes cast on the proposal.\n    function accept(uint256 proposalId, uint256 snapIndex)\n        public\n        onlyDelegateCall\n        returns (uint256 totalVotes)\n    {\n        // Get the information about the proposal.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        // Can only vote in certain proposal statuses.\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Allow voting even if the proposal is passed/ready so it can\n            // potentially reach 100% consensus, which unlocks special\n            // behaviors for certain proposal types.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // Cannot vote twice.\n        if (info.hasVoted[msg.sender]) {\n            revert AlreadyVotedError(msg.sender);\n        }\n        // Mark the caller as having voted.\n        info.hasVoted[msg.sender] = true;\n\n        // Increase the total votes that have been cast on this proposal.\n        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\n        values.votes += votingPower;\n        info.values = values;\n        emit ProposalAccepted(proposalId, msg.sender, votingPower);\n\n        // Update the proposal status if it has reached the pass threshold.\n        if (values.passedTime == 0 && _areVotesPassing(\n            values.votes,\n            _governanceValues.totalVotingPower,\n            _governanceValues.passThresholdBps))\n        {\n            info.values.passedTime = uint40(block.timestamp);\n            emit ProposalPassed(proposalId);\n        }\n        return values.votes;\n    }\n\n    /// @notice As a party host, veto a proposal, unilaterally rejecting it.\n    /// @dev The proposal will never be executable and cannot be voted on anymore.\n    ///      A proposal that has been already executed at least once (in the `InProgress` status)\n    ///      cannot be vetoed.\n    /// @param proposalId The ID of the proposal to veto.\n    function veto(uint256 proposalId) external onlyHost onlyDelegateCall {\n        // Setting `votes` to -1 indicates a veto.\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\n        ProposalStateValues memory values = info.values;\n\n        {\n            ProposalStatus status = _getProposalStatus(values);\n            // Proposal must be in one of the following states.\n            if (\n                status != ProposalStatus.Voting &&\n                status != ProposalStatus.Passed &&\n                status != ProposalStatus.Ready\n            ) {\n                revert BadProposalStatusError(status);\n            }\n        }\n\n        // -1 indicates veto.\n        info.values.votes = VETO_VALUE;\n        emit ProposalVetoed(proposalId, msg.sender);\n    }\n\n    /// @notice Executes a proposal that has passed governance.\n    /// @dev The proposal must be in the `Ready` or `InProgress` status.\n    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`\n    ///      if the proposal has extra steps (must be executed again) to carry out,\n    ///      in which case `nextProgressData` should be passed into the next `execute()` call.\n    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal\n    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`\n    ///      in order to execute a different proposal.\n    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.\n    /// @param proposalId The ID of the proposal to execute.\n    /// @param proposal The details of the proposal.\n    /// @param preciousTokens The tokens that the party considers precious.\n    /// @param preciousTokenIds The token IDs associated with each precious token.\n    /// @param progressData The data returned from the last `execute()` call, if any.\n    /// @param extraData Off-chain data a proposal might need to execute a step.\n    function execute(\n        uint256 proposalId,\n        Proposal memory proposal,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        bytes calldata progressData,\n        bytes calldata extraData\n    )\n        external\n        payable\n        onlyActiveMember\n        onlyWhenNotGloballyDisabled\n        onlyDelegateCall\n    {\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        ProposalStatus status = _getProposalStatus(values);\n        // The proposal must be executable or have already been executed but still\n        // has more steps to go.\n        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {\n            revert BadProposalStatusError(status);\n        }\n        if (status == ProposalStatus.Ready) {\n            // If the proposal has not been executed yet, make sure it hasn't\n            // expired. Note that proposals that have been executed\n            // (but still have more steps) ignore `maxExecutableTime`.\n            if (proposal.maxExecutableTime < block.timestamp) {\n                revert ExecutionTimeExceededError(\n                    proposal.maxExecutableTime,\n                    uint40(block.timestamp)\n                );\n            }\n            proposalState.values.executedTime = uint40(block.timestamp);\n        }\n        // Check that the precious list is valid.\n        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {\n            revert BadPreciousListError();\n        }\n        // Preemptively set the proposal to completed to avoid it being executed\n        // again in a deeper call.\n        proposalState.values.completedTime = uint40(block.timestamp);\n        // Execute the proposal.\n        bool completed = _executeProposal(\n            proposalId,\n            proposal,\n            preciousTokens,\n            preciousTokenIds,\n            _getProposalFlags(values),\n            progressData,\n            extraData\n        );\n        if (!completed) {\n            // Proposal did not complete.\n            proposalState.values.completedTime = 0;\n        }\n    }\n\n    /// @notice Cancel a (probably stuck) InProgress proposal.\n    /// @dev `proposal.cancelDelay` seconds must have passed since it was first\n    ///      executed for this to be valid. The currently active proposal will\n    ///      simply be yeeted out of existence so another proposal can execute.\n    ///      This is intended to be a last resort and can leave the party in a\n    ///      broken state. Whenever possible, active proposals should be\n    ///      allowed to complete their lifecycle.\n    /// @param proposalId The ID of the proposal to cancel.\n    /// @param proposal The details of the proposal to cancel.\n    function cancel(uint256 proposalId, Proposal calldata proposal)\n        external\n        onlyActiveMember\n        onlyDelegateCall\n    {\n        // Get information about the proposal.\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\n        // Proposal details must remain the same from `propose()`.\n        _validateProposalHash(proposal, proposalState.hash);\n        ProposalStateValues memory values = proposalState.values;\n        {\n            // Must be `InProgress`.\n            ProposalStatus status = _getProposalStatus(values);\n            if (status != ProposalStatus.InProgress) {\n                revert BadProposalStatusError(status);\n            }\n        }\n        {\n            // Limit the `cancelDelay` to the global max and min cancel delay\n            // to mitigate parties accidentally getting stuck forever by setting an\n            // unrealistic `cancelDelay` or being reckless with too low a\n            // cancel delay.\n            uint256 cancelDelay = proposal.cancelDelay;\n            uint256 globalMaxCancelDelay =\n                _GLOBALS.getUint256(LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION);\n            uint256 globalMinCancelDelay =\n                _GLOBALS.getUint256(LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION);\n            if (globalMaxCancelDelay != 0) { // Only if we have one set.\n                if (cancelDelay > globalMaxCancelDelay) {\n                    cancelDelay = globalMaxCancelDelay;\n                }\n            }\n            if (globalMinCancelDelay != 0) { // Only if we have one set.\n                if (cancelDelay < globalMinCancelDelay) {\n                    cancelDelay = globalMinCancelDelay;\n                }\n            }\n            uint256 cancelTime = values.executedTime + cancelDelay;\n            // Must not be too early.\n            if (block.timestamp < cancelTime) {\n                revert ProposalCannotBeCancelledYetError(\n                    uint40(block.timestamp),\n                    uint40(cancelTime)\n                );\n            }\n        }\n        // Mark the proposal as cancelled by setting the completed time to the current\n        // time with the high bit set.\n        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);\n        {\n            // Delegatecall into the proposal engine impl to perform the cancel.\n            (bool success, bytes memory resultData) =\n            (address(_getProposalExecutionEngine())).delegatecall(abi.encodeCall(\n                IProposalExecutionEngine.cancelProposal,\n                (proposalId)\n            ));\n            if (!success) {\n                resultData.rawRevert();\n            }\n        }\n        emit ProposalCancelled(proposalId);\n    }\n\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\n    /// @dev Emergency actions must not be revoked for this to work.\n    /// @param targetAddress The contract to call.\n    /// @param targetCallData The data to pass to the contract.\n    /// @param amountEth The amount of ETH to send to the contract.\n    function emergencyExecute(\n        address targetAddress,\n        bytes calldata targetCallData,\n        uint256 amountEth\n    )\n        external\n        payable\n        onlyPartyDao\n        onlyWhenEmergencyExecuteAllowed\n        onlyDelegateCall\n    {\n        (bool success, bytes memory res) = targetAddress.call{value: amountEth}(targetCallData);\n        if (!success) {\n            res.rawRevert();\n        }\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\n    }\n\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\n    /// @dev Either the DAO or the party host can call this.\n    function disableEmergencyExecute() external onlyPartyDaoOrHost onlyDelegateCall {\n        emergencyExecuteDisabled = true;\n        emit EmergencyExecuteDisabled();\n    }\n\n    function _executeProposal(\n        uint256 proposalId,\n        Proposal memory proposal,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        uint256 flags,\n        bytes memory progressData,\n        bytes memory extraData\n    )\n        private\n        returns (bool completed)\n    {\n        // Setup the arguments for the proposal execution engine.\n        IProposalExecutionEngine.ExecuteProposalParams memory executeParams =\n            IProposalExecutionEngine.ExecuteProposalParams({\n                proposalId: proposalId,\n                proposalData: proposal.proposalData,\n                progressData: progressData,\n                extraData: extraData,\n                preciousTokens: preciousTokens,\n                preciousTokenIds: preciousTokenIds,\n                flags: flags\n            });\n        // Get the progress data returned after the proposal is executed.\n        bytes memory nextProgressData;\n        {\n            // Execute the proposal.\n            (bool success, bytes memory resultData) =\n                address(_getProposalExecutionEngine()).delegatecall(abi.encodeCall(\n                    IProposalExecutionEngine.executeProposal,\n                    (executeParams)\n                ));\n            if (!success) {\n                resultData.rawRevert();\n            }\n            nextProgressData = abi.decode(resultData, (bytes));\n        }\n        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);\n        // If the returned progress data is empty, then the proposal completed\n        // and it should not be executed again.\n        return nextProgressData.length == 0;\n    }\n\n    // Get the most recent voting power snapshot <= timestamp using `hintindex` as a \"hint\".\n    function _getVotingPowerSnapshotAt(address voter, uint40 timestamp, uint256 hintIndex)\n        internal\n        view\n        returns (VotingPowerSnapshot memory snap)\n    {\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\n        uint256 snapsLength = snaps.length;\n        if (snapsLength != 0) {\n            if (\n                // Hint is within bounds.\n                hintIndex < snapsLength &&\n                // Snapshot is not too recent.\n                snaps[hintIndex].timestamp <= timestamp &&\n                // Snapshot is not too old.\n                (hintIndex == snapsLength - 1 || snaps[hintIndex+1].timestamp > timestamp)\n            ) {\n                return snaps[hintIndex];\n            }\n\n            // Hint was wrong, fallback to binary search to find snapshot.\n            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);\n            // Check that snapshot was found.\n            if (hintIndex != type(uint256).max) {\n                return snaps[hintIndex];\n            }\n        }\n\n        // No snapshot found.\n        return snap;\n    }\n\n    // Transfers some voting power of `from` to `to`. The total voting power of\n    // their respective delegates will be updated as well.\n    function _transferVotingPower(address from, address to, uint256 power)\n        internal\n    {\n        int192 powerI192 = power.safeCastUint256ToInt192();\n        _adjustVotingPower(from, -powerI192, address(0));\n        _adjustVotingPower(to, powerI192, address(0));\n    }\n\n    // Increase `voter`'s intrinsic voting power and update their delegate if delegate is nonzero.\n    function _adjustVotingPower(address voter, int192 votingPower, address delegate)\n        internal\n    {\n        VotingPowerSnapshot memory oldSnap =\n            _getLastVotingPowerSnapshotForVoter(voter);\n        address oldDelegate = delegationsByVoter[voter];\n        // If `oldDelegate` is zero and `voter` never delegated, then have\n        // `voter` delegate to themself.\n        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;\n        // If the new `delegate` is zero, use the current (old) delegate.\n        delegate = delegate == address(0) ? oldDelegate : delegate;\n\n        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({\n            timestamp: uint40(block.timestamp),\n            delegatedVotingPower: oldSnap.delegatedVotingPower,\n            intrinsicVotingPower: (\n                    oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() + votingPower\n                ).safeCastInt192ToUint96(),\n            isDelegated: delegate != voter\n        });\n        _insertVotingPowerSnapshot(voter, newSnap);\n        delegationsByVoter[voter] = delegate;\n        // Handle rebalancing delegates.\n        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);\n    }\n\n    function _getTotalVotingPower() internal view returns (uint256) {\n        return _governanceValues.totalVotingPower;\n    }\n\n    // Update the delegated voting power of the old and new delegates delegated to\n    // by `voter` based on the snapshot change.\n    function _rebalanceDelegates(\n        address voter,\n        address oldDelegate,\n        address newDelegate,\n        VotingPowerSnapshot memory oldSnap,\n        VotingPowerSnapshot memory newSnap\n    )\n        private\n    {\n        if (newDelegate == address(0) || oldDelegate == address(0)) {\n            revert InvalidDelegateError();\n        }\n        if (oldDelegate != voter && oldDelegate != newDelegate) {\n            // Remove past voting power from old delegate.\n            VotingPowerSnapshot memory oldDelegateSnap =\n                _getLastVotingPowerSnapshotForVoter(oldDelegate);\n            VotingPowerSnapshot memory updatedOldDelegateSnap =\n                VotingPowerSnapshot({\n                    timestamp: uint40(block.timestamp),\n                    delegatedVotingPower:\n                        oldDelegateSnap.delegatedVotingPower -\n                            oldSnap.intrinsicVotingPower,\n                    intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,\n                    isDelegated: oldDelegateSnap.isDelegated\n                });\n            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);\n        }\n        if (newDelegate != voter) { // Not delegating to self.\n            // Add new voting power to new delegate.\n            VotingPowerSnapshot memory newDelegateSnap =\n                _getLastVotingPowerSnapshotForVoter(newDelegate);\n            uint96 newDelegateDelegatedVotingPower =\n                newDelegateSnap.delegatedVotingPower + newSnap.intrinsicVotingPower;\n            if (newDelegate == oldDelegate) {\n                // If the old and new delegate are the same, subtract the old\n                // intrinsic voting power of the voter, or else we will double\n                // count a portion of it.\n                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;\n            }\n            VotingPowerSnapshot memory updatedNewDelegateSnap =\n                VotingPowerSnapshot({\n                    timestamp: uint40(block.timestamp),\n                    delegatedVotingPower: newDelegateDelegatedVotingPower,\n                    intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,\n                    isDelegated: newDelegateSnap.isDelegated\n                });\n            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);\n        }\n    }\n\n    // Append a new voting power snapshot, overwriting the last one if possible.\n    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap)\n        private\n    {\n        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];\n        uint256 n = voterSnaps.length;\n        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.\n        if (n != 0) {\n            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];\n            if (lastSnap.timestamp == snap.timestamp) {\n                voterSnaps[n - 1] = snap;\n                return;\n            }\n        }\n        voterSnaps.push(snap);\n    }\n\n    function _getLastVotingPowerSnapshotForVoter(address voter)\n        private\n        view\n        returns (VotingPowerSnapshot memory snap)\n    {\n        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];\n        uint256 n = voterSnaps.length;\n        if (n != 0) {\n            snap = voterSnaps[n - 1];\n        }\n    }\n\n    function _getProposalFlags(ProposalStateValues memory pv)\n        private\n        view\n        returns (uint256)\n    {\n        if (_isUnanimousVotes(pv.votes, _governanceValues.totalVotingPower)) {\n            return LibProposal.PROPOSAL_FLAG_UNANIMOUS;\n        }\n        return 0;\n    }\n\n    function _getProposalStatus(ProposalStateValues memory pv)\n        private\n        view\n        returns (ProposalStatus status)\n    {\n        // Never proposed.\n        if (pv.proposedTime == 0) {\n            return ProposalStatus.Invalid;\n        }\n        // Executed at least once.\n        if (pv.executedTime != 0) {\n            if (pv.completedTime == 0) {\n                return ProposalStatus.InProgress;\n            }\n            // completedTime high bit will be set if cancelled.\n            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {\n                return ProposalStatus.Cancelled;\n            }\n            return ProposalStatus.Complete;\n        }\n        // Vetoed.\n        if (pv.votes == type(uint96).max) {\n            return ProposalStatus.Defeated;\n        }\n        uint40 t = uint40(block.timestamp);\n        GovernanceValues memory gv = _governanceValues;\n        if (pv.passedTime != 0) {\n            // Ready.\n            if (pv.passedTime + gv.executionDelay <= t) {\n                return ProposalStatus.Ready;\n            }\n            // If unanimous, we skip the execution delay.\n            if (_isUnanimousVotes(pv.votes, gv.totalVotingPower)) {\n                return ProposalStatus.Ready;\n            }\n            // Passed.\n            return ProposalStatus.Passed;\n        }\n        // Voting window expired.\n        if (pv.proposedTime + gv.voteDuration <= t) {\n            return ProposalStatus.Defeated;\n        }\n        return ProposalStatus.Voting;\n    }\n\n    function _isUnanimousVotes(uint96 totalVotes, uint96 totalVotingPower)\n        private\n        pure\n        returns (bool)\n    {\n        uint256 acceptanceRatio = (totalVotes * 1e4) / totalVotingPower;\n        // If >= 99.99% acceptance, consider it unanimous.\n        // The minting formula for voting power is a bit lossy, so we check\n        // for slightly less than 100%.\n        return acceptanceRatio >= 0.9999e4;\n    }\n\n    function _areVotesPassing(\n        uint96 voteCount,\n        uint96 totalVotingPower,\n        uint16 passThresholdBps\n    )\n        private\n        pure\n        returns (bool)\n    {\n          return uint256(voteCount) * 1e4\n            / uint256(totalVotingPower) >= uint256(passThresholdBps);\n    }\n\n    function _setPreciousList(\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        private\n    {\n        if (preciousTokens.length != preciousTokenIds.length) {\n            revert MismatchedPreciousListLengths();\n        }\n        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);\n    }\n\n    function _isPreciousListCorrect(\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        private\n        view\n        returns (bool)\n    {\n        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);\n    }\n\n    function _hashPreciousList(\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        pure\n        returns (bytes32 h)\n    {\n        assembly {\n            mstore(0x00, keccak256(\n                add(preciousTokens, 0x20),\n                mul(mload(preciousTokens), 0x20)\n            ))\n            mstore(0x20, keccak256(\n                add(preciousTokenIds, 0x20),\n                mul(mload(preciousTokenIds), 0x20)\n            ))\n            h := keccak256(0x00, 0x40)\n        }\n    }\n\n    // Assert that the hash of a proposal matches expectedHash.\n    function _validateProposalHash(Proposal memory proposal, bytes32 expectedHash)\n        private\n        pure\n    {\n        bytes32 actualHash = getProposalHash(proposal);\n        if (expectedHash != actualHash) {\n            revert BadProposalHashError(actualHash, expectedHash);\n        }\n    }\n\n}\n"
    },
    "contracts/party/PartyGovernanceNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/ReadOnlyDelegateCall.sol\";\nimport \"../utils/LibSafeCast.sol\";\nimport \"openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport \"../globals/IGlobals.sol\";\nimport \"../tokens/IERC721.sol\";\nimport \"../vendor/solmate/ERC721.sol\";\nimport \"./PartyGovernance.sol\";\nimport \"../renderers/RendererStorage.sol\";\n\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\ncontract PartyGovernanceNFT is\n    PartyGovernance,\n    ERC721,\n    IERC2981\n{\n    using LibSafeCast for uint256;\n    using LibSafeCast for uint96;\n\n    error OnlyMintAuthorityError(address actual, address expected);\n\n    // The `Globals` contract storing global configuration values. This contract\n    // is immutable and it’s address will never change.\n    IGlobals private immutable _GLOBALS;\n\n    /// @notice Who can call `mint()`. Usually this will be the crowdfund contract that\n    /// created the party.\n    address public mintAuthority;\n    /// @notice The number of tokens that have been minted.\n    uint96 public tokenCount;\n    /// @notice The total minted voting power.\n    ///         Capped to `_governanceValues.totalVotingPower`\n    uint96 public mintedVotingPower;\n    /// @notice The voting power of `tokenId`.\n    mapping (uint256 => uint256) public votingPowerByTokenId;\n\n    modifier onlyMinter() {\n        address minter = mintAuthority;\n        if (msg.sender != minter) {\n            revert OnlyMintAuthorityError(msg.sender, minter);\n        }\n        _;\n    }\n\n    // Set the `Globals` contract. The name of symbol of ERC721 does not matter;\n    // it will be set in `_initialize()`.\n    constructor(IGlobals globals) PartyGovernance(globals) ERC721('', '') {\n        _GLOBALS = globals;\n    }\n\n    // Initialize storage for proxy contracts.\n    function _initialize(\n        string memory name_,\n        string memory symbol_,\n        uint256 customizationPresetId,\n        PartyGovernance.GovernanceOpts memory governanceOpts,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds,\n        address mintAuthority_\n    )\n        internal\n    {\n        PartyGovernance._initialize(governanceOpts, preciousTokens, preciousTokenIds);\n        name = name_;\n        symbol = symbol_;\n        mintAuthority = mintAuthority_;\n        if (customizationPresetId != 0) {\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\n                .useCustomizationPreset(customizationPresetId);\n        }\n    }\n\n    /// @inheritdoc ERC721\n    function ownerOf(uint256 tokenId)\n        public\n        view\n        override(ERC721, ITokenDistributorParty)\n        returns (address owner)\n    {\n        return ERC721.ownerOf(tokenId);\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        override(PartyGovernance, ERC721, IERC165)\n        returns (bool)\n    {\n        return PartyGovernance.supportsInterface(interfaceId) ||\n            ERC721.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC2981).interfaceId;\n    }\n\n    /// @inheritdoc ERC721\n    function tokenURI(uint256) public override view returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\n    function contractURI() external view returns (string memory) {\n        _delegateToRenderer();\n        return \"\"; // Just to make the compiler happy.\n    }\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    function royaltyInfo(uint256, uint256)\n        external\n        view\n        returns (address, uint256)\n    {\n        _delegateToRenderer();\n        return (address(0), 0); // Just to make the compiler happy.\n    }\n\n    /// @inheritdoc ITokenDistributorParty\n    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {\n        return votingPowerByTokenId[tokenId] * 1e18 / _getTotalVotingPower();\n    }\n\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\n    /// immediately delegate voting power to `delegate.`\n    /// @param owner The owner of the NFT.\n    /// @param votingPower The voting power of the NFT.\n    /// @param delegate The address to delegate voting power to.\n    function mint(\n        address owner,\n        uint256 votingPower,\n        address delegate\n    )\n        external\n        onlyMinter\n        onlyDelegateCall\n        returns (uint256 tokenId)\n    {\n        (uint96 tokenCount_, uint96 mintedVotingPower_) = (tokenCount, mintedVotingPower);\n        uint96 totalVotingPower = _governanceValues.totalVotingPower;\n        // Cap voting power to remaining unminted voting power supply.\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\n        if (totalVotingPower - mintedVotingPower_ < votingPower_) {\n            votingPower_ = totalVotingPower - mintedVotingPower_;\n        }\n        mintedVotingPower_ += votingPower_;\n        // Update state.\n        tokenId = tokenCount = tokenCount_ + 1;\n        mintedVotingPower = mintedVotingPower_;\n        votingPowerByTokenId[tokenId] = votingPower_;\n\n        // Use delegate from party over the one set during crowdfund.\n        address delegate_ = delegationsByVoter[owner];\n        if (delegate_ != address(0)) {\n            delegate = delegate_;\n        }\n\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\n        _safeMint(owner, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function transferFrom(address owner, address to, uint256 tokenId)\n        public\n        override\n        onlyDelegateCall\n    {\n        // Transfer voting along with token.\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\n        super.transferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(address owner, address to, uint256 tokenId)\n        public\n        override\n        onlyDelegateCall\n    {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId);\n    }\n\n    /// @inheritdoc ERC721\n    function safeTransferFrom(address owner, address to, uint256 tokenId, bytes calldata data)\n        public\n        override\n        onlyDelegateCall\n    {\n        // super.safeTransferFrom() will call transferFrom() first which will\n        // transfer voting power.\n        super.safeTransferFrom(owner, to, tokenId, data);\n    }\n\n    /// @notice Relinquish the ability to call `mint()` by an authority.\n    function abdicate() external onlyMinter onlyDelegateCall {\n        delete mintAuthority;\n    }\n\n    function _delegateToRenderer() private view {\n        _readOnlyDelegateCall(\n            // Instance of IERC721Renderer.\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\n            msg.data\n        );\n        assert(false); // Will not be reached.\n    }\n}\n"
    },
    "contracts/proposals/IProposalExecutionEngine.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\n\n// Upgradeable proposals logic contract interface.\ninterface IProposalExecutionEngine {\n    struct ExecuteProposalParams {\n        uint256 proposalId;\n        bytes proposalData;\n        bytes progressData;\n        bytes extraData;\n        uint256 flags;\n        IERC721[] preciousTokens;\n        uint256[] preciousTokenIds;\n    }\n\n    function initialize(address oldImpl, bytes memory initData) external;\n\n    /// @notice Execute a proposal.\n    /// @dev Must be delegatecalled into by PartyGovernance.\n    ///      If the proposal is incomplete, continues its next step (if possible).\n    ///      If another proposal is incomplete, this will fail. Only one\n    ///      incomplete proposal is allowed at a time.\n    /// @param params The data needed to execute the proposal.\n    /// @return nextProgressData Bytes to be passed into the next `execute()` call,\n    ///         if the proposal execution is incomplete. Otherwise, empty bytes\n    ///         to indicate the proposal is complete.\n    function executeProposal(ExecuteProposalParams memory params)\n        external returns (bytes memory nextProgressData);\n\n    /// @notice Forcibly cancel an incomplete proposal.\n    /// @param proposalId The ID of the proposal to cancel.\n    /// @dev This is intended to be a last resort as it can leave a party in a\n    ///      broken step. Whenever possible, proposals should be allowed to\n    ///      complete their entire lifecycle.\n    function cancelProposal(uint256 proposalId) external;\n}\n"
    },
    "contracts/proposals/LibProposal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\n\nlibrary LibProposal {\n    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;\n\n    function isTokenPrecious(IERC721 token, IERC721[] memory preciousTokens)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint256 i; i < preciousTokens.length; ++i) {\n            if (token == preciousTokens[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isTokenIdPrecious(\n        IERC721 token,\n        uint256 tokenId,\n        IERC721[] memory preciousTokens,\n        uint256[] memory preciousTokenIds\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint256 i; i < preciousTokens.length; ++i) {\n            if (token == preciousTokens[i] && tokenId == preciousTokenIds[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    },
    "contracts/proposals/ProposalStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./IProposalExecutionEngine.sol\";\nimport \"../utils/LibRawResult.sol\";\n\n// The storage bucket shared by `PartyGovernance` and the `ProposalExecutionEngine`.\n// Read this for more context on the pattern motivating this:\n// https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets\nabstract contract ProposalStorage {\n    using LibRawResult for bytes;\n\n    struct SharedProposalStorage {\n        IProposalExecutionEngine engineImpl;\n    }\n\n    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;\n    uint256 private constant SHARED_STORAGE_SLOT = uint256(keccak256(\"ProposalStorage.SharedProposalStorage\"));\n\n    function _getProposalExecutionEngine()\n        internal\n        view\n        returns (IProposalExecutionEngine impl)\n    {\n        return _getSharedProposalStorage().engineImpl;\n    }\n\n    function _setProposalExecutionEngine(IProposalExecutionEngine impl) internal {\n        _getSharedProposalStorage().engineImpl = impl;\n    }\n\n    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData)\n        internal\n    {\n        SharedProposalStorage storage stor = _getSharedProposalStorage();\n        IProposalExecutionEngine oldImpl = stor.engineImpl;\n        stor.engineImpl = impl;\n        (bool s, bytes memory r) = address(impl).delegatecall(\n            abi.encodeCall(\n                IProposalExecutionEngine.initialize,\n                (address(oldImpl), initData)\n            )\n        );\n        if (!s) {\n            r.rawRevert();\n        }\n    }\n\n    function _getSharedProposalStorage()\n        private\n        pure\n        returns (SharedProposalStorage storage stor)\n    {\n        uint256 s = SHARED_STORAGE_SLOT;\n        assembly { stor.slot := s }\n    }\n\n}\n"
    },
    "contracts/renderers/RendererStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"solmate/utils/SSTORE2.sol\";\nimport \"../utils/Multicall.sol\";\n\ncontract RendererStorage is Multicall {\n    error AlreadySetError();\n    error NotOwnerError(address caller, address owner);\n\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    uint256 constant CROWDFUND_CARD_DATA = 0;\n    uint256 constant PARTY_CARD_DATA = 1;\n\n    /// @notice Address allowed to store new data.\n    address public owner;\n\n    /// @notice Customization presets by ID, used for rendering cards. Begins at\n    ///         1, 0 is reserved to indicate in `getPresetFor()` that a\n    ///         party instance use the preset set by the crowdfund instance that\n    ///         created it.\n    mapping(uint256 => bytes) public customizationPresets;\n    /// @notice Customization preset used by a crowdfund or party instance.\n    mapping(address => uint256) public getPresetFor;\n    /// @notice Addresses where URI data chunks are stored.\n    mapping(uint256 => address) public files;\n\n    modifier onlyOwner() {\n        address owner_ = owner;\n        if (msg.sender != owner_) {\n            revert NotOwnerError(msg.sender, owner_);\n        }\n\n        _;\n    }\n\n    constructor(address _owner) {\n        // Set the address allowed to write new data.\n        owner = _owner;\n\n        // Write URI data used by V1 of the renderers:\n\n        files[CROWDFUND_CARD_DATA] = SSTORE2.write(bytes(\n            '<path class=\"o\" d=\"M118.4 419.5h5.82v1.73h-4.02v1.87h3.74v1.73h-3.74v1.94h4.11v1.73h-5.91v-9Zm9.93 1.76h-2.6v-1.76h7.06v1.76h-2.61v7.24h-1.85v-7.24Zm6.06-1.76h1.84v3.55h3.93v-3.55H142v9h-1.84v-3.67h-3.93v3.67h-1.84v-9Z\"/><path class=\"o\" d=\"M145 413a4 4 0 0 1 4 4v14a4 4 0 0 1-4 4H35a4 4 0 0 1-4-4v-14a4 4 0 0 1 4-4h110m0-1H35a5 5 0 0 0-5 5v14a5 5 0 0 0 5 5h110a5 5 0 0 0 5-5v-14a5 5 0 0 0-5-5Z\"/><path d=\"M239.24 399.83h3.04c1.7 0 2.82 1 2.82 2.55 0 2.1-1.27 3.32-3.57 3.32h-1.97l-.71 3.3h-1.56l1.96-9.17Zm2.34 4.38c1.23 0 1.88-.58 1.88-1.68 0-.73-.49-1.2-1.48-1.2h-1.51l-.6 2.88h1.7Zm3.57 1.86c0-2.27 1.44-3.83 3.57-3.83 1.82 0 3.06 1.25 3.06 3.09 0 2.28-1.43 3.83-3.57 3.83-1.82 0-3.06-1.25-3.06-3.09Zm3.13 1.74c1.19 0 1.93-1.02 1.93-2.52 0-1.06-.62-1.69-1.56-1.69-1.19 0-1.93 1.02-1.93 2.52 0 1.06.62 1.69 1.56 1.69Zm4.74-5.41h1.49l.28 4.73 2.25-4.73h1.64l.23 4.77 2.25-4.77h1.56l-3.3 6.61h-1.62l-.25-5.04-2.42 5.04h-1.63l-.48-6.61Zm9.54 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm3.46-2.59h1.55l-.28 1.28c.81-1.7 2.56-1.36 2.77-1.29l-.35 1.46c-.18-.06-2.3-.63-2.82 1.68l-.74 3.48h-1.55l1.42-6.61Zm3.91 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm2.25 1.36c0-2.44 1.36-4.1 3.26-4.1 1 0 1.76.53 2.05 1.31l.79-3.72h1.55l-1.96 9.17h-1.55l.2-.92a2.15 2.15 0 0 1-1.92 1.08c-1.49 0-2.43-1.18-2.43-2.82Zm3 1.51c.88 0 1.51-.58 1.73-1.56l.17-.81c.24-1.1-.31-1.93-1.36-1.93-1.19 0-1.94 1.08-1.94 2.59 0 1.06.55 1.71 1.4 1.71Zm9.6-.01-.25 1.16h-1.55l1.96-9.17h1.55l-.73 3.47a2.35 2.35 0 0 1 1.99-1.05c1.49 0 2.35 1.16 2.35 2.76 0 2.52-1.36 4.16-3.21 4.16-.98 0-1.81-.53-2.1-1.32Zm1.83.01c1.16 0 1.87-1.06 1.87-2.61 0-1.04-.5-1.69-1.39-1.69s-1.52.56-1.73 1.55l-.17.79c-.24 1.14.34 1.97 1.42 1.97Zm5.68 1.16-1.04-6.62h1.52l.66 4.75 2.66-4.75h1.69l-5.31 9.13h-1.73l1.55-2.51Zm23.48-6.8a42.14 42.14 0 0 0-.75 6.01 43.12 43.12 0 0 0 5.58 2.35 42.54 42.54 0 0 0 5.58-2.35 45.32 45.32 0 0 0-.75-6.01c-.91-.79-2.6-2.21-4.83-3.66a42.5 42.5 0 0 0-4.83 3.66Zm13.07-7.95s.82-.29 1.76-.45a14.9 14.9 0 0 0-9.53-3.81c.66.71 1.28 1.67 1.84 2.75 1.84.22 4.07.7 5.92 1.51Zm-2.71 18.36c-2.06-.4-4.05-.97-5.53-1.51a38.65 38.65 0 0 1-5.53 1.51c.12 1.5.35 3.04.76 4.58 0 0 1.54 1.82 4.78 2.8 3.23-.98 4.78-2.8 4.78-2.8.4-1.53.64-3.08.76-4.58Zm-13.77-18.37a22.3 22.3 0 0 1 5.93-1.51 12.4 12.4 0 0 1 1.84-2.75 14.97 14.97 0 0 0-9.53 3.81c.95.16 1.76.45 1.76.45Zm-4.72 8.77a25.74 25.74 0 0 0 3.58 2.94 37.48 37.48 0 0 1 4.08-4.04c.27-1.56.77-3.57 1.46-5.55a25.24 25.24 0 0 0-4.34-1.63s-2.35.42-4.81 2.74c-.77 3.29.04 5.54.04 5.54Zm25.92 0s.81-2.25.04-5.54c-2.46-2.31-4.81-2.74-4.81-2.74-1.53.42-2.99.99-4.34 1.63a37.79 37.79 0 0 1 1.46 5.55 37.44 37.44 0 0 1 4.08 4.04 25.86 25.86 0 0 0 3.58-2.94Zm-26.38.2s-.66-.56-1.27-1.3c-.7 3.34-.27 6.93 1.46 10.16.28-.93.8-1.94 1.46-2.97a22.32 22.32 0 0 1-1.66-5.88Zm8.24 14.27a22.07 22.07 0 0 1-4.27-4.38c-1.22.06-2.36 0-3.3-.22a14.91 14.91 0 0 0 8.07 6.34c-.34-.9-.5-1.75-.5-1.75Zm18.6-14.27s.66-.56 1.27-1.3c.7 3.34.27 6.93-1.46 10.16-.28-.93-.8-1.94-1.46-2.97a22.32 22.32 0 0 0 1.66-5.88Zm-8.24 14.27a22.07 22.07 0 0 0 4.27-4.38c1.22.06 2.36 0 3.3-.22a14.91 14.91 0 0 1-8.07 6.34c.34-.9.5-1.75.5-1.75ZM330 391.84l-4.12 2.45 1.26 3.91h5.72l1.26-3.91-4.12-2.45Zm-11.4 19.74 4.18 2.35 2.75-3.05-2.86-4.95-4.02.86-.06 4.79Zm22.79 0-.06-4.79-4.02-.86-2.86 4.95 2.75 3.05 4.18-2.35Z\" style=\"fill:#00c1fa\"/><use height=\"300\" transform=\"matrix(1 0 0 .09 29.85 444)\" width=\"300.15\" xlink:href=\"#a\"/><use height=\"21.15\" transform=\"translate(30 446.92)\" width=\"300\" xlink:href=\"#b\"/><g><path d=\"m191.54 428.67-28.09-24.34A29.98 29.98 0 0 0 143.8 397H30a15 15 0 0 0-15 15v98a15 15 0 0 0 15 15h300a15 15 0 0 0 15-15v-59a15 15 0 0 0-15-15H211.19a30 30 0 0 1-19.65-7.33Z\" style=\"fill:url(#i)\"/></g></svg>'\n        ));\n\n        files[PARTY_CARD_DATA] = SSTORE2.write(bytes(\n            ' d=\"M30 444.28h4.3c3.05 0 5.17 2.13 5.17 5.36s-2.11 5.35-5.17 5.35H30v-10.72Zm3.95 8.61c2.07 0 3.24-1.2 3.24-3.25s-1.16-3.26-3.24-3.26h-1.77v6.51h1.77Zm7.78-8.61h2.19V455h-2.19v-10.72Zm4.79 10.02v-2.31c1 .74 2.13 1.13 3.25 1.13s1.68-.45 1.68-1.23c0-.69-.39-.95-1.23-1.19l-1.19-.34c-1.78-.48-2.65-1.46-2.65-3.1 0-1.95 1.5-3.18 3.87-3.18 1.05 0 2.09.21 2.91.66V447a5.53 5.53 0 0 0-2.96-.84c-.93 0-1.57.35-1.57 1.06.01.6.39.91 1.16 1.12l1.32.39c1.82.5 2.61 1.42 2.61 3.07 0 2.1-1.53 3.39-3.82 3.39a6.08 6.08 0 0 1-3.38-.9Zm11.93-7.92h-3.1v-2.1h8.41v2.1h-3.11V455h-2.2v-8.62Zm7.56-2.1h4.5c2 0 3.33 1.26 3.33 3.25 0 1.86-1.18 3.1-3.01 3.19l3.53 4.27H71.7l-3.54-4.43v4.43h-2.14v-10.72Zm4.1 4.85c.98 0 1.54-.55 1.54-1.44s-.56-1.43-1.54-1.43h-1.96v2.87h1.96Zm6.04-4.85h2.19V455h-2.19v-10.72Zm5.07 0h4.5c1.99 0 3.21 1.15 3.21 2.79 0 1.06-.5 1.93-1.36 2.32a2.46 2.46 0 0 1 1.78 2.49c0 1.9-1.33 3.11-3.52 3.11h-4.61v-10.72Zm4.17 4.4c.87 0 1.37-.45 1.37-1.26s-.5-1.26-1.37-1.26h-2.06v2.52h2.06Zm.34 4.44c.88 0 1.46-.46 1.46-1.29s-.57-1.3-1.46-1.3h-2.39v2.59h2.39Zm5.63-2.51v-6.33h2.18v6.29c0 1.6.88 2.52 2.3 2.52s2.28-.92 2.28-2.52v-6.29h2.18v6.33c0 2.86-1.72 4.58-4.47 4.58s-4.48-1.72-4.48-4.58Zm14.21-4.23h-3.1v-2.1h8.41v2.1h-3.11V455h-2.2v-8.62Zm7.56-2.1h2.18V455h-2.18v-10.72Zm4.45 5.36c0-3.25 2.21-5.56 5.32-5.56s5.28 2.31 5.28 5.56-2.2 5.55-5.28 5.55-5.32-2.31-5.32-5.55Zm5.32 3.45c1.85 0 3-1.34 3-3.45s-1.15-3.46-3-3.46-3.04 1.34-3.04 3.46 1.16 3.45 3.04 3.45Zm7.54-8.81h2.94l4.03 8.17v-8.17h2.07V455h-2.93l-4.03-8.17V455h-2.09v-10.72Zm11.65 10.02v-2.31c.99.74 2.13 1.13 3.25 1.13s1.68-.45 1.68-1.23c0-.69-.39-.95-1.23-1.19l-1.19-.34c-1.78-.48-2.65-1.46-2.65-3.1 0-1.95 1.5-3.18 3.87-3.18 1.05 0 2.09.21 2.91.66V447a5.53 5.53 0 0 0-2.96-.84c-.92 0-1.57.35-1.57 1.06.01.6.39.91 1.16 1.12l1.32.39c1.82.5 2.61 1.42 2.61 3.07 0 2.1-1.53 3.39-3.82 3.39a6.08 6.08 0 0 1-3.38-.9Zm45.9-10.02h2.38l2.63 8.18 2.72-8.18h2.33L194.39 455h-2.76l-3.64-10.72Zm11.19 5.36c0-3.25 2.21-5.56 5.32-5.56s5.28 2.31 5.28 5.56-2.2 5.55-5.28 5.55-5.32-2.31-5.32-5.55Zm5.32 3.45c1.85 0 3-1.34 3-3.45s-1.15-3.46-3-3.46-3.04 1.34-3.04 3.46 1.16 3.45 3.04 3.45Zm9.41-6.71h-3.1v-2.1h8.41v2.1h-3.11V455h-2.2v-8.62Zm7.56-2.1h6.93v2.06h-4.79v2.23h4.45v2.06h-4.45v2.31h4.89V455h-7.03v-10.72Zm14.17 0h4.27c2.25 0 3.66 1.33 3.66 3.52s-1.4 3.53-3.66 3.53h-2.11V455h-2.16v-10.72Zm4.08 4.99c1.06 0 1.61-.53 1.61-1.47s-.55-1.46-1.61-1.46h-1.92v2.93h1.92Zm5.49.38c0-3.25 2.21-5.56 5.32-5.56s5.28 2.31 5.28 5.56-2.2 5.55-5.28 5.55-5.32-2.31-5.32-5.55Zm5.32 3.45c1.85 0 3-1.34 3-3.45s-1.15-3.46-3-3.46-3.04 1.34-3.04 3.46 1.16 3.45 3.04 3.45Zm6.54-8.81h2.34l1.69 7.84 1.86-7.84h2.41l1.82 7.84 1.75-7.84h2.27l-2.66 10.72H266l-1.88-8.15-1.85 8.15h-2.55l-2.66-10.72Zm16.11 0h6.93v2.06h-4.79v2.23h4.45v2.06h-4.45v2.31h4.89v2.06h-7.03v-10.72Zm9.69 0h4.5c2 0 3.33 1.26 3.33 3.25 0 1.86-1.18 3.1-3.01 3.19l3.53 4.27h-2.66l-3.54-4.43V455h-2.14v-10.72Zm4.1 4.85c.98 0 1.54-.55 1.54-1.44s-.56-1.43-1.54-1.43h-1.96v2.87h1.96ZM30 259.28h4.27c2.25 0 3.66 1.33 3.66 3.52s-1.4 3.53-3.66 3.53h-2.12V270h-2.16v-10.72Zm4.08 4.99c1.06 0 1.61-.53 1.61-1.47s-.55-1.46-1.61-1.46h-1.92v2.93h1.92Zm6.1-4.99h4.5c2 0 3.33 1.26 3.33 3.25 0 1.86-1.18 3.1-3.01 3.19l3.53 4.27h-2.66l-3.54-4.43v4.43h-2.14v-10.72Zm4.1 4.85c.98 0 1.54-.55 1.54-1.44s-.56-1.43-1.54-1.43h-1.96v2.87h1.96Zm5.43.52c0-3.25 2.21-5.56 5.32-5.56s5.28 2.31 5.28 5.56-2.2 5.55-5.28 5.55-5.32-2.31-5.32-5.55Zm5.32 3.45c1.85 0 3-1.34 3-3.45s-1.15-3.46-3-3.46-3.04 1.34-3.04 3.46 1.16 3.45 3.04 3.45Zm7.54-8.81h4.27c2.25 0 3.66 1.33 3.66 3.52s-1.4 3.53-3.66 3.53h-2.11v3.67h-2.16v-10.72Zm4.08 4.99c1.06 0 1.61-.53 1.61-1.47s-.55-1.46-1.61-1.46h-1.92v2.93h1.92Zm5.49.38c0-3.25 2.21-5.56 5.32-5.56s5.28 2.31 5.28 5.56-2.2 5.55-5.28 5.55-5.32-2.31-5.32-5.55Zm5.32 3.45c1.85 0 3-1.34 3-3.45s-1.15-3.46-3-3.46-3.04 1.34-3.04 3.46 1.16 3.45 3.04 3.45Zm7.26 1.21v-2.31c.99.74 2.13 1.13 3.25 1.13s1.68-.45 1.68-1.23c0-.69-.39-.95-1.23-1.19l-1.19-.34c-1.78-.48-2.65-1.46-2.65-3.1 0-1.95 1.5-3.18 3.87-3.18 1.05 0 2.09.21 2.91.66v2.26a5.53 5.53 0 0 0-2.96-.84c-.92 0-1.57.35-1.57 1.06.01.6.39.91 1.16 1.12l1.32.39c1.82.5 2.61 1.42 2.61 3.07 0 2.1-1.53 3.39-3.82 3.39a6.08 6.08 0 0 1-3.38-.9Zm12.22-10.02h2.83l3.67 10.72h-2.28l-.83-2.55h-4.02l-.83 2.55h-2.2l3.66-10.72Zm2.76 6.25-1.39-4.24-1.37 4.24h2.76Zm5.72-6.25h2.19v8.61h4.73v2.1h-6.92v-10.72Zm9.06 10.02v-2.31c.99.74 2.13 1.13 3.25 1.13s1.68-.45 1.68-1.23c0-.69-.39-.95-1.23-1.19l-1.19-.34c-1.78-.48-2.65-1.46-2.65-3.1 0-1.95 1.5-3.18 3.87-3.18 1.05 0 2.09.21 2.91.66v2.26a5.53 5.53 0 0 0-2.96-.84c-.92 0-1.57.35-1.57 1.06.01.6.39.91 1.16 1.12l1.32.39c1.82.5 2.61 1.42 2.61 3.07 0 2.1-1.53 3.39-3.82 3.39a6.08 6.08 0 0 1-3.38-.9ZM30 199.28h2.94l4.03 8.17v-8.17h2.07V210h-2.93l-4.03-8.17V210h-2.09v-10.72Zm14.7 0h2.83L51.2 210h-2.28l-.83-2.55h-4.02l-.83 2.55h-2.2l3.66-10.72Zm2.76 6.25-1.39-4.24-1.37 4.24h2.76Zm5.72-6.25h3.28l2.49 8.21 2.45-8.21h3.33V210h-2.04v-8.62L59.96 210h-2.07l-2.7-8.47V210h-2v-10.72Zm14.43 0h6.93v2.06h-4.79v2.23h4.45v2.06h-4.45v2.31h4.89V210h-7.03v-10.72Z\" /><path d=\"M239.24 24.83h3.04c1.7 0 2.82 1 2.82 2.55 0 2.1-1.27 3.32-3.57 3.32h-1.97l-.71 3.3h-1.56l1.96-9.17Zm2.34 4.38c1.23 0 1.88-.58 1.88-1.68 0-.73-.49-1.2-1.48-1.2h-1.51l-.6 2.88h1.7Zm3.57 1.86c0-2.27 1.44-3.83 3.57-3.83 1.82 0 3.06 1.25 3.06 3.09 0 2.28-1.43 3.83-3.57 3.83-1.82 0-3.06-1.25-3.06-3.09Zm3.13 1.74c1.19 0 1.93-1.02 1.93-2.52 0-1.06-.62-1.69-1.56-1.69-1.19 0-1.93 1.02-1.93 2.52 0 1.06.62 1.69 1.56 1.69Zm4.74-5.41h1.49l.28 4.73 2.25-4.73h1.64l.23 4.77 2.25-4.77h1.56l-3.3 6.61h-1.62l-.25-5.04-2.42 5.04h-1.63l-.48-6.61Zm9.54 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm3.46-2.59h1.55l-.28 1.28c.81-1.7 2.56-1.36 2.77-1.29l-.35 1.46c-.18-.06-2.3-.63-2.82 1.68l-.74 3.48h-1.55l1.42-6.61Zm3.91 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm2.25 1.36c0-2.44 1.36-4.1 3.26-4.1 1 0 1.76.53 2.05 1.31l.79-3.72h1.55l-1.96 9.17h-1.55l.2-.92a2.15 2.15 0 0 1-1.92 1.08c-1.49 0-2.43-1.18-2.43-2.82Zm3 1.51c.88 0 1.51-.58 1.73-1.56l.17-.81c.24-1.1-.31-1.93-1.36-1.93-1.19 0-1.94 1.08-1.94 2.59 0 1.06.55 1.71 1.4 1.71Zm9.6-.01-.25 1.16h-1.55l1.96-9.17h1.55l-.73 3.47a2.35 2.35 0 0 1 1.99-1.05c1.49 0 2.35 1.16 2.35 2.76 0 2.52-1.36 4.16-3.21 4.16-.98 0-1.81-.53-2.1-1.32Zm1.83.01c1.16 0 1.87-1.06 1.87-2.61 0-1.04-.5-1.69-1.39-1.69s-1.52.56-1.73 1.55l-.17.79c-.24 1.14.34 1.97 1.42 1.97Zm5.68 1.16-1.04-6.62h1.52l.66 4.75 2.66-4.75h1.69l-5.31 9.13h-1.73l1.55-2.51Zm23.47-6.8c.91-.79 2.6-2.21 4.83-3.66a42.5 42.5 0 0 1 4.83 3.66c.23 1.18.62 3.36.75 6.01a43.12 43.12 0 0 1-5.58 2.35 42.54 42.54 0 0 1-5.58-2.35c.14-2.65.53-4.83.75-6.01Zm13.07-7.95s.82-.29 1.76-.45a14.9 14.9 0 0 0-9.53-3.81c.66.71 1.28 1.67 1.84 2.75 1.84.22 4.07.7 5.92 1.51Zm-2.71 18.36c-2.06-.4-4.05-.97-5.53-1.51a38.65 38.65 0 0 1-5.53 1.51c.12 1.5.35 3.04.76 4.58 0 0 1.54 1.82 4.78 2.8 3.23-.98 4.78-2.8 4.78-2.8.4-1.53.64-3.08.76-4.58Zm-13.77-18.37a22.3 22.3 0 0 1 5.93-1.51 12.4 12.4 0 0 1 1.84-2.75 14.97 14.97 0 0 0-9.53 3.81c.95.16 1.76.45 1.76.45Zm-4.72 8.77a25.74 25.74 0 0 0 3.58 2.94 37.48 37.48 0 0 1 4.08-4.04c.27-1.56.77-3.57 1.46-5.55a25.24 25.24 0 0 0-4.34-1.63s-2.35.42-4.81 2.74c-.77 3.29.04 5.54.04 5.54Zm25.92 0s.81-2.25.04-5.54c-2.46-2.31-4.81-2.74-4.81-2.74-1.53.42-2.99.99-4.34 1.63a37.79 37.79 0 0 1 1.46 5.55 37.44 37.44 0 0 1 4.08 4.04 25.86 25.86 0 0 0 3.58-2.94Zm-26.38.2s-.66-.56-1.27-1.3c-.7 3.34-.27 6.93 1.46 10.16.28-.93.8-1.94 1.46-2.97a22.32 22.32 0 0 1-1.66-5.88Zm8.24 14.27a22.07 22.07 0 0 1-4.27-4.38c-1.22.06-2.36 0-3.3-.22a14.91 14.91 0 0 0 8.07 6.34c-.34-.9-.5-1.75-.5-1.75Zm18.6-14.27s.66-.56 1.27-1.3c.7 3.34.27 6.93-1.46 10.16-.28-.93-.8-1.94-1.46-2.97a22.32 22.32 0 0 0 1.66-5.88Zm-8.24 14.27a22.07 22.07 0 0 0 4.27-4.38c1.22.06 2.36 0 3.3-.22a14.91 14.91 0 0 1-8.07 6.34c.34-.9.5-1.75.5-1.75Zm-5.18-25.66-4.12 2.45 1.26 3.91h5.72l1.26-3.91-4.12-2.45Zm-11.4 19.74 4.18 2.35 2.75-3.05-2.86-4.95-4.02.86-.06 4.79Zm22.79 0-.06-4.79-4.02-.86-2.86 4.95 2.75 3.05 4.18-2.35Z\" style=\"fill:#00c1fa\"/><path d=\"M106.67 109.1a304.9 304.9 0 0 0-3.72-10.89c5.04-5.53 35.28-40.74 24.54-68.91 10.57 10.67 8.19 28.85 3.59 41.95-4.79 13.14-13.43 26.48-24.4 37.84Zm30.89 20.82c-5.87 6.12-20.46 17.92-21.67 18.77a99.37 99.37 0 0 0 7.94 6.02 133.26 133.26 0 0 0 20.09-18.48 353.47 353.47 0 0 0-6.36-6.31Zm-29.65-16.74a380.9 380.9 0 0 1 3.13 11.56c-4.8-1.37-8.66-2.53-12.36-3.82a123.4 123.4 0 0 1-21.16 13.21l15.84 5.47c14.83-8.23 28.13-20.82 37.81-34.68 0 0 8.56-12.55 12.42-23.68 2.62-7.48 4.46-16.57 3.49-24.89-2.21-12.27-6.95-15.84-9.32-17.66 6.16 5.72 3.25 27.8-2.79 39.89-6.08 12.16-15.73 24.27-27.05 34.59Zm59.05-37.86c-.03 7.72-3.05 15.69-6.44 22.69 1.7 2.2 3.18 4.36 4.42 6.49 7.97-16.51 3.74-26.67 2.02-29.18ZM61.18 128.51l12.5 4.3a101.45 101.45 0 0 0 21.42-13.19 163.26 163.26 0 0 1-10.61-4.51 101.28 101.28 0 0 1-23.3 13.4Zm87.78-42.73c.86.77 5.44 5.18 6.75 6.59 6.39-16.61.78-28.86-1.27-30.56.72 8.05-2.02 16.51-5.48 23.98Zm-14.29 40.62-2.47-15.18a142.42 142.42 0 0 1-35.74 29.45c6.81 2.36 12.69 4.4 15.45 5.38a115.98 115.98 0 0 0 22.75-19.66Zm-42.62 34.73c4.48 2.93 12.94 4.24 18.8 1.23 6.03-3.84-.6-8.34-8.01-9.88-9.8-2.03-16.82 1.22-13.4 6.21.41.6 1.19 1.5 2.62 2.44m-1.84.4c-3.56-2.37-6.77-7.2-.23-10.08 10.41-3.43 28.39 3.2 24.99 9.22-.58 1.04-1.46 1.6-2.38 2.19h-.03v.02h-.03v.02h-.03c-7.04 3.65-17.06 2.13-22.3-1.36m5.48-3.86a4.94 4.94 0 0 0 5.06.49l1.35-.74-4.68-2.38-1.47.79c-.38.22-1.53.88-.26 1.84m-1.7.59c-2.35-1.57-.78-2.61-.02-3.11 1.09-.57 2.19-1.15 3.28-1.77 6.95 3.67 7.22 3.81 13.19 6.17l-1.38.81c-1.93-.78-4.52-1.82-6.42-2.68.86 1.4 1.99 3.27 2.9 4.64l-1.68.87c-.75-1.28-1.76-2.99-2.47-4.29-3.19 2.06-6.99-.36-7.42-.64\" style=\"fill:url(#f2)\"/><path d=\"M159.13 52.37C143.51 24.04 119.45 15 103.6 15c-11.92 0-25.97 5.78-36.84 13.17 9.54 4.38 21.86 15.96 22.02 16.11-7.94-3.05-17.83-6.72-33.23-7.87a135.1 135.1 0 0 0-19.77 20.38c.77 7.66 2.88 15.68 2.88 15.68-6.28-4.75-11.02-4.61-18 9.45-5.4 12.66-6.93 24.25-4.65 33.18 0 0 4.72 26.8 36.23 40.07-1.3-4.61-1.58-9.91-.93-15.73a87.96 87.96 0 0 1-15.63-9.87c.79-6.61 2.79-13.82 6-21.36 4.42-10.66 4.35-15.14 4.35-15.19.03.07 5.48 12.43 12.95 22.08 4.23-8.84 9.46-16.08 13.67-21.83l-3.77-6.75a143.73 143.73 0 0 1 18.19-18.75c2.05 1.07 4.79 2.47 6.84 3.58 8.68-7.27 19.25-14.05 30.56-18.29-7-11.49-16.02-19.27-16.02-19.27s27.7 2.74 42.02 15.69a25.8 25.8 0 0 1 8.65 2.89ZM28.58 107.52a70.1 70.1 0 0 0-2.74 12.52 55.65 55.65 0 0 1-6.19-8.84 69.17 69.17 0 0 1 2.65-12.1c1.77-5.31 3.35-5.91 5.86-2.23v-.05c2.14 3.07 1.81 6.14.42 10.7ZM61.69 72.2l-.05.05a221.85 221.85 0 0 1-7.77-18.1l.14-.14a194.51 194.51 0 0 1 18.56 6.98 144.44 144.44 0 0 0-10.88 11.22Zm54.84-47.38c-4.42.7-9.02 1.95-13.67 3.72a65.03 65.03 0 0 0-7.81-5.31 66.04 66.04 0 0 1 13.02-3.54c1.53-.19 6.23-.79 10.32 2.42v-.05c2.47 1.91.14 2.37-1.86 2.75Z\" style=\"fill:url(#h)\"/>'\n        ));\n    }\n\n    /// @notice Transfer ownership to a new owner.\n    /// @param newOwner The address to transfer ownership to.\n    function transferOwnership(address newOwner) external onlyOwner {\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /// @notice Write data to be accessed by a given file key.\n    /// @param key The key to access the written data.\n    /// @param data The data to be written.\n    function writeFile(uint256 key, string memory data) external onlyOwner {\n        files[key] = SSTORE2.write(bytes(data));\n    }\n\n    /// @notice Read data using a given file key.\n    /// @param key The key to access the stored data.\n    /// @return data The data stored at the given key.\n    function readFile(uint256 key) external view returns (string memory data) {\n        return string(SSTORE2.read(files[key]));\n    }\n\n    /// @notice Create or set a customization preset for renderers to use.\n    /// @param id The ID of the customization preset.\n    /// @param customizationData Data decoded by renderers used to render the SVG according to the preset.\n    function createCustomizationPreset(uint256 id, bytes memory customizationData) external onlyOwner {\n        customizationPresets[id] = customizationData;\n    }\n\n    /// @notice For crowdfund or party instances to set the customization preset they want to use.\n    /// @param id The ID of the customization preset.\n    function useCustomizationPreset(uint256 id) external {\n        getPresetFor[msg.sender] = id;\n    }\n}\n"
    },
    "contracts/tokens/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8;\n\nimport \"../vendor/solmate/ERC1155.sol\";\nimport \"../utils/EIP165.sol\";\n\nabstract contract ERC1155Receiver is EIP165, ERC1155TokenReceiverBase {\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        override\n        virtual\n        pure\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId) ||\n            interfaceId == type(ERC1155TokenReceiverBase).interfaceId;\n    }\n\n}\n"
    },
    "contracts/tokens/ERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8;\n\nimport \"./IERC721Receiver.sol\";\nimport \"../utils/EIP165.sol\";\nimport \"../vendor/solmate/ERC721.sol\";\n\n/// @notice Mixin for contracts that want to receive ERC721 tokens.\n/// @dev Use this instead of solmate's ERC721TokenReceiver because the\n///      compiler has issues when overriding EIP165/IERC721Receiver functions.\nabstract contract ERC721Receiver is IERC721Receiver, EIP165, ERC721TokenReceiver {\n    /// @inheritdoc IERC721Receiver\n    function onERC721Received(address, address, uint256, bytes memory)\n        public\n        virtual\n        override(IERC721Receiver, ERC721TokenReceiver)\n        returns (bytes4)\n    {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    /// @inheritdoc EIP165\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        override\n        returns (bool)\n    {\n        return EIP165.supportsInterface(interfaceId) ||\n            interfaceId == type(IERC721Receiver).interfaceId;\n    }\n}\n"
    },
    "contracts/tokens/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8;\n\n// Minimal ERC1155 interface.\ninterface IERC1155 {\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function setApprovalForAll(address operator, bool approved) external;\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n    function balanceOf(address owner, uint256 tokenId) external view returns (uint256);\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory balances);\n}\n"
    },
    "contracts/tokens/IERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8;\n\n// Minimal ERC20 interface.\ninterface IERC20 {\n    event Transfer(address indexed owner, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 allowance);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 allowance) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function balanceOf(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/tokens/IERC721.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8;\n\n// Minimal ERC721 interface.\ninterface IERC721 {\n    event Transfer(address indexed owner, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed operator, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address operator, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool isApproved) external;\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function getApproved(uint256 tokenId) external view returns (address);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function balanceOf(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/tokens/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8;\n\ninterface IERC721Receiver {\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/utils/EIP165.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nabstract contract EIP165 {\n    /// @notice Query if a contract implements an interface.\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @return `true` if the contract implements `interfaceId` and\n    ///         `interfaceId` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId)\n        public\n        virtual\n        pure\n        returns (bool)\n    {\n        return interfaceId == this.supportsInterface.selector;\n    }\n}\n"
    },
    "contracts/utils/Implementation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n// Base contract for all contracts intended to be delegatecalled into.\nabstract contract Implementation {\n    error OnlyDelegateCallError();\n    error OnlyConstructorError();\n\n    address public immutable IMPL;\n\n    constructor() { IMPL = address(this); }\n\n    // Reverts if the current function context is not inside of a delegatecall.\n    modifier onlyDelegateCall() virtual {\n        if (address(this) == IMPL) {\n            revert OnlyDelegateCallError();\n        }\n        _;\n    }\n\n    // Reverts if the current function context is not inside of a constructor.\n    modifier onlyConstructor() {\n        uint256 codeSize;\n        assembly { codeSize := extcodesize(address()) }\n        if (codeSize != 0) {\n            revert OnlyConstructorError();\n        }\n        _;\n    }\n}\n"
    },
    "contracts/utils/LibAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nlibrary LibAddress {\n    error EthTransferFailed(address receiver, bytes errData);\n\n    // Transfer ETH with full gas stipend.\n    function transferEth(address payable receiver, uint256 amount)\n        internal\n    {\n        if (amount == 0) return;\n\n        (bool s, bytes memory r) = receiver.call{value: amount}(\"\");\n        if (!s) {\n            revert EthTransferFailed(receiver, r);\n        }\n    }\n}\n"
    },
    "contracts/utils/LibERC20Compat.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC20.sol\";\n\n// Compatibility helpers for ERC20s.\nlibrary LibERC20Compat {\n    error NotATokenError(IERC20 token);\n    error TokenTransferFailedError(IERC20 token, address to, uint256 amount);\n\n    // Perform an `IERC20.transfer()` handling non-compliant implementations.\n    function compatTransfer(IERC20 token, address to, uint256 amount)\n        internal\n    {\n        (bool s, bytes memory r) =\n            address(token).call(abi.encodeCall(IERC20.transfer, (to, amount)));\n        if (s) {\n            if (r.length == 0) {\n                uint256 cs;\n                assembly { cs := extcodesize(token) }\n                if (cs == 0) {\n                    revert NotATokenError(token);\n                }\n                return;\n            }\n            if (abi.decode(r, (bool))) {\n                return;\n            }\n        }\n        revert TokenTransferFailedError(token, to, amount);\n    }\n}\n"
    },
    "contracts/utils/LibRawResult.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nlibrary LibRawResult {\n    // Revert with the data in `b`.\n    function rawRevert(bytes memory b)\n        internal\n        pure\n    {\n        assembly { revert(add(b, 32), mload(b)) }\n    }\n\n    // Return with the data in `b`.\n    function rawReturn(bytes memory b)\n        internal\n        pure\n    {\n        assembly { return(add(b, 32), mload(b)) }\n    }\n}\n"
    },
    "contracts/utils/LibSafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nlibrary LibSafeCast {\n    error Uint256ToUint96CastOutOfRange(uint256 v);\n    error Uint256ToInt192CastOutOfRange(uint256 v);\n    error Int192ToUint96CastOutOfRange(int192 i192);\n    error Uint256ToInt128CastOutOfRangeError(uint256 u256);\n    error Uint256ToUint128CastOutOfRangeError(uint256 u256);\n    error Uint256ToUint40CastOutOfRangeError(uint256 u256);\n\n    function safeCastUint256ToUint96(uint256 v) internal pure returns (uint96) {\n        if (v > uint256(type(uint96).max)) {\n            revert Uint256ToUint96CastOutOfRange(v);\n        }\n        return uint96(v);\n    }\n\n    function safeCastUint256ToUint128(uint256 v) internal pure returns (uint128) {\n        if (v > uint256(type(uint128).max)) {\n            revert Uint256ToUint128CastOutOfRangeError(v);\n        }\n        return uint128(v);\n    }\n\n    function safeCastUint256ToInt192(uint256 v) internal pure returns (int192) {\n        if (v > uint256(uint192(type(int192).max))) {\n            revert Uint256ToInt192CastOutOfRange(v);\n        }\n        return int192(uint192(v));\n    }\n\n    function safeCastUint96ToInt192(uint96 v) internal pure returns (int192) {\n        return int192(uint192(v));\n    }\n\n    function safeCastInt192ToUint96(int192 i192) internal pure returns (uint96) {\n        if (i192 < 0 || i192 > int192(uint192(type(uint96).max))) {\n            revert Int192ToUint96CastOutOfRange(i192);\n        }\n        return uint96(uint192(i192));\n    }\n\n    function safeCastUint256ToInt128(uint256 x)\n        internal\n        pure\n        returns (int128)\n    {\n        if (x > uint256(uint128(type(int128).max))) {\n            revert Uint256ToInt128CastOutOfRangeError(x);\n        }\n        return int128(uint128(x));\n    }\n\n    function safeCastUint256ToUint40(uint256 x)\n        internal\n        pure\n        returns (uint40)\n    {\n        if (x > uint256(type(uint40).max)) {\n            revert Uint256ToUint40CastOutOfRangeError(x);\n        }\n        return uint40(x);\n    }\n}\n"
    },
    "contracts/utils/LibSafeERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../tokens/IERC721.sol\";\nimport \"./LibRawResult.sol\";\n\nlibrary LibSafeERC721 {\n    using LibRawResult for bytes;\n\n    // Call `IERC721.ownerOf()` without reverting and return `address(0)` if:\n    // - `tokenID` does not exist.\n    // - `token` is an EOA\n    // - `token` is an empty contract\n    // - `token` is a \"bad\" implementation of ERC721 that returns nothing for\n    //   `ownerOf()`\n    function safeOwnerOf(IERC721 token, uint256 tokenId)\n        internal\n        view\n        returns (address owner)\n    {\n        (bool s, bytes memory r) = address(token).staticcall(\n            abi.encodeCall(token.ownerOf, (tokenId))\n        );\n\n        if (!s || r.length < 32) {\n            return address(0);\n        }\n\n        return abi.decode(r, (address));\n    }\n}\n"
    },
    "contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"../utils/LibRawResult.sol\";\n\nabstract contract Multicall {\n    using LibRawResult for bytes;\n\n    /// @notice Perform multiple delegatecalls on ourselves.\n    function multicall(bytes[] calldata multicallData) external {\n        for (uint256 i; i < multicallData.length; ++i) {\n            (bool s, bytes memory r) = address(this).delegatecall(multicallData[i]);\n            if (!s) {\n                r.rawRevert();\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./LibRawResult.sol\";\nimport \"./Implementation.sol\";\n\n/// @notice Base class for all proxy contracts.\ncontract Proxy {\n    using LibRawResult for bytes;\n\n    /// @notice The address of the implementation contract used by this proxy.\n    Implementation public immutable IMPL;\n\n    // Made `payable` to allow initialized crowdfunds to receive ETH as an\n    // initial contribution.\n    constructor(Implementation impl, bytes memory initCallData) payable {\n        IMPL = impl;\n        (bool s, bytes memory r) = address(impl).delegatecall(initCallData);\n        if (!s) {\n            r.rawRevert();\n        }\n    }\n\n    // Forward all calls to the implementation.\n    fallback() external payable {\n        Implementation impl = IMPL;\n        assembly {\n            calldatacopy(0x00, 0x00, calldatasize())\n            let s := delegatecall(gas(), impl, 0x00, calldatasize(), 0x00, 0)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(s) {\n                revert(0x00, returndatasize())\n            }\n            return(0x00, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/utils/ReadOnlyDelegateCall.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./LibRawResult.sol\";\n\ninterface IReadOnlyDelegateCall {\n    // Marked `view` so that `_readOnlyDelegateCall` can be `view` as well.\n    function delegateCallAndRevert(address impl, bytes memory callData)\n        external\n        view;\n}\n\n// Inherited by contracts to perform read-only delegate calls.\nabstract contract ReadOnlyDelegateCall {\n    using LibRawResult for bytes;\n\n    // Delegatecall into implement and revert with the raw result.\n    function delegateCallAndRevert(address impl, bytes memory callData) external {\n        // Attempt to gate to only `_readOnlyDelegateCall()` invocations.\n        require(msg.sender == address(this));\n        (bool s, bytes memory r) = impl.delegatecall(callData);\n        // Revert with success status and return data.\n        abi.encode(s, r).rawRevert();\n    }\n\n    // Perform a `delegateCallAndRevert()` then return the raw result data.\n    function _readOnlyDelegateCall(address impl, bytes memory callData) internal view {\n        try IReadOnlyDelegateCall(address(this)).delegateCallAndRevert(impl, callData) {\n            // Should never happen.\n            assert(false);\n        }\n        catch (bytes memory r) {\n            (bool success, bytes memory resultData) = abi.decode(r, (bool, bytes));\n            if (!success) {\n                resultData.rawRevert();\n            }\n            resultData.rawReturn();\n        }\n    }\n}\n"
    },
    "contracts/vendor/solmate/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Based on solmate commit 1681dc505f4897ef636f0435d01b1aa027fdafaf (v6.4.0)\n//  @ https://github.com/Rari-Capital/solmate/blob/1681dc505f4897ef636f0435d01b1aa027fdafaf/src/tokens/ERC1155.sol\n// Only modified to inherit IERC1155 and rename ERC1155TokenReceiver -> ERC1155TokenReceiverBase.\npragma solidity ^0.8;\n\nimport \"../../tokens/IERC1155.sol\";\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 is IERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiverBase(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiverBase.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiverBase(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiverBase.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiverBase(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiverBase.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiverBase(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiverBase.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiverBase {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiverBase.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiverBase.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "contracts/vendor/solmate/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Based on solmate commit 1681dc505f4897ef636f0435d01b1aa027fdafaf (v6.4.0)\n//  @ https://github.com/Rari-Capital/solmate/blob/1681dc505f4897ef636f0435d01b1aa027fdafaf/src/tokens/ERC1155.sol\n// Only modified to inherit IERC721 and EIP165.\npragma solidity >=0.8.0;\n\n// NOTE: Only modified to inherit IERC20 and EIP165\nimport \"../../tokens/IERC721.sol\";\nimport \"../../utils/EIP165.sol\";\n\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 is IERC721, EIP165 {\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public /* view */ virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n        // NOTE: modified from original to call super.\n        return super.supportsInterface(interfaceId) ||\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/solmate/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\n\n    /*//////////////////////////////////////////////////////////////\n                               WRITE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function write(bytes memory data) internal returns (address pointer) {\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n        bytes memory runtimeCode = abi.encodePacked(hex\"00\", data);\n\n        bytes memory creationCode = abi.encodePacked(\n            //---------------------------------------------------------------------------------------------------------------//\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\n            //---------------------------------------------------------------------------------------------------------------//\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\n            //---------------------------------------------------------------------------------------------------------------//\n            hex\"60_0B_59_81_38_03_80_92_59_39_F3\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\n        );\n\n        assembly {\n            // Deploy a new contract with the generated creation code.\n            // We start 32 bytes into the code to avoid copying the byte length.\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\n        }\n\n        require(pointer != address(0), \"DEPLOYMENT_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               READ LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function read(address pointer) internal view returns (bytes memory) {\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\n    }\n\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n\n        return readBytecode(pointer, start, pointer.code.length - start);\n    }\n\n    function read(\n        address pointer,\n        uint256 start,\n        uint256 end\n    ) internal view returns (bytes memory) {\n        start += DATA_OFFSET;\n        end += DATA_OFFSET;\n\n        require(pointer.code.length >= end, \"OUT_OF_BOUNDS\");\n\n        return readBytecode(pointer, start, end - start);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function readBytecode(\n        address pointer,\n        uint256 start,\n        uint256 size\n    ) private view returns (bytes memory data) {\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), start, size)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/solmate/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}