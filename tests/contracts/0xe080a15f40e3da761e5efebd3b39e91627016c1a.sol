{{
  "language": "Solidity",
  "sources": {
    "src/BBOTS.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.13;\n\nimport {IERC165} from \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport {IERC2981} from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport {CantBeEvil, LicenseVersion} from \"@a16z/contracts/licenses/CantBeEvil.sol\";\n\nimport {ERC721Checkpointable} from \"src/base/ERC721Checkpointable.sol\";\nimport {IBBOTSRenderer} from \"src/interface/BBOTSRenderer.interface.sol\";\nimport {IBBOTS, MintPhase, Ticket} from \"src/interface/BBOTS.interface.sol\";\nimport {ExternalRenderer} from \"src/metadata/ExternalRenderer.sol\";\n\n//_/\\\\\\\\\\\\\\\\\\\\\\\\\\__________________/\\\\\\\\\\\\\\\\\\\\\\\\\\_________/\\\\\\\\\\_______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\___\n//_\\/\\\\\\/////////\\\\\\_______________\\/\\\\\\/////////\\\\\\_____/\\\\\\///\\\\\\____\\///////\\\\\\/////____/\\\\\\/////////\\\\\\_\n// _\\/\\\\\\_______\\/\\\\\\_______________\\/\\\\\\_______\\/\\\\\\___/\\\\\\/__\\///\\\\\\________\\/\\\\\\________\\//\\\\\\______\\///__\n//  _\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\___/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\___/\\\\\\______\\//\\\\\\_______\\/\\\\\\_________\\////\\\\\\_________\n//   _\\/\\\\\\/////////\\\\\\_\\///////////__\\/\\\\\\/////////\\\\\\_\\/\\\\\\_______\\/\\\\\\_______\\/\\\\\\____________\\////\\\\\\______\n//    _\\/\\\\\\_______\\/\\\\\\_______________\\/\\\\\\_______\\/\\\\\\_\\//\\\\\\______/\\\\\\________\\/\\\\\\_______________\\////\\\\\\___\n//     _\\/\\\\\\_______\\/\\\\\\_______________\\/\\\\\\_______\\/\\\\\\__\\///\\\\\\__/\\\\\\__________\\/\\\\\\________/\\\\\\______\\//\\\\\\__\n//      _\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/________________\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/_____\\///\\\\\\\\\\/___________\\/\\\\\\_______\\///\\\\\\\\\\\\\\\\\\\\\\/___\n//       _\\/////////////__________________\\/////////////_________\\/////_____________\\///__________\\///////////_____\n\n/// @title B-BOTS: CC0 Media Model\n/// @author ghard.eth\ncontract BBOTS is\n    IBBOTS,\n    ERC721Checkpointable,\n    Ownable,\n    ExternalRenderer,\n    CantBeEvil\n{\n    /*///////////////////////////////////////////////////////////////\n                            MINT STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /** Total supply that can ever be minted */\n    uint256 public immutable MAX_SUPPLY;\n    /** Cost to mint (not applicable to admin) */\n    uint256 public immutable MINT_COST;\n    /** Max per address that can be minted (not applicable to admin) */\n    uint256 public MAX_PER_ADDRESS;\n    /** Total supply that is available to mint currently (not applicable to admin) */\n    uint256 public AVAILABLE_SUPPLY;\n    /** Next tokenId to be minted */\n    uint256 public nextId;\n\n    bytes32 public constant TICKET_TYPEHASH =\n        keccak256(\"Ticket(address buyer)\");\n\n    mapping(address => uint256) public numMinted;\n\n    MintPhase public mintPhase = MintPhase.Locked;\n    address public gatekeeper;\n\n    /*///////////////////////////////////////////////////////////////\n                              ROYALTIES\n    //////////////////////////////////////////////////////////////*/\n\n    address recipient;\n    uint256 royaltyBps;\n\n    constructor(\n        IBBOTSRenderer _renderer,\n        address _gatekeeper,\n        address _recipient,\n        uint256 _royaltyBps,\n        uint256 _maxSupply,\n        uint256 _maxPerAddress,\n        uint256 _availableSupply,\n        uint256 _mintCost,\n        string memory _name,\n        string memory _symbol\n    )\n        ERC721Checkpointable(_name, _symbol)\n        ExternalRenderer(_renderer)\n        CantBeEvil(LicenseVersion.CBE_CC0)\n    {\n        gatekeeper = _gatekeeper;\n\n        recipient = _recipient;\n        royaltyBps = _royaltyBps;\n\n        if (_availableSupply > _maxSupply) revert InvalidAvailableSupply();\n\n        MAX_SUPPLY = _maxSupply;\n        MAX_PER_ADDRESS = _maxPerAddress;\n        AVAILABLE_SUPPLY = _availableSupply;\n        MINT_COST = _mintCost;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        \t\tMINTING\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev validates payment exceeds minting costs\n    modifier validatePayment(uint256 _amt) {\n        if (msg.value != _amt * MINT_COST) revert InvalidPayment();\n        _;\n    }\n\n    /// @dev validates that contract is in the expected phase\n    modifier validatePhase(MintPhase _expected) {\n        if (mintPhase != _expected) revert InvalidMintPhase();\n        _;\n    }\n\n    /// @dev validates that call wont exceed available supply\n    modifier validateAvailableSupply(uint256 _amt) {\n        if (nextId + _amt > AVAILABLE_SUPPLY) revert AvailableSupplyExceeded();\n        _;\n    }\n\n    /// @dev validates that call wont exceed total supply\n    modifier validateTotalSupply(uint256 _amt) {\n        if (nextId + _amt > MAX_SUPPLY) revert TotalSupplyExceeded();\n        _;\n    }\n\n    /// @dev validates address cant mint more than MAX_PER_ADDRESS\n    modifier validateAddressSupply(uint256 _amt) {\n        numMinted[msg.sender] += _amt;\n        if (numMinted[msg.sender] > MAX_PER_ADDRESS) revert MaxMintsExceeded();\n        _;\n    }\n\n    /// @dev validates that the ticket was signed by the gatekeeper for the caller\n    modifier validateTicket(Ticket calldata _ticket) {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(abi.encode(TICKET_TYPEHASH, msg.sender));\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n\n        address signatory = ecrecover(digest, _ticket.v, _ticket.r, _ticket.s);\n\n        if (signatory != gatekeeper) revert InvalidTicket();\n        _;\n    }\n\n    /**\n     * @notice Sets the phase which allows who can mint\n     * @dev Only callable by owner\n     */\n    function setMintPhase(MintPhase _phase) external onlyOwner {\n        mintPhase = _phase;\n\n        emit MintPhaseSet(_phase);\n    }\n\n    /**\n     * @notice Sets supply available for public and allowlist minting\n     * @dev only callable by owner\n     */\n    function setAvailableSupply(uint256 _amt) external onlyOwner {\n        // Available supply can never be more than max supply\n        if (_amt > MAX_SUPPLY) revert InvalidAvailableSupply();\n        // Available supply can never be less than current supply\n        if (_amt < nextId) revert InvalidAvailableSupply();\n\n        AVAILABLE_SUPPLY = _amt;\n        emit AvailableSupplySet(_amt);\n    }\n\n    /**\n     * @notice Sets how many can be minted per address\n     * @dev only callable by owner\n     */\n    function setMaxPerAddress(uint256 _amt) external onlyOwner {\n        MAX_PER_ADDRESS = _amt;\n        emit MaxPerAddressSet(_amt);\n    }\n\n    /**\n     * @notice Allows owner to mint directly `_amt` of B-BOTS to `_to`. Cant exceed total supply.\n     * @dev Only callable by owner\n     */\n    function mintTo(address _to, uint256 _amt) external onlyOwner {\n        _processMint(_to, _amt);\n    }\n\n    /**\n     * @notice Allows an address on the allowlist to mint with a signed ticket.\n     * @dev To be called during the allowlist minting phase\n     */\n    function mint(uint256 _amt, Ticket calldata _ticket)\n        external\n        payable\n        validatePayment(_amt)\n        validatePhase(MintPhase.Allow)\n        validateTicket(_ticket)\n        validateAddressSupply(_amt)\n        validateAvailableSupply(_amt)\n    {\n        _processMint(msg.sender, _amt);\n    }\n\n    /**\n     * @notice Allows anyone to mint up to `MAX_PER_ADDRESS`.\n     * @dev To be called during the public minting phase\n     */\n    function mint(uint256 _amt)\n        external\n        payable\n        validatePayment(_amt)\n        validatePhase(MintPhase.Public)\n        validateAddressSupply(_amt)\n        validateAvailableSupply(_amt)\n    {\n        _processMint(msg.sender, _amt);\n    }\n\n    /// @dev validate total supply and call internal mint function\n    function _processMint(address _to, uint256 _amt)\n        internal\n        validateTotalSupply(_amt)\n    {\n        for (uint256 i; i < _amt; i++) {\n            // Assume minter can receive to save gas\n            _mint(_to, nextId);\n            nextId++;\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        \t\tROYALTIES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev returns royalty info according to EIP-2981 standard\n    function royaltyInfo(uint256, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        return (recipient, (salePrice * royaltyBps) / 10_000);\n    }\n\n    function updateRoyaltyRecipient(address _recipient) external onlyOwner {\n        recipient = _recipient;\n    }\n\n    /// @dev send funds to recipient\n    function sweep() external {\n        (bool success, ) = recipient.call{\n            value: address(this).balance\n        }(new bytes(0));\n        require(success);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        \t   METADATA\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Get the metadata address for token `_id`. Will be updated after the reveal of each tranche\n     */\n    function tokenURI(uint256 id)\n        public\n        view\n        override\n        returns (string memory metadataUri)\n    {\n        return renderer.tokenURI(id);\n    }\n\n    function updateMetadataRenderer(address _renderer)\n        external\n        override\n        onlyOwner\n    {\n        _updateMetadataRenderer(_renderer);\n    }\n\n    function lockMetadata() external override onlyOwner {\n        _lockMetadata();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                UTILS\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(IERC165, ERC721, CantBeEvil)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC2981).interfaceId ||\n            ERC721.supportsInterface(interfaceId) ||\n            CantBeEvil.supportsInterface(interfaceId) ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "lib/a16z-contracts/contracts/licenses/CantBeEvil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// a16z Contracts v0.0.1 (CantBeEvil.sol)\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./ICantBeEvil.sol\";\n\nenum LicenseVersion {\n    CBE_CC0,\n    CBE_ECR,\n    CBE_NECR,\n    CBE_NECR_HS,\n    CBE_PR,\n    CBE_PR_HS\n}\n\ncontract CantBeEvil is ERC165, ICantBeEvil {\n    using Strings for uint;\n    string internal constant _BASE_LICENSE_URI = \"ar://_D9kN1WrNWbCq55BSAGRbTB4bS3v8QAPTYmBThSbX3A/\";\n    LicenseVersion public licenseVersion; // return string\n    constructor(LicenseVersion _licenseVersion) {\n        licenseVersion = _licenseVersion;\n    }\n\n    function getLicenseURI() public view returns (string memory) {\n        return string.concat(_BASE_LICENSE_URI, uint(licenseVersion).toString());\n    }\n\n    function getLicenseName() public view returns (string memory) {\n        return _getLicenseVersionKeyByValue(licenseVersion);\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {\n        return\n            interfaceId == type(ICantBeEvil).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _getLicenseVersionKeyByValue(LicenseVersion _licenseVersion) internal pure returns (string memory) {\n        require(uint8(_licenseVersion) <= 6);\n        if (LicenseVersion.CBE_CC0 == _licenseVersion) return \"CBE_CC0\";\n        if (LicenseVersion.CBE_ECR == _licenseVersion) return \"CBE_ECR\";\n        if (LicenseVersion.CBE_NECR == _licenseVersion) return \"CBE_NECR\";\n        if (LicenseVersion.CBE_NECR_HS == _licenseVersion) return \"CBE_NECR_HS\";\n        if (LicenseVersion.CBE_PR == _licenseVersion) return \"CBE_PR\";\n        else return \"CBE_PR_HS\";\n    }\n}\n"
    },
    "src/base/ERC721Checkpointable.sol": {
      "content": "//SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.13;\n\nimport {ERC721} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\n/// @notice This is port of the Nouns ERC721Checkpointable.sol using solmate as a base. For licensing information please check original implementation:\n/// @notice https://github.com/nounsDAO/nouns-monorepo/blob/1.0.0/packages/nouns-contracts/contracts/base/ERC721Checkpointable.sol\nabstract contract ERC721Checkpointable is ERC721 {\n    /// @notice Defines decimals as per ERC-20 convention to make integrations with 3rd party governance platforms easier\n    uint8 public constant decimals = 0;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) private _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH =\n        keccak256(\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    constructor(string memory _name, string memory _symbol)\n        ERC721(_name, _symbol)\n    {}\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public override {\n        _beforeTokenTransfer(from, to, id);\n        super.transferFrom(from, to, id);\n    }\n\n    function _mint(address to, uint256 id) internal virtual override {\n        _beforeTokenTransfer(address(0), to, id);\n        super._mint(to, id);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 id\n    ) internal virtual {\n        /// @notice Differs from `_transferTokens()` to use `delegates` override method to simulate auto-delegation\n        _moveDelegates(delegates(from), delegates(to), 1);\n    }\n\n    /**\n     * @notice The votes a delegator can delegate, which is the current balance of the delegator.\n     * @dev Used when calling `_delegate()`\n     */\n    function votesToDelegate(address delegator) public view returns (uint96) {\n        return\n            safe96(\n                balanceOf(delegator),\n                \"ERC721Checkpointable::votesToDelegate: amount exceeds 96 bits\"\n            );\n    }\n\n    /**\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\n     * the delegator's own address if they haven't delegated.\n     * This avoids having to delegate to oneself.\n     */\n    function delegates(address delegator) public view returns (address) {\n        address current = _delegates[delegator];\n        return current == address(0) ? delegator : current;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        if (delegatee == address(0)) delegatee = msg.sender;\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        address signatory = ecrecover(digest, v, r, s);\n        require(\n            signatory != address(0),\n            \"ERC721Checkpointable::delegateBySig: invalid signature\"\n        );\n        require(\n            nonce == nonces[signatory]++,\n            \"ERC721Checkpointable::delegateBySig: invalid nonce\"\n        );\n        require(\n            block.timestamp <= expiry,\n            \"ERC721Checkpointable::delegateBySig: signature expired\"\n        );\n\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return\n            nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber)\n        public\n        view\n        returns (uint96)\n    {\n        require(\n            blockNumber < block.number,\n            \"ERC721Checkpointable::getPriorVotes: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n        address currentDelegate = delegates(delegator);\n\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        uint96 amount = votesToDelegate(delegator);\n\n        _moveDelegates(currentDelegate, delegatee, amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0\n                    ? checkpoints[srcRep][srcRepNum - 1].votes\n                    : 0;\n                uint96 srcRepNew = sub96(\n                    srcRepOld,\n                    amount,\n                    \"ERC721Checkpointable::_moveDelegates: amount underflows\"\n                );\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0\n                    ? checkpoints[dstRep][dstRepNum - 1].votes\n                    : 0;\n                uint96 dstRepNew = add96(\n                    dstRepOld,\n                    amount,\n                    \"ERC721Checkpointable::_moveDelegates: amount overflows\"\n                );\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(\n            block.number,\n            \"ERC721Checkpointable::_writeCheckpoint: block number exceeds 32 bits\"\n        );\n\n        if (\n            nCheckpoints > 0 &&\n            checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber\n        ) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(\n                blockNumber,\n                newVotes\n            );\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint96)\n    {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal view returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "src/interface/BBOTSRenderer.interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {BBOTSRendererEvents} from \"./BBOTSRenderer.events.sol\";\nimport {IMetadataRenderer} from \"./MetadataRenderer.interface.sol\";\n\ninterface IBBOTSRenderer is BBOTSRendererEvents, IMetadataRenderer {\n    error TooMuchEntropy();\n\n    /*///////////////////////////////////////////////////////////////\n                        \t   RANDOMNESS\n    //////////////////////////////////////////////////////////////*/\n\n    function requestEntropy(bytes32 _keyHash, uint32 _callbackGasLimit)\n        external;\n}\n"
    },
    "src/interface/BBOTS.interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IERC2981} from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {BBOTSEvents, MintPhase, Ticket} from \"./BBOTS.events.sol\";\n\ninterface IBBOTS is IERC2981, BBOTSEvents {\n    /*///////////////////////////////////////////////////////////////\n                            ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    error InvalidMintPhase();\n    error InvalidPayment();\n    error InvalidTicket();\n    error TotalSupplyExceeded();\n    error AvailableSupplyExceeded();\n    error MaxMintsExceeded();\n    error InvalidAvailableSupply();\n\n    /*///////////////////////////////////////////////////////////////\n                        \tMINTING\n    //////////////////////////////////////////////////////////////*/\n\n    function setMintPhase(MintPhase _phase) external;\n\n    function mintTo(address _to, uint256 _amt) external;\n\n    function mint(uint256 _amt, Ticket calldata _ticket) external payable;\n\n    function mint(uint256 _amt) external payable;\n\n    /*///////////////////////////////////////////////////////////////\n                        \tUTILS\n    //////////////////////////////////////////////////////////////*/\n\n    function updateMetadataRenderer(address _renderer) external;\n\n    function lockMetadata() external;\n\n    function sweep() external;\n}\n"
    },
    "src/metadata/ExternalRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IMetadataRenderer} from \"../interface/MetadataRenderer.interface.sol\";\n\ncontract ExternalRenderer {\n    error MetadataLocked();\n\n    IMetadataRenderer public renderer;\n    bool public metadataLocked;\n\n    constructor(IMetadataRenderer _renderer) {\n        renderer = _renderer;\n    }\n\n    modifier requireMetadataUnlocked() {\n        if (metadataLocked) revert MetadataLocked();\n        _;\n    }\n\n    function _updateMetadataRenderer(address _renderer)\n        internal\n        virtual\n        requireMetadataUnlocked\n    {\n        renderer = IMetadataRenderer(_renderer);\n    }\n\n    function _lockMetadata() internal virtual requireMetadataUnlocked {\n        metadataLocked = true;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/a16z-contracts/contracts/licenses/ICantBeEvil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// a16z Contracts v0.0.1 (ICantBeEvil.sol)\npragma solidity ^0.8.13;\n\ninterface ICantBeEvil {\n    function getLicenseURI() external view returns (string memory);\n    function getLicenseName() external view returns (string memory);\n}"
    },
    "src/interface/BBOTSRenderer.events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface BBOTSRendererEvents {\n    event EntropyRequested();\n    event EntropyReceived(uint256 entropy);\n}\n"
    },
    "src/interface/MetadataRenderer.interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IMetadataRenderer {\n    /*///////////////////////////////////////////////////////////////\n                        \t   RENDERING\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(uint256 id) external view returns (string memory);\n}\n"
    },
    "src/interface/BBOTS.events.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.13;\n\nenum MintPhase {\n    Locked,\n    Allow,\n    Public\n}\n\nstruct Ticket {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface BBOTSEvents {\n    /*///////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event MintPhaseSet(MintPhase phase);\n    event AvailableSupplySet(uint256 amt);\n    event MaxPerAddressSet(uint256 amt);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@a16z/=lib/a16z-contracts/",
      "@chainlink/=lib/chainlink/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@rari-capital/solmate/=lib/solmate/",
      "a16z-contracts/=lib/a16z-contracts/",
      "chainlink/=lib/chainlink/contracts/src/v0.8/dev/vendor/@arbitrum/nitro-contracts/src/",
      "ds-test/=lib/solmate/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1337
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}