{{
  "language": "Solidity",
  "sources": {
    "contracts/gALCX.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\n\nimport {IALCXSource} from \"./interfaces/IALCXSource.sol\";\n\n/// @title A wrapper for single-sided ALCX staking\ncontract gALCX is ERC20 {\n\n    IERC20 public alcx = IERC20(0xdBdb4d16EdA451D0503b854CF79D55697F90c8DF);\n    IALCXSource public pools = IALCXSource(0xAB8e74017a8Cc7c15FFcCd726603790d26d7DeCa);\n    uint public poolId = 1;\n    uint public constant exchangeRatePrecision = 1e18;\n    uint public exchangeRate = exchangeRatePrecision;\n    address public owner;\n\n    event ExchangeRateChange(uint _exchangeRate);\n    event Stake(address _from, uint _gAmount, uint _amount);\n    event Unstake(address _from, uint _gAmount, uint _amount);\n\n    /// @param _name The token name\n    /// @param _symbol The token symbol\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol, 18) {\n        owner = msg.sender;\n        reApprove();\n    }\n\n    // OWNERSHIP\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /// @notice Transfer contract ownership\n    /// @param _owner The new owner address\n    function transferOwnership(address _owner) external onlyOwner {\n        owner = _owner;\n    }\n\n    /// @notice Set a new staking pool address and migrate funds there\n    /// @param _pools The new pool address\n    /// @param _poolId The new pool id\n    function migrateSource(address _pools, uint _poolId) external onlyOwner {\n        // Withdraw ALCX\n        bumpExchangeRate();\n\n        uint poolBalance = pools.getStakeTotalDeposited(address(this), poolId);\n        pools.withdraw(poolId, poolBalance);\n        // Update staking pool address and id\n        pools = IALCXSource(_pools);\n        poolId = _poolId;\n        // Deposit ALCX\n        uint balance = alcx.balanceOf(address(this));\n        reApprove();\n        pools.deposit(poolId, balance);\n    }\n\n    /// @notice Approve the staking pool to move funds in this address, can be called by anyone\n    function reApprove() public {\n        bool success = alcx.approve(address(pools), type(uint).max);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Claim and autocompound rewards\n    function bumpExchangeRate() public {\n        // Claim from pool\n        pools.claim(poolId);\n        // Bump exchange rate\n        uint balance = alcx.balanceOf(address(this));\n\n        if (balance > 0) {\n            exchangeRate += (balance * exchangeRatePrecision) / totalSupply;\n            emit ExchangeRateChange(exchangeRate);\n            // Restake\n            pools.deposit(poolId, balance);\n        }\n    }\n\n    /// @notice Deposit new funds into the staking pool\n    /// @param amount The amount of ALCX to deposit\n    function stake(uint amount) external {\n        // Get current exchange rate between ALCX and gALCX\n        bumpExchangeRate();\n        // Then receive new deposits\n        bool success = alcx.transferFrom(msg.sender, address(this), amount);\n        require(success, \"Transfer failed\");\n        pools.deposit(poolId, amount);\n        // gAmount always <= amount\n        uint gAmount = amount * exchangeRatePrecision / exchangeRate;\n        _mint(msg.sender, gAmount);\n        emit Stake(msg.sender, gAmount, amount);\n    }\n\n    /// @notice Withdraw funds from the staking pool\n    /// @param gAmount the amount of gALCX to withdraw\n    function unstake(uint gAmount) external {\n        bumpExchangeRate();\n        uint amount = gAmount * exchangeRate / exchangeRatePrecision;\n        _burn(msg.sender, gAmount);\n        // Withdraw ALCX and send to user\n        pools.withdraw(poolId, amount);\n        bool success = alcx.transfer(msg.sender, amount); // Should return true or revert, but doesn't hurt\n        require(success, \"Transfer failed\"); \n        emit Unstake(msg.sender, gAmount, amount);\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "contracts/interfaces/IALCXSource.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.11;\n\ninterface IALCXSource {\n    function getStakeTotalDeposited(address _user, uint256 _poolId) external view returns (uint256);\n    function claim(uint256 _poolId) external;\n    function deposit(uint256 _poolId, uint256 _depositAmount) external;\n    function withdraw(uint256 _poolId, uint256 _withdrawAmount) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}}