{{
  "language": "Solidity",
  "sources": {
    "contracts/GachaDraw.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.15;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./IAnimeMetaverseTicket.sol\";\nimport \"./IAnimeMetaverseReward.sol\";\n\n/// @notice Should have sufficient reward for gacha activity\n/// @dev Use this custom error on revert function whenever there is insufficiant reward\nerror InsufficientReward();\n\n/// @notice Should provide a valid activity Id for any gacha activity\n/// @dev Use this custom error on revert function whenever invalid activity Id\nerror InvalidActivity();\n\n/// @notice Should provide a valid activity type either FREE_ACTIVITY_TYPE or PREMIUM_ACTIVITY_TYPE\n/// @dev Use this custom error on revert function whenever the activity type is not valid\nerror InvalidActivityType();\n\n/// @notice Should draw ticket for a active gacha activity\n/// @dev Use this custom error on revert function the activity is not active\nerror InactiveActivity();\n\n/// @notice Should draw ticket for a active gacha activity\n/// @dev Use this custom error on revert function draw is out of event timestamp\nerror ActivityTimestampError();\n\n/// @notice Should input valid address other than 0x0\n/// @dev Use this custom error on revert function whenever validating address\nerror InvalidAddress();\n\n/// @notice Should provide valid timestamp\n/// @dev Use this custom error on revert function whenever there is invalid timestamp\nerror InvalidTimestamp();\n\n/// @notice Should provide valid amount of ticket\n/// @dev Use this custom error on revert function whenever there is invalid amount of ticket\nerror InsufficientTicket();\n\n/// @notice Should provide valid array length as input\n/// @dev Use this custom error on revert function whenever the array length does not match\nerror InvalidInputLength();\n\n/// @notice Should provide valid input\n/// @dev Use this custom error with message on revert function whenever the input is not valid\nerror InvalidInput(string message);\n\ncontract GachaDraw is Ownable {\n    /// @notice Emit when a new activity is created\n    /// @dev Emeits in createActivity method\n    /// @param _activityId New activity Id\n    /// @param _startTimestamp Activity starting timestamp\n    /// @param _endTimestamp Activity end timestamp\n    /// @param _rewardTokenSupply Maximumreward supply for this activity\n    event ActivityCreated(\n        uint256 _activityId,\n        uint256 _startTimestamp,\n        uint256 _endTimestamp,\n        uint256[] _rewardTokenSupply\n    );\n\n    /// @notice Emit a gacha draw is completed\n    /// @dev Emeits in drawTicket function\n    /// @param _activityId Gacha activity Id\n    /// @param _walletAddress Activity event Id\n    /// @param _ticketType Used ticket type\n    /// @param _ticketAmount Amount of ticket used for draw\n    /// @param _drawIndex Gacha draw index\n    event DrawCompleted(\n        uint256 _activityId,\n        address _walletAddress,\n        uint256 _ticketType,\n        uint256 _ticketAmount,\n        uint256 _drawIndex\n    );\n\n    modifier validActivity(uint256 _activityId) {\n        if (_activityId > totalActivities || _activityId < 1) {\n            revert InvalidActivity();\n        }\n        _;\n    }\n\n    modifier validActivityType(uint256 _activitType) {\n        if (\n            !(_activitType == FREE_ACTIVITY_TYPE ||\n                _activitType == PREMIUM_ACTIVITY_TYPE)\n        ) {\n            revert InvalidActivityType();\n        }\n        _;\n    }\n\n    modifier validAddress(address _address) {\n        if (_address == address(0) || _address == address(this)) {\n            revert InvalidAddress();\n        }\n        _;\n    }\n\n    modifier validTimestamp(uint256 _startTimestamp, uint256 _endTimestamp) {\n        if (_endTimestamp <= _startTimestamp) {\n            revert InvalidTimestamp();\n        }\n        _;\n    }\n\n    uint256 public constant FREE_ACTIVITY_TYPE = 1;\n    uint256 public constant PREMIUM_ACTIVITY_TYPE = 2;\n\n    /// @dev Ticket smart contract instance\n    IAnimeMetaverseTicket public TicketContract;\n    /// @dev Reward smart contract instance\n    IAnimeMetaverseReward public RewardContract;\n\n    /// @dev Activity structure for keeping track all activity information\n    struct Activity {\n        uint256 activityId;\n        uint256 startTimestamp;\n        uint256 endTimestamp;\n        uint256 activityType;\n        bool isActive;\n        uint256[] rewardTokenIds;\n        uint256[] totalGivenRewardSupply;\n        uint256[] maximumRewardSupply;\n        uint256 remainingRewardSupply;\n    }\n\n    /// @dev Mapping to store activity information\n    mapping(uint256 => Activity) public activities;\n\n    uint256 public totalActivities;\n    uint256 public totalRewardWon;\n    uint256 public totalCompleteDraws;\n    uint256 public maxRewardTokenId = 18;\n\n    /// @dev Create gacha draw contract instance\n    /// @param _ticketContractAddress Ticket contract address\n    /// @param _rewardContractAddress Reward contract address\n    constructor(address _ticketContractAddress, address _rewardContractAddress)\n    {\n        TicketContract = IAnimeMetaverseTicket(_ticketContractAddress);\n        RewardContract = IAnimeMetaverseReward(_rewardContractAddress);\n    }\n\n    /// @notice Owner only method for updating ticket token contract\n    /// @dev Update ticket contract address\n    /// @param _ticketContractAddress New ticket contract address\n    function setTicketContract(address _ticketContractAddress)\n        external\n        onlyOwner\n        validAddress(_ticketContractAddress)\n    {\n        TicketContract = IAnimeMetaverseTicket(_ticketContractAddress);\n    }\n\n    /// @notice Owner only method for updating max Id range for reward token\n    /// @dev Update max reward tokenId range\n    /// @param _maxRewardTokenId New range for reward tokenId\n    function setMaxRewardTokenId(uint256 _maxRewardTokenId) external onlyOwner {\n        maxRewardTokenId = _maxRewardTokenId;\n    }\n\n    /// @notice Owner only method for updating reward token contract\n    /// @dev Update reward contract address\n    /// @param _rewardContractAddress New reward contract address\n    function setRewardContract(address _rewardContractAddress)\n        external\n        onlyOwner\n        validAddress(_rewardContractAddress)\n    {\n        RewardContract = IAnimeMetaverseReward(_rewardContractAddress);\n    }\n\n    /// @notice Owner only method for creating an activity for gacha draw\n    /// @dev Create a new activity\n    /// @param _startTimestamp Activity starting time\n    /// @param _endTimestamp Activity ending time\n    /// @param _activityType Activity type: free or premium\n    /// @param _rewardTokenIds tokenIds for giving reward\n    /// @param _maxRewardSupply Max supply for each tokenId\n    function createActivity(\n        uint256 _startTimestamp,\n        uint256 _endTimestamp,\n        uint256 _activityType,\n        uint256[] calldata _rewardTokenIds,\n        uint256[] calldata _maxRewardSupply\n    )\n        external\n        onlyOwner\n        validActivityType(_activityType)\n        validTimestamp(_startTimestamp, _endTimestamp)\n    {\n        if (_rewardTokenIds.length != _maxRewardSupply.length) {\n            revert InvalidInputLength();\n        }\n\n        uint256 remainingRewardSupply;\n        for (uint256 index = 0; index < _rewardTokenIds.length; index++) {\n            remainingRewardSupply =\n                remainingRewardSupply +\n                _maxRewardSupply[index];\n            if (\n                _rewardTokenIds[index] > maxRewardTokenId ||\n                _rewardTokenIds[index] < 1\n            ) {\n                revert InvalidInput(\"Invalid reward tokenId.\");\n            }\n        }\n\n        /// @dev validate supply input\n        if (remainingRewardSupply < 1) {\n            revert InsufficientReward();\n        }\n\n        totalActivities++;\n\n        /// @dev Store activity information in map\n        activities[totalActivities] = Activity({\n            activityId: totalActivities,\n            startTimestamp: _startTimestamp,\n            endTimestamp: _endTimestamp,\n            activityType: _activityType,\n            isActive: true,\n            totalGivenRewardSupply: new uint256[](_maxRewardSupply.length),\n            maximumRewardSupply: _maxRewardSupply,\n            remainingRewardSupply: remainingRewardSupply,\n            rewardTokenIds: _rewardTokenIds\n        });\n\n        /// @dev emit event after creating activity\n        emit ActivityCreated(\n            totalActivities,\n            _startTimestamp,\n            _endTimestamp,\n            _maxRewardSupply\n        );\n    }\n\n    /// @notice Owner only method for updating activity status\n    /// @dev Sets activity as active or inactive\n    /// @param _activityId Activity Id for which the status will be updated\n    /// @param _flag Activity status flag\n    function setActivityStatus(uint256 _activityId, bool _flag)\n        external\n        onlyOwner\n        validActivity(_activityId)\n    {\n        activities[_activityId].isActive = _flag;\n    }\n\n    /// @notice Owner only method for updating activity timestamp\n    /// @dev Update new timestamp\n    /// @param _activityId Activity Id for which the timestamp will be updated\n    /// @param _startTimestamp New start timestamp\n    /// @param _endTimestamp New end timestamp\n    function setActivityTimestamp(\n        uint256 _activityId,\n        uint256 _startTimestamp,\n        uint256 _endTimestamp\n    )\n        external\n        onlyOwner\n        validActivity(_activityId)\n        validTimestamp(_startTimestamp, _endTimestamp)\n    {\n        activities[_activityId].startTimestamp = _startTimestamp;\n        activities[_activityId].endTimestamp = _endTimestamp;\n    }\n\n    /// @notice Owner only method for updating max supply for an activity\n    /// @dev Update activity reward supply\n    /// @param _activityId Selected activity\n    /// @param _maxRewardSupply Max supply for each tokenId\n    function updateMaximumRewardSupply(\n        uint256 _activityId,\n        uint256[] calldata _maxRewardSupply\n    ) external onlyOwner validActivity(_activityId) {\n        if (\n            _maxRewardSupply.length !=\n            activities[_activityId].rewardTokenIds.length\n        ) {\n            revert InvalidInputLength();\n        }\n\n        uint256 newMaxRewardSupply;\n        uint256 totalSupplyInCirculation;\n\n        for (uint256 index = 0; index < _maxRewardSupply.length; index++) {\n            if (\n                _maxRewardSupply[index] <\n                activities[_activityId].totalGivenRewardSupply[index]\n            ) {\n                revert InvalidInput(\n                    \"Maximum Supply Can Not Be Lower Than Total Supply.\"\n                );\n            }\n\n            totalSupplyInCirculation += activities[_activityId]\n                .totalGivenRewardSupply[index];\n            newMaxRewardSupply = newMaxRewardSupply + _maxRewardSupply[index];\n            activities[_activityId].maximumRewardSupply[\n                index\n            ] = _maxRewardSupply[index];\n        }\n\n        activities[_activityId].remainingRewardSupply =\n            newMaxRewardSupply -\n            totalSupplyInCirculation;\n    }\n\n    /// @notice External function for gacha draw. It burns tickets and provide rewards\n    /// @dev Randomly choice reward tickets, burn the gacha tickets and then mint the reward for user\n    /// @param _activityId Id of the activity for which users want to draw tickets\n    /// @param _ticketAmount Id of the activity for getting total reward token supply\n    function drawTicket(uint256 _activityId, uint256 _ticketAmount)\n        external\n        validActivity(_activityId)\n    {\n        /// @notice Reverts if the activity is not active\n        /// @dev Validates if the activity is active or not\n        if (!activities[_activityId].isActive) {\n            revert InactiveActivity();\n        }\n\n        /// @notice Reverts if current timestamp is out of range of the activity start and end timestamp\n        /// @dev Validates if the current timestamp is within activity start and end timestamp\n        if (\n            block.timestamp < activities[_activityId].startTimestamp ||\n            block.timestamp > activities[_activityId].endTimestamp\n        ) {\n            revert ActivityTimestampError();\n        }\n\n        if (_ticketAmount < 1) {\n            revert InsufficientTicket();\n        }\n\n        /// @notice Reverts if the rewards supply is not enough\n        /// @dev Validates if there are enough tickets or not\n        if (activities[_activityId].remainingRewardSupply < _ticketAmount) {\n            revert InsufficientReward();\n        }\n\n        /// @dev Burns the tickets\n        TicketContract.burn(\n            activities[_activityId].activityType,\n            msg.sender,\n            _ticketAmount\n        );\n        unchecked {\n            totalCompleteDraws++;\n        }\n\n        /// @dev For each tickets burns the tickets and mint a random reward\n        for (\n            uint256 ticketAmountIndex = 0;\n            ticketAmountIndex < _ticketAmount;\n            ticketAmountIndex = _uncheckedIncOne(ticketAmountIndex)\n        ) {\n            uint256 randomIndex = getRandomNumber(\n                activities[_activityId].remainingRewardSupply\n            );\n\n            uint256 selectedTokenId;\n            uint256 indexCount;\n\n            /// @dev Find out the choosen reward time and increase it's supply\n            for (\n                uint256 rewardTokenIndex = 0;\n                rewardTokenIndex <\n                activities[_activityId].rewardTokenIds.length;\n                rewardTokenIndex = _uncheckedIncOne(rewardTokenIndex)\n            ) {\n                uint256 toBeMintedId = activities[_activityId]\n                    .maximumRewardSupply[rewardTokenIndex] -\n                    activities[_activityId].totalGivenRewardSupply[\n                        rewardTokenIndex\n                    ];\n                indexCount = _uncheckedIncDelta(indexCount, toBeMintedId);\n                if (toBeMintedId > 0 && indexCount >= randomIndex) {\n                    selectedTokenId = activities[_activityId].rewardTokenIds[\n                        rewardTokenIndex\n                    ];\n                    activities[_activityId].totalGivenRewardSupply[rewardTokenIndex] = \n                    _uncheckedIncOne(\n                        activities[_activityId].totalGivenRewardSupply[rewardTokenIndex]\n                    );\n                    break;\n                }\n            }\n\n            ///@dev Mints one randomly choosen reward ticket\n            RewardContract.mint(\n                ticketAmountIndex + 1,\n                totalCompleteDraws,\n                _activityId,\n                msg.sender,\n                selectedTokenId,\n                1,\n                \"\"\n            );\n\n            unchecked {\n                activities[_activityId].remainingRewardSupply--;\n                totalRewardWon++;\n            }\n        }\n\n        emit DrawCompleted(\n            _activityId,\n            msg.sender,\n            activities[_activityId].activityType,\n            _ticketAmount,\n            totalCompleteDraws\n        );\n    }\n\n    /// @notice Internal function for generating random number\n    /// @dev Generate a randmom number where, 0 <= randomnumber < _moduler\n    /// @param _moduler The range for generating random number\n    function getRandomNumber(uint256 _moduler) internal view returns (uint256) {\n        uint256 seed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp +\n                        block.difficulty +\n                        ((\n                            uint256(keccak256(abi.encodePacked(block.coinbase)))\n                        ) / (block.timestamp)) +\n                        block.gaslimit +\n                        ((uint256(keccak256(abi.encodePacked(msg.sender)))) /\n                            (block.timestamp)) +\n                        block.number +\n                        totalRewardWon\n                )\n            )\n        );\n\n        return (seed - ((seed / _moduler) * _moduler));\n    }\n\n    /// @notice getTotalRewardSupply is a external view method which has no gas fee\n    /// @dev Provides the saved total reward token supply for any activity\n    /// @param _activityId Id of the activity for getting total reward token supply\n    function getTotalRewardSupply(uint256 _activityId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return activities[_activityId].totalGivenRewardSupply;\n    }\n\n    /// @notice getMaximumRewardSupply is a external view method which has no gas fee\n    /// @dev Provides the saved maximum reward token supply for any activity\n    /// @param _activityId Id of the activity for getting maximum reward token supply\n    function getMaximumRewardSupply(uint256 _activityId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return activities[_activityId].maximumRewardSupply;\n    }\n\n    /// @notice getRewardTokenIds is a external view method which has no gas fee\n    /// @dev Provides the saved reward token Ids for any activity\n    /// @param _activityId Id of the activity for getting reward tokenIds\n    function getRewardTokenIds(uint256 _activityId)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return activities[_activityId].rewardTokenIds;\n    }\n\n    /// @dev Unchecked increment function, just to reduce gas usage\n    /// @notice This value can not be greater than 36000 for reward count because we will have maximum 36000 rewards\n    /// @notice For reward tokenId count this value can not be greater that 18\n    /// @param val value to be incremented by 1, should not overflow 2**256 - 1\n    /// @return incremented value\n    function _uncheckedIncOne(uint256 val) internal pure returns (uint256) {\n        return _uncheckedIncDelta(val, 1);\n    }\n\n    /// @dev Unchecked increment function, just to reduce gas usage\n    /// @notice This value can not be greater than 36000 for reward count because we will have maximum 36000 rewards\n    /// @notice For reward tokenId count this value can not be greater that 18\n    /// @param val value to be incremented by delta, ensure that it should not overflow 2**256 - 1 before calling this function\n    /// @return incremented value\n    function _uncheckedIncDelta(uint256 val, uint256 delta)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            return val + delta;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/IAnimeMetaverseTicket.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\npragma solidity ^0.8.15;\n\ninterface IAnimeMetaverseTicket {\n    function burn(\n        uint256 tokenId,\n        address _account,\n        uint256 _numberofTickets\n    ) external;\n}"
    },
    "contracts/IAnimeMetaverseReward.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n\npragma solidity ^0.8.15;\n\ninterface IAnimeMetaverseReward {\n    function mintBatch(\n        uint256 ticket,\n        uint256 _drawIndex,\n        uint256 _activityId,\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes memory _data\n    ) external;\n\n    function mint(\n        uint256 ticket,\n        uint256 _drawIndex,\n        uint256 _activityId,\n        address _to,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external;\n\n    function forceBurn(\n        address _account,\n        uint256 _id,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}