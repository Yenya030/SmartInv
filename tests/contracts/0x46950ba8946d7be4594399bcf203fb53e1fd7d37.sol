{{
  "language": "Solidity",
  "sources": {
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/VaultERC20.sol\";\nimport \"src/VaultERC721.sol\";\nimport \"src/VaultETH.sol\";\nimport \"src/VaultExecute.sol\";\nimport \"src/VaultNewReceivers.sol\";\nimport \"src/VaultIssueERC721.sol\";\n\ncontract Vault is\n  VaultERC20,\n  VaultERC721,\n  VaultETH,\n  VaultExecute,\n  VaultNewReceivers,\n  VaultIssueERC721\n{\n  constructor()\n    VaultERC20(1, 2, 11)\n    VaultERC721(3)\n    VaultETH(4, 5)\n    VaultExecute(6, 7)\n    VaultNewReceivers(8)\n    VaultIssueERC721(9)\n    Pausable(10)\n  {}\n}\n"
    },
    "src/commons/Limits.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/commons/Ownable.sol\";\n\n\ncontract Limits is Ownable {\n  error ExceededLimit(uint256 _amount, uint256 _limit);\n\n  uint256 public ERC20Limit;\n\n  event UpdateERC20Limit(uint256 _limit);\n\n  modifier underLimit(uint256 _amount) {\n    if (!isUnderLimit(_amount)) {\n      revert ExceededLimit(_amount, ERC20Limit);\n    }\n\n    _;\n  }\n\n  function isUnderLimit(uint256 _amount) public view returns (bool) {\n    return _amount <= ERC20Limit;\n  }\n\n  function updateERC20Limit(uint256 _limit) external virtual onlyOwner {\n    _updateERC20Limit(_limit);\n  }\n\n  function _updateERC20Limit(uint256 _limit) internal {\n    ERC20Limit = _limit;\n    emit UpdateERC20Limit(_limit);\n  }\n}\n"
    },
    "src/commons/Ownable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/interfaces/IERC173.sol\";\n\ncontract Ownable is IERC173 {\n  error NotOwner(address _sender, address _owner);\n  error InvalidNewOwner();\n\n  address public owner;\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnershipTransferred(address(0), msg.sender);\n  }\n\n  modifier onlyOwner() {\n    if (!isOwner(msg.sender)) revert NotOwner(msg.sender, owner);\n    _;\n  }\n\n  function isOwner(address _owner) public view returns (bool) {\n    return _owner == owner && _owner != address(0);\n  }\n\n  function transferOwnership(address _newOwner) external onlyOwner {\n    if (_newOwner == address(0)) revert InvalidNewOwner();\n\n    owner = _newOwner;\n    emit OwnershipTransferred(msg.sender, _newOwner);\n  }\n\n  function rennounceOwnership() external onlyOwner {\n    owner = address(0);\n    emit OwnershipTransferred(msg.sender, address(0));\n  }\n}\n"
    },
    "src/commons/Pausable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/commons/Ownable.sol\";\nimport \"src/commons/Permissions.sol\";\n\ncontract Pausable is Ownable, Permissions {\n  error ContractPaused();\n\n  event Unpaused(address _sender);\n  event Paused(address _sender);\n\n  enum State { Invalid, Unpaused, Paused }\n\n  State internal _state = State.Unpaused;\n  uint8 public immutable PERMISSION_PAUSE;\n\n  constructor(uint8 _permissionPause) {\n    PERMISSION_PAUSE = _permissionPause;\n  }\n\n  modifier notPaused() {\n    if (_state == State.Paused) {\n      revert ContractPaused();\n    }\n\n    _;\n  }\n\n  function isPaused() public view returns (bool) {\n    return _state == State.Paused;\n  }\n\n  function pause() external onlyPermissioned(PERMISSION_PAUSE) {\n    _state = State.Paused;\n    emit Paused(msg.sender);\n  }\n\n  function unpause() external onlyOwner {\n    _state = State.Unpaused;\n    emit Unpaused(msg.sender);\n  }\n}\n"
    },
    "src/commons/Permissions.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/commons/Ownable.sol\";\n\n\ncontract Permissions is Ownable {\n  error PermissionDenied(address _sender, uint8 _permission);\n  error DuplicatedPermission(uint8 _permission);\n\n  mapping (address => bytes32) public permissions;\n  mapping (uint8 => bool) public permissionExists;\n\n  event AddPermission(address indexed _addr, uint8 _permission);\n  event DelPermission(address indexed _addr, uint8 _permission);\n  event ClearPermissions(address indexed _addr);\n\n  modifier onlyPermissioned(uint8 _permission) {\n    if (!hasPermission(msg.sender, _permission) && !isOwner(msg.sender)) {\n      revert PermissionDenied(msg.sender, _permission);\n    }\n\n    _;\n  }\n\n  function _registerPermission(uint8 _permission) internal {\n    if (permissionExists[_permission]) {\n      revert DuplicatedPermission(_permission);\n    }\n\n    permissionExists[_permission] = true;\n  }\n\n  function hasPermission(address _addr, uint8 _permission) public view returns (bool) {\n    return (permissions[_addr] & _maskForPermission(_permission)) != 0;\n  }\n\n  function addPermission(address _addr, uint8 _permission) external virtual onlyOwner {\n    _addPermission(_addr, _permission);\n  }\n\n  function addPermissions(address _addr, uint8[] calldata _permissions) external virtual onlyOwner {\n    _addPermissions(_addr, _permissions);\n  }\n\n  function delPermission(address _addr, uint8 _permission) external virtual onlyOwner {\n    _delPermission(_addr, _permission);\n  }\n\n  function clearPermissions(address _addr) external virtual onlyOwner {\n    _clearPermissions(_addr);\n  }\n\n  function _maskForPermission(uint8 _permission) internal pure returns (bytes32) {\n    return bytes32(1 << _permission);\n  }\n\n  function _addPermission(address _addr, uint8 _permission) internal {\n    permissions[_addr] |= _maskForPermission(_permission);\n    emit AddPermission(_addr, _permission);\n  }\n\n  function _addPermissions(address _addr, uint8[] calldata _permissions) internal {\n    unchecked {\n      for (uint256 i = 0; i < _permissions.length; ++i) {\n        _addPermission(_addr, _permissions[i]);\n      }\n    }\n  }\n\n  function _delPermission(address _addr, uint8 _permission) internal {\n    permissions[_addr] &= ~_maskForPermission(_permission);\n    emit DelPermission(_addr, _permission);\n  }\n\n  function _clearPermissions(address _addr) internal {\n    delete permissions[_addr];\n    emit ClearPermissions(_addr);\n  }\n}\n"
    },
    "src/commons/receiver/Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/interfaces/IERC721Receiver.sol\";\n\n\ncontract Receiver is IERC721Receiver {\n  error NotAuthorized(address _sender);\n\n  address immutable private owner;\n\n  constructor () {\n    owner = msg.sender;\n  }\n\n  function execute(address payable _to, uint256 _value, bytes calldata _data) external returns (bool, bytes memory) {\n    if (msg.sender != owner) revert NotAuthorized(msg.sender);\n    return _to.call{ value: _value }(_data);\n  }\n\n  function onERC721Received(address, address, uint256, bytes calldata) external pure returns (bytes4) {\n    // return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n    return 0x150b7a02;\n  }\n\n  receive() external payable { }\n  fallback() external payable { }\n}\n"
    },
    "src/commons/receiver/ReceiverHub.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/libs/CREATE2.sol\";\nimport \"src/utils/Proxy.sol\";\n\nimport \"src/commons/receiver/Receiver.sol\";\n\ncontract ReceiverHub {\n  error ReceiverCallError(address _receiver, address _to, uint256 _value, bytes _data, bytes _result);\n  \n  address immutable public receiverTemplate;\n  bytes32 immutable private receiverTemplateCreationCodeHash;\n\n  constructor () {\n    receiverTemplate = address(new Receiver());\n    receiverTemplateCreationCodeHash = keccak256(Proxy.creationCode(address(receiverTemplate)));\n  }\n\n  function receiverFor(uint256 _id) public view returns (Receiver) {\n    return Receiver(CREATE2.addressOf(address(this), _id, receiverTemplateCreationCodeHash));\n  }\n\n  function createReceiver(uint256 _id) internal returns (Receiver) {\n    return Receiver(CREATE2.deploy(_id, Proxy.creationCode(receiverTemplate)));\n  }\n\n  function createIfNeeded(Receiver receiver, uint256 _id) internal returns (Receiver) {\n    uint256 receiverCodeSize; assembly { receiverCodeSize := extcodesize(receiver) }\n    if (receiverCodeSize != 0) {\n      return receiver;\n    }\n\n    return createReceiver(_id);\n  }\n\n  function useReceiver(uint256 _id) internal returns (Receiver) {\n    return createIfNeeded(receiverFor(_id), _id);\n  }\n\n  function executeOnReceiver(uint256 _id, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory) {\n    return executeOnReceiver(useReceiver(_id), _to, _value, _data);\n  }\n\n  function executeOnReceiver(Receiver _receiver, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory) {\n    (bool succeed, bytes memory result) = _receiver.execute(payable(_to), _value, _data);\n    if (!succeed) revert ReceiverCallError(address(_receiver), _to, _value, _data, result);\n\n    return result;\n  }\n}\n"
    },
    "src/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\n\ninterface IERC173 {\n  event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n  function owner() view external returns(address);\n  function transferOwnership(address _newOwner) external;\t\n}\n"
    },
    "src/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\n\ninterface IERC20 {\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address _account) external view returns (uint256);\n  function transfer(address _to, uint256 _amount) external returns (bool);\n  function allowance(address _owner, address _spender) external view returns (uint256);\n  function approve(address _spender, uint256 _amount) external returns (bool);\n  function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\n}\n"
    },
    "src/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\n\ninterface IERC721 {\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  function balanceOf(address _owner) external view returns (uint256);\n  function ownerOf(uint256 _tokenId) external view returns (address);\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n  function approve(address _approved, uint256 _tokenId) external payable;\n  function setApprovalForAll(address _operator, bool _approved) external;\n  function getApproved(uint256 _tokenId) external view returns (address);\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "src/interfaces/IERC721Deterministic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\n\ninterface IERC721Deterministic {\n  function issueToken(address _beneficiary, uint256 _optionId, uint256 _issuedId) external;\n}\n"
    },
    "src/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\n\ninterface IERC721Receiver {\n  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n"
    },
    "src/libs/CREATE2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\n\nlibrary CREATE2 {\n  error ContractNotCreated();\n\n  function addressOf(address _creator, uint256 _salt, bytes32 _creationCodeHash) internal pure returns (address payable) {\n    return payable(\n        address(\n        uint160(\n          uint256(\n            keccak256(\n              abi.encodePacked(\n                bytes1(0xff),\n                _creator,\n                _salt,\n                _creationCodeHash\n              )\n            )\n          )\n        )\n      )\n    );\n  }\n\n  function deploy(uint256 _salt, bytes memory _creationCode) internal returns (address payable _contract) {\n    assembly {\n      _contract := create2(callvalue(), add(_creationCode, 32), mload(_creationCode), _salt)\n    }\n\n    if (_contract == address(0)) {\n      revert ContractNotCreated();\n    }\n  }\n}\n"
    },
    "src/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/*\nThe MIT License (MIT)\nCopyright (c) 2018 Murray Software, LLC.\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n//solhint-disable max-line-length\n//solhint-disable no-inline-assembly\n\nlibrary Proxy {\n  function creationCode(address _target) internal pure returns (bytes memory result) {\n    return abi.encodePacked(\n      hex'3d602d80600a3d3981f3363d3d373d3d3d363d73',\n      _target,\n      hex'5af43d82803e903d91602b57fd5bf3'\n    );\n  }\n}\n"
    },
    "src/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/interfaces/IERC20.sol\";\n\n\nlibrary SafeERC20 {\n  error ErrorSendingERC20(address _token, address _to, uint256 _amount, bytes _result);\n\n  function safeTransfer(IERC20 _token, address _to, uint256 _amount) internal {\n    (bool success, bytes memory result) = address(_token).call(abi.encodeWithSelector(\n      IERC20.transfer.selector,\n      _to,\n      _amount\n    ));\n\n    if (!success || !optionalReturnsTrue(result)) {\n      revert ErrorSendingERC20(address(_token), _to, _amount, result);\n    }\n  }\n\n  function optionalReturnsTrue(bytes memory _return) internal pure returns (bool) {\n    return _return.length == 0 || abi.decode(_return, (bool));\n  }\n}\n"
    },
    "src/VaultERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/interfaces/IERC20.sol\";\n\nimport \"src/commons/receiver/ReceiverHub.sol\";\n\nimport \"src/commons/Limits.sol\";\nimport \"src/commons/Permissions.sol\";\nimport \"src/commons/Pausable.sol\";\n\nimport \"src/utils/SafeERC20.sol\";\n\n\nabstract contract VaultERC20 is ReceiverHub, Limits, Permissions, Pausable {\n  using SafeERC20 for IERC20;\n\n  error ErrorSweepingERC20(address _token, address _receiver, uint256 _amount, bytes _result);\n  error ArrayLengthMismatchERC20(uint256 _array1, uint256 _array2);\n\n  uint8 public immutable PERMISSION_SWEEP_ERC20;\n  uint8 public immutable PERMISSION_SEND_ERC20;\n  uint8 public immutable PERMISSION_SEND_ERC20_LIMIT;\n\n  constructor (uint8 _sweepErc20Permission, uint8 _sendErc20Permission, uint8 _sendErc20LimitPermission) {\n    PERMISSION_SWEEP_ERC20 = _sweepErc20Permission;\n    PERMISSION_SEND_ERC20 = _sendErc20Permission;\n    PERMISSION_SEND_ERC20_LIMIT = _sendErc20LimitPermission;\n\n    _registerPermission(PERMISSION_SWEEP_ERC20);\n    _registerPermission(PERMISSION_SEND_ERC20);\n    _registerPermission(PERMISSION_SEND_ERC20_LIMIT);\n  }\n\n  function sweepERC20(\n    IERC20 _token,\n    uint256 _id\n  ) external notPaused onlyPermissioned(PERMISSION_SWEEP_ERC20) {\n    _sweepERC20(_token, _id);\n  }\n\n  function sweepBatchERC20(\n    IERC20 _token,\n    uint256[] calldata _ids\n  ) external notPaused onlyPermissioned(PERMISSION_SWEEP_ERC20) {\n    unchecked {\n      uint256 idsLength = _ids.length;\n      for (uint256 i = 0; i < idsLength; ++i) {\n        _sweepERC20(_token, _ids[i]);\n      }\n    }\n  }\n\n  function _sweepERC20(\n    IERC20 _token,\n    uint256 _id\n  ) internal {\n    Receiver receiver = receiverFor(_id);\n    uint256 balance = _token.balanceOf(address(receiver));\n\n    if (balance != 0) {\n      createIfNeeded(receiver, _id);\n\n      bytes memory res = executeOnReceiver(receiver, address(_token), 0, abi.encodeWithSelector(\n        IERC20.transfer.selector,\n        address(this),\n        balance\n      ));\n\n      if (!SafeERC20.optionalReturnsTrue(res)) {\n        revert ErrorSweepingERC20(address(_token), address(receiver), balance, res);\n      }\n    }\n  }\n\n  function sendERC20(\n    IERC20 _token,\n    address _to,\n    uint256 _amount\n  ) external notPaused onlyPermissioned(PERMISSION_SEND_ERC20) {\n    _token.safeTransfer(_to, _amount);\n  }\n\n  function sendBatchERC20(\n    IERC20 _token,\n    address[] calldata _to,\n    uint256[] calldata _amounts\n  ) external notPaused onlyPermissioned(PERMISSION_SEND_ERC20) {\n    uint256 toLength = _to.length;\n    if (toLength != _amounts.length) {\n      revert ArrayLengthMismatchERC20(toLength, _amounts.length);\n    }\n\n    unchecked {\n      for (uint256 i = 0; i < toLength; ++i) {\n        _token.safeTransfer(_to[i], _amounts[i]);\n      }\n    }\n  }\n\n  function sendERC20WithLimit(\n    IERC20 _token,\n    address _to,\n    uint256 _amount\n  ) external notPaused onlyPermissioned(PERMISSION_SEND_ERC20_LIMIT) underLimit(_amount) {\n    _token.safeTransfer(_to, _amount);\n  }\n}\n"
    },
    "src/VaultERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/interfaces/IERC721.sol\";\n\nimport \"src/commons/receiver/ReceiverHub.sol\";\nimport \"src/commons/Permissions.sol\";\nimport \"src/commons/Pausable.sol\";\n\nabstract contract VaultERC721 is ReceiverHub, Permissions, Pausable {\n  uint8 public immutable PERMISSION_SEND_ERC721;\n\n  error ArrayLengthMismatchERC721(uint256 _array1, uint256 _array2, uint256 _array3);\n\n  constructor (uint8 _sendErc721Permission) {\n    PERMISSION_SEND_ERC721 = _sendErc721Permission;\n\n    _registerPermission(PERMISSION_SEND_ERC721);\n  }\n\n  function sendERC721(\n    IERC721 _token,\n    uint256 _from,\n    address _to,\n    uint256 _id\n  ) external notPaused onlyPermissioned(PERMISSION_SEND_ERC721) {\n    Receiver receiver = useReceiver(_from);\n\n    executeOnReceiver(receiver, address(_token), 0, abi.encodeWithSelector(\n        _token.transferFrom.selector,\n        address(receiver),\n        _to,\n        _id\n      )\n    );\n  }\n\n  function sendBatchERC721(\n    IERC721 _token,\n    uint256[] calldata _ids,\n    address[] calldata _tos,\n    uint256[] calldata _tokenIds\n  ) external notPaused onlyPermissioned(PERMISSION_SEND_ERC721) {\n    unchecked {\n      uint256 idsLength = _ids.length;\n\n      if (idsLength != _tos.length || idsLength != _tokenIds.length) {\n        revert ArrayLengthMismatchERC721(idsLength, _tos.length, _tokenIds.length);\n      }\n\n      for (uint256 i = 0; i < idsLength; ++i) {\n        Receiver receiver = useReceiver(_ids[i]);\n        executeOnReceiver(receiver, address(_token), 0, abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            address(receiver),\n            _tos[i],\n            _tokenIds[i]\n          )\n        );\n      }\n    }\n  }\n}\n"
    },
    "src/VaultETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/commons/receiver/ReceiverHub.sol\";\nimport \"src/commons/Permissions.sol\";\nimport \"src/commons/Pausable.sol\";\n\nabstract contract VaultETH is ReceiverHub, Permissions, Pausable {\n  error ErrorSendingETH(address _to, uint256 _amount, bytes _result);\n  error ArrayLengthMismatchETH(uint256 _array1, uint256 _array2);\n\n  uint8 public immutable PERMISSION_SWEEP_ETH;\n  uint8 public immutable PERMISSION_SEND_ETH;\n\n  constructor (uint8 _sweepETHPermission, uint8 _sendETHPermission) {\n    PERMISSION_SWEEP_ETH = _sweepETHPermission;\n    PERMISSION_SEND_ETH = _sendETHPermission;\n\n    _registerPermission(PERMISSION_SWEEP_ETH);\n    _registerPermission(PERMISSION_SEND_ETH);\n  }\n\n  function sweepETH(\n    uint256 _id\n  ) external notPaused onlyPermissioned(PERMISSION_SWEEP_ETH) {\n    _sweepETH(_id);\n  }\n\n  function sweepBatchETH(\n    uint256[] calldata _ids\n  ) external notPaused onlyPermissioned(PERMISSION_SWEEP_ETH) {\n    unchecked {\n      uint256 idsLength = _ids.length;\n      for (uint256 i = 0; i < idsLength; ++i) {\n        _sweepETH(_ids[i]);\n      }\n    }\n  }\n\n  function _sweepETH(uint256 _id) internal {\n    Receiver receiver = receiverFor(_id);\n    uint256 balance = address(receiver).balance;\n    if (balance != 0) {\n      createIfNeeded(receiver, _id);\n      executeOnReceiver(receiver, address(this), balance, bytes(\"\"));\n    }\n  }\n\n  function sendETH(\n    address payable _to,\n    uint256 _amount\n  ) external notPaused onlyPermissioned(PERMISSION_SEND_ETH) {\n    (bool succeed, bytes memory result) = _to.call{ value: _amount }(\"\");\n    if (!succeed) { revert ErrorSendingETH(_to, _amount, result); }\n  }\n\n  function sendBatchETH(\n    address payable[] calldata  _tos,\n    uint256[] calldata _amounts\n  ) external notPaused onlyPermissioned(PERMISSION_SEND_ETH) {\n    uint256 toLength = _tos.length;\n    if (toLength != _amounts.length) {\n      revert ArrayLengthMismatchETH(toLength, _amounts.length);\n    }\n\n    unchecked {\n      for (uint256 i = 0; i < toLength; ++i) {\n        (bool succeed, bytes memory result) = _tos[i].call{ value: _amounts[i] }(\"\");\n        if (!succeed) { revert ErrorSendingETH(_tos[i], _amounts[i], result); }\n      }\n    }\n  }\n\n  receive() external payable {}\n}\n"
    },
    "src/VaultExecute.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/commons/receiver/ReceiverHub.sol\";\nimport \"src/commons/Permissions.sol\";\nimport \"src/commons/Pausable.sol\";\n\nabstract contract VaultExecute is ReceiverHub, Permissions, Pausable {\n  uint8 public immutable PERMISSION_EXECUTE_ON_RECEIVER;\n  uint8 public immutable PERMISSION_EXECUTE;\n\n  error CallError(address _to, uint256 _value, bytes _data, bytes _result);\n\n  constructor(\n    uint8 _executeOnReceiverPermission,\n    uint8 _executePermission\n  ) {\n    PERMISSION_EXECUTE_ON_RECEIVER = _executeOnReceiverPermission;\n    PERMISSION_EXECUTE = _executePermission;\n\n    _registerPermission(PERMISSION_EXECUTE_ON_RECEIVER);\n    _registerPermission(PERMISSION_EXECUTE);\n  }\n\n  function executeOnReceiver(\n    uint256 _id,\n    address payable _to,\n    uint256 _value,\n    bytes calldata _data\n  ) external notPaused onlyPermissioned(PERMISSION_EXECUTE_ON_RECEIVER) returns (bytes memory) {\n    return executeOnReceiver(_id, _to, _value, _data);\n  }\n\n  function execute(\n    address payable _to,\n    uint256 _value,\n    bytes calldata _data\n  ) external notPaused onlyPermissioned(PERMISSION_EXECUTE) returns (bytes memory) {\n    (bool res, bytes memory result) = _to.call{ value: _value }(_data);\n    if (!res) revert CallError(_to, _value, _data, result);\n    return result;\n  }\n}\n"
    },
    "src/VaultIssueERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/commons/Permissions.sol\";\nimport \"src/commons/Pausable.sol\";\n\nimport \"src/interfaces/IERC721Deterministic.sol\";\n\nabstract contract VaultIssueERC721 is Permissions, Pausable {\n  uint8 public immutable PERMISSION_ISSUE_ERC721;\n\n  error ArrayLengthMismatchIssueERC721(uint256 _array1, uint256 _array2, uint256 _array3);\n\n  constructor (uint8 _issueERC721Permission) {\n    PERMISSION_ISSUE_ERC721 = _issueERC721Permission;\n\n    _registerPermission(PERMISSION_ISSUE_ERC721);\n  }\n\n  function issueERC721(\n    address _beneficiary,\n    IERC721Deterministic _contract,\n    uint256 _optionId,\n    uint256 _issuedId\n  ) external notPaused onlyPermissioned(PERMISSION_ISSUE_ERC721) {\n    _contract.issueToken(_beneficiary, _optionId, _issuedId);\n  }\n\n  function issueBatchERC721(\n    address _beneficiary,\n    IERC721Deterministic[] calldata _contracts,\n    uint256[] calldata _optionIds,\n    uint256[] calldata _issuedIds\n  ) external notPaused onlyPermissioned(PERMISSION_ISSUE_ERC721) {\n    unchecked {\n      uint256 contractsLength = _contracts.length;\n\n      if (contractsLength != _optionIds.length || contractsLength != _issuedIds.length) {\n        revert ArrayLengthMismatchIssueERC721(contractsLength, _optionIds.length, _issuedIds.length);\n      }\n\n      for (uint256 i = 0; i < contractsLength; ++i) {\n        _contracts[i].issueToken(_beneficiary, _optionIds[i], _issuedIds[i]);\n      }\n    }\n  }\n}\n"
    },
    "src/VaultNewReceivers.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.16;\n\nimport \"src/commons/receiver/ReceiverHub.sol\";\nimport \"src/commons/Permissions.sol\";\nimport \"src/commons/Pausable.sol\";\n\nabstract contract VaultNewReceivers is ReceiverHub, Permissions, Pausable {\n  uint8 public immutable PERMISSION_DEPLOY_RECEIVER;\n\n  constructor (uint8 _deployReceiverPermission) {\n    PERMISSION_DEPLOY_RECEIVER = _deployReceiverPermission;\n\n    _registerPermission(PERMISSION_DEPLOY_RECEIVER);\n  }\n\n  function deployReceivers(\n    uint256[] calldata _receivers\n  ) external notPaused onlyPermissioned(PERMISSION_DEPLOY_RECEIVER) {\n    unchecked {\n      uint256 receiversLength = _receivers.length;\n\n      for (uint256 i = 0; i < receiversLength; ++i) {\n        useReceiver(_receivers[i]);\n      }\n    }\n  }\n\n  function deployReceiversRange(\n    uint256 _from,\n    uint256 _to\n  ) external notPaused onlyPermissioned(PERMISSION_DEPLOY_RECEIVER) {\n    unchecked {\n      for (uint256 i = _from; i < _to; ++i) {\n        useReceiver(i);\n      }\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}