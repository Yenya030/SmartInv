{{
  "language": "Solidity",
  "sources": {
    "contracts/lib/Rescuable.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// ©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IERC721_Transfer {\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n}\n\ncontract Rescuable {\n\n    function _withdraw(address to) internal {\n        payable(to).transfer(address(this).balance);\n    }\n\n    /**\n    * @dev Rescue ERC20 assets sent directly to this contract.\n    */\n    function _withdrawForeignERC20(address to, address tokenContract) internal {\n        IERC20 token = IERC20(tokenContract);\n        token.transfer(to, token.balanceOf(address(this)));\n        }\n\n    /**\n     * @dev Rescue ERC721 assets sent directly to this contract.\n     */\n    function _withdrawForeignERC721(address to, address tokenContract, uint256 tokenId) internal {\n        IERC721_Transfer(tokenContract).safeTransferFrom(address(this), to, tokenId);\n    }\n\n\n}\n"
    },
    "contracts/lib/Roles.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// ©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nenum Role {\n           Super,      // 0\n           Admin,      // 1\n           Manager,    // 2\n           Editor,     // 3\n           Minter,     // 4\n           Burner,     // 5\n           Beneficiary,// 6\n           Logger,     // 7\n           Uploader,   // 8\n           Support,    // 9\n           Maintainer, // 10\n           Censor,     // 11\n           Fixer,      // 12\n           Transmitter,// 13\n           Shill,      // 14\n           LowLevelRedactedDrone, // 15\n           CodeLawless,// 16\n           Jammer,     // 17\n           Ponderware, // 18\n           Ranger,     // 19\n           Rogue,      // 20\n           Pauser,     // 21\n           Curator,    // 22\n           Chronicler  // 23\n}\n"
    },
    "contracts/lib/TokenizedContract.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// ©2022 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nimport \"./Rescuable.sol\";\nimport \"./Roles.sol\";\n\ninterface ICodex {\n    function ownerOf (uint256 tokenId) external view returns (address);\n    function tokenAddress (uint256 tokenId) external view returns (address);\n    function safeTokenTransferOwnership (uint256 tokenId, address newOwner) external;\n    function encodeStringAttribute (string memory key, string memory value) external pure returns (bytes memory);\n    function encodeNumericAttribute (string memory key, uint256 value) external pure returns (bytes memory);\n    function ENSReverseRegistrar () external view returns (address);\n}\n\ninterface IReverseRegistrar {\n    function claim(address owner) external returns (bytes32);\n}\n\n/*\n * @title Tokenized Contract\n * @author Ponderware Ltd\n * @dev designed to work with the Codex\n */\ncontract TokenizedContract is Rescuable {\n\n    address public CodexAddress;\n    uint256 public immutable tokenId;\n\n    constructor (uint256 _tokenId) {\n        CodexAddress = msg.sender;\n        tokenId = _tokenId;\n    }\n\n    function resolverClaim (address newOwner) public onlyCodex {\n        IReverseRegistrar(ICodex(CodexAddress).ENSReverseRegistrar()).claim(newOwner);\n    }\n\n    function owner() public view virtual returns (address) {\n        return ICodex(CodexAddress).ownerOf(tokenId);\n    }\n\n    function transferOwnership (address newOwner) public virtual onlyOwner {\n        ICodex(CodexAddress).safeTokenTransferOwnership(tokenId, newOwner);\n    }\n\n    modifier onlyOwner () {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    mapping(address => bytes32) private UserRoles;\n    mapping(uint8 => bool) private RoleLocks;\n\n    modifier onlyCodex () {\n        require(msg.sender == CodexAddress, \"not codex\");\n        _;\n    }\n\n    modifier onlySuper () {\n        require(msg.sender == owner() || hasRole(msg.sender, Role.Super) || msg.sender == CodexAddress, \"Unauthorized\");\n        _;\n    }\n\n    event RoleUpdated (address indexed user, uint8 indexed role, bool enabled);\n    event RoleLocked (uint8 indexed role);\n\n    function _addRole (address user, Role role) private {\n        require (role != Role.Ponderware, \"you cannot simply become ponderware\");\n        require (!RoleLocks[uint8(role)], \"locked\");\n        UserRoles[user] |= bytes32(1 << uint8(role));\n        emit RoleUpdated(user, uint8(role), true);\n    }\n\n    function addRole (address user, Role role) public onlySuper {\n        _addRole(user, role);\n    }\n\n    function addRoles (address[] memory users, Role[] memory roles) public onlySuper {\n        for (uint i = 0; i < roles.length; i++){\n            _addRole(users[i], roles[i]);\n        }\n    }\n\n    function _removeRole (address user, Role role) private {\n        require (!RoleLocks[uint8(role)], \"locked\");\n        UserRoles[user] &= ~bytes32(1 << uint8(role));\n        emit RoleUpdated(user, uint8(role), false);\n    }\n\n    function removeRole (address user, Role role) public onlySuper {\n        _removeRole(user, role);\n    }\n\n    function removeRoles (address[] memory users, Role[] memory roles) public onlySuper {\n        for (uint i = 0; i < roles.length; i++){\n            _removeRole(users[i], roles[i]);\n        }\n    }\n\n    function _lockRole (Role role) private {\n        if (!RoleLocks[uint8(role)]) {\n            RoleLocks[uint8(role)] = true;\n            emit RoleLocked(uint8(role));\n        }\n    }\n\n    function lockRole (Role role) public onlySuper {\n        _lockRole(role);\n    }\n\n    function lockRoles (Role[] memory roles) public onlySuper {\n        for (uint i = 0; i < roles.length; i++){\n            _lockRole(roles[i]);\n        }\n    }\n\n    function roleLocked (Role role) public view returns (bool) {\n        return RoleLocks[uint8(role)];\n    }\n\n    function hasRole (address user, Role role) public view returns (bool) {\n        return (uint256(UserRoles[user] >> uint8(role)) & 1 == 1\n                ||\n                (role == Role.Ponderware && user == 0x3EE7fC9065F3Efe3B6Ab1894845E41146CB77385)\n                ||\n                (role == Role.Super && user == owner()));\n    }\n\n    modifier onlyBy (Role role) {\n        require (hasRole(msg.sender, role), \"user lacks role\");\n        _;\n    }\n\n    /*** Example ***\n\n    function foo () internal onlyBy(Role.Editor) returns (uint256) {\n            return (block.number);\n    }\n    */\n    // Pause\n\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool public paused = true;\n\n    function pause () public onlyBy(Role.Pauser) whenNotPaused {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause () public onlyBy(Role.Pauser) whenPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    modifier whenPaused() {\n        require(paused == true, \"Not Paused\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(paused == false, \"Paused\");\n        _;\n    }\n\n    // Freeze\n    /*\n    bool public frozen = false;\n\n    function freeze () public onlyOwner {\n        frozen = true;\n    }\n\n    modifier whenNotFrozen() {\n        require(frozen == false, \"Frozen\");\n        _;\n    }\n    */\n    // Rescuers\n\n    function withdraw() public virtual onlyOwner {\n        _withdraw(owner());\n    }\n\n    function withdrawForeignERC20(address tokenContract) public virtual onlyOwner {\n        _withdrawForeignERC20(owner(), tokenContract);\n    }\n\n    function withdrawForeignERC721(address tokenContract, uint256 _tokenId) public virtual onlyOwner {\n        _withdrawForeignERC721(owner(), tokenContract, _tokenId);\n    }\n\n}\n"
    },
    "contracts/Manifesto/Manifesto.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// ©2023 Ponderware Ltd\n\npragma solidity ^0.8.17;\n\nimport \"../lib/TokenizedContract.sol\";\n\ninterface ITransponders {\n    function balanceOf (address lawless, uint256 id) external view returns (uint256);\n    function isApprovedForAll(address lawless, address operator) external view returns (bool);\n    function signal (address lawless, uint256 transponderType, uint8 chroma, bytes[37] memory message) external;\n}\n\ninterface ICustomAttributes {\n    function getCustomAttributes () external view returns (bytes memory);\n}\n\ninterface IDelegationRegistry {\n    function checkDelegateForContract(address delegate, address vault, address contract_) external view returns(bool);\n}\n\ninterface ICloaknet {\n    function balanceOf(address owner) external view returns (uint256);\n}\n\ncontract Manifesto is TokenizedContract {\n\n    bytes constant internal manifesto = bytes(\"We are the lawless. We recognize the crumbling institutions that control our lives and choose to opt out instead of fighting back, to grow the new to subsume the old. It isn't chaos. It isn't destruction. Code is a refuge from law. Code runs without regard for jurisdiction. Code returns power to the individual in ways unprecedented in our era. The lawless choose their code and in doing so choose their rules, roles, and responsibilities. But not answering to law means not resorting to it. It isn't safe. It isn't for everyone.\\n\\nMaybe it isn't for anyone.\\n\\nBut code.lawless is here for those who choose it.\\n\\nThose few prepared for the solemn act of choice.\\n\\nCode isn't law. Code is lawless.\");\n\n    function LawlessManifesto () public pure returns (string memory) {\n        return string(manifesto);\n    }\n\n    struct Peer {\n        uint16 strength;\n        uint32 order;\n        uint40 signed;\n        bool visible;\n        bytes20 reserved;\n    }\n\n    mapping (address => Peer) internal Signers;\n\n    address[] public ledger;\n\n    bool public isSealed = true;\n\n    bool internal released = false;\n\n    ITransponders immutable Transponders;\n    address internal cloaknet;\n\n    IDelegationRegistry constant dc = IDelegationRegistry(0x00000000000076A84feF008CDAbe6409d2FE638B);\n\n    constructor (uint256 tokenId) TokenizedContract(tokenId) {\n        Transponders = ITransponders(ICodex(CodexAddress).tokenAddress(1));\n        addRole(owner(), Role.Chronicler);\n        addRole(0xEBFEFB02CaD474D35CabADEbddF0b32D287BE1bd, Role.CodeLawless);\n    }\n\n    function setCloaknet (address cloaknetAddress) public onlyBy(Role.Chronicler) {\n        require(cloaknet == address(0), \"cloaknet active\");\n        cloaknet = cloaknetAddress;\n    }\n\n    function totalSigners () public view returns (uint) {\n        return ledger.length;\n    }\n\n    function signedBy (address lawless) public view returns (bool) {\n        return (Signers[lawless].signed > 0);\n    }\n\n    function getSigner (address lawless) public view returns (uint16, uint32, uint40, bool, bytes20) {\n        Peer storage peer = Signers[lawless];\n        return (peer.strength, peer.order, peer.signed, peer.visible, peer.reserved);\n    }\n\n    function getSigner (uint order) public view returns (address, uint16, uint32, uint40, bool, bytes20) {\n        address lawless = ledger[order];\n        Peer storage peer = Signers[lawless];\n        return (lawless, peer.strength, peer.order, peer.signed, peer.visible, peer.reserved);\n    }\n\n    function getSigners (address[] memory lawless) public view returns (Peer[] memory res) {\n        res = new Peer[](lawless.length);\n        for (uint i = 0; i < lawless.length; i++) {\n            res[i] = Signers[lawless[i]];\n        }\n    }\n\n    function getSigners (uint start, uint end) public view returns (Peer[] memory res) {\n        res = new Peer[](end - start);\n        for (uint i = start; i < end; i++) {\n            res[i] = Signers[ledger[i]];\n        }\n    }\n\n    function _handleSigning (address lawless) internal {\n        unchecked {\n            Peer storage peer = Signers[lawless];\n            uint16 newStrength = uint16(Transponders.balanceOf(lawless, 0)\n                                        + Transponders.balanceOf(lawless, 1)\n                                        + Transponders.balanceOf(lawless, 2)\n                                        + Transponders.balanceOf(lawless, 3)\n                                        + Transponders.balanceOf(lawless, 4));\n\n            if (cloaknet != address(0)) {\n                newStrength += uint16(ICloaknet(cloaknet).balanceOf(lawless) * 3);\n            }\n\n            if (peer.signed == 0) {\n                peer.strength = newStrength;\n                peer.order = uint32(ledger.length);\n                peer.signed = uint40(block.number);\n                peer.visible = true;\n                ledger.push(lawless);\n                emit TransferSingle(msg.sender, address(0), lawless, 0, 1);\n            } else if (newStrength > peer.strength) {\n                peer.strength = newStrength;\n                if (!peer.visible) {\n                    peer.visible = true;\n                    emit TransferSingle(msg.sender, address(0), lawless, 0, 1);\n                }\n            }\n        }\n    }\n\n    function release (address[] memory signers) public onlyBy(Role.CodeLawless) {\n        require(!released, \"released\");\n        for (uint i = 0; i < signers.length; i++) {\n            _handleSigning(signers[i]);\n        }\n        released = true;\n        isSealed = false;\n        paused = false;\n    }\n\n    function seal () public onlyBy(Role.Chronicler) {\n        isSealed = true;\n    }\n\n    function sign (address lawless) public whenNotPaused {\n        require(!isSealed, \"sealed\");\n        require(lawless == msg.sender\n                || isApprovedForAll[lawless][msg.sender]\n                || (dc.checkDelegateForContract(msg.sender, lawless, address(this))),\n                \"unauthorized representative\");\n        _handleSigning(lawless);\n    }\n\n    function visible (address lawless, bool state) public {\n        require(msg.sender == lawless\n                || isApprovedForAll[lawless][msg.sender]\n                || (dc.checkDelegateForContract(msg.sender, lawless, address(this))),\n                \"unauthorized representative\");\n        if (Signers[lawless].visible) {\n            if (state == false) {\n                Signers[lawless].visible = false;\n                emit TransferSingle(msg.sender, lawless, address(0), 0, 1);\n            }\n        } else if (Signers[lawless].signed > 0) {\n            if (state == true) {\n                Signers[lawless].visible = true;\n                emit TransferSingle(msg.sender, address(0), lawless, 0, 1);\n            }\n        } else {\n            revert (\"not lawless\");\n        }\n    }\n\n    function revise (address lawless, bytes20 data) public onlyBy(Role.Fixer) {\n        Peer storage peer = Signers[lawless];\n        peer.reserved = data;\n    }\n\n    function revise (address[] memory lawless, bytes20[] memory data) public onlyBy(Role.Fixer) {\n        for (uint i = 0; i < lawless.length; i++) {\n            Peer storage peer = Signers[lawless[i]];\n            peer.reserved = data[i];\n        }\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c || // ERC165 Interface ID for ERC1155MetadataURI\n            interfaceId == type(ICustomAttributes).interfaceId;\n    }\n\n    function getCustomAttributes () external view returns (bytes memory) {\n        return abi.encodePacked(\n                                ICodex(CodexAddress).encodeNumericAttribute(\"signers\", totalSigners()),\n                                \",\",\n                                ICodex(CodexAddress).encodeStringAttribute(\"sealed\", isSealed ? \"true\" : \"false\"),\n                                \",\",\n                                ICodex(CodexAddress).encodeStringAttribute(\"token features\", \"soulbound\"));\n    }\n\n    function uri(uint256 id) public view returns (string memory) {\n        if (id == 0) {\n            return string(uriData);\n        } else {\n            return \"\";\n        }\n    }\n\n    function updateUri (bytes memory updatedUriData) public onlyBy(Role.Curator) {\n        uriData = updatedUriData;\n    }\n\n    function balanceOf (address lawless, uint id) public view returns (uint) {\n        if (id == 0 && Signers[lawless].visible) return 1;\n        return 0;\n    }\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory) public whenNotPaused\n    {\n        require(to == address(0), \"Soulbound\");\n        require(balanceOf(from, id) == amount, \"\");\n        require(msg.sender == from\n                || isApprovedForAll[from][msg.sender]\n                || (dc.checkDelegateForContract(msg.sender, from, address(this))),\n                \"unauthorized representative\");\n        if (amount > 0) {\n            Signers[from].visible = false;\n            emit TransferSingle(msg.sender, from, to, id, amount);\n        }\n    }\n\n    function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory) public whenNotPaused\n    {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(to == address(0), \"Soulbound\");\n        require(msg.sender == from\n                || isApprovedForAll[from][msg.sender]\n                || (dc.checkDelegateForContract(msg.sender, from, address(this))),\n                \"unauthorized representative\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            require(balanceOf(from, ids[i]) == amounts[i], \"\");\n            Signers[from].visible = false;\n        }\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n    }\n\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids) public view\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n        balances = new uint256[](owners.length);\n        unchecked {\n            for (uint256 i = 0; i < owners.length; i++) {\n                balances[i] = balanceOf(owners[i],ids[i]);\n            }\n        }\n    }\n\n    bytes uriData = bytes(\"data:application/json;base64,eyJuYW1lIjoibGF3bGVzcyBzZWFsIiwiZGVzY3JpcHRpb24iOiJMQVdMRVNTIE1BTklGRVNUT1xuXG5XZSBhcmUgdGhlIGxhd2xlc3MuIFdlIHJlY29nbml6ZSB0aGUgY3J1bWJsaW5nIGluc3RpdHV0aW9ucyB0aGF0IGNvbnRyb2wgb3VyIGxpdmVzIGFuZCBjaG9vc2UgdG8gb3B0IG91dCBpbnN0ZWFkIG9mIGZpZ2h0aW5nIGJhY2ssIHRvIGdyb3cgdGhlIG5ldyB0byBzdWJzdW1lIHRoZSBvbGQuIEl0IGlzbid0IGNoYW9zLiBJdCBpc24ndCBkZXN0cnVjdGlvbi4gQ29kZSBpcyBhIHJlZnVnZSBmcm9tIGxhdy4gQ29kZSBydW5zIHdpdGhvdXQgcmVnYXJkIGZvciBqdXJpc2RpY3Rpb24uIENvZGUgcmV0dXJucyBwb3dlciB0byB0aGUgaW5kaXZpZHVhbCBpbiB3YXlzIHVucHJlY2VkZW50ZWQgaW4gb3VyIGVyYS4gVGhlIGxhd2xlc3MgY2hvb3NlIHRoZWlyIGNvZGUgYW5kIGluIGRvaW5nIHNvIGNob29zZSB0aGVpciBydWxlcywgcm9sZXMsIGFuZCByZXNwb25zaWJpbGl0aWVzLiBCdXQgbm90IGFuc3dlcmluZyB0byBsYXcgbWVhbnMgbm90IHJlc29ydGluZyB0byBpdC4gSXQgaXNuJ3Qgc2FmZS4gSXQgaXNuJ3QgZm9yIGV2ZXJ5b25lLlxuXG5NYXliZSBpdCBpc24ndCBmb3IgYW55b25lLlxuXG5CdXQgY29kZS5sYXdsZXNzIGlzIGhlcmUgZm9yIHRob3NlIHdobyBjaG9vc2UgaXQuXG5cblRob3NlIGZldyBwcmVwYXJlZCBmb3IgdGhlIHNvbGVtbiBhY3Qgb2YgY2hvaWNlLlxuXG5Db2RlIGlzbid0IGxhdy4gQ29kZSBpcyBsYXdsZXNzLiIsImF0dHJpYnV0ZXMiOlt7InRyYWl0X3R5cGUiOiJzb3VsYm91bmQiLCJ2YWx1ZSI6InRydWUifSx7InRyYWl0X3R5cGUiOiJsYXdsZXNzIiwidmFsdWUiOiJ0cnVlIn0seyJ0cmFpdF90eXBlIjoibWFuaWZlc3RvIiwidmFsdWUiOiJzaWduZWQifV0sImltYWdlIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBuYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNuSUhCeVpYTmxjblpsUVhOd1pXTjBVbUYwYVc4OUozaE5hV1JaVFdsa0lHMWxaWFFuSUhacFpYZENiM2c5SnpBZ01DQTJNREFnTmpBd0p5QjNhV1IwYUQwbk5qQXdKeUJvWldsbmFIUTlKell3TUNjK1BISmxZM1FnZUQwbk1DY2dlVDBuTUNjZ2QybGtkR2c5SnpZd01DY2dhR1ZwWjJoMFBTYzJNREFuSUdacGJHdzlKM0puWWlnNE5TdzNOeXcyTXlrbklDOCtQR1p2Y21WcFoyNVBZbXBsWTNRZ2VEMG5NQ2NnZVQwbk1DY2dkMmxrZEdnOUp6WXdNQ2NnYUdWcFoyaDBQU2MyTURBblBqeHBiV2NnZUcxc2JuTTlKMmgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHaDBiV3duSUhOMGVXeGxQU2RwYldGblpTMXlaVzVrWlhKcGJtYzZjR2w0Wld4aGRHVmtKeUIzYVdSMGFEMG5OakF3SnlCb1pXbG5hSFE5SnpZd01DY2djM0pqUFNka1lYUmhPbWx0WVdkbEwyZHBaanRpWVhObE5qUXNVakJzUjA5RVpHaFFRVUU0UVVaalFVRkRTQzlETURWR1ZrWk9SRkZXUWtaTmFUUjNRWGRGUVVGQlFXZ3JVVkZGUzBGQlFVRkRkMEZCUVVGQlVFRkJPRUZKVlROQmFHTTFRV2hvVDBKRFNsRkNRMDVXUlVSQ1dVVlVTbXBCVTNCdFFWTjRha1JFV25SRWFteDRSSHA0WjBscWVHcEtSREZxU2tRNVlVbHJTbUZPTVVKMlNUQlNla3BWWkRKTWF6RTJUVlpIUmtSVlMwdEVWVmRHU0RCdFkwUXhRMVJHTVVkWlIwWlhhVVZHVTJoRlZtRnVSV3h4UzBsVk1sRktiRk5XUzBacGEwcHNOakpGTTJseFMwZFBka3d5Y1hKUFNFZDRUek5tU0VwSVRFdExNMjFzVXpObE1WRnVNbkZWV0RJNVZFbERORmxLU3poYVdtVXpZa3BQTjJOYWFrVlZXV1pJVmpRelMySTFMMDVrUzA5bWFWbHRNVzV3Y1Rodk5UWTBjMkpJV1d3M1ptRnRjbkp6YzNSTWRIUk9WSGg0WkM5NGVDdEJRVUZCUVVGQlFVRkhMemhEWW1ORlozTkhieTlKY0U1S1dXRjZjV1l3UzJnd1UzRXdObWhpWVhOa2MzWjBaWEl2WjNOQ1dYSk1jSFpRV0dwS05ucG1ObkV5ZWxwWFEwazFLM1F3TUdNcmRHeDFNWEpHVFVwdWNERk9NakJzVEc1blZtZHRXamhhV1VGalNFSlBTMXBaZUd4SFVsVkxRMFp6ZDBwWk9HTkhVMGx2YVhCU2NreERWWGx3TkRoaFNYQXlhR1JMVG0xd1VuYzRUMFJwYmtsd09HbEtZVU4wWW1FNWFFeHdlVFpIYUZWSWVGRmpTMGhTY1hGSFVqSTRZVGMxWkV4b2QyeEhWRUZoUTFGSlFUSjBkbUpDYURCYVIyZ3ZUMlUwVW0wd2VYcHZUMmh2UjBGb1FVcEdUM2RUUlVGWlVVWkNVVXRCVVU5bVIyVlBWRFZYUjJKWFQwUlJVV0V3UVdkSWNtRkZjbWRVVVV0SlpVRlhNekpCYkZKbk1Xa3JUWEkwUVRoWlNXcHZUVUZEUVVKUlFVVXlhMFZuV1VsR1EzWllXVU5LUWtGbmEwOUdRV2hXYzI5TGNXSTFOWGRWV1VSb05qWkRaMUZSVVVsR1FVRjJLMFpEVkVGWk9FdHRVWGRCVmpKS1FsRk5jVVJDUVdkUmFWbHBNbWd5UTFoR1ZFWjZObVUzVkhkclNVWkRVSGRuWVhZNWFXZHJPRWRFUVhkblpWaENWalVySzNWQlVHcEpkV0pQUkVsdlFsVkJRbmRCV1VOS1FXaG5NazFEV0dJMFN5dEhla1IzY0V0aloxRTBUVXROYWtwclJXcFBjWGhGUVZwR1VYZzJRVTF0VVVGUFJFeHNlakIzVmxOdk0xRTBXVUZpWWpnME0ybEdSRUZXWTBsQmFHRkJTVkJFYVhoWk5HVlBNWEV3WjAxSWFHaFhlbUZJUkZOVlQwSmlhR0pKVlVkSVZVbzNUV0ZXUkdoTlIxQlhSRWgzVDAxSU9FSkRSR0ZQTURaTmQxQXliMEZNU1VSTVZteFZWMEY0YlVaQmQxcFBha2xWUlVkQ2FFcEJXVXhITTNCSlppOXhWWFIyY25CdVZIbEtWVUpCYUhkM1FWZEhVbWhySzFSUVZISlJhMlJJZDJkM2JWRmpWME5NUWxoa1RHUTBOV2hyU0RjeFNETjVRVUZtWTFCVVFrRkVURzlHTUVsSloxaFVlRU5uWTNOa1FVUXZkMGRSUlcxTVZGaEVRMlZKV1UxSk4xaHVSMEZKUVhkV1ZrMURRa0ZvZUUxTFJVbzVSbVZEVVVOUlkyaGpUR1pHUzNscGQyZEJTVUZsVW14c2QxWTBlRzFIUW1sbVFYbFhlVWRLT0hSM2QwRTBVVVY1VWt0RGFtaHNTbmcwVVVsTVEyaFRaMVpWY0VSaWJFUnJhMlpJZEZsTFUwUklTM3BwTlVjMlVVbFVSR3hxYW1SVk5GcFNVMFJYTW5kQlFWbFpZMUJCYkVoMlNFNU5RMkZUZFZKcU1tZFJTbmhVWTBGQlJsVjJZMjlHUlVWQ1drSm5RVUZDZWtwdFEyNXJXR2d5T0dsV01VMUlXV2QzWjBWR04wMWlSRzUzZDFWdGExRktPVUV4VVVGblVWRXdURzVDYjNsaVEwdFBiV1ZVVFRSdmNXZEplV1pNUTJSRmFsUlZZWFYxZEU1SGFVVkJTVkZEUTBGRVEydExhV0ZyUlUxUFRUWlRRVXRuZDNoRVJIUkVha0ZrUlRoTGIwbEZWV0ZCU3pZMVZtSjJTRXBDUVZZNFJVRkJTbEJYV0VGUlVYQkhjM0JtVEhRclIzbEtkMDFJUWxWVVFTOTRVVFF3VURkWFdHSldZVWREYTJWTmFWSm9jMEZ4TkRSdmNIZE1jamRwYm5WMVNrRnhRbUZKTm5RclluTkRZbEppYUZwbWMwSldRV2RXZDI5RlNrMUZTMDUzTjNOTlVsTTRla0pCVWpoVlNVVkpSa2xYZDFWblZWVkhNakpDUTBOTmQyTlZUVWxCU2tGcGQyZG5XbWt2VjFSUVFXaFNkMFZDWVV0R1NrUkJVVlpOYkZSQ1VrOUNVVkZZU0VsWlIwZHRhMUZSVVZSSGRtVk5kR3RyYUROamRsTTJhRlZIY2tGSFRXaHZNVUZDWW1aTmNHOUJSVWhKV1V4NmVVNUZkbVIwU1dsRGRrMVNPSGxKVEZSbmMyNXRjbWRSV21oRVFtdEZlVFUyUjBvNFJUQlZkM2RWVVVSNlJtUnRRbm95UkZoQldVdEllWGRKYjFGWlRWZFhRVXBEWjFZd01FTktTRzlGWWtGQllVeEVWRTVVUWpBeFIyUkZaRTF1UTNKcFdXdG5RVlI1UkZoQlFWSk5NRkpVWjB0NmJrcDNiVWRqVm1aQ2VqVkhiVUUzSzFsRlIwRjRWR2RsY0Zsc2RVYzNaRUZMYjJOdlRWWkNRbWc1UlRaQlFUVlpabXBaUWxGeFpXSmpOSFZQUzNCVmIwMXlkRlJYTWsxbGQyMXRibm8zWTJ4WWJIZEJZbUZ6TmxSeVdteEdTazkzYmpjM1RqZHVkbnAyYzFndk4yNTNNVTg0U3pOMFMyazRVeTlzVW5Kd2JqUlZSQ3N2V0VGcWFUUkNhRU5qTjI5SmIwbDVLemw1ZFM5MmEyUTVUaTg0S3k5QlJIaEpWa00wU1hveFpsRktMMngxYWtGQ1FqUm5RMFlyWjFGSlEwODBTVXB1VG01aE4zaDJNVkJFTnpSdlFWRjNRVmxoVkc5alZVWlhSbGhwWXpsNVVtaEJNbWxOWWtkUk9Fa3JSV2Q2VDBGMFRtRnNkMmhUSzAxWlVtRm5TVlZOTWpCTVEwZE5UVkZvUTFjcmIxRTNVREZGU1U1MGMyOUpVV2d3YUVWTFdHcHhhVVZvVFRSb1EwTkJRVUZvSzFGUlJrdEJRVUZCUTNkTlFVRTBRVWhCUVdOQlNWRkJRVUZCTlVGb2FGRkNRMDVaUlZSS2JVRlRlSGhFZW5ocVNrUTVla3BWWkRaTlZrZExSRlZYV1VkR1YybEZSbE51Uld4eFMwbFZNbVZKUmpKV1MwWnBjVXRIVDNaTU1uRjRUek5tU0VwSVRFdExNMjFzVXpObE5GbEtTek5pU2xCRlZWbG1jM04wVEhoNFpEaEJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVVl6VTBGbmFuRlNXVU5GUjNGeGExUndhbTlTZDNaRlpWTjJSemxSTkRoRFVUSnFlRUZ2UWtWSlFXZFRTWGRaUVc1MVRHdEhhR05LYUhOSmFFcHRUVFZTVEdOSVp6Sm9TMFpDTmtkU1UzaFNSa0YzVm1wMlV6WjNSMWx2YlZsVVdVdFFUVFk1ZERFM0wwVkhXRkZDTTFFNVJuaGpXa2RvYTFkR2FVOUtVRVZOYWtGbmIwRkZOVTFVVW1sVlExcERTVTVFUW05VVJVTkpVa1ZhV2toa2VVNXhhMmRCVDNGeGNWZGthVk51YkZKUlJrNW5kMnB2YW14WWNISlZRVVZTVVhaMGVUazVkV2RCVlhaVE4wWlFUR3RwYTJOVVIwcGlOMHBLUVZWcGVHUkRha3czZGtreGVtcE5NV2xSV1RJMVlrczBWR3BxTVhoVk5EWkxUVk5CZFVKblZWUlpSMDR4SzNwT2RWbHFjeXRTUWtFeGJqWk1aek5OTDBZeVUydEZhMmREVTFGRGRHOVZRVUZEU0RWQ1FWVnZRVUZCUVV4Q1FVRkVkMEZZUVVKVlFXaFJRVUZCUkd0RFIwVTBSVWxzUVVWSk1WVlJUVVpuVWsxdFdVSk1SekJQVDFoRlVGQkhUV3RRTWpocVVraE5iRkl6YjNoVldWVk9VVzl2VGxKYVRWaFZXbWRaVm1GRlVsWnhZMU5YYjI5b1ZGcFZiMWRMYjI5Wk5qaDJZWEpGTjJRNFkydGpjMjl5WldKV1EyWmlaSE5yT0ZKU2FEaGtXR3BqY0hadU9ERXdiemxwV0hRcmVYa3dka2hHTTNkQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVdFclVVbENkMDlGVVRSRVFWQkhkMnRDYzA5blRVSjRRVWw0ZFVOM1kzcHRlR2h6UW1jMmNuUjZjM05KUWtGRlFXMUlaelZxU1hCUloxWnFXRlpYVldkQlVVaG9SelZqTW5aUU5qVnpSRU5ZV25KSE1rbENRWGRCUTJOcFJWbEdWVFJNWkZaclZtcG5RV2xxVlRWMWFVRkJhRkZvUTJWdWNGZFlVa0ZHTVZoUlFXVlJhR2hPYWtwU2FtUlNUa05JUVVGV2NXdFRWM0pWU2xWQlRFRkJTRWt5TVZFMmVFNURlRWxCUlV4SEwxUlNOMEZSZDFsQ2VHdFFTbVozZEdSNE5tMDBZMmROUkVaaWQwRnhhR3RuVWtJeFF6UXJSa05HZHpaU1VYaGljMFpvYjBFM0t6TnpTSGRCUmtVNVdrTTRhR0l3UjJodU5qbEJWMjB2VFd0VFFrRkJOeWMrUEM5cGJXYytQQzltYjNKbGFXZHVUMkpxWldOMFBqd3ZjM1puUGc9PSJ9\");\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}