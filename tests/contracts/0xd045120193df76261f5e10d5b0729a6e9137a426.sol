{{
  "language": "Solidity",
  "sources": {
    "lion.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\nSTAY AHEAD IN THE GAME\nMeet DexLions, the elite DeFi traders, and access their signals to boost your trading skills and outpace the market.\n\nWebsite: https://dexlions.com\nWhite paper: https://premium.dexlions.com\nTelegram: https://t.me/dexlions\nTwitter: https://twitter.com/dexlionscom\n*/\n\npragma solidity ^0.8.0 <0.9.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this;\n        return msg.data;\n    }\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n    unchecked {\n        _approve(sender, _msgSender(), currentAllowance - amount);\n    }\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n    unchecked {\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n    }\n\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n        _balances[sender] = senderBalance - amount;\n    }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _createInitialSupply(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IDexRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n    external\n    payable\n    returns (\n        uint256 amountToken,\n        uint256 amountETH,\n        uint256 liquidity\n    );\n}\n\ninterface IDexFactory {\n    function createPair(address tokenA, address tokenB)\n    external\n    returns (address pair);\n}\n\ncontract DEXLIONS is ERC20, Ownable {\n\n    uint256 public maxBuyAmount;\n    uint256 public maxSellAmount;\n    uint256 public maxWalletAmount;\n\n    IDexRouter public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n\n    bool private _swapping;\n    uint256 public swapTokensAtAmount;\n\n    address public MarketingAddress;\n\n    uint256 public tradingActiveBlock = 0; \n    uint256 public deadBlocks = 2;\n\n    bool public limitsInEffect = true;\n    bool public tradingActive = false;\n    bool public swapEnabled = false;\n    bool public sniperManagementEnabled = true;\n\n    uint256 public buyFee;\n\n    uint256 public sellFee;\n\n    mapping (address => bool) public isExcludedFromFees;\n    mapping (address => bool) public isExcludedFromLimits;\n    mapping (address => bool) public automatedMarketMakerPairs;\n    mapping (address => bool) public isSniper;\n\n    constructor() ERC20(\"DEXLIONS\", \"LION\") {\n\n        address newOwner = msg.sender; \n\n        IDexRouter _uniswapV2Router = IDexRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        _excludeFromLimits(address(_uniswapV2Router), true);\n        uniswapV2Router = _uniswapV2Router;\n\n        address tokenA = address(this);\n        address tokenB = _uniswapV2Router.WETH();\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        uniswapV2Pair = address(uint160(uint(keccak256(abi.encodePacked(\n            hex'ff',\n            _uniswapV2Router.factory(),\n            keccak256(abi.encodePacked(token0, token1)),\n            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\n        )))));\n\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\n\n        uint256 totalSupply = 100000000  * 1e18;\n\n        maxBuyAmount = totalSupply * 2 / 100;\n        maxSellAmount = totalSupply *  2 / 100;\n        maxWalletAmount = totalSupply * 4 / 100;\n        swapTokensAtAmount = totalSupply * 50 / 100000; \n\n        buyFee = 5;\n        sellFee = 20;\n\n        _excludeFromLimits(newOwner, true);\n        _excludeFromLimits(address(this), true);\n\n        MarketingAddress = address(0x8866214224889999716908e2c1663bb355ee3BBa);\n\n        excludeFromFees(newOwner, true);\n        excludeFromFees(address(this), true);\n\n        _createInitialSupply(newOwner, totalSupply);\n        transferOwnership(newOwner);\n    }\n\n    receive() external payable {}\n\n    function createPair() external onlyOwner {\n        IDexFactory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\n    }\n\n    function updateMaxBuyAmount(uint256 newAmount) external onlyOwner {\n        require(newAmount * 1e18 >= (totalSupply() * 1 / 100), \"DEXLIONS: new max buy amount less than 1% of total supply\");\n        maxBuyAmount = newAmount * 1e18;\n    }\n\n    function updateMaxSellAmount(uint256 newAmount) external onlyOwner {\n        require(newAmount * 1e18 >= (totalSupply() * 1 / 100), \"DEXLIONS: new max sell amount less than 1% of total supply\");\n        maxSellAmount = newAmount * 1e18;\n    }\n\n    function updateMaxWalletAmount(uint256 newAmount) external onlyOwner {\n        require(newAmount * 1e18 >= (totalSupply() * 2 / 100), \"DEXLIONS: new max wallet amount less than 2% of total supply\");\n        maxWalletAmount = newAmount * 1e18;\n    }\n\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {\n        require(newAmount * 1e18 >= totalSupply() * 1 / 100000, \"DEXLIONS: new swap amount less than 0.001% of total supply\");\n        require(newAmount <= totalSupply() * 1 / 1000, \"DEXLIONS: new Swap amount exceeds 0.1% of total supply\");\n        swapTokensAtAmount = newAmount * 1e18;\n    }\n\n    function removeLimits() external onlyOwner {\n        limitsInEffect = false;\n    }\n\n    function _excludeFromLimits(address account, bool isExcluded) private {\n        isExcludedFromLimits[account] = isExcluded;\n    }\n\n    function excludeFromLimits(address account, bool isExcluded) external onlyOwner {\n        if (!isExcluded) {\n            require(account != uniswapV2Pair, \"DEXLIONS: account to be exscluded is pair address\");\n        }\n        _excludeFromLimits(account, isExcluded);\n    }\n\n    function updateBuyFee(uint256 newBuyFee) external onlyOwner {\n        require(newBuyFee <= 5, \"DEXLIONS: new buy fee exceeds 5%\");\n        buyFee = newBuyFee;\n    }\n\n    function updateSellFee(uint256 newSellFee) external onlyOwner {\n        if (sellFee > 5) {\n            require(newSellFee <= sellFee, \"DEXLIONS: new sell fee exceeds current sell fee\");\n        } else {\n            require(sellFee <= 5, \"DEXLIONS: new sell fee exceeds 5%\");\n        }\n        sellFee = newSellFee;\n    }\n\n    function excludeFromFees(address account, bool isExcluded) public onlyOwner {\n        isExcludedFromFees[account] = isExcluded;\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        require(amount > 0, \"DEXLIONS: amount is zero\");\n        require(!isSniper[from], \"DEXLIONS: sender marked as sniper\");\n        require(!isSniper[to], \"DEXLIONS: recipient marked as sniper\");\n \n        if (limitsInEffect) {\n            if (from != owner() && to != owner() && !isExcludedFromFees[from] && !isExcludedFromFees[to]) {\n                require(tradingActive, \"DEXLIONS: trading is not active\");\n                if (tradingActiveBlock > 0 && block.number < (tradingActiveBlock + deadBlocks) ) {\n                    isSniper[to] = true;\n                }\n                // buy\n                if (automatedMarketMakerPairs[from] && !isExcludedFromLimits[to]) {\n                    require(amount <= maxBuyAmount, \"DEXLIONS: transfer amount exceeds max buy amount\");\n                    require(amount + balanceOf(to) <= maxWalletAmount, \"DEXLIONS: balance exceeds max wallet amount\");\n                }\n                // sell\n                else if (automatedMarketMakerPairs[to] && !isExcludedFromLimits[from]) {\n                    require(amount <= maxSellAmount, \"DEXLIONS: transfer amount exceeds max sell amount\");\n                }\n                else if (!isExcludedFromLimits[to]) {\n                    require(amount + balanceOf(to) <= maxWalletAmount, \"DEXLIONS: balance exceeds max wallet amount\");\n                }\n            }\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n        if(canSwap && swapEnabled && !_swapping && !automatedMarketMakerPairs[from] && !isExcludedFromFees[from] && !isExcludedFromFees[to]) {\n            _swapping = true;\n            _swapBack();\n            _swapping = false;\n        }\n\n        uint256 fee = 0;\n        uint256 penaltyAmount = 0;\n        if(!isExcludedFromFees[from] && !isExcludedFromFees[to]){\n            // sniper penalty\n            if (tradingActiveBlock > 0 && block.number < (tradingActiveBlock + deadBlocks) ) {\n                penaltyAmount = amount * 98 / 100;\n                super._transfer(from, MarketingAddress, penaltyAmount);\n            }\n            // sell\n            else if (automatedMarketMakerPairs[to] && sellFee > 0){\n                fee = amount * sellFee / 100;\n            }\n            // buy\n            else if(automatedMarketMakerPairs[from] && buyFee > 0) {\n                fee = amount * buyFee / 100;\n            }\n            if(fee > 0){\n                super._transfer(from, address(this), fee);\n            }\n            amount -= fee + penaltyAmount;\n        }\n\n        super._transfer(from, to, amount);\n    }\n\n    function _swapTokensForEth(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function setAutomatedMarketMakerPair(address pair, bool isAMM) external onlyOwner {\n        if(!isAMM) {\n            require(pair != uniswapV2Pair, \"DEXLIONS: automated market maker pair is uniswap V2 pair\");\n        }\n        _setAutomatedMarketMakerPair(pair, isAMM);\n    }\n\n    function _setAutomatedMarketMakerPair(address pair, bool isAMM) private {\n        automatedMarketMakerPairs[pair] = isAMM;\n        _excludeFromLimits(pair, isAMM);\n    }\n\n    // once enabled, can never be turned off\n    function enableTrading(bool _status, uint256 _deadBlocks) external onlyOwner {\n        require(!tradingActive, \"DEXLIONS: trading is already active\");\n        require(_deadBlocks <= 5, \"DEXLIONS: deadblocks amount exceeds 5\");\n        tradingActive = _status;\n        swapEnabled = true;\n\n        if (tradingActive && tradingActiveBlock == 0) {\n            tradingActiveBlock = block.number;\n            deadBlocks = _deadBlocks;\n        }\n    }\n\n    function setMarketingAddress(address newMarketingAddress) external onlyOwner {\n        require(newMarketingAddress != address(0), \"DEXLIONS: new marketing address is the zero address\");\n        MarketingAddress = payable(newMarketingAddress);\n    }\n\n    function manageSniper(address sniperAddress, bool status) external onlyOwner {\n        require(sniperManagementEnabled, \"DEXLIONS: sniper management permanently disabled\");\n        isSniper[sniperAddress] = status;\n    }\n\n    function manageSnipers(address[] calldata addresses, bool status) external onlyOwner {\n        require(sniperManagementEnabled, \"DEXLIONS: snipers management permanently disabled\");\n        for (uint256 i; i < addresses.length; ++i) {\n            isSniper[addresses[i]] = status;\n        }\n    }\n\n    // permanently disable sniper management\n    function disableSniperManagement() external onlyOwner {\n        sniperManagementEnabled = false;\n    }\n\n    function _swapBack() private {\n        uint256 contractBalance = balanceOf(address(this));\n        if (contractBalance == 0) {\n            return;\n        }\n        if (contractBalance > swapTokensAtAmount * 10) {\n            contractBalance = swapTokensAtAmount * 10;\n        }\n        _swapTokensForEth(contractBalance);\n        bool success;\n        (success,) = address(MarketingAddress).call{value: address(this).balance}(\"\");\n    }\n\n    function transferForeignToken(address token, address to) external onlyOwner returns (bool) {\n        require(token != address(0), \"DEXLIONS: token is the zero address\");\n        uint256 _contractBalance = IERC20(token).balanceOf(address(this));\n        return IERC20(token).transfer(to, _contractBalance);\n    }\n\n    function withdrawStuckETH() external onlyOwner {\n        bool success;\n        (success,) = address(msg.sender).call{value: address(this).balance}(\"\");\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}