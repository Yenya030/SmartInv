{{
  "language": "Solidity",
  "sources": {
    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/GreyMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./GreyMarketStorage.sol\";\r\nimport \"./GreyMarketEvent.sol\";\r\nimport \"./GreyMarketData.sol\";\r\n\r\n/** \r\n * @title gm.co\r\n * @custom:version 1.0\r\n * @author projectPXN\r\n * @custom:coauthor bldr\r\n * @notice gm.co is a Business-to-Consumer (B2C) and Peer-to-Peer (P2P) marketplace\r\n *         using blockchain technology for proof of transactions and allow users\r\n *         to buy and sell real world goods using cryptocurrency.\r\n */\r\ncontract GreyMarket is Ownable, ReentrancyGuard, GreyMarketStorage, GreyMarketEvent {\r\n    using SafeERC20 for IERC20;\r\n\r\n    string public constant CONTRACT_NAME = \"GreyMarket Contract\";\r\n    \r\n    bytes32 public constant DOMAIN_TYPEHASH = \r\n        keccak256(\r\n            \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\r\n        );\r\n    \r\n    bytes32 public constant CREATE_ORDER_TYPEHASH = \r\n        keccak256(\r\n            \"Create(bytes32 id,address buyer,address seller,address paymentToken,uint256 orderType,uint256 amount)\"\r\n        );\r\n\r\n    bytes32 public constant CLAIM_ORDER_TYPEHASH = \r\n        keccak256(\r\n            \"Claim(bytes32 id,address buyer,address seller,uint256 orderStatus)\"\r\n        );\r\n    \r\n    bytes32 public constant WITHDRAW_ORDER_TYPEHASH = \r\n        keccak256(\r\n            \"Withdraw(bytes32 id,address buyer,address seller,uint256 orderStatus)\"\r\n        );\r\n\r\n    bytes32 public constant RELEASE_DISPUTED_ORDER_TYPEHASH = \r\n        keccak256(\r\n            \"Release(bytes32 id,address buyer,address seller,uint256 orderStatus,address winner)\"\r\n        );\r\n\r\n    bytes32 public domainSeperator = \r\n        keccak256(\r\n            abi.encode(\r\n                DOMAIN_TYPEHASH, \r\n                keccak256(bytes(CONTRACT_NAME)), \r\n                getChainId(), \r\n                address(this)\r\n            )\r\n        );\r\n    \r\n    constructor(address _proofSigner, address _usdc) {\r\n        require(_usdc != address(0) && _proofSigner != address(0), \"invalid token or signer address\");\r\n\r\n        proofSigner = _proofSigner;\r\n        paymentTokens[_usdc] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Create the order.\r\n     * @dev Create the order with order information.\r\n     * @param id Order id\r\n     * @param seller Address of the seller\r\n     * @param paymentToken Address of the payment token used for the order\r\n     * @param orderType Type of the order\r\n     * @param amount Payment amount\r\n     * @param sig ECDSA signature\r\n     */\r\n    function createOrder(\r\n        bytes32 id, \r\n        address seller, \r\n        address paymentToken,\r\n        OrderType orderType, \r\n        uint256 amount, \r\n        Sig calldata sig\r\n    ) external payable {\r\n        require(validateCreateOrder(sig, id, msg.sender, seller, paymentToken, uint256(orderType), amount), \"createOrder: invalid signature\");\r\n        require(paymentToken == address(0) || paymentTokens[paymentToken], \"createOrder: invalid payment token\");\r\n        require(orderType < OrderType.COUNT, \"createOrder: invalid order type\");\r\n        OrderInfo storage orderInfo = orders[id];\r\n        require(orderInfo.status == OrderStatus.ORDER_NONE, \"createOrder: invalid status\");\r\n\r\n        orderInfo.id = id;\r\n        orderInfo.createdAt = uint128(block.timestamp);\r\n        orderInfo.buyer = msg.sender;\r\n        orderInfo.orderType = orderType;\r\n        orderInfo.seller = seller;\r\n        orderInfo.status = OrderStatus.ORDER_CREATED;\r\n\r\n        if (paymentToken == address(0)) {\r\n            orderInfo.amount = msg.value;\r\n            orderInfo.paymentType = PaymentType.PAYMENT_ETH;\r\n        } else {\r\n            IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), amount);\r\n            orderInfo.amount = amount;\r\n            orderInfo.paymentType = PaymentType.PAYMENT_ERC20;\r\n        }\r\n\r\n        orderInfo.paymentToken = paymentToken;\r\n        emit OrderCreated(id, orderInfo.buyer, seller, uint8(orderInfo.paymentType), uint8(orderType), orderInfo.createdAt, orderInfo.amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim the order fund by seller after order is delivered and confirmed.\r\n     * @dev Claim the order fund with order information.\r\n     * @param id Order id\r\n     * @param buyer Address of the buyer\r\n     * @param seller Address of the seller\r\n     * @param sig ECDSA signature\r\n     */\r\n    function claimOrder(\r\n        bytes32 id,\r\n        address buyer,\r\n        address seller,\r\n        Sig calldata sig\r\n    ) public {\r\n        require(validateClaimOrder(sig, id, buyer, seller, uint256(OrderStatus.ORDER_DELIVERED)), \"claimOrder: invalid signature\");\r\n        OrderInfo storage orderInfo = orders[id];\r\n        require(orderInfo.status == OrderStatus.ORDER_CREATED, \"claimOrder: invalid status\");\r\n        require(orderInfo.seller == msg.sender && orderInfo.seller == seller, \"claimOrder: invalid seller\");\r\n        require(orderInfo.buyer == buyer, \"claimOrder: invalid buyer info\");\r\n        require(orderInfo.orderType < OrderType.COUNT, \"claimOrder: invalid order type\");\r\n\r\n        uint256 fee = orderInfo.amount * transactionFee / 100000;\r\n\r\n        if(orderInfo.orderType == OrderType.ESCROW) {\r\n            uint256 escrowFee = orderInfo.amount * defaultEscrowFee / 100000;\r\n            fee += escrowFee * 10 / 100;\r\n            escrowFees[orderInfo.seller] = escrowFees[orderInfo.seller] + escrowFee * 90 / 100;\r\n        }\r\n\r\n        adminFees[orderInfo.paymentToken] = adminFees[orderInfo.paymentToken] + fee;\r\n        orderInfo.status = OrderStatus.ORDER_COMPLETED;\r\n\r\n        if (orderInfo.paymentType == PaymentType.PAYMENT_ETH)\r\n            payable(orderInfo.seller).transfer(orderInfo.amount - fee);\r\n        else\r\n            IERC20(orderInfo.paymentToken).safeTransfer(orderInfo.seller, orderInfo.amount - fee);\r\n\r\n        orderInfo.completedAt = uint128(block.timestamp);\r\n        emit OrderCompleted(id, orderInfo.buyer, orderInfo.seller, orderInfo.completedAt);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim multiple orders.\r\n     * @dev Claim multiple orders.\r\n     * @param ids Order ids\r\n     * @param buyers The addresses of the buyers\r\n     * @param sellers The addresses of the sellers\r\n     * @param sigs Array of ECDSA signatures\r\n     */\r\n    function claimOrders(\r\n        bytes32[] calldata ids,\r\n        address[] calldata buyers,\r\n        address[] calldata sellers,\r\n        Sig[] calldata sigs\r\n    ) external {\r\n        require(sigs.length == ids.length, \"invalid length\");\r\n        require(sellers.length == buyers.length, \"invalid length\");\r\n\r\n        uint256 len = ids.length;\r\n        uint256 i;\r\n\r\n        unchecked {\r\n            do {\r\n               claimOrder(ids[i], buyers[i], sellers[i], sigs[i]);\r\n            } while(++i < len);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw funds for a buyer after an order is cancelled\r\n     * @dev Withdraw the order fund with order data\r\n     * @param id Order id\r\n     * @param buyer Address of the buyer\r\n     * @param seller Address of the seller\r\n     * @param sig ECDSA signature\r\n     */\r\n    function withdrawOrder(\r\n        bytes32 id, \r\n        address buyer, \r\n        address seller, \r\n        Sig calldata sig\r\n    ) external {\r\n        require(validateWithdrawOrder(sig, id, buyer, seller, uint256(OrderStatus.ORDER_CANCELLED)), \"withdrawOrder: invalid signature\");\r\n        OrderInfo storage orderInfo = orders[id];\r\n        require(orderInfo.status == OrderStatus.ORDER_CREATED, \"withdrawOrder: invalid status\");\r\n        require(orderInfo.buyer == msg.sender && orderInfo.buyer == buyer, \"withdrawOrder: invalid buyer\");\r\n        require(orderInfo.seller == seller, \"withdrawOrder: invalid seller info\");\r\n\r\n        orderInfo.status = OrderStatus.ORDER_CANCELLED;\r\n\r\n        if (orderInfo.paymentType == PaymentType.PAYMENT_ETH)\r\n            payable(orderInfo.buyer).transfer(orderInfo.amount);\r\n        else\r\n            IERC20(orderInfo.paymentToken).safeTransfer(orderInfo.buyer, orderInfo.amount);\r\n\r\n        uint256 remainingEscrowFees = escrowFees[orderInfo.seller];\r\n        if(remainingEscrowFees > 0) {\r\n            escrowFees[orderInfo.seller] = 0;\r\n            if (orderInfo.paymentType == PaymentType.PAYMENT_ETH)\r\n                payable(orderInfo.seller).transfer(remainingEscrowFees);\r\n            else\r\n                IERC20(orderInfo.paymentToken).safeTransfer(orderInfo.seller, remainingEscrowFees);\r\n        }\r\n            \r\n        orderInfo.cancelledAt = uint128(block.timestamp);\r\n        emit OrderCancelled(id, orderInfo.buyer, orderInfo.seller, orderInfo.cancelledAt);\r\n    }\r\n\r\n    /**\r\n     * @notice Release the disputed fund by buyer or seller as admin indicated.\r\n     * @dev Release the disputed fund by buyer or seller as admin indicated.\r\n     * @param id Order id.\r\n     * @param buyer Address of the buyer\r\n     * @param seller Address of the seller\r\n     * @param winner Address of the winner\r\n     * @param sigs Array of the v,r,s values of the ECDSA signatures\r\n     */\r\n    function releaseDisputedOrder(\r\n        bytes32 id, \r\n        address buyer, \r\n        address seller, \r\n        address winner, \r\n        Sig[] calldata sigs\r\n    ) external {\r\n        require(validateReleaseDisputedOrder(sigs, id, buyer, seller, uint256(OrderStatus.ORDER_DISPUTE), winner), \"releaseDisputedOrder: invalid signature\");\r\n        require(buyer == winner || seller == winner, \"releaseDisputedOrder: invalid winner\");\r\n        OrderInfo storage orderInfo = orders[id];\r\n        require(orderInfo.status == OrderStatus.ORDER_CREATED, \"releaseDisputedOrder: invalid status\");\r\n        require(winner == msg.sender && orderInfo.buyer == buyer &&  orderInfo.seller == seller, \"releaseDisputedOrder: invalid info\");\r\n\r\n        orderInfo.status = OrderStatus.ORDER_DISPUTE_HANDLED;\r\n        if (orderInfo.paymentType == PaymentType.PAYMENT_ETH)\r\n            payable(winner).transfer(orderInfo.amount);\r\n        else\r\n            IERC20(orderInfo.paymentToken).safeTransfer(winner, orderInfo.amount);\r\n\r\n        orderInfo.disputedAt = uint128(block.timestamp);\r\n        emit OrderDisputeHandled(id, orderInfo.buyer, orderInfo.seller, winner, orderInfo.disputedAt);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the proof signer address.\r\n     * @dev Admin function to set the proof signer address.\r\n     * @param newProofSigner The new proof signer.\r\n     */\r\n    function _setProofSigner(address newProofSigner) external onlyOwner {\r\n        require(newProofSigner != address(0), \"invalid proof signer\");\r\n        proofSigner = newProofSigner;\r\n        emit NewProofSigner(proofSigner);\r\n    }\r\n\r\n    /**\r\n     * @notice Add new market admin.\r\n     * @dev Admin function to add new market admin.\r\n     * @param newAdmins The new admin.\r\n     */\r\n    function _setNewAdmins(address[] calldata newAdmins) external onlyOwner {\r\n        require(newAdmins.length > 0, \"invalid admins length\");\r\n        admins = newAdmins;\r\n        emit NewAdmins(admins);\r\n    }\r\n\r\n    /**\r\n     * @notice Add new payment token\r\n     * @dev Admin function to add new payment token\r\n     * @param paymentToken Supported payment token\r\n     * @param add Add or remove admin.\r\n     */\r\n    function _addOrRemovePaymentToken(address paymentToken, bool add) external onlyOwner {\r\n        require(paymentToken != address(0), \"invalid payment token\");\r\n        paymentTokens[paymentToken] = add;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the transaction fee \r\n     * @dev Admin function to set the transaction fee\r\n     * @param newFee escrow fee recipient.\r\n     */\r\n     function _setTransactionFee(uint256 newFee) external onlyOwner {\r\n        require(newFee <= MAX_TRANSACTION_FEE, \"invalid fee range\");\r\n        transactionFee = newFee;\r\n        emit NewTransactionFee(newFee);\r\n     }\r\n\r\n    /**\r\n     * @notice Sets the escrow fee.\r\n     * @dev Admin function to set the escrow fee.\r\n     * @param newEscrowFee The new escrow fee, scaled by 1e18.\r\n     */\r\n    function _setEscrowFee(uint256 newEscrowFee) external onlyOwner {\r\n        require(newEscrowFee <= MAX_ESCROW_FEE, \"invalid fee range\");\r\n        defaultEscrowFee = newEscrowFee;\r\n        emit NewEscrowFee(newEscrowFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the escrow pending period.\r\n     * @dev Admin function to set the escrow pending period.\r\n     * @param newEscrowPendingPeriod The new escrow pending period in timestamp\r\n     */\r\n    function _setEscrowPendingPeriod(uint256 newEscrowPendingPeriod) external onlyOwner {\r\n        require(newEscrowPendingPeriod <= MAX_ESCROW_PENDING_PERIOD, \"pending period must not exceed maximum period\");\r\n        require(newEscrowPendingPeriod >= MIN_ESCROW_PENDING_PERIOD, \"pending period must exceed minimum period\");\r\n        escrowPendingPeriod = newEscrowPendingPeriod;\r\n        emit NewEscrowPendingPeriod(escrowPendingPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the escrow lock period.\r\n     * @dev Admin function to set the escrow lock period.\r\n     * @param newEscrowLockPeriod The new escrow lock period in timestamp\r\n     */\r\n    function _setEscrowLockPeriod(uint256 newEscrowLockPeriod) external onlyOwner {\r\n        require(newEscrowLockPeriod <= MAX_ESCROW_LOCK_PERIOD, \"lock period must not exceed maximum period\");\r\n        require(newEscrowLockPeriod >= MIN_ESCROW_LOCK_PERIOD, \"lock period must exceed minimum period\");\r\n        escrowLockPeriod = newEscrowLockPeriod;\r\n        emit NewEscrowLockPeriod(escrowLockPeriod);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the admin fee.\r\n     * @dev Admin function to withdraw the admin fee.\r\n     * @param recipient The address that will receive the fees.\r\n     * @param token The token address to withdraw, NULL for ETH, token address for ERC20.\r\n     * @param amount The amount to withdraw.\r\n     */\r\n    function _withdrawAdminFee(address recipient, address token, uint256 amount) external onlyOwner {\r\n        require(recipient != address(0), \"invalid recipient address\");\r\n        require(adminFees[token] >= amount, \"invalid token address or amount\");\r\n\r\n        if (token == address(0))\r\n            payable(recipient).transfer(amount);\r\n        else\r\n            IERC20(token).safeTransfer(recipient, amount);\r\n\r\n        adminFees[token] = adminFees[token] - amount;\r\n        emit WithdrawAdminFee(msg.sender, recipient, token, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the unclaimed fund for lock period.\r\n     * @dev Admin function to withdraw the unclaimed fund for lock period.\r\n     * @param id The order id.\r\n     * @param recipient The address that will receive the fees.\r\n     */\r\n    function _withdrawLockedFund(bytes32 id, address recipient) external onlyOwner {\r\n        OrderInfo storage orderInfo = orders[id];\r\n        require(orderInfo.status == OrderStatus.ORDER_CREATED, \"invalid order status\");\r\n        require(recipient != address(0), \"invalid recipient address\");\r\n        require(orderInfo.createdAt + escrowLockPeriod >= block.timestamp, \"can not withdraw before lock period\");\r\n        \r\n        if (orderInfo.paymentToken == address(0))\r\n            payable(recipient).transfer(orderInfo.amount);\r\n        else\r\n            IERC20(orderInfo.paymentToken).safeTransfer(recipient, orderInfo.amount);\r\n\r\n        orderInfo.status = OrderStatus.ORDER_ADMIN_WITHDRAWN;\r\n        emit WithdrawLockedFund(msg.sender, id, recipient, orderInfo.amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the chain ID the contract is deployed to\r\n     * @dev Retrieve the chain ID from the EVM\r\n     * @return chainId chain ID\r\n     */\r\n    function getChainId() internal view returns (uint) {\r\n        uint chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates a create order signature\r\n     * @dev Validates the signature of a create order action by verifying the signature\r\n     * @param sig ECDSA signature\r\n     * @param id Order id\r\n     * @param buyer Buyer address\r\n     * @param seller Seller address\r\n     * @param paymentToken Payment token address\r\n     * @param orderType Order type\r\n     * @param amount Order amount\r\n     * @return bool Whether the signature is valid or not\r\n     */\r\n    function validateCreateOrder(\r\n        Sig calldata sig,\r\n        bytes32 id, \r\n        address buyer, \r\n        address seller, \r\n        address paymentToken, \r\n        uint256 orderType, \r\n        uint256 amount\r\n    ) internal view returns(bool) {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeperator,\r\n                keccak256(\r\n                    abi.encode(\r\n                        CREATE_ORDER_TYPEHASH,\r\n                        id,\r\n                        buyer,\r\n                        seller,\r\n                        paymentToken,\r\n                        orderType,\r\n                        amount\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        return ecrecover(digest, sig.v, sig.r, sig.s) == proofSigner;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates a claim order signature\r\n     * @dev Validates the signature of a claim order action by verifying the signature\r\n     * @param sig ECDSA signature\r\n     * @param id Order id\r\n     * @param buyer Buyer address\r\n     * @param seller Seller address\r\n     * @param orderStatus Order status in integer value\r\n     * @return bool Whether the signature is valid or not\r\n     */\r\n    function validateClaimOrder(\r\n        Sig calldata sig,\r\n        bytes32 id, \r\n        address buyer, \r\n        address seller, \r\n        uint256 orderStatus\r\n    ) internal view returns(bool) {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeperator,\r\n                keccak256(\r\n                    abi.encode(\r\n                        CLAIM_ORDER_TYPEHASH,\r\n                        id,\r\n                        buyer,\r\n                        seller,\r\n                        orderStatus\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        \r\n        return ecrecover(digest, sig.v, sig.r, sig.s) == proofSigner;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates a withdraw order signature\r\n     * @dev Validates the signature of a withdraw order action by verifying the signature\r\n     * @param sig ECDSA signature\r\n     * @param id Order id\r\n     * @param buyer Buyer address\r\n     * @param seller Seller address\r\n     * @param orderStatus Order status in integer value\r\n     * @return bool Whether the signature is valid or not\r\n     */\r\n    function validateWithdrawOrder(\r\n        Sig calldata sig,\r\n        bytes32 id, \r\n        address buyer, \r\n        address seller, \r\n        uint256 orderStatus\r\n    ) internal view returns(bool) {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeperator,\r\n                keccak256(\r\n                    abi.encode(\r\n                        WITHDRAW_ORDER_TYPEHASH,\r\n                        id,\r\n                        buyer,\r\n                        seller,\r\n                        orderStatus\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        return ecrecover(digest, sig.v, sig.r, sig.s) == proofSigner;\r\n    }\r\n\r\n    /**\r\n     * @notice Validates a release disputed order signature\r\n     * @dev Validates the signature of a release disputed order action by verifying the signature\r\n     * @param sigs Array of the v,r,s values of the ECDSA signatures\r\n     * @param id Order id\r\n     * @param buyer Buyer address\r\n     * @param seller Seller address\r\n     * @param orderStatus Order status in integer value\r\n     * @param winner Winner address\r\n     * @return bool Whether the signature is valid or not\r\n     */\r\n    function validateReleaseDisputedOrder(\r\n        Sig[] calldata sigs,\r\n        bytes32 id,\r\n        address buyer,\r\n        address seller,\r\n        uint256 orderStatus,\r\n        address winner\r\n    ) internal view returns(bool) {\r\n        require(sigs.length == REQUIRED_SIGNATURE_COUNT, \"invalid signature required count\");\r\n\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                domainSeperator,\r\n                keccak256(\r\n                    abi.encode(\r\n                        RELEASE_DISPUTED_ORDER_TYPEHASH,\r\n                        id,\r\n                        buyer,\r\n                        seller,\r\n                        orderStatus,\r\n                        winner\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        \r\n        address signerOne = ecrecover(digest, sigs[0].v, sigs[0].r, sigs[0].s);\r\n        address signerTwo = ecrecover(digest, sigs[1].v, sigs[1].r, sigs[1].s);\r\n        require(signerOne != signerTwo, \"same signature\");\r\n\r\n        uint256 validSignatureCount;\r\n        for(uint256 i; i < admins.length; i++) {\r\n            if(signerOne == admins[i] || signerTwo == admins[i]) {\r\n                validSignatureCount++;\r\n            }\r\n        }\r\n\r\n        return validSignatureCount == REQUIRED_SIGNATURE_COUNT;\r\n    }\r\n\r\n    /**\r\n     * @notice View function to get order info by ID\r\n     * @dev Retrieves the order struct by ID\r\n     * @param orderId Order ID\r\n     * @return OrderInfo Order struct\r\n     */\r\n    function getOrderInfo(bytes32 orderId) public view returns (OrderInfo memory) {\r\n        return orders[orderId];\r\n    }\r\n    \r\n    /**\r\n     * @notice View function to get the amount of admin fees by a specific token\r\n     * @dev Retrieves the amount of admin fees by a specific token address, either ETH or ERC20\r\n     * @param token Token address\r\n     * @return uint256 Amount of fees in wei\r\n     */\r\n    function getAdminFeeAmount(address token) public view returns (uint256) {\r\n        return adminFees[token];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to retrieve the name of this contract as a\r\n     *      string that will be used to derive the name hash in the constructor.\r\n     * @return The name of this contract as a string.\r\n     */\r\n    function _nameString() public pure returns (string memory) {\r\n        return \"GreyMarket\";\r\n    }\r\n\r\n    /**\r\n     * @notice UUID V4 to bytes32 representation in Solidity\r\n     * @param s UUID V4 string\r\n     */\r\n    function UUIDStringToBytes32(string memory s) public pure returns (bytes32) {\r\n        bytes memory bytesArray = bytes(s);\r\n        bytes memory noDashes = new bytes(32);\r\n        uint index;\r\n        for (uint256 i; i < bytesArray.length; i++) {\r\n            if (bytesArray[i] == \"-\") {\r\n                continue;\r\n            }\r\n            noDashes[index] = bytesArray[i];\r\n            index++;\r\n        }\r\n        bytes32 result;\r\n        assembly {\r\n            result := mload(add(noDashes, 32))\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"
    },
    "src/GreyMarketData.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nuint256 constant MAX_TRANSACTION_FEE = 10000;\r\nuint256 constant MAX_ESCROW_FEE = 5000;\r\nuint256 constant MAX_ESCROW_PENDING_PERIOD = 6 * 30 days;\r\nuint256 constant MIN_ESCROW_PENDING_PERIOD = 7 days;\r\nuint256 constant REQUIRED_SIGNATURE_COUNT = 2;\r\nuint256 constant MAX_ESCROW_LOCK_PERIOD = 12 * 30 days;\r\nuint256 constant MIN_ESCROW_LOCK_PERIOD = 6 * 30 days;\r\n\r\nenum PaymentType {\r\n    PAYMENT_ETH,\r\n    PAYMENT_ERC20\r\n}\r\n\r\nenum OrderStatus {\r\n    ORDER_NONE,\r\n    ORDER_CREATED,\r\n    ORDER_PENDING,\r\n    ORDER_TRANSIT,\r\n    ORDER_DELIVERED,\r\n    ORDER_COMPLETED,\r\n    ORDER_CANCELLED,\r\n    ORDER_DISPUTE,\r\n    ORDER_DISPUTE_HANDLED,\r\n    ORDER_ADMIN_WITHDRAWN\r\n}\r\n\r\nenum OrderType {\r\n    ESCROW,\r\n    DIRECT,\r\n    COUNT\r\n}\r\n\r\nstruct OrderInfo {\r\n    bytes32 id;\r\n    address buyer;\r\n    address seller;\r\n    OrderStatus status;\r\n    PaymentType paymentType;\r\n    address paymentToken;\r\n    uint256 amount;\r\n    OrderType orderType;\r\n    bytes sellerSignature;\r\n    uint128 createdAt;\r\n    uint128 cancelledAt;\r\n    uint128 completedAt;\r\n    uint128 disputedAt;\r\n}\r\n\r\nstruct Sig {\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n}\r\n"
    },
    "src/GreyMarketEvent.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * @title gm.co Event\r\n * @author projectPXN\r\n * @custom:coauthor bldr\r\n * @notice gm.co is a Business-to-Consumer (B2C) and Peer-to-Peer (P2P) marketplace\r\n *         using blockchain technology for proof of transactions and allow users\r\n *         to buy and sell real world goods using cryptocurrency.\r\n */\r\ncontract GreyMarketEvent {\r\n    event NewProofSigner(address newProofSigner);\r\n\r\n    event OrderCreated(bytes32 id, address indexed buyer, address indexed seller, uint8 paymentType, uint8 orderType, uint256 blockTimestamp, uint256 amount);\r\n\r\n    event OrderCancelled(bytes32 id, address indexed buyer, address indexed seller, uint256 blockTimestamp);\r\n\r\n    event OrderCompleted(bytes32 id, address indexed buyer, address indexed seller, uint256 blockTimestamp);\r\n\r\n    event OrderDisputeHandled(bytes32 id, address indexed buyer, address indexed seller, address winner, uint256 blockTimestamp);\r\n\r\n    event NewEscrowFee(uint256 newEscrowFee);\r\n\r\n    event NewEscrowPendingPeriod(uint256 newEscrowPendingPeriod);\r\n\r\n    event NewEscrowLockPeriod(uint256 newEscrowLockPeriod);\r\n\r\n    event NewAdmins(address[] newAdmins);\r\n\r\n    event WithdrawAdminFee(address caller, address recipient, address token, uint256 amount);\r\n\r\n    event WithdrawLockedFund(address caller, bytes32 orderId, address recipient, uint256 amount);\r\n\r\n    event NewTransactionFee(uint256 newTransactionFee);\r\n}\r\n"
    },
    "src/GreyMarketStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"./GreyMarketData.sol\";\r\n\r\n/**\r\n * @title gm.co Storage\r\n * @author projectPXN\r\n * @custom:coauthor bldr\r\n * @notice gm.co is a Business-to-Consumer (B2C) and Peer-to-Peer (P2P) marketplace\r\n *         using blockchain technology for proof of transactions and allow users\r\n *         to buy and sell real world goods using cryptocurrency.\r\n */\r\ncontract GreyMarketStorage {\r\n    address public proofSigner;\r\n\r\n    address[] public admins;\r\n\r\n    uint256 public transactionFee = 5000;\r\n\r\n    uint256 public defaultEscrowFee = 2900;\r\n\r\n    uint256 public escrowPendingPeriod;\r\n\r\n    uint256 public escrowLockPeriod;\r\n\r\n    mapping(address => uint256) public adminFees;\r\n\r\n    mapping(address => uint256) public escrowFees;\r\n\r\n    mapping(bytes32 => OrderInfo) public orders;\r\n\r\n    mapping(address => bool) public paymentTokens;\r\n}\r\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}}