{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/TPL/TPLRevealedParts/ITPLRevealedParts.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {IBase721A} from \"../../utils/tokens/ERC721/IBase721A.sol\";\n\n/// @title ITPLRevealedParts\n/// @author CyberBrokers\n/// @author dev by @dievardump\n/// @notice Interface for the Revealed Parts contract.\ninterface ITPLRevealedParts is IBase721A {\n    struct TokenData {\n        uint256 generation;\n        uint256 originalId;\n        uint256 bodyPart;\n        uint256 model;\n        uint256[] stats;\n    }\n\n    /// @notice verifies that `account` owns all `tokenIds`\n    /// @param account the account\n    /// @param tokenIds the token ids to check\n    /// @return if account owns all tokens\n    function isOwnerOfBatch(address account, uint256[] calldata tokenIds) external view returns (bool);\n\n    /// @notice returns a Mech Part data (body part and original id)\n    /// @param tokenId the tokenId to check\n    /// @return the Mech Part data (body part and original id)\n    function partData(uint256 tokenId) external view returns (TokenData memory);\n\n    /// @notice returns a list of Mech Part data (body part and original id)\n    /// @param tokenIds the tokenIds to knoMechParts type of\n    /// @return a list of Mech Part data (body part and original id)\n    function partDataBatch(uint256[] calldata tokenIds) external view returns (TokenData[] memory);\n\n    /// @notice Allows to burn tokens in batch\n    /// @param tokenIds the tokens to burn\n    function burnBatch(uint256[] calldata tokenIds) external;\n}\n"
    },
    "src/TPL/TPLSwap.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {ERC165, IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\nimport {ITPLRevealedParts} from \"./TPLRevealedParts/ITPLRevealedParts.sol\";\n\n/// @title TPLSwap\n/// @author CyberBrokers\n/// @author dev by @dievardump\n/// @notice Contract allowing to swap unrevealed TPL Mech Parts against revealed TPL Mech Parts\ncontract TPLSwap is IERC1155Receiver, ERC165 {\n    error UnknownContract();\n\n    address public immutable UNREVEALED_PARTS;\n    address public immutable REVEALED_PARTS;\n\n    modifier onlyKnownContract() {\n        if (msg.sender != UNREVEALED_PARTS) {\n            revert UnknownContract();\n        }\n        _;\n    }\n\n    constructor(address unrevealed, address revealed) {\n        UNREVEALED_PARTS = unrevealed;\n        REVEALED_PARTS = revealed;\n    }\n\n    /////////////////////////////////////////////////////////\n    // Getters                                             //\n    /////////////////////////////////////////////////////////\n\n    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /////////////////////////////////////////////////////////\n    // Interaction                                         //\n    /////////////////////////////////////////////////////////\n\n    /// @notice Allows an user to swap `amounts` of unrevealed parts of `ids` and get as many TPLRevealedParts\n    /// @dev the user must have approved the current contract on TPLUnrevealedParts\n    /// @param ids the unrevealed parts ids to swap\n    /// @param amounts the amounts to swap\n    function swap(uint256[] calldata ids, uint256[] calldata amounts) external {\n        IERC1155Burnable(UNREVEALED_PARTS).burnBatch(msg.sender, ids, amounts);\n\n        uint256 length = ids.length;\n        for (uint256 i; i < length; i++) {\n            _mintBodyPartFrom(msg.sender, ids[i], amounts[i]);\n        }\n    }\n\n    /////////////////////////////////////////////////////////\n    // Callbacks / Hooks                                   //\n    /////////////////////////////////////////////////////////\n\n    /// @dev hook allowing users to directly send TPLUnrevealedPartsIds to this contract in order to swap\n    /// @dev tests have shown that this method will be more expensive to use than approval then swap\n    function onERC1155Received(\n        address, /*operator*/\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata\n    ) external onlyKnownContract returns (bytes4) {\n        // burn\n        IERC1155Burnable(msg.sender).burn(address(this), id, value);\n\n        // mint\n        _mintBodyPartFrom(from, id, value);\n\n        // ACK\n        return this.onERC1155Received.selector;\n    }\n\n    /// @dev hook allowing users to directly send TPLUnrevealedPartsIds in batch to this contract in order to swap\n    /// @dev tests have shown that this method will be more expensive to use than approval then swap\n    function onERC1155BatchReceived(\n        address, /* operator */\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata\n    ) external onlyKnownContract returns (bytes4) {\n        // burn\n        IERC1155Burnable(msg.sender).burnBatch(address(this), ids, values);\n\n        // mint\n        uint256 length = ids.length;\n        for (uint256 i; i < length; i++) {\n            _mintBodyPartFrom(from, ids[i], values[i]);\n        }\n\n        // ACK\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /////////////////////////////////////////////////////////\n    // Internals                                           //\n    /////////////////////////////////////////////////////////\n\n    /// @dev this function mint & reveals the body part wanted from the unrevealed `id`\n    /// @param to the account receiving the part\n    /// @param id the unrevealed part id\n    /// @param amount the amount of part wanted\n    function _mintBodyPartFrom(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        // most left 12 bits are the original unrevealed id\n        // most right 12 bits is the \"generation\" of the part. Here all parts are Genesis parts\n        uint24 packedData = uint24((id << 12) | 1);\n\n        // mint `amount` revealed parts to `to` with `packedData`\n        ITPLRevealedParts(REVEALED_PARTS).mintTo(to, amount, packedData);\n    }\n}\n\ninterface IERC1155Burnable {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) external;\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) external;\n}\n"
    },
    "src/utils/tokens/ERC721/IBase721A.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\ninterface IBase721A {\n    /// @notice Allows a `minter` to mint `amount` tokens to `to` with `extraData_`\n    /// @param to to whom we need to mint\n    /// @param amount how many to mint\n    /// @param extraData extraData for these items\n    function mintTo(\n        address to,\n        uint256 amount,\n        uint24 extraData\n    ) external;\n}\n"
    }
  }
}}